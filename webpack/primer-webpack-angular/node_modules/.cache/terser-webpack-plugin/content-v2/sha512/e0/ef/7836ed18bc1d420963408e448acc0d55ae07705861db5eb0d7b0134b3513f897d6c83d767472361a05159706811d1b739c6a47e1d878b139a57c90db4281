{"map":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\"}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return __extends; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return __assign; });\\n/* unused harmony export __rest */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return __decorate; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return __param; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return __metadata; });\\n/* unused harmony export __awaiter */\\n/* unused harmony export __generator */\\n/* unused harmony export __exportStar */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return __values; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return __read; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return __spread; });\\n/* unused harmony export __await */\\n/* unused harmony export __asyncGenerator */\\n/* unused harmony export __asyncDelegator */\\n/* unused harmony export __asyncValues */\\n/* unused harmony export __makeTemplateObject */\\n/* unused harmony export __importStar */\\n/* unused harmony export __importDefault */\\n/*! *****************************************************************************\\r\\nCopyright (c) Microsoft Corporation. All rights reserved.\\r\\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\\r\\nthis file except in compliance with the License. You may obtain a copy of the\\r\\nLicense at http://www.apache.org/licenses/LICENSE-2.0\\r\\n\\r\\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\r\\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\\r\\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\\r\\nMERCHANTABLITY OR NON-INFRINGEMENT.\\r\\n\\r\\nSee the Apache Version 2.0 License for specific language governing permissions\\r\\nand limitations under the License.\\r\\n***************************************************************************** */\\r\\n/* global Reflect, Promise */\\r\\n\\r\\nvar extendStatics = function(d, b) {\\r\\n    extendStatics = Object.setPrototypeOf ||\\r\\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n    return extendStatics(d, b);\\r\\n};\\r\\n\\r\\nfunction __extends(d, b) {\\r\\n    extendStatics(d, b);\\r\\n    function __() { this.constructor = d; }\\r\\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n}\\r\\n\\r\\nvar __assign = function() {\\r\\n    __assign = Object.assign || function __assign(t) {\\r\\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\\r\\n            s = arguments[i];\\r\\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\\r\\n        }\\r\\n        return t;\\r\\n    }\\r\\n    return __assign.apply(this, arguments);\\r\\n}\\r\\n\\r\\nfunction __rest(s, e) {\\r\\n    var t = {};\\r\\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\\r\\n        t[p] = s[p];\\r\\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\\r\\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\\r\\n            t[p[i]] = s[p[i]];\\r\\n    return t;\\r\\n}\\r\\n\\r\\nfunction __decorate(decorators, target, key, desc) {\\r\\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\\r\\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\\r\\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\\r\\n}\\r\\n\\r\\nfunction __param(paramIndex, decorator) {\\r\\n    return function (target, key) { decorator(target, key, paramIndex); }\\r\\n}\\r\\n\\r\\nfunction __metadata(metadataKey, metadataValue) {\\r\\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\\r\\n}\\r\\n\\r\\nfunction __awaiter(thisArg, _arguments, P, generator) {\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n}\\r\\n\\r\\nfunction __generator(thisArg, body) {\\r\\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\\r\\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\\r\\n    function verb(n) { return function (v) { return step([n, v]); }; }\\r\\n    function step(op) {\\r\\n        if (f) throw new TypeError(\"Generator is already executing.\");\\r\\n        while (_) try {\\r\\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\\r\\n            if (y = 0, t) op = [op[0] & 2, t.value];\\r\\n            switch (op[0]) {\\r\\n                case 0: case 1: t = op; break;\\r\\n                case 4: _.label++; return { value: op[1], done: false };\\r\\n                case 5: _.label++; y = op[1]; op = [0]; continue;\\r\\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\\r\\n                default:\\r\\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\\r\\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\\r\\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\\r\\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\\r\\n                    if (t[2]) _.ops.pop();\\r\\n                    _.trys.pop(); continue;\\r\\n            }\\r\\n            op = body.call(thisArg, _);\\r\\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\\r\\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction __exportStar(m, exports) {\\r\\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\\r\\n}\\r\\n\\r\\nfunction __values(o) {\\r\\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\\r\\n    if (m) return m.call(o);\\r\\n    return {\\r\\n        next: function () {\\r\\n            if (o && i >= o.length) o = void 0;\\r\\n            return { value: o && o[i++], done: !o };\\r\\n        }\\r\\n    };\\r\\n}\\r\\n\\r\\nfunction __read(o, n) {\\r\\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\\r\\n    if (!m) return o;\\r\\n    var i = m.call(o), r, ar = [], e;\\r\\n    try {\\r\\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\\r\\n    }\\r\\n    catch (error) { e = { error: error }; }\\r\\n    finally {\\r\\n        try {\\r\\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\\r\\n        }\\r\\n        finally { if (e) throw e.error; }\\r\\n    }\\r\\n    return ar;\\r\\n}\\r\\n\\r\\nfunction __spread() {\\r\\n    for (var ar = [], i = 0; i < arguments.length; i++)\\r\\n        ar = ar.concat(__read(arguments[i]));\\r\\n    return ar;\\r\\n}\\r\\n\\r\\nfunction __await(v) {\\r\\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\\r\\n}\\r\\n\\r\\nfunction __asyncGenerator(thisArg, _arguments, generator) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\\r\\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\\r\\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\\r\\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\\r\\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\\r\\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\\r\\n    function fulfill(value) { resume(\"next\", value); }\\r\\n    function reject(value) { resume(\"throw\", value); }\\r\\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\\r\\n}\\r\\n\\r\\nfunction __asyncDelegator(o) {\\r\\n    var i, p;\\r\\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\\r\\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\\r\\n}\\r\\n\\r\\nfunction __asyncValues(o) {\\r\\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\\r\\n    var m = o[Symbol.asyncIterator], i;\\r\\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\\r\\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\\r\\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\\r\\n}\\r\\n\\r\\nfunction __makeTemplateObject(cooked, raw) {\\r\\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\\r\\n    return cooked;\\r\\n};\\r\\n\\r\\nfunction __importStar(mod) {\\r\\n    if (mod && mod.__esModule) return mod;\\r\\n    var result = {};\\r\\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\\r\\n    result.default = mod;\\r\\n    return result;\\r\\n}\\r\\n\\r\\nfunction __importDefault(mod) {\\r\\n    return (mod && mod.__esModule) ? mod : { default: mod };\\r\\n}\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/OWFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///0\\n')},1:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_l\\\", function() { return APPLICATION_MODULE_PROVIDERS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_i\\\", function() { return _iterableDiffersFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_j\\\", function() { return _keyValueDiffersFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_k\\\", function() { return _localeFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_f\\\", function() { return _appIdRandomProviderFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_g\\\", function() { return DefaultIterableDifferFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_h\\\", function() { return DefaultKeyValueDifferFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_c\\\", function() { return ReflectiveInjector_; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_d\\\", function() { return ReflectiveDependency; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_e\\\", function() { return resolveReflectiveProviders; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_m\\\", function() { return wtfEnabled; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_o\\\", function() { return createScope; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_n\\\", function() { return detectWTF; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_r\\\", function() { return endTimeRange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_p\\\", function() { return leave; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_q\\\", function() { return startTimeRange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_bd\\\", function() { return NG_INJECTABLE_DEF; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_w\\\", function() { return _getViewData; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_x\\\", function() { return bindingUpdated; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_v\\\", function() { return getPreviousOrParentTNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_z\\\", function() { return BoundPlayerFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_bg\\\", function() { return loadInternal; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_ba\\\", function() { return createElementRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_bb\\\", function() { return createTemplateRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_bc\\\", function() { return createViewRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_a\\\", function() { return makeParamDecorator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_b\\\", function() { return makePropDecorator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_be\\\", function() { return getClosureSafeProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_s\\\", function() { return _def; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_t\\\", function() { return DebugRendererFactory2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_core_core_u\\\", function() { return DebugContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"createPlatform\\\", function() { return createPlatform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"assertPlatform\\\", function() { return assertPlatform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"destroyPlatform\\\", function() { return destroyPlatform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getPlatform\\\", function() { return getPlatform; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PlatformRef\\\", function() { return PlatformRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ApplicationRef\\\", function() { return ApplicationRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"createPlatformFactory\\\", function() { return createPlatformFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgProbeToken\\\", function() { return NgProbeToken; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"enableProdMode\\\", function() { return enableProdMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"isDevMode\\\", function() { return isDevMode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"APP_ID\\\", function() { return APP_ID; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PACKAGE_ROOT_URL\\\", function() { return PACKAGE_ROOT_URL; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PLATFORM_INITIALIZER\\\", function() { return PLATFORM_INITIALIZER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"PLATFORM_ID\\\", function() { return PLATFORM_ID; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"APP_BOOTSTRAP_LISTENER\\\", function() { return APP_BOOTSTRAP_LISTENER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"APP_INITIALIZER\\\", function() { return APP_INITIALIZER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ApplicationInitStatus\\\", function() { return ApplicationInitStatus; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DebugElement\\\", function() { return DebugElement; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DebugNode\\\", function() { return DebugNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"asNativeElements\\\", function() { return asNativeElements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getDebugNode\\\", function() { return getDebugNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Testability\\\", function() { return Testability; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TestabilityRegistry\\\", function() { return TestabilityRegistry; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"setTestabilityGetter\\\", function() { return setTestabilityGetter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRANSLATIONS\\\", function() { return TRANSLATIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TRANSLATIONS_FORMAT\\\", function() { return TRANSLATIONS_FORMAT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"LOCALE_ID\\\", function() { return LOCALE_ID; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MissingTranslationStrategy\\\", function() { return MissingTranslationStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ApplicationModule\\\", function() { return ApplicationModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"wtfCreateScope\\\", function() { return wtfCreateScope; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"wtfLeave\\\", function() { return wtfLeave; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"wtfStartTimeRange\\\", function() { return wtfStartTimeRange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"wtfEndTimeRange\\\", function() { return wtfEndTimeRange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Type\\\", function() { return Type; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EventEmitter\\\", function() { return EventEmitter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ErrorHandler\\\", function() { return ErrorHandler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Sanitizer\\\", function() { return Sanitizer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SecurityContext\\\", function() { return SecurityContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ANALYZE_FOR_ENTRY_COMPONENTS\\\", function() { return ANALYZE_FOR_ENTRY_COMPONENTS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Attribute\\\", function() { return Attribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ContentChild\\\", function() { return ContentChild; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ContentChildren\\\", function() { return ContentChildren; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Query\\\", function() { return Query; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ViewChild\\\", function() { return ViewChild; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ViewChildren\\\", function() { return ViewChildren; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Component\\\", function() { return Component; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Directive\\\", function() { return Directive; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HostBinding\\\", function() { return HostBinding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HostListener\\\", function() { return HostListener; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Input\\\", function() { return Input; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Output\\\", function() { return Output; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Pipe\\\", function() { return Pipe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CUSTOM_ELEMENTS_SCHEMA\\\", function() { return CUSTOM_ELEMENTS_SCHEMA; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NO_ERRORS_SCHEMA\\\", function() { return NO_ERRORS_SCHEMA; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgModule\\\", function() { return NgModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ViewEncapsulation\\\", function() { return ViewEncapsulation; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Version\\\", function() { return Version; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VERSION\\\", function() { return VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"defineInjectable\\\", function() { return defineInjectable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"defineInjector\\\", function() { return defineInjector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"forwardRef\\\", function() { return forwardRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"resolveForwardRef\\\", function() { return resolveForwardRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Injectable\\\", function() { return Injectable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"inject\\\", function() { return inject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"INJECTOR\\\", function() { return INJECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Injector\\\", function() { return Injector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReflectiveInjector\\\", function() { return ReflectiveInjector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"createInjector\\\", function() { return createInjector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ResolvedReflectiveFactory\\\", function() { return ResolvedReflectiveFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReflectiveKey\\\", function() { return ReflectiveKey; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"InjectionToken\\\", function() { return InjectionToken; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Inject\\\", function() { return Inject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Optional\\\", function() { return Optional; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Self\\\", function() { return Self; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SkipSelf\\\", function() { return SkipSelf; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Host\\\", function() { return Host; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgZone\\\", function() { return NgZone; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵNoopNgZone\\\", function() { return NoopNgZone; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RenderComponentType\\\", function() { return RenderComponentType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Renderer\\\", function() { return Renderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Renderer2\\\", function() { return Renderer2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RendererFactory2\\\", function() { return RendererFactory2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RendererStyleFlags2\\\", function() { return RendererStyleFlags2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RootRenderer\\\", function() { return RootRenderer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"COMPILER_OPTIONS\\\", function() { return COMPILER_OPTIONS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Compiler\\\", function() { return Compiler; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CompilerFactory\\\", function() { return CompilerFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ModuleWithComponentFactories\\\", function() { return ModuleWithComponentFactories; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ComponentFactory\\\", function() { return ComponentFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ComponentRef\\\", function() { return ComponentRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ComponentFactoryResolver\\\", function() { return ComponentFactoryResolver; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ElementRef\\\", function() { return ElementRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgModuleFactory\\\", function() { return NgModuleFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgModuleRef\\\", function() { return NgModuleRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"NgModuleFactoryLoader\\\", function() { return NgModuleFactoryLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getModuleFactory\\\", function() { return getModuleFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QueryList\\\", function() { return QueryList$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SystemJsNgModuleLoader\\\", function() { return SystemJsNgModuleLoader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SystemJsNgModuleLoaderConfig\\\", function() { return SystemJsNgModuleLoaderConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"TemplateRef\\\", function() { return TemplateRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ViewContainerRef\\\", function() { return ViewContainerRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"EmbeddedViewRef\\\", function() { return EmbeddedViewRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ViewRef\\\", function() { return ViewRef$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ChangeDetectionStrategy\\\", function() { return ChangeDetectionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ChangeDetectorRef\\\", function() { return ChangeDetectorRef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"DefaultIterableDiffer\\\", function() { return DefaultIterableDiffer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"IterableDiffers\\\", function() { return IterableDiffers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"KeyValueDiffers\\\", function() { return KeyValueDiffers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"SimpleChange\\\", function() { return SimpleChange; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"WrappedValue\\\", function() { return WrappedValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"platformCore\\\", function() { return platformCore; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵALLOW_MULTIPLE_PLATFORMS\\\", function() { return ALLOW_MULTIPLE_PLATFORMS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵAPP_ID_RANDOM_PROVIDER\\\", function() { return APP_ID_RANDOM_PROVIDER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefaultIterableDiffers\\\", function() { return defaultIterableDiffers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefaultKeyValueDiffers\\\", function() { return defaultKeyValueDiffers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdevModeEqual\\\", function() { return devModeEqual; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵisListLikeIterable\\\", function() { return isListLikeIterable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵChangeDetectorStatus\\\", function() { return ChangeDetectorStatus; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵisDefaultChangeDetectionStrategy\\\", function() { return isDefaultChangeDetectionStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵConsole\\\", function() { return Console; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetInjectableDef\\\", function() { return getInjectableDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinject\\\", function() { return inject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵsetCurrentInjector\\\", function() { return setCurrentInjector; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵAPP_ROOT\\\", function() { return APP_ROOT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵivyEnabled\\\", function() { return ivyEnabled$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵComponentFactory\\\", function() { return ComponentFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵCodegenComponentFactoryResolver\\\", function() { return CodegenComponentFactoryResolver; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵresolveComponentResources\\\", function() { return resolveComponentResources; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵReflectionCapabilities\\\", function() { return ReflectionCapabilities; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵRenderDebugInfo\\\", function() { return RenderDebugInfo; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵ_sanitizeHtml\\\", function() { return _sanitizeHtml; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵ_sanitizeStyle\\\", function() { return _sanitizeStyle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵ_sanitizeUrl\\\", function() { return _sanitizeUrl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵglobal\\\", function() { return _global; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵlooseIdentical\\\", function() { return looseIdentical; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵstringify\\\", function() { return stringify; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵmakeDecorator\\\", function() { return makeDecorator; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵisObservable\\\", function() { return isObservable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵisPromise\\\", function() { return isPromise; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵclearOverrides\\\", function() { return clearOverrides; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinitServicesIfNeeded\\\", function() { return initServicesIfNeeded; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵoverrideComponentView\\\", function() { return overrideComponentView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵoverrideProvider\\\", function() { return overrideProvider; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR\\\", function() { return NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefineBase\\\", function() { return defineBase; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefineComponent\\\", function() { return defineComponent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefineDirective\\\", function() { return defineDirective; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefinePipe\\\", function() { return definePipe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdefineNgModule\\\", function() { return defineNgModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdetectChanges\\\", function() { return detectChanges; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵrenderComponent\\\", function() { return renderComponent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵRender3ComponentFactory\\\", function() { return ComponentFactory$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵRender3ComponentRef\\\", function() { return ComponentRef$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdirectiveInject\\\", function() { return directiveInject; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinjectAttribute\\\", function() { return injectAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetFactoryOf\\\", function() { return getFactoryOf; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetInheritedFactory\\\", function() { return getInheritedFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵtemplateRefExtractor\\\", function() { return templateRefExtractor; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵPublicFeature\\\", function() { return PublicFeature; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵInheritDefinitionFeature\\\", function() { return InheritDefinitionFeature; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵNgOnChangesFeature\\\", function() { return NgOnChangesFeature; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵRender3NgModuleRef\\\", function() { return NgModuleRef$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵmarkDirty\\\", function() { return markDirty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵNgModuleFactory\\\", function() { return NgModuleFactory$1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵNO_CHANGE\\\", function() { return NO_CHANGE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcontainer\\\", function() { return container; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵnextContext\\\", function() { return nextContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementStart\\\", function() { return elementStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵnamespaceHTML\\\", function() { return namespaceHTML; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵnamespaceMathML\\\", function() { return namespaceMathML; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵnamespaceSVG\\\", function() { return namespaceSVG; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelement\\\", function() { return element; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵlistener\\\", function() { return listener; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵtext\\\", function() { return text; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵembeddedViewStart\\\", function() { return embeddedViewStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵquery\\\", function() { return query; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵregisterContentQuery\\\", function() { return registerContentQuery; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵprojection\\\", function() { return projection; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbind\\\", function() { return bind; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation1\\\", function() { return interpolation1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation2\\\", function() { return interpolation2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation3\\\", function() { return interpolation3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation4\\\", function() { return interpolation4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation5\\\", function() { return interpolation5; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation6\\\", function() { return interpolation6; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation7\\\", function() { return interpolation7; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolation8\\\", function() { return interpolation8; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolationV\\\", function() { return interpolationV; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipeBind1\\\", function() { return pipeBind1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipeBind2\\\", function() { return pipeBind2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipeBind3\\\", function() { return pipeBind3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipeBind4\\\", function() { return pipeBind4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipeBindV\\\", function() { return pipeBindV; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction0\\\", function() { return pureFunction0; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction1\\\", function() { return pureFunction1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction2\\\", function() { return pureFunction2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction3\\\", function() { return pureFunction3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction4\\\", function() { return pureFunction4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction5\\\", function() { return pureFunction5; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction6\\\", function() { return pureFunction6; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction7\\\", function() { return pureFunction7; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunction8\\\", function() { return pureFunction8; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpureFunctionV\\\", function() { return pureFunctionV; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetCurrentView\\\", function() { return getCurrentView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵrestoreView\\\", function() { return restoreView; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcontainerRefreshStart\\\", function() { return containerRefreshStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcontainerRefreshEnd\\\", function() { return containerRefreshEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵqueryRefresh\\\", function() { return queryRefresh; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵloadQueryList\\\", function() { return loadQueryList; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementEnd\\\", function() { return elementEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementProperty\\\", function() { return elementProperty; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵprojectionDef\\\", function() { return projectionDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵreference\\\", function() { return reference; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵenableBindings\\\", function() { return enableBindings; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdisableBindings\\\", function() { return disableBindings; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementAttribute\\\", function() { return elementAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementStyling\\\", function() { return elementStyling; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementStylingMap\\\", function() { return elementStylingMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementStyleProp\\\", function() { return elementStyleProp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementStylingApply\\\", function() { return elementStylingApply; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementClassProp\\\", function() { return elementClassProp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵtextBinding\\\", function() { return textBinding; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵtemplate\\\", function() { return template; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵembeddedViewEnd\\\", function() { return embeddedViewEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵstore\\\", function() { return store; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵload\\\", function() { return load; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpipe\\\", function() { return pipe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵwhenRendered\\\", function() { return whenRendered; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nAttribute\\\", function() { return i18nAttribute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nExp\\\", function() { return i18nExp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nStart\\\", function() { return i18nStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nEnd\\\", function() { return i18nEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nApply\\\", function() { return i18nApply; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nExpMapping\\\", function() { return i18nExpMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation1\\\", function() { return i18nInterpolation1; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation2\\\", function() { return i18nInterpolation2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation3\\\", function() { return i18nInterpolation3; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation4\\\", function() { return i18nInterpolation4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation5\\\", function() { return i18nInterpolation5; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation6\\\", function() { return i18nInterpolation6; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation7\\\", function() { return i18nInterpolation7; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolation8\\\", function() { return i18nInterpolation8; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nInterpolationV\\\", function() { return i18nInterpolationV; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵi18nMapping\\\", function() { return i18nMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵWRAP_RENDERER_FACTORY2\\\", function() { return WRAP_RENDERER_FACTORY2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵRender3DebugRendererFactory2\\\", function() { return Render3DebugRendererFactory2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcompileNgModuleDefs\\\", function() { return R3_COMPILE_NGMODULE_DEFS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpatchComponentDefWithScope\\\", function() { return R3_PATCH_COMPONENT_DEF_WTIH_SCOPE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcompileComponent\\\", function() { return R3_COMPILE_COMPONENT; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcompileDirective\\\", function() { return R3_COMPILE_DIRECTIVE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcompilePipe\\\", function() { return R3_COMPILE_PIPE; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵsanitizeHtml\\\", function() { return sanitizeHtml; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵsanitizeStyle\\\", function() { return sanitizeStyle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵsanitizeUrl\\\", function() { return sanitizeUrl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵsanitizeResourceUrl\\\", function() { return sanitizeResourceUrl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbypassSanitizationTrustHtml\\\", function() { return bypassSanitizationTrustHtml; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbypassSanitizationTrustStyle\\\", function() { return bypassSanitizationTrustStyle; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbypassSanitizationTrustScript\\\", function() { return bypassSanitizationTrustScript; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbypassSanitizationTrustUrl\\\", function() { return bypassSanitizationTrustUrl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbypassSanitizationTrustResourceUrl\\\", function() { return bypassSanitizationTrustResourceUrl; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetContext\\\", function() { return getContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵbindPlayerFactory\\\", function() { return bindPlayerFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵaddPlayer\\\", function() { return addPlayer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetPlayers\\\", function() { return getPlayers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcompileNgModuleFactory__POST_NGCC__\\\", function() { return compileNgModuleFactory__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_COMPILE_COMPONENT__POST_NGCC__\\\", function() { return R3_COMPILE_COMPONENT__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_COMPILE_DIRECTIVE__POST_NGCC__\\\", function() { return R3_COMPILE_DIRECTIVE__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_COMPILE_INJECTABLE__POST_NGCC__\\\", function() { return R3_COMPILE_INJECTABLE__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_COMPILE_NGMODULE__POST_NGCC__\\\", function() { return R3_COMPILE_NGMODULE__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_COMPILE_PIPE__POST_NGCC__\\\", function() { return R3_COMPILE_PIPE__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵivyEnable__POST_NGCC__\\\", function() { return ivyEnable__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_ELEMENT_REF_FACTORY__POST_NGCC__\\\", function() { return R3_ELEMENT_REF_FACTORY__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_TEMPLATE_REF_FACTORY__POST_NGCC__\\\", function() { return R3_TEMPLATE_REF_FACTORY__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_CHANGE_DETECTOR_REF_FACTORY__POST_NGCC__\\\", function() { return R3_CHANGE_DETECTOR_REF_FACTORY__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_VIEW_CONTAINER_REF_FACTORY__POST_NGCC__\\\", function() { return R3_VIEW_CONTAINER_REF_FACTORY__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵR3_RENDERER2_FACTORY__POST_NGCC__\\\", function() { return R3_RENDERER2_FACTORY__POST_NGCC__; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵregisterModuleFactory\\\", function() { return registerModuleFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵEMPTY_ARRAY\\\", function() { return EMPTY_ARRAY$4; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵEMPTY_MAP\\\", function() { return EMPTY_MAP; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵand\\\", function() { return anchorDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵccf\\\", function() { return createComponentFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcmf\\\", function() { return createNgModuleFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵcrt\\\", function() { return createRendererType2; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵdid\\\", function() { return directiveDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵeld\\\", function() { return elementDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵelementEventFullName\\\", function() { return elementEventFullName; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵgetComponentViewDefinitionFactory\\\", function() { return getComponentViewDefinitionFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinlineInterpolate\\\", function() { return inlineInterpolate; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵinterpolate\\\", function() { return interpolate; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵmod\\\", function() { return moduleDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵmpd\\\", function() { return moduleProvideDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵncd\\\", function() { return ngContentDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵnov\\\", function() { return nodeValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpid\\\", function() { return pipeDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵprd\\\", function() { return providerDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpad\\\", function() { return pureArrayDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵpod\\\", function() { return pureObjectDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵppd\\\", function() { return purePipeDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵqud\\\", function() { return queryDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵted\\\", function() { return textDef; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵunv\\\", function() { return unwrapValue; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵvid\\\", function() { return viewDef; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(129);\\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(355);\\n/**\\n * @license Angular v7.0.4\\n * (c) 2010-2018 Google, Inc. https://angular.io/\\n * License: MIT\\n */\\n\\n\\n\\n\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\\n    for (var key in objWithPropertyToExtract) {\\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\\n            return key;\\n        }\\n    }\\n    throw Error('Could not find renamed property on target object.');\\n}\\n/**\\n * Sets properties on a target object from a source object, but only if\\n * the property doesn't already exist on the target object.\\n * @param target The target to set properties on\\n * @param source The source of the property keys and values to set\\n */\\nfunction fillProperties(target, source) {\\n    for (var key in source) {\\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\\n            target[key] = source[key];\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar NG_COMPONENT_DEF = getClosureSafeProperty({ ngComponentDef: getClosureSafeProperty });\\nvar NG_DIRECTIVE_DEF = getClosureSafeProperty({ ngDirectiveDef: getClosureSafeProperty });\\nvar NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });\\nvar NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });\\nvar NG_PIPE_DEF = getClosureSafeProperty({ ngPipeDef: getClosureSafeProperty });\\nvar NG_MODULE_DEF = getClosureSafeProperty({ ngModuleDef: getClosureSafeProperty });\\nvar NG_BASE_DEF = getClosureSafeProperty({ ngBaseDef: getClosureSafeProperty });\\n/**\\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\\n * the key and the directive's unique ID as the value. This allows us to map directives to their\\n * bloom filter bit for DI.\\n */\\nvar NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\\n * in which injectors (if any) it will be available.\\n *\\n * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\\n * `InjectableType`.\\n *\\n * Options:\\n * * `providedIn` determines which injectors will include the injectable, by either associating it\\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\\n * * `factory` gives the zero argument function which will create an instance of the injectable.\\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\\n *\\n * @publicApi\\n */\\nfunction defineInjectable(opts) {\\n    return {\\n        providedIn: opts.providedIn || null, factory: opts.factory, value: undefined,\\n    };\\n}\\n/**\\n * Construct an `InjectorDef` which configures an injector.\\n *\\n * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\\n * `InjectorType`.\\n *\\n * Options:\\n *\\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\\n *   create the type must be provided. If that factory function needs to inject arguments, it can\\n *   use the `inject` function.\\n * * `providers`: an optional array of providers to add to the injector. Each provider must\\n *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\\n *   type must be an `InjectableType`).\\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\\n *   whose providers will also be added to the injector. Locally provided types will override\\n *   providers from imports.\\n *\\n * @publicApi\\n */\\nfunction defineInjector(options) {\\n    return {\\n        factory: options.factory, providers: options.providers || [], imports: options.imports || [],\\n    };\\n}\\n/**\\n * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.\\n *\\n * @param type type which may have `ngInjectableDef`\\n */\\nfunction getInjectableDef(type) {\\n    return type.hasOwnProperty(NG_INJECTABLE_DEF) ? type[NG_INJECTABLE_DEF] : null;\\n}\\n/**\\n * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.\\n *\\n * @param type type which may have `ngInjectorDef`\\n */\\nfunction getInjectorDef(type) {\\n    return type.hasOwnProperty(NG_INJECTOR_DEF) ? type[NG_INJECTOR_DEF] : null;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Creates a token that can be used in a DI Provider.\\n *\\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\\n * runtime representation) such as when injecting an interface, callable type, array or\\n * parametrized type.\\n *\\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\\n * the `Injector`. This provides additional level of type safety.\\n *\\n * ```\\n * interface MyInterface {...}\\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\\n * // myInterface is inferred to be MyInterface.\\n * ```\\n *\\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\\n * dependencies, it can do so using the `inject` function. See below for an example.\\n *\\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\\n * mentioned above, `'root'` is the default value for `providedIn`.\\n *\\n * @usageNotes\\n * ### Basic Example\\n *\\n * ### Plain InjectionToken\\n *\\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\\n *\\n * ### Tree-shakable InjectionToken\\n *\\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\\n *\\n *\\n * @publicApi\\n */\\nvar InjectionToken = /** @class */ (function () {\\n    function InjectionToken(_desc, options) {\\n        this._desc = _desc;\\n        /** @internal */\\n        this.ngMetadataName = 'InjectionToken';\\n        if (options !== undefined) {\\n            this.ngInjectableDef = defineInjectable({\\n                providedIn: options.providedIn || 'root',\\n                factory: options.factory,\\n            });\\n        }\\n        else {\\n            this.ngInjectableDef = undefined;\\n        }\\n    }\\n    InjectionToken.prototype.toString = function () { return \\\"InjectionToken \\\" + this._desc; };\\n    return InjectionToken;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar ANNOTATIONS = '__annotations__';\\nvar PARAMETERS = '__parameters__';\\nvar PROP_METADATA = '__prop__metadata__';\\n/**\\n * @suppress {globalThis}\\n */\\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\\n    var metaCtor = makeMetadataCtor(props);\\n    function DecoratorFactory() {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var _a;\\n        if (this instanceof DecoratorFactory) {\\n            metaCtor.call.apply(metaCtor, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([this], args));\\n            return this;\\n        }\\n        var annotationInstance = new ((_a = DecoratorFactory).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], args)))();\\n        return function TypeDecorator(cls) {\\n            if (typeFn)\\n                typeFn.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([cls], args));\\n            // Use of Object.defineProperty is important since it creates non-enumerable property which\\n            // prevents the property is copied during subclassing.\\n            var annotations = cls.hasOwnProperty(ANNOTATIONS) ?\\n                cls[ANNOTATIONS] :\\n                Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\\n            annotations.push(annotationInstance);\\n            if (additionalProcessing)\\n                additionalProcessing(cls);\\n            return cls;\\n        };\\n    }\\n    if (parentClass) {\\n        DecoratorFactory.prototype = Object.create(parentClass.prototype);\\n    }\\n    DecoratorFactory.prototype.ngMetadataName = name;\\n    DecoratorFactory.annotationCls = DecoratorFactory;\\n    return DecoratorFactory;\\n}\\nfunction makeMetadataCtor(props) {\\n    return function ctor() {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        if (props) {\\n            var values = props.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(args));\\n            for (var propName in values) {\\n                this[propName] = values[propName];\\n            }\\n        }\\n    };\\n}\\nfunction makeParamDecorator(name, props, parentClass) {\\n    var metaCtor = makeMetadataCtor(props);\\n    function ParamDecoratorFactory() {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var _a;\\n        if (this instanceof ParamDecoratorFactory) {\\n            metaCtor.apply(this, args);\\n            return this;\\n        }\\n        var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], args)))();\\n        ParamDecorator.annotation = annotationInstance;\\n        return ParamDecorator;\\n        function ParamDecorator(cls, unusedKey, index) {\\n            // Use of Object.defineProperty is important since it creates non-enumerable property which\\n            // prevents the property is copied during subclassing.\\n            var parameters = cls.hasOwnProperty(PARAMETERS) ?\\n                cls[PARAMETERS] :\\n                Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\\n            // there might be gaps if some in between parameters do not have annotations.\\n            // we pad with nulls.\\n            while (parameters.length <= index) {\\n                parameters.push(null);\\n            }\\n            (parameters[index] = parameters[index] || []).push(annotationInstance);\\n            return cls;\\n        }\\n    }\\n    if (parentClass) {\\n        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\\n    }\\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\\n    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\\n    return ParamDecoratorFactory;\\n}\\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\\n    var metaCtor = makeMetadataCtor(props);\\n    function PropDecoratorFactory() {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var _a;\\n        if (this instanceof PropDecoratorFactory) {\\n            metaCtor.apply(this, args);\\n            return this;\\n        }\\n        var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], args)))();\\n        function PropDecorator(target, name) {\\n            var constructor = target.constructor;\\n            // Use of Object.defineProperty is important since it creates non-enumerable property which\\n            // prevents the property is copied during subclassing.\\n            var meta = constructor.hasOwnProperty(PROP_METADATA) ?\\n                constructor[PROP_METADATA] :\\n                Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\\n            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\\n            meta[name].unshift(decoratorInstance);\\n            if (additionalProcessing)\\n                additionalProcessing.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([target, name], args));\\n        }\\n        return PropDecorator;\\n    }\\n    if (parentClass) {\\n        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\\n    }\\n    PropDecoratorFactory.prototype.ngMetadataName = name;\\n    PropDecoratorFactory.annotationCls = PropDecoratorFactory;\\n    return PropDecoratorFactory;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This token can be used to create a virtual provider that will populate the\\n * `entryComponents` fields of components and ng modules based on its `useValue`.\\n * All components that are referenced in the `useValue` value (either directly\\n * or in a nested array or map) will be added to the `entryComponents` property.\\n *\\n * @usageNotes\\n * ### Example\\n * The following example shows how the router can populate the `entryComponents`\\n * field of an NgModule based on the router configuration which refers\\n * to components.\\n *\\n * ```typescript\\n * // helper function inside the router\\n * function provideRoutes(routes) {\\n *   return [\\n *     {provide: ROUTES, useValue: routes},\\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\\n *   ];\\n * }\\n *\\n * // user code\\n * let routes = [\\n *   {path: '/root', component: RootComp},\\n *   {path: '/teams', component: TeamsComp}\\n * ];\\n *\\n * @NgModule({\\n *   providers: [provideRoutes(routes)]\\n * })\\n * class ModuleWithRoutes {}\\n * ```\\n *\\n * @publicApi\\n */\\nvar ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');\\n/**\\n * Attribute decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Attribute = makeParamDecorator('Attribute', function (attributeName) { return ({ attributeName: attributeName }); });\\n/**\\n * Base class for query metadata.\\n *\\n * @see `ContentChildren`.\\n * @see `ContentChild`.\\n * @see `ViewChildren`.\\n * @see `ViewChild`.\\n *\\n * @publicApi\\n */\\nvar Query = /** @class */ (function () {\\n    function Query() {\\n    }\\n    return Query;\\n}());\\n/**\\n * ContentChildren decorator and metadata.\\n *\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar ContentChildren = makePropDecorator('ContentChildren', function (selector, data) {\\n    if (data === void 0) { data = {}; }\\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ selector: selector, first: false, isViewQuery: false, descendants: false }, data));\\n}, Query);\\n/**\\n * ContentChild decorator and metadata.\\n *\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar ContentChild = makePropDecorator('ContentChild', function (selector, data) {\\n    if (data === void 0) { data = {}; }\\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ selector: selector, first: true, isViewQuery: false, descendants: true }, data));\\n}, Query);\\n/**\\n * ViewChildren decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar ViewChildren = makePropDecorator('ViewChildren', function (selector, data) {\\n    if (data === void 0) { data = {}; }\\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ selector: selector, first: false, isViewQuery: true, descendants: true }, data));\\n}, Query);\\n/**\\n * ViewChild decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar ViewChild = makePropDecorator('ViewChild', function (selector, data) {\\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ selector: selector, first: true, isViewQuery: true, descendants: true }, data));\\n}, Query);\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * The strategy that the default change detector uses to detect changes.\\n * When set, takes effect the next time change detection is triggered.\\n *\\n * @publicApi\\n */\\nvar ChangeDetectionStrategy;\\n(function (ChangeDetectionStrategy) {\\n    /**\\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\\n     * Change detection can still be explictly invoked.\\n     */\\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\\\"OnPush\\\"] = 0] = \\\"OnPush\\\";\\n    /**\\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\\n     * explicitly deactivated.\\n     */\\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\\\"Default\\\"] = 1] = \\\"Default\\\";\\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\\n/**\\n * Defines the possible states of the default change detector.\\n * @see `ChangeDetectorRef`\\n */\\nvar ChangeDetectorStatus;\\n(function (ChangeDetectorStatus) {\\n    /**\\n     * A state in which, after calling `detectChanges()`, the change detector\\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"CheckOnce\\\"] = 0] = \\\"CheckOnce\\\";\\n    /**\\n     * A state in which change detection is skipped until the change detector mode\\n     * becomes `CheckOnce`.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"Checked\\\"] = 1] = \\\"Checked\\\";\\n    /**\\n     * A state in which change detection continues automatically until explictly\\n     * deactivated.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"CheckAlways\\\"] = 2] = \\\"CheckAlways\\\";\\n    /**\\n     * A state in which a change detector sub tree is not a part of the main tree and\\n     * should be skipped.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"Detached\\\"] = 3] = \\\"Detached\\\";\\n    /**\\n     * Indicates that the change detector encountered an error checking a binding\\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\\n     * detectors in this state do not detect changes.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"Errored\\\"] = 4] = \\\"Errored\\\";\\n    /**\\n     * Indicates that the change detector has been destroyed.\\n     */\\n    ChangeDetectorStatus[ChangeDetectorStatus[\\\"Destroyed\\\"] = 5] = \\\"Destroyed\\\";\\n})(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\\n/**\\n * Reports whether a given strategy is currently the default for change detection.\\n * @param changeDetectionStrategy The strategy to check.\\n * @returns True if the given strategy is the current default, false otherwise.\\n * @see `ChangeDetectorStatus`\\n * @see `ChangeDetectorRef`\\n */\\nfunction isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\\n    return changeDetectionStrategy == null ||\\n        changeDetectionStrategy === ChangeDetectionStrategy.Default;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar __window = typeof window !== 'undefined' && window;\\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\\n    self instanceof WorkerGlobalScope && self;\\nvar __global = typeof global !== 'undefined' && global;\\n// Check __global first, because in Node tests both __global and __window may be defined and _global\\n// should be __global in that case.\\nvar _global = __global || __window || __self;\\nvar promise = Promise.resolve(0);\\nvar _symbolIterator = null;\\nfunction getSymbolIterator() {\\n    if (!_symbolIterator) {\\n        var Symbol_1 = _global['Symbol'];\\n        if (Symbol_1 && Symbol_1.iterator) {\\n            _symbolIterator = Symbol_1.iterator;\\n        }\\n        else {\\n            // es6-shim specific logic\\n            var keys = Object.getOwnPropertyNames(Map.prototype);\\n            for (var i = 0; i < keys.length; ++i) {\\n                var key = keys[i];\\n                if (key !== 'entries' && key !== 'size' &&\\n                    Map.prototype[key] === Map.prototype['entries']) {\\n                    _symbolIterator = key;\\n                }\\n            }\\n        }\\n    }\\n    return _symbolIterator;\\n}\\nfunction scheduleMicroTask(fn) {\\n    if (typeof Zone === 'undefined') {\\n        // use promise to schedule microTask instead of use Zone\\n        promise.then(function () { fn && fn.apply(null, null); });\\n    }\\n    else {\\n        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\\n    }\\n}\\n// JS has NaN !== NaN\\nfunction looseIdentical(a, b) {\\n    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\\n}\\nfunction stringify(token) {\\n    if (typeof token === 'string') {\\n        return token;\\n    }\\n    if (token instanceof Array) {\\n        return '[' + token.map(stringify).join(', ') + ']';\\n    }\\n    if (token == null) {\\n        return '' + token;\\n    }\\n    if (token.overriddenName) {\\n        return \\\"\\\" + token.overriddenName;\\n    }\\n    if (token.name) {\\n        return \\\"\\\" + token.name;\\n    }\\n    var res = token.toString();\\n    if (res == null) {\\n        return '' + res;\\n    }\\n    var newLineIndex = res.indexOf('\\\\n');\\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\\n}\\n/**\\n * Convince closure compiler that the wrapped function has no side-effects.\\n *\\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\\n * It is important that the return value for the `noSideEffects` function be assigned\\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\\n * compiler.\\n */\\nfunction noSideEffects(fn) {\\n    return '' + { toString: fn };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Allows to refer to references which are not yet defined.\\n *\\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\\n * a query is not yet defined.\\n *\\n * @usageNotes\\n * ### Example\\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\\n * @publicApi\\n */\\nfunction forwardRef(forwardRefFn) {\\n    forwardRefFn.__forward_ref__ = forwardRef;\\n    forwardRefFn.toString = function () { return stringify(this()); };\\n    return forwardRefFn;\\n}\\n/**\\n * Lazily retrieves the reference value from a forwardRef.\\n *\\n * Acts as the identity function when given a non-forward-ref value.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\\n *\\n * @see `forwardRef`\\n * @publicApi\\n */\\nfunction resolveForwardRef(type) {\\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&\\n        type.__forward_ref__ === forwardRef) {\\n        return type();\\n    }\\n    else {\\n        return type;\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Inject decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Inject = makeParamDecorator('Inject', function (token) { return ({ token: token }); });\\n/**\\n * Optional decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Optional = makeParamDecorator('Optional');\\n/**\\n * Self decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Self = makeParamDecorator('Self');\\n/**\\n * SkipSelf decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar SkipSelf = makeParamDecorator('SkipSelf');\\n/**\\n * Host decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Host = makeParamDecorator('Host');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar SOURCE = '__source';\\nvar _THROW_IF_NOT_FOUND = new Object();\\nvar THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\\n/**\\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\\n *\\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\\n * project.\\n *\\n * @publicApi\\n */\\nvar INJECTOR = new InjectionToken('INJECTOR');\\nvar NullInjector = /** @class */ (function () {\\n    function NullInjector() {\\n    }\\n    NullInjector.prototype.get = function (token, notFoundValue) {\\n        if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }\\n        if (notFoundValue === _THROW_IF_NOT_FOUND) {\\n            // Intentionally left behind: With dev tools open the debugger will stop here. There is no\\n            // reason why correctly written application should cause this exception.\\n            // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\\n            // if(ngDevMode) debugger;\\n            throw new Error(\\\"NullInjectorError: No provider for \\\" + stringify(token) + \\\"!\\\");\\n        }\\n        return notFoundValue;\\n    };\\n    return NullInjector;\\n}());\\n/**\\n * Concrete injectors implement this interface.\\n *\\n * For more details, see the [\\\"Dependency Injection Guide\\\"](guide/dependency-injection).\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * {@example core/di/ts/injector_spec.ts region='Injector'}\\n *\\n * `Injector` returns itself when given `Injector` as a token:\\n *\\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\\n *\\n * @publicApi\\n */\\nvar Injector = /** @class */ (function () {\\n    function Injector() {\\n    }\\n    /**\\n     * Create a new Injector which is configure using `StaticProvider`s.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\\n     */\\n    Injector.create = function (options, parent) {\\n        if (Array.isArray(options)) {\\n            return new StaticInjector(options, parent);\\n        }\\n        else {\\n            return new StaticInjector(options.providers, options.parent, options.name || null);\\n        }\\n    };\\n    Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\\n    Injector.NULL = new NullInjector();\\n    Injector.ngInjectableDef = defineInjectable({\\n        providedIn: 'any',\\n        factory: function () { return inject(INJECTOR); },\\n    });\\n    return Injector;\\n}());\\nvar IDENT = function (value) {\\n    return value;\\n};\\nvar EMPTY = [];\\nvar CIRCULAR = IDENT;\\nvar MULTI_PROVIDER_FN = function () {\\n    return Array.prototype.slice.call(arguments);\\n};\\nvar USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\\nvar NG_TOKEN_PATH = 'ngTokenPath';\\nvar NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\\nvar NULL_INJECTOR = Injector.NULL;\\nvar NEW_LINE = /\\\\n/gm;\\nvar NO_NEW_LINE = 'ɵ';\\nvar StaticInjector = /** @class */ (function () {\\n    function StaticInjector(providers, parent, source) {\\n        if (parent === void 0) { parent = NULL_INJECTOR; }\\n        if (source === void 0) { source = null; }\\n        this.parent = parent;\\n        this.source = source;\\n        var records = this._records = new Map();\\n        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });\\n        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });\\n        recursivelyProcessProviders(records, providers);\\n    }\\n    StaticInjector.prototype.get = function (token, notFoundValue, flags) {\\n        if (flags === void 0) { flags = 0 /* Default */; }\\n        var record = this._records.get(token);\\n        try {\\n            return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\\n        }\\n        catch (e) {\\n            var tokenPath = e[NG_TEMP_TOKEN_PATH];\\n            if (token[SOURCE]) {\\n                tokenPath.unshift(token[SOURCE]);\\n            }\\n            e.message = formatError('\\\\n' + e.message, tokenPath, this.source);\\n            e[NG_TOKEN_PATH] = tokenPath;\\n            e[NG_TEMP_TOKEN_PATH] = null;\\n            throw e;\\n        }\\n    };\\n    StaticInjector.prototype.toString = function () {\\n        var tokens = [], records = this._records;\\n        records.forEach(function (v, token) { return tokens.push(stringify(token)); });\\n        return \\\"StaticInjector[\\\" + tokens.join(', ') + \\\"]\\\";\\n    };\\n    return StaticInjector;\\n}());\\nfunction resolveProvider(provider) {\\n    var deps = computeDeps(provider);\\n    var fn = IDENT;\\n    var value = EMPTY;\\n    var useNew = false;\\n    var provide = resolveForwardRef(provider.provide);\\n    if (USE_VALUE in provider) {\\n        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\\n        value = provider.useValue;\\n    }\\n    else if (provider.useFactory) {\\n        fn = provider.useFactory;\\n    }\\n    else if (provider.useExisting) ;\\n    else if (provider.useClass) {\\n        useNew = true;\\n        fn = resolveForwardRef(provider.useClass);\\n    }\\n    else if (typeof provide == 'function') {\\n        useNew = true;\\n        fn = provide;\\n    }\\n    else {\\n        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);\\n    }\\n    return { deps: deps, fn: fn, useNew: useNew, value: value };\\n}\\nfunction multiProviderMixError(token) {\\n    return staticError('Cannot mix multi providers and regular providers', token);\\n}\\nfunction recursivelyProcessProviders(records, provider) {\\n    if (provider) {\\n        provider = resolveForwardRef(provider);\\n        if (provider instanceof Array) {\\n            // if we have an array recurse into the array\\n            for (var i = 0; i < provider.length; i++) {\\n                recursivelyProcessProviders(records, provider[i]);\\n            }\\n        }\\n        else if (typeof provider === 'function') {\\n            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\\n            // error messages\\n            throw staticError('Function/Class not supported', provider);\\n        }\\n        else if (provider && typeof provider === 'object' && provider.provide) {\\n            // At this point we have what looks like a provider: {provide: ?, ....}\\n            var token = resolveForwardRef(provider.provide);\\n            var resolvedProvider = resolveProvider(provider);\\n            if (provider.multi === true) {\\n                // This is a multi provider.\\n                var multiProvider = records.get(token);\\n                if (multiProvider) {\\n                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {\\n                        throw multiProviderMixError(token);\\n                    }\\n                }\\n                else {\\n                    // Create a placeholder factory which will look up the constituents of the multi provider.\\n                    records.set(token, multiProvider = {\\n                        token: provider.provide,\\n                        deps: [],\\n                        useNew: false,\\n                        fn: MULTI_PROVIDER_FN,\\n                        value: EMPTY\\n                    });\\n                }\\n                // Treat the provider as the token.\\n                token = provider;\\n                multiProvider.deps.push({ token: token, options: 6 /* Default */ });\\n            }\\n            var record = records.get(token);\\n            if (record && record.fn == MULTI_PROVIDER_FN) {\\n                throw multiProviderMixError(token);\\n            }\\n            records.set(token, resolvedProvider);\\n        }\\n        else {\\n            throw staticError('Unexpected provider', provider);\\n        }\\n    }\\n}\\nfunction tryResolveToken(token, record, records, parent, notFoundValue, flags) {\\n    try {\\n        return resolveToken(token, record, records, parent, notFoundValue, flags);\\n    }\\n    catch (e) {\\n        // ensure that 'e' is of type Error.\\n        if (!(e instanceof Error)) {\\n            e = new Error(e);\\n        }\\n        var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\\n        path.unshift(token);\\n        if (record && record.value == CIRCULAR) {\\n            // Reset the Circular flag.\\n            record.value = EMPTY;\\n        }\\n        throw e;\\n    }\\n}\\nfunction resolveToken(token, record, records, parent, notFoundValue, flags) {\\n    var _a;\\n    var value;\\n    if (record && !(flags & 4 /* SkipSelf */)) {\\n        // If we don't have a record, this implies that we don't own the provider hence don't know how\\n        // to resolve it.\\n        value = record.value;\\n        if (value == CIRCULAR) {\\n            throw Error(NO_NEW_LINE + 'Circular dependency');\\n        }\\n        else if (value === EMPTY) {\\n            record.value = CIRCULAR;\\n            var obj = undefined;\\n            var useNew = record.useNew;\\n            var fn = record.fn;\\n            var depRecords = record.deps;\\n            var deps = EMPTY;\\n            if (depRecords.length) {\\n                deps = [];\\n                for (var i = 0; i < depRecords.length; i++) {\\n                    var depRecord = depRecords[i];\\n                    var options = depRecord.options;\\n                    var childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;\\n                    deps.push(tryResolveToken(\\n                    // Current Token to resolve\\n                    depRecord.token, \\n                    // A record which describes how to resolve the token.\\n                    // If undefined, this means we don't have such a record\\n                    childRecord, \\n                    // Other records we know about.\\n                    records, \\n                    // If we don't know how to resolve dependency and we should not check parent for it,\\n                    // than pass in Null injector.\\n                    !childRecord && !(options & 4 /* CheckParent */) ? NULL_INJECTOR : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, 0 /* Default */));\\n                }\\n            }\\n            record.value = value = useNew ? new ((_a = fn).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], deps)))() : fn.apply(obj, deps);\\n        }\\n    }\\n    else if (!(flags & 2 /* Self */)) {\\n        value = parent.get(token, notFoundValue, 0 /* Default */);\\n    }\\n    return value;\\n}\\nfunction computeDeps(provider) {\\n    var deps = EMPTY;\\n    var providerDeps = provider.deps;\\n    if (providerDeps && providerDeps.length) {\\n        deps = [];\\n        for (var i = 0; i < providerDeps.length; i++) {\\n            var options = 6 /* Default */;\\n            var token = resolveForwardRef(providerDeps[i]);\\n            if (token instanceof Array) {\\n                for (var j = 0, annotations = token; j < annotations.length; j++) {\\n                    var annotation = annotations[j];\\n                    if (annotation instanceof Optional || annotation == Optional) {\\n                        options = options | 1 /* Optional */;\\n                    }\\n                    else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\\n                        options = options & ~2 /* CheckSelf */;\\n                    }\\n                    else if (annotation instanceof Self || annotation == Self) {\\n                        options = options & ~4 /* CheckParent */;\\n                    }\\n                    else if (annotation instanceof Inject) {\\n                        token = annotation.token;\\n                    }\\n                    else {\\n                        token = resolveForwardRef(annotation);\\n                    }\\n                }\\n            }\\n            deps.push({ token: token, options: options });\\n        }\\n    }\\n    else if (provider.useExisting) {\\n        var token = resolveForwardRef(provider.useExisting);\\n        deps = [{ token: token, options: 6 /* Default */ }];\\n    }\\n    else if (!providerDeps && !(USE_VALUE in provider)) {\\n        // useValue & useExisting are the only ones which are exempt from deps all others need it.\\n        throw staticError('\\\\'deps\\\\' required', provider);\\n    }\\n    return deps;\\n}\\nfunction formatError(text, obj, source) {\\n    if (source === void 0) { source = null; }\\n    text = text && text.charAt(0) === '\\\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\\n    var context = stringify(obj);\\n    if (obj instanceof Array) {\\n        context = obj.map(stringify).join(' -> ');\\n    }\\n    else if (typeof obj === 'object') {\\n        var parts = [];\\n        for (var key in obj) {\\n            if (obj.hasOwnProperty(key)) {\\n                var value = obj[key];\\n                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\\n            }\\n        }\\n        context = \\\"{\\\" + parts.join(', ') + \\\"}\\\";\\n    }\\n    return \\\"StaticInjectorError\\\" + (source ? '(' + source + ')' : '') + \\\"[\\\" + context + \\\"]: \\\" + text.replace(NEW_LINE, '\\\\n  ');\\n}\\nfunction staticError(text, obj) {\\n    return new Error(formatError(text, obj));\\n}\\n/**\\n * Current injector value used by `inject`.\\n * - `undefined`: it is an error to call `inject`\\n * - `null`: `inject` can be called but there is no injector (limp-mode).\\n * - Injector instance: Use the injector for resolution.\\n */\\nvar _currentInjector = undefined;\\nfunction setCurrentInjector(injector) {\\n    var former = _currentInjector;\\n    _currentInjector = injector;\\n    return former;\\n}\\nfunction inject(token, flags) {\\n    if (flags === void 0) { flags = 0 /* Default */; }\\n    if (_currentInjector === undefined) {\\n        throw new Error(\\\"inject() must be called from an injection context\\\");\\n    }\\n    else if (_currentInjector === null) {\\n        var injectableDef = getInjectableDef(token);\\n        if (injectableDef && injectableDef.providedIn == 'root') {\\n            return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\\n                injectableDef.value;\\n        }\\n        if (flags & 8 /* Optional */)\\n            return null;\\n        throw new Error(\\\"Injector: NOT_FOUND [\\\" + stringify(token) + \\\"]\\\");\\n    }\\n    else {\\n        return _currentInjector.get(token, flags & 8 /* Optional */ ? null : undefined, flags);\\n    }\\n}\\nfunction injectArgs(types) {\\n    var args = [];\\n    for (var i = 0; i < types.length; i++) {\\n        var arg = types[i];\\n        if (Array.isArray(arg)) {\\n            if (arg.length === 0) {\\n                throw new Error('Arguments array must have arguments.');\\n            }\\n            var type = undefined;\\n            var flags = 0 /* Default */;\\n            for (var j = 0; j < arg.length; j++) {\\n                var meta = arg[j];\\n                if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\\n                    flags |= 8 /* Optional */;\\n                }\\n                else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\\n                    flags |= 4 /* SkipSelf */;\\n                }\\n                else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\\n                    flags |= 2 /* Self */;\\n                }\\n                else if (meta instanceof Inject) {\\n                    type = meta.token;\\n                }\\n                else {\\n                    type = meta;\\n                }\\n            }\\n            args.push(inject(type, flags));\\n        }\\n        else {\\n            args.push(inject(arg));\\n        }\\n    }\\n    return args;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Represents a type that a Component or other object is instances of.\\n *\\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\\n * the `MyCustomComponent` constructor function.\\n *\\n * @publicApi\\n */\\nvar Type = Function;\\nfunction isType(v) {\\n    return typeof v === 'function';\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Attention: These regex has to hold even if the code is minified!\\n */\\nvar DELEGATE_CTOR = /^function\\\\s+\\\\S+\\\\(\\\\)\\\\s*{[\\\\s\\\\S]+\\\\.apply\\\\(this,\\\\s*arguments\\\\)/;\\nvar INHERITED_CLASS = /^class\\\\s+[A-Za-z\\\\d$_]*\\\\s*extends\\\\s+[^{]+{/;\\nvar INHERITED_CLASS_WITH_CTOR = /^class\\\\s+[A-Za-z\\\\d$_]*\\\\s*extends\\\\s+[^{]+{[\\\\s\\\\S]*constructor\\\\s*\\\\(/;\\nvar ReflectionCapabilities = /** @class */ (function () {\\n    function ReflectionCapabilities(reflect) {\\n        this._reflect = reflect || _global['Reflect'];\\n    }\\n    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\\n    ReflectionCapabilities.prototype.factory = function (t) { return function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        return new (t.bind.apply(t, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], args)))();\\n    }; };\\n    /** @internal */\\n    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {\\n        var result;\\n        if (typeof paramTypes === 'undefined') {\\n            result = new Array(paramAnnotations.length);\\n        }\\n        else {\\n            result = new Array(paramTypes.length);\\n        }\\n        for (var i = 0; i < result.length; i++) {\\n            // TS outputs Object for parameters without types, while Traceur omits\\n            // the annotations. For now we preserve the Traceur behavior to aid\\n            // migration, but this can be revisited.\\n            if (typeof paramTypes === 'undefined') {\\n                result[i] = [];\\n            }\\n            else if (paramTypes[i] != Object) {\\n                result[i] = [paramTypes[i]];\\n            }\\n            else {\\n                result[i] = [];\\n            }\\n            if (paramAnnotations && paramAnnotations[i] != null) {\\n                result[i] = result[i].concat(paramAnnotations[i]);\\n            }\\n        }\\n        return result;\\n    };\\n    ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {\\n        var typeStr = type.toString();\\n        // If we have no decorators, we only have function.length as metadata.\\n        // In that case, to detect whether a child class declared an own constructor or not,\\n        // we need to look inside of that constructor to check whether it is\\n        // just calling the parent.\\n        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\\n        // that sets 'design:paramtypes' to []\\n        // if a class inherits from another class but has no ctor declared itself.\\n        if (DELEGATE_CTOR.exec(typeStr) ||\\n            (INHERITED_CLASS.exec(typeStr) && !INHERITED_CLASS_WITH_CTOR.exec(typeStr))) {\\n            return null;\\n        }\\n        // Prefer the direct API.\\n        if (type.parameters && type.parameters !== parentCtor.parameters) {\\n            return type.parameters;\\n        }\\n        // API of tsickle for lowering decorators to properties on the class.\\n        var tsickleCtorParams = type.ctorParameters;\\n        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\\n            // Newer tsickle uses a function closure\\n            // Retain the non-function case for compatibility with older tsickle\\n            var ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\\n            var paramTypes_1 = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });\\n            var paramAnnotations_1 = ctorParameters.map(function (ctorParam) {\\n                return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);\\n            });\\n            return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);\\n        }\\n        // API for metadata created by invoking the decorators.\\n        var paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\\n        var paramTypes = this._reflect && this._reflect.getOwnMetadata &&\\n            this._reflect.getOwnMetadata('design:paramtypes', type);\\n        if (paramTypes || paramAnnotations) {\\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\\n        }\\n        // If a class has no decorators, at least create metadata\\n        // based on function.length.\\n        // Note: We know that this is a real constructor as we checked\\n        // the content of the constructor above.\\n        return new Array(type.length).fill(undefined);\\n    };\\n    ReflectionCapabilities.prototype.parameters = function (type) {\\n        // Note: only report metadata if we have at least one class decorator\\n        // to stay in sync with the static reflector.\\n        if (!isType(type)) {\\n            return [];\\n        }\\n        var parentCtor = getParentCtor(type);\\n        var parameters = this._ownParameters(type, parentCtor);\\n        if (!parameters && parentCtor !== Object) {\\n            parameters = this.parameters(parentCtor);\\n        }\\n        return parameters || [];\\n    };\\n    ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {\\n        // Prefer the direct API.\\n        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\\n            var annotations = typeOrFunc.annotations;\\n            if (typeof annotations === 'function' && annotations.annotations) {\\n                annotations = annotations.annotations;\\n            }\\n            return annotations;\\n        }\\n        // API of tsickle for lowering decorators to properties on the class.\\n        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\\n            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\\n        }\\n        // API for metadata created by invoking the decorators.\\n        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\\n            return typeOrFunc[ANNOTATIONS];\\n        }\\n        return null;\\n    };\\n    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {\\n        if (!isType(typeOrFunc)) {\\n            return [];\\n        }\\n        var parentCtor = getParentCtor(typeOrFunc);\\n        var ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\\n        var parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\\n        return parentAnnotations.concat(ownAnnotations);\\n    };\\n    ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {\\n        // Prefer the direct API.\\n        if (typeOrFunc.propMetadata &&\\n            typeOrFunc.propMetadata !== parentCtor.propMetadata) {\\n            var propMetadata = typeOrFunc.propMetadata;\\n            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\\n                propMetadata = propMetadata.propMetadata;\\n            }\\n            return propMetadata;\\n        }\\n        // API of tsickle for lowering decorators to properties on the class.\\n        if (typeOrFunc.propDecorators &&\\n            typeOrFunc.propDecorators !== parentCtor.propDecorators) {\\n            var propDecorators_1 = typeOrFunc.propDecorators;\\n            var propMetadata_1 = {};\\n            Object.keys(propDecorators_1).forEach(function (prop) {\\n                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);\\n            });\\n            return propMetadata_1;\\n        }\\n        // API for metadata created by invoking the decorators.\\n        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\\n            return typeOrFunc[PROP_METADATA];\\n        }\\n        return null;\\n    };\\n    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\\n        if (!isType(typeOrFunc)) {\\n            return {};\\n        }\\n        var parentCtor = getParentCtor(typeOrFunc);\\n        var propMetadata = {};\\n        if (parentCtor !== Object) {\\n            var parentPropMetadata_1 = this.propMetadata(parentCtor);\\n            Object.keys(parentPropMetadata_1).forEach(function (propName) {\\n                propMetadata[propName] = parentPropMetadata_1[propName];\\n            });\\n        }\\n        var ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\\n        if (ownPropMetadata) {\\n            Object.keys(ownPropMetadata).forEach(function (propName) {\\n                var decorators = [];\\n                if (propMetadata.hasOwnProperty(propName)) {\\n                    decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(propMetadata[propName]));\\n                }\\n                decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(ownPropMetadata[propName]));\\n                propMetadata[propName] = decorators;\\n            });\\n        }\\n        return propMetadata;\\n    };\\n    ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\\n        return type instanceof Type && lcProperty in type.prototype;\\n    };\\n    ReflectionCapabilities.prototype.guards = function (type) { return {}; };\\n    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };\\n    ReflectionCapabilities.prototype.setter = function (name) {\\n        return new Function('o', 'v', 'return o.' + name + ' = v;');\\n    };\\n    ReflectionCapabilities.prototype.method = function (name) {\\n        var functionBody = \\\"if (!o.\\\" + name + \\\") throw new Error('\\\\\\\"\\\" + name + \\\"\\\\\\\" is undefined');\\\\n        return o.\\\" + name + \\\".apply(o, args);\\\";\\n        return new Function('o', 'args', functionBody);\\n    };\\n    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\\n    ReflectionCapabilities.prototype.importUri = function (type) {\\n        // StaticSymbol\\n        if (typeof type === 'object' && type['filePath']) {\\n            return type['filePath'];\\n        }\\n        // Runtime type\\n        return \\\"./\\\" + stringify(type);\\n    };\\n    ReflectionCapabilities.prototype.resourceUri = function (type) { return \\\"./\\\" + stringify(type); };\\n    ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\\n        return runtime;\\n    };\\n    ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };\\n    return ReflectionCapabilities;\\n}());\\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\\n    if (!decoratorInvocations) {\\n        return [];\\n    }\\n    return decoratorInvocations.map(function (decoratorInvocation) {\\n        var decoratorType = decoratorInvocation.type;\\n        var annotationCls = decoratorType.annotationCls;\\n        var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\\n        return new (annotationCls.bind.apply(annotationCls, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], annotationArgs)))();\\n    });\\n}\\nfunction getParentCtor(ctor) {\\n    var parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\\n    var parentCtor = parentProto ? parentProto.constructor : null;\\n    // Note: We always use `Object` as the null value\\n    // to simplify checking later on.\\n    return parentCtor || Object;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\\n *\\n * Example:\\n * ```\\n * @Component({\\n *   selector: 'my-comp',\\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\\n * })\\n * class MyComponnent{\\n * }\\n *\\n * // Calling `renderComponent` will fail because `MyComponent`'s `@Compenent.templateUrl`\\n * // needs to be resolved because `renderComponent` is synchronous process.\\n * // renderComponent(MyComponent);\\n *\\n * // Calling `resolveComponentResources` will resolve `@Compenent.templateUrl` into\\n * // `@Compenent.template`, which would allow `renderComponent` to proceed in synchronous manner.\\n * // Use browser's `fetch` function as the default resource resolution strategy.\\n * resolveComponentResources(fetch).then(() => {\\n *   // After resolution all URLs have been converted into strings.\\n *   renderComponent(MyComponent);\\n * });\\n *\\n * ```\\n *\\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\\n * to call this method outside JIT mode.\\n *\\n * @param resourceResolver a function which is responsible to returning a `Promise` of the resolved\\n * URL. Browser's `fetch` method is a good default implementation.\\n */\\nfunction resolveComponentResources(resourceResolver) {\\n    // Store all promises which are fetching the resources.\\n    var urlFetches = [];\\n    // Cache so that we don't fetch the same resource more than once.\\n    var urlMap = new Map();\\n    function cachedResourceResolve(url) {\\n        var promise = urlMap.get(url);\\n        if (!promise) {\\n            var resp = resourceResolver(url);\\n            urlMap.set(url, promise = resp.then(unwrapResponse));\\n            urlFetches.push(promise);\\n        }\\n        return promise;\\n    }\\n    componentResourceResolutionQueue.forEach(function (component) {\\n        if (component.templateUrl) {\\n            cachedResourceResolve(component.templateUrl).then(function (template) {\\n                component.template = template;\\n                component.templateUrl = undefined;\\n            });\\n        }\\n        var styleUrls = component.styleUrls;\\n        var styles = component.styles || (component.styles = []);\\n        var styleOffset = component.styles.length;\\n        styleUrls && styleUrls.forEach(function (styleUrl, index) {\\n            styles.push(''); // pre-allocate array.\\n            cachedResourceResolve(styleUrl).then(function (style) {\\n                styles[styleOffset + index] = style;\\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\\n                if (styleUrls.length == 0) {\\n                    component.styleUrls = undefined;\\n                }\\n            });\\n        });\\n    });\\n    componentResourceResolutionQueue.clear();\\n    return Promise.all(urlFetches).then(function () { return null; });\\n}\\nvar componentResourceResolutionQueue = new Set();\\nfunction maybeQueueResolutionOfComponentResources(metadata) {\\n    if (componentNeedsResolution(metadata)) {\\n        componentResourceResolutionQueue.add(metadata);\\n    }\\n}\\nfunction componentNeedsResolution(component) {\\n    return component.templateUrl || component.styleUrls && component.styleUrls.length;\\n}\\nfunction unwrapResponse(response) {\\n    return typeof response == 'string' ? response : response.text();\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Defines template and style encapsulation options available for Component's {@link Component}.\\n *\\n * See {@link Component#encapsulation encapsulation}.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\\n *\\n * @publicApi\\n */\\nvar ViewEncapsulation;\\n(function (ViewEncapsulation) {\\n    /**\\n     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\\n     * Element and pre-processing the style rules provided via {@link Component#styles styles} or\\n     * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\\n     * selectors.\\n     *\\n     * This is the default option.\\n     */\\n    ViewEncapsulation[ViewEncapsulation[\\\"Emulated\\\"] = 0] = \\\"Emulated\\\";\\n    /**\\n     * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\\n     * Use the native encapsulation mechanism of the renderer.\\n     *\\n     * For the DOM this means using the deprecated [Shadow DOM\\n     * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\\n     * creating a ShadowRoot for Component's Host Element.\\n     */\\n    ViewEncapsulation[ViewEncapsulation[\\\"Native\\\"] = 1] = \\\"Native\\\";\\n    /**\\n     * Don't provide any template or style encapsulation.\\n     */\\n    ViewEncapsulation[ViewEncapsulation[\\\"None\\\"] = 2] = \\\"None\\\";\\n    /**\\n     * Use Shadow DOM to encapsulate styles.\\n     *\\n     * For the DOM this means using modern [Shadow\\n     * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\\n     * creating a ShadowRoot for Component's Host Element.\\n     */\\n    ViewEncapsulation[ViewEncapsulation[\\\"ShadowDom\\\"] = 3] = \\\"ShadowDom\\\";\\n})(ViewEncapsulation || (ViewEncapsulation = {}));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction ngDevModeResetPerfCounters() {\\n    var newCounters = {\\n        firstTemplatePass: 0,\\n        tNode: 0,\\n        tView: 0,\\n        rendererCreateTextNode: 0,\\n        rendererSetText: 0,\\n        rendererCreateElement: 0,\\n        rendererAddEventListener: 0,\\n        rendererSetAttribute: 0,\\n        rendererRemoveAttribute: 0,\\n        rendererSetProperty: 0,\\n        rendererSetClassName: 0,\\n        rendererAddClass: 0,\\n        rendererRemoveClass: 0,\\n        rendererSetStyle: 0,\\n        rendererRemoveStyle: 0,\\n        rendererDestroy: 0,\\n        rendererDestroyNode: 0,\\n        rendererMoveNode: 0,\\n        rendererRemoveNode: 0,\\n        rendererCreateComment: 0,\\n    };\\n    // NOTE: Under Ivy we may have both window & global defined in the Node\\n    //    environment since ensureDocument() in render3.ts sets global.window.\\n    if (typeof window != 'undefined') {\\n        // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\\n        window['ngDevMode'] = newCounters;\\n    }\\n    if (typeof global != 'undefined') {\\n        // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\\n        global['ngDevMode'] = newCounters;\\n    }\\n    if (typeof self != 'undefined') {\\n        // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\\n        self['ngDevMode'] = newCounters;\\n    }\\n    return newCounters;\\n}\\n/**\\n * This checks to see if the `ngDevMode` has been set. If yes,\\n * than we honor it, otherwise we default to dev mode with additional checks.\\n *\\n * The idea is that unless we are doing production build where we explicitly\\n * set `ngDevMode == false` we should be helping the developer by providing\\n * as much early warning and errors as possible.\\n */\\nif (typeof ngDevMode === 'undefined' || ngDevMode) {\\n    ngDevModeResetPerfCounters();\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar EMPTY$1 = {};\\nvar EMPTY_ARRAY = [];\\nif (typeof ngDevMode !== 'undefined' && ngDevMode) {\\n    Object.freeze(EMPTY$1);\\n    Object.freeze(EMPTY_ARRAY);\\n}\\nvar _renderCompCount = 0;\\n/**\\n * Create a component definition object.\\n *\\n *\\n * # Example\\n * ```\\n * class MyDirective {\\n *   // Generated by Angular Template Compiler\\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\\n *   static ngComponentDef = defineComponent({\\n *     ...\\n *   });\\n * }\\n * ```\\n */\\nfunction defineComponent(componentDefinition) {\\n    var type = componentDefinition.type;\\n    var typePrototype = type.prototype;\\n    var declaredInputs = {};\\n    var def = {\\n        type: type,\\n        diPublic: null,\\n        consts: componentDefinition.consts,\\n        vars: componentDefinition.vars,\\n        hostVars: componentDefinition.hostVars || 0,\\n        factory: componentDefinition.factory,\\n        template: componentDefinition.template || null,\\n        hostBindings: componentDefinition.hostBindings || null,\\n        contentQueries: componentDefinition.contentQueries || null,\\n        contentQueriesRefresh: componentDefinition.contentQueriesRefresh || null,\\n        attributes: componentDefinition.attributes || null,\\n        declaredInputs: declaredInputs,\\n        inputs: null,\\n        outputs: null,\\n        exportAs: componentDefinition.exportAs || null,\\n        onInit: typePrototype.ngOnInit || null,\\n        doCheck: typePrototype.ngDoCheck || null,\\n        afterContentInit: typePrototype.ngAfterContentInit || null,\\n        afterContentChecked: typePrototype.ngAfterContentChecked || null,\\n        afterViewInit: typePrototype.ngAfterViewInit || null,\\n        afterViewChecked: typePrototype.ngAfterViewChecked || null,\\n        onDestroy: typePrototype.ngOnDestroy || null,\\n        onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\\n        directiveDefs: null,\\n        pipeDefs: null,\\n        selectors: componentDefinition.selectors,\\n        viewQuery: componentDefinition.viewQuery || null,\\n        features: componentDefinition.features || null,\\n        data: componentDefinition.data || {},\\n        // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\\n        // next line. Also `None` should be 0 not 2.\\n        encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\\n        providers: EMPTY_ARRAY,\\n        viewProviders: EMPTY_ARRAY,\\n        id: 'c',\\n        styles: componentDefinition.styles || EMPTY_ARRAY,\\n        _: null,\\n    };\\n    def._ = noSideEffects(function () {\\n        var directiveTypes = componentDefinition.directives;\\n        var feature = componentDefinition.features;\\n        var pipeTypes = componentDefinition.pipes;\\n        def.id += _renderCompCount++;\\n        def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\\n            def.outputs = invertObject(componentDefinition.outputs),\\n            feature && feature.forEach(function (fn) { return fn(def); });\\n        def.directiveDefs = directiveTypes ?\\n            function () { return (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\\n                .map(extractDirectiveDef); } :\\n            null;\\n        def.pipeDefs = pipeTypes ?\\n            function () { return (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef); } :\\n            null;\\n    });\\n    return def;\\n}\\nfunction extractDirectiveDef(type) {\\n    var def = getComponentDef(type) || getDirectiveDef(type);\\n    if (ngDevMode && !def) {\\n        throw new Error(\\\"'\\\" + type.name + \\\"' is neither 'ComponentType' or 'DirectiveType'.\\\");\\n    }\\n    return def;\\n}\\nfunction extractPipeDef(type) {\\n    var def = getPipeDef(type);\\n    if (ngDevMode && !def) {\\n        throw new Error(\\\"'\\\" + type.name + \\\"' is not a 'PipeType'.\\\");\\n    }\\n    return def;\\n}\\nfunction defineNgModule(def) {\\n    var res = {\\n        type: def.type,\\n        bootstrap: def.bootstrap || EMPTY_ARRAY,\\n        declarations: def.declarations || EMPTY_ARRAY,\\n        imports: def.imports || EMPTY_ARRAY,\\n        exports: def.exports || EMPTY_ARRAY,\\n        transitiveCompileScopes: null,\\n    };\\n    return res;\\n}\\n/**\\n * Inverts an inputs or outputs lookup such that the keys, which were the\\n * minified keys, are part of the values, and the values are parsed so that\\n * the publicName of the property is the new key\\n *\\n * e.g. for\\n *\\n * ```\\n * class Comp {\\n *   @Input()\\n *   propName1: string;\\n *\\n *   @Input('publicName')\\n *   propName2: number;\\n * }\\n * ```\\n *\\n * will be serialized as\\n *\\n * ```\\n * {\\n *   a0: 'propName1',\\n *   b1: ['publicName', 'propName2'],\\n * }\\n * ```\\n *\\n * becomes\\n *\\n * ```\\n * {\\n *  'propName1': 'a0',\\n *  'publicName': 'b1'\\n * }\\n * ```\\n *\\n * Optionally the function can take `secondary` which will result in:\\n *\\n * ```\\n * {\\n *  'propName1': 'a0',\\n *  'propName2': 'b1'\\n * }\\n * ```\\n *\\n\\n */\\nfunction invertObject(obj, secondary) {\\n    if (obj == null)\\n        return EMPTY$1;\\n    var newLookup = {};\\n    for (var minifiedKey in obj) {\\n        if (obj.hasOwnProperty(minifiedKey)) {\\n            var publicName = obj[minifiedKey];\\n            var declaredName = publicName;\\n            if (Array.isArray(publicName)) {\\n                declaredName = publicName[1];\\n                publicName = publicName[0];\\n            }\\n            newLookup[publicName] = minifiedKey;\\n            if (secondary) {\\n                (secondary[declaredName] = minifiedKey);\\n            }\\n        }\\n    }\\n    return newLookup;\\n}\\n/**\\n * Create a base definition\\n *\\n * # Example\\n * ```\\n * class ShouldBeInherited {\\n *   static ngBaseDef = defineBase({\\n *      ...\\n *   })\\n * }\\n * @param baseDefinition The base definition parameters\\n */\\nfunction defineBase(baseDefinition) {\\n    var declaredInputs = {};\\n    return {\\n        inputs: invertObject(baseDefinition.inputs, declaredInputs),\\n        declaredInputs: declaredInputs,\\n        outputs: invertObject(baseDefinition.outputs),\\n    };\\n}\\n/**\\n * Create a directive definition object.\\n *\\n * # Example\\n * ```\\n * class MyDirective {\\n *   // Generated by Angular Template Compiler\\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\\n *   static ngDirectiveDef = defineDirective({\\n *     ...\\n *   });\\n * }\\n * ```\\n */\\nvar defineDirective = defineComponent;\\n/**\\n * Create a pipe definition object.\\n *\\n * # Example\\n * ```\\n * class MyPipe implements PipeTransform {\\n *   // Generated by Angular Template Compiler\\n *   static ngPipeDef = definePipe({\\n *     ...\\n *   });\\n * }\\n * ```\\n * @param pipeDef Pipe definition generated by the compiler\\n */\\nfunction definePipe(pipeDef) {\\n    return {\\n        name: pipeDef.name,\\n        factory: pipeDef.factory,\\n        pure: pipeDef.pure !== false,\\n        onDestroy: pipeDef.type.prototype.ngOnDestroy || null\\n    };\\n}\\n/**\\n * The following getter methods retrieve the definition form the type. Currently the retrieval\\n * honors inheritance, but in the future we may change the rule to require that definitions are\\n * explicit. This would require some sort of migration strategy.\\n */\\nfunction getComponentDef(type) {\\n    return type[NG_COMPONENT_DEF] || null;\\n}\\nfunction getDirectiveDef(type) {\\n    return type[NG_DIRECTIVE_DEF] || null;\\n}\\nfunction getPipeDef(type) {\\n    return type[NG_PIPE_DEF] || null;\\n}\\nfunction getNgModuleDef(type) {\\n    return type[NG_MODULE_DEF] || null;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar R3ResolvedDependencyType;\\n(function (R3ResolvedDependencyType) {\\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\\\"Token\\\"] = 0] = \\\"Token\\\";\\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\\\"Attribute\\\"] = 1] = \\\"Attribute\\\";\\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\\\"Injector\\\"] = 2] = \\\"Injector\\\";\\n})(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction getCompilerFacade() {\\n    var globalNg = _global.ng;\\n    if (!globalNg || !globalNg.ɵcompilerFacade) {\\n        throw new Error(\\\"Angular JIT compilation failed: '@angular/compiler' not loaded!\\\\n\\\" +\\n            \\\"  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\\\\n\\\" +\\n            \\\"  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\\\\n\\\" +\\n            \\\"  - Alternatively provide the compiler with 'import \\\\\\\"@angular/compiler\\\\\\\";' before bootstrapping.\\\");\\n    }\\n    return globalNg.ɵcompilerFacade;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction assertEqual(actual, expected, msg) {\\n    if (actual != expected) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertNotEqual(actual, expected, msg) {\\n    if (actual == expected) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertLessThan(actual, expected, msg) {\\n    if (actual >= expected) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertGreaterThan(actual, expected, msg) {\\n    if (actual <= expected) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertDefined(actual, msg) {\\n    if (actual == null) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertComponentType(actual, msg) {\\n    if (msg === void 0) { msg = 'Type passed in is not ComponentType, it does not have \\\\'ngComponentDef\\\\' property.'; }\\n    if (!getComponentDef(actual)) {\\n        throwError(msg);\\n    }\\n}\\nfunction assertNgModuleType(actual, msg) {\\n    if (msg === void 0) { msg = 'Type passed in is not NgModuleType, it does not have \\\\'ngModuleDef\\\\' property.'; }\\n    if (!getNgModuleDef(actual)) {\\n        throwError(msg);\\n    }\\n}\\nfunction throwError(msg) {\\n    // tslint:disable-next-line\\n    debugger; // Left intentionally for better debugger experience.\\n    throw new Error(\\\"ASSERTION ERROR: \\\" + msg);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This property will be monkey-patched on elements, components and directives\\n */\\nvar MONKEY_PATCH_KEY_NAME = '__ngContext__';\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/** Size of LViewData's header. Necessary to adjust for it when setting slots.  */\\nvar HEADER_OFFSET = 17;\\n// Below are constants for LViewData indices to help us look up LViewData members\\n// without having to remember the specific indices.\\n// Uglify will inline these when minifying so there shouldn't be a cost.\\nvar TVIEW = 0;\\nvar FLAGS = 1;\\nvar PARENT = 2;\\nvar NEXT = 3;\\nvar QUERIES = 4;\\nvar HOST = 5;\\nvar HOST_NODE = 6;\\nvar BINDING_INDEX = 7;\\nvar CLEANUP = 8;\\nvar CONTEXT = 9;\\nvar INJECTOR$1 = 10;\\nvar RENDERER = 11;\\nvar SANITIZER = 12;\\nvar TAIL = 13;\\nvar CONTAINER_INDEX = 14;\\nvar CONTENT_QUERIES = 15;\\nvar DECLARATION_VIEW = 16;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction devModeEqual(a, b) {\\n    var isListLikeIterableA = isListLikeIterable(a);\\n    var isListLikeIterableB = isListLikeIterable(b);\\n    if (isListLikeIterableA && isListLikeIterableB) {\\n        return areIterablesEqual(a, b, devModeEqual);\\n    }\\n    else {\\n        var isAObject = a && (typeof a === 'object' || typeof a === 'function');\\n        var isBObject = b && (typeof b === 'object' || typeof b === 'function');\\n        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\\n            return true;\\n        }\\n        else {\\n            return looseIdentical(a, b);\\n        }\\n    }\\n}\\n/**\\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\\n * reference has not changed.\\n *\\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\\n * is stored.\\n *\\n * Example:\\n *\\n * ```\\n * if (this._latestValue === this._latestReturnedValue) {\\n *    return this._latestReturnedValue;\\n *  } else {\\n *    this._latestReturnedValue = this._latestValue;\\n *    return WrappedValue.wrap(this._latestValue); // this will force update\\n *  }\\n * ```\\n *\\n * @publicApi\\n */\\nvar WrappedValue = /** @class */ (function () {\\n    function WrappedValue(value) {\\n        this.wrapped = value;\\n    }\\n    /** Creates a wrapped value. */\\n    WrappedValue.wrap = function (value) { return new WrappedValue(value); };\\n    /**\\n     * Returns the underlying value of a wrapped value.\\n     * Returns the given `value` when it is not wrapped.\\n     **/\\n    WrappedValue.unwrap = function (value) { return WrappedValue.isWrapped(value) ? value.wrapped : value; };\\n    /** Returns true if `value` is a wrapped value. */\\n    WrappedValue.isWrapped = function (value) { return value instanceof WrappedValue; };\\n    return WrappedValue;\\n}());\\n/**\\n * Represents a basic change from a previous to a new value.\\n *\\n * @publicApi\\n */\\nvar SimpleChange = /** @class */ (function () {\\n    function SimpleChange(previousValue, currentValue, firstChange) {\\n        this.previousValue = previousValue;\\n        this.currentValue = currentValue;\\n        this.firstChange = firstChange;\\n    }\\n    /**\\n     * Check whether the new value is the first value assigned.\\n     */\\n    SimpleChange.prototype.isFirstChange = function () { return this.firstChange; };\\n    return SimpleChange;\\n}());\\nfunction isListLikeIterable(obj) {\\n    if (!isJsObject(obj))\\n        return false;\\n    return Array.isArray(obj) ||\\n        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\\n            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\\n}\\nfunction areIterablesEqual(a, b, comparator) {\\n    var iterator1 = a[getSymbolIterator()]();\\n    var iterator2 = b[getSymbolIterator()]();\\n    while (true) {\\n        var item1 = iterator1.next();\\n        var item2 = iterator2.next();\\n        if (item1.done && item2.done)\\n            return true;\\n        if (item1.done || item2.done)\\n            return false;\\n        if (!comparator(item1.value, item2.value))\\n            return false;\\n    }\\n}\\nfunction iterateListLike(obj, fn) {\\n    if (Array.isArray(obj)) {\\n        for (var i = 0; i < obj.length; i++) {\\n            fn(obj[i]);\\n        }\\n    }\\n    else {\\n        var iterator = obj[getSymbolIterator()]();\\n        var item = void 0;\\n        while (!((item = iterator.next()).done)) {\\n            fn(item.value);\\n        }\\n    }\\n}\\nfunction isJsObject(o) {\\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Below are constants for LContainer indices to help us look up LContainer members\\n * without having to remember the specific indices.\\n * Uglify will inline these when minifying so there shouldn't be a cost.\\n */\\nvar ACTIVE_INDEX = 0;\\nvar VIEWS = 1;\\n// PARENT, NEXT, QUERIES, and HOST are indices 2, 3, 4, and 5.\\n// As we already have these constants in LViewData, we don't need to re-create them.\\nvar NATIVE = 6;\\nvar RENDER_PARENT = 7;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Returns whether the values are different from a change detection stand point.\\n *\\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\\n */\\nfunction isDifferent(a, b, checkNoChangesMode) {\\n    if (ngDevMode && checkNoChangesMode) {\\n        return !devModeEqual(a, b);\\n    }\\n    // NaN is the only value that is not equal to itself so the first\\n    // test checks if both a and b are not NaN\\n    return !(a !== a && b !== b) && a !== b;\\n}\\nfunction stringify$1(value) {\\n    if (typeof value == 'function')\\n        return value.name || value;\\n    if (typeof value == 'string')\\n        return value;\\n    if (value == null)\\n        return '';\\n    return '' + value;\\n}\\n/**\\n * Flattens an array in non-recursive way. Input arrays are not modified.\\n */\\nfunction flatten(list) {\\n    var result = [];\\n    var i = 0;\\n    while (i < list.length) {\\n        var item = list[i];\\n        if (Array.isArray(item)) {\\n            if (item.length > 0) {\\n                list = item.concat(list.slice(i + 1));\\n                i = 0;\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        else {\\n            result.push(item);\\n            i++;\\n        }\\n    }\\n    return result;\\n}\\n/** Retrieves a value from any `LViewData` or `TData`. */\\nfunction loadInternal(index, arr) {\\n    ngDevMode && assertDataInRangeInternal(index + HEADER_OFFSET, arr);\\n    return arr[index + HEADER_OFFSET];\\n}\\nfunction assertDataInRangeInternal(index, arr) {\\n    assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');\\n}\\n/**\\n * Takes the value of a slot in `LViewData` and returns the element node.\\n *\\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\\n * it might be wrapped in a styling context. Or if that node has a directive that injects\\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\\n * it will be wrapped in LViewData. It could even have all three, so we keep looping\\n * until we find something that isn't an array.\\n *\\n * @param value The initial value in `LViewData`\\n */\\nfunction readElementValue(value) {\\n    while (Array.isArray(value)) {\\n        value = value[HOST];\\n    }\\n    return value;\\n}\\n/**\\n * Retrieves an element value from the provided `viewData`, by unwrapping\\n * from any containers, component views, or style contexts.\\n */\\nfunction getNativeByIndex(index, arr) {\\n    return readElementValue(arr[index + HEADER_OFFSET]);\\n}\\nfunction getNativeByTNode(tNode, hostView) {\\n    return readElementValue(hostView[tNode.index]);\\n}\\nfunction getTNode(index, view) {\\n    return view[TVIEW].data[index + HEADER_OFFSET];\\n}\\nfunction getComponentViewByIndex(nodeIndex, hostView) {\\n    // Could be an LViewData or an LContainer. If LContainer, unwrap to find LViewData.\\n    var slotValue = hostView[nodeIndex];\\n    return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];\\n}\\nfunction isContentQueryHost(tNode) {\\n    return (tNode.flags & 16384 /* hasContentQuery */) !== 0;\\n}\\nfunction isComponent(tNode) {\\n    return (tNode.flags & 4096 /* isComponent */) === 4096 /* isComponent */;\\n}\\nfunction isLContainer(value) {\\n    // Styling contexts are also arrays, but their first index contains an element node\\n    return Array.isArray(value) && typeof value[ACTIVE_INDEX] === 'number';\\n}\\n/**\\n * Retrieve the root view from any component by walking the parent `LViewData` until\\n * reaching the root `LViewData`.\\n *\\n * @param component any component\\n */\\nfunction getRootView(target) {\\n    ngDevMode && assertDefined(target, 'component');\\n    var lViewData = Array.isArray(target) ? target : readPatchedLViewData(target);\\n    while (lViewData && !(lViewData[FLAGS] & 64 /* IsRoot */)) {\\n        lViewData = lViewData[PARENT];\\n    }\\n    return lViewData;\\n}\\nfunction getRootContext(viewOrComponent) {\\n    return getRootView(viewOrComponent)[CONTEXT];\\n}\\n/**\\n * Returns the monkey-patch value data present on the target (which could be\\n * a component, directive or a DOM node).\\n */\\nfunction readPatchedData(target) {\\n    return target[MONKEY_PATCH_KEY_NAME];\\n}\\nfunction readPatchedLViewData(target) {\\n    var value = readPatchedData(target);\\n    if (value) {\\n        return Array.isArray(value) ? value : value.lViewData;\\n    }\\n    return null;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\\n *\\n * This function will examine the provided DOM element, component, or directive instance\\\\'s\\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\\n * value will be that of the newly created `LContext`.\\n *\\n * If the monkey-patched value is the `LViewData` instance then the context value for that\\n * target will be created and the monkey-patch reference will be updated. Therefore when this\\n * function is called it may mutate the provided element\\\\'s, component\\\\'s or any of the associated\\n * directive\\\\'s monkey-patch values.\\n *\\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\\n * is found which contains a monkey-patch reference. When that occurs then the provided element\\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\\n * detected for a component/directive instance then it will throw an error (all components and\\n * directives should be automatically monkey-patched by ivy).\\n */\\nfunction getContext(target) {\\n    var mpValue = readPatchedData(target);\\n    if (mpValue) {\\n        // only when it's an array is it considered an LViewData instance\\n        // ... otherwise it's an already constructed LContext instance\\n        if (Array.isArray(mpValue)) {\\n            var lViewData = mpValue;\\n            var nodeIndex = void 0;\\n            var component = undefined;\\n            var directives = undefined;\\n            if (isComponentInstance(target)) {\\n                nodeIndex = findViaComponent(lViewData, target);\\n                if (nodeIndex == -1) {\\n                    throw new Error('The provided component was not found in the application');\\n                }\\n                component = target;\\n            }\\n            else if (isDirectiveInstance(target)) {\\n                nodeIndex = findViaDirective(lViewData, target);\\n                if (nodeIndex == -1) {\\n                    throw new Error('The provided directive was not found in the application');\\n                }\\n                directives = discoverDirectives(nodeIndex, lViewData, false);\\n            }\\n            else {\\n                nodeIndex = findViaNativeElement(lViewData, target);\\n                if (nodeIndex == -1) {\\n                    return null;\\n                }\\n            }\\n            // the goal is not to fill the entire context full of data because the lookups\\n            // are expensive. Instead, only the target data (the element, compontent or\\n            // directive details) are filled into the context. If called multiple times\\n            // with different target values then the missing target data will be filled in.\\n            var native = readElementValue(lViewData[nodeIndex]);\\n            var existingCtx = readPatchedData(native);\\n            var context = (existingCtx && !Array.isArray(existingCtx)) ?\\n                existingCtx :\\n                createLContext(lViewData, nodeIndex, native);\\n            // only when the component has been discovered then update the monkey-patch\\n            if (component && context.component === undefined) {\\n                context.component = component;\\n                attachPatchData(context.component, context);\\n            }\\n            // only when the directives have been discovered then update the monkey-patch\\n            if (directives && context.directives === undefined) {\\n                context.directives = directives;\\n                for (var i = 0; i < directives.length; i++) {\\n                    attachPatchData(directives[i], context);\\n                }\\n            }\\n            attachPatchData(context.native, context);\\n            mpValue = context;\\n        }\\n    }\\n    else {\\n        var rElement = target;\\n        ngDevMode && assertDomElement(rElement);\\n        // if the context is not found then we need to traverse upwards up the DOM\\n        // to find the nearest element that has already been monkey patched with data\\n        var parent_1 = rElement;\\n        while (parent_1 = parent_1.parentNode) {\\n            var parentContext = readPatchedData(parent_1);\\n            if (parentContext) {\\n                var lViewData = void 0;\\n                if (Array.isArray(parentContext)) {\\n                    lViewData = parentContext;\\n                }\\n                else {\\n                    lViewData = parentContext.lViewData;\\n                }\\n                // the edge of the app was also reached here through another means\\n                // (maybe because the DOM was changed manually).\\n                if (!lViewData) {\\n                    return null;\\n                }\\n                var index = findViaNativeElement(lViewData, rElement);\\n                if (index >= 0) {\\n                    var native = readElementValue(lViewData[index]);\\n                    var context = createLContext(lViewData, index, native);\\n                    attachPatchData(native, context);\\n                    mpValue = context;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return mpValue || null;\\n}\\n/**\\n * Creates an empty instance of a `LContext` context\\n */\\nfunction createLContext(lViewData, nodeIndex, native) {\\n    return {\\n        lViewData: lViewData,\\n        nodeIndex: nodeIndex, native: native,\\n        component: undefined,\\n        directives: undefined,\\n        localRefs: undefined,\\n    };\\n}\\n/**\\n * Takes a component instance and returns the view for that component.\\n *\\n * @param componentInstance\\n * @returns The component's view\\n */\\nfunction getComponentViewByInstance(componentInstance) {\\n    var lViewData = readPatchedData(componentInstance);\\n    var view;\\n    if (Array.isArray(lViewData)) {\\n        var nodeIndex = findViaComponent(lViewData, componentInstance);\\n        view = getComponentViewByIndex(nodeIndex, lViewData);\\n        var context = createLContext(lViewData, nodeIndex, view[HOST]);\\n        context.component = componentInstance;\\n        attachPatchData(componentInstance, context);\\n        attachPatchData(context.native, context);\\n    }\\n    else {\\n        var context = lViewData;\\n        view = getComponentViewByIndex(context.nodeIndex, context.lViewData);\\n    }\\n    return view;\\n}\\n/**\\n * Assigns the given data to the given target (which could be a component,\\n * directive or DOM node instance) using monkey-patching.\\n */\\nfunction attachPatchData(target, data) {\\n    target[MONKEY_PATCH_KEY_NAME] = data;\\n}\\nfunction isComponentInstance(instance) {\\n    return instance && instance.constructor && instance.constructor.ngComponentDef;\\n}\\nfunction isDirectiveInstance(instance) {\\n    return instance && instance.constructor && instance.constructor.ngDirectiveDef;\\n}\\n/**\\n * Locates the element within the given LViewData and returns the matching index\\n */\\nfunction findViaNativeElement(lViewData, target) {\\n    var tNode = lViewData[TVIEW].firstChild;\\n    while (tNode) {\\n        var native = getNativeByTNode(tNode, lViewData);\\n        if (native === target) {\\n            return tNode.index;\\n        }\\n        tNode = traverseNextElement(tNode);\\n    }\\n    return -1;\\n}\\n/**\\n * Locates the next tNode (child, sibling or parent).\\n */\\nfunction traverseNextElement(tNode) {\\n    if (tNode.child) {\\n        return tNode.child;\\n    }\\n    else if (tNode.next) {\\n        return tNode.next;\\n    }\\n    else if (tNode.parent) {\\n        return tNode.parent.next || null;\\n    }\\n    return null;\\n}\\n/**\\n * Locates the component within the given LViewData and returns the matching index\\n */\\nfunction findViaComponent(lViewData, componentInstance) {\\n    var componentIndices = lViewData[TVIEW].components;\\n    if (componentIndices) {\\n        for (var i = 0; i < componentIndices.length; i++) {\\n            var elementComponentIndex = componentIndices[i];\\n            var componentView = getComponentViewByIndex(elementComponentIndex, lViewData);\\n            if (componentView[CONTEXT] === componentInstance) {\\n                return elementComponentIndex;\\n            }\\n        }\\n    }\\n    else {\\n        var rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lViewData);\\n        var rootComponent = rootComponentView[CONTEXT];\\n        if (rootComponent === componentInstance) {\\n            // we are dealing with the root element here therefore we know that the\\n            // element is the very first element after the HEADER data in the lView\\n            return HEADER_OFFSET;\\n        }\\n    }\\n    return -1;\\n}\\n/**\\n * Locates the directive within the given LViewData and returns the matching index\\n */\\nfunction findViaDirective(lViewData, directiveInstance) {\\n    // if a directive is monkey patched then it will (by default)\\n    // have a reference to the LViewData of the current view. The\\n    // element bound to the directive being search lives somewhere\\n    // in the view data. We loop through the nodes and check their\\n    // list of directives for the instance.\\n    var tNode = lViewData[TVIEW].firstChild;\\n    while (tNode) {\\n        var directiveIndexStart = getDirectiveStartIndex(tNode);\\n        var directiveIndexEnd = getDirectiveEndIndex(tNode, directiveIndexStart);\\n        for (var i = directiveIndexStart; i < directiveIndexEnd; i++) {\\n            if (lViewData[i] === directiveInstance) {\\n                return tNode.index;\\n            }\\n        }\\n        tNode = traverseNextElement(tNode);\\n    }\\n    return -1;\\n}\\nfunction assertDomElement(element) {\\n    assertEqual(element.nodeType, 1, 'The provided value must be an instance of an HTMLElement');\\n}\\n/**\\n * Returns a list of directives extracted from the given view based on the\\n * provided list of directive index values.\\n *\\n * @param nodeIndex The node index\\n * @param lViewData The target view data\\n * @param includeComponents Whether or not to include components in returned directives\\n */\\nfunction discoverDirectives(nodeIndex, lViewData, includeComponents) {\\n    var tNode = lViewData[TVIEW].data[nodeIndex];\\n    var directiveStartIndex = getDirectiveStartIndex(tNode);\\n    var directiveEndIndex = getDirectiveEndIndex(tNode, directiveStartIndex);\\n    if (!includeComponents && tNode.flags & 4096 /* isComponent */)\\n        directiveStartIndex++;\\n    return lViewData.slice(directiveStartIndex, directiveEndIndex);\\n}\\n/**\\n * Returns a map of local references (local reference name => element or directive instance) that\\n * exist on a given element.\\n */\\nfunction discoverLocalRefs(lViewData, nodeIndex) {\\n    var tNode = lViewData[TVIEW].data[nodeIndex];\\n    if (tNode && tNode.localNames) {\\n        var result = {};\\n        for (var i = 0; i < tNode.localNames.length; i += 2) {\\n            var localRefName = tNode.localNames[i];\\n            var directiveIndex = tNode.localNames[i + 1];\\n            result[localRefName] =\\n                directiveIndex === -1 ? getNativeByTNode(tNode, lViewData) : lViewData[directiveIndex];\\n        }\\n        return result;\\n    }\\n    return null;\\n}\\nfunction getDirectiveStartIndex(tNode) {\\n    // the tNode instances store a flag value which then has a\\n    // pointer which tells the starting index of where all the\\n    // active directives are in the master directive array\\n    return tNode.flags >> 15 /* DirectiveStartingIndexShift */;\\n}\\nfunction getDirectiveEndIndex(tNode, startIndex) {\\n    // The end value is also a part of the same flag\\n    // (see `TNodeFlags` to see how the flag bit shifting\\n    // values are used).\\n    var count = tNode.flags & 4095 /* DirectiveCountMask */;\\n    return count ? (startIndex + count) : -1;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\\n * TView.initHooks during directiveCreate.\\n *\\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\\n * directive index), then saved in the even indices of the initHooks array. The odd indices\\n * hold the hook functions themselves.\\n *\\n * @param index The index of the directive in LViewData\\n * @param hooks The static hooks map on the directive def\\n * @param tView The current TView\\n */\\nfunction queueInitHooks(index, onInit, doCheck, tView) {\\n    ngDevMode &&\\n        assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');\\n    if (onInit) {\\n        (tView.initHooks || (tView.initHooks = [])).push(index, onInit);\\n    }\\n    if (doCheck) {\\n        (tView.initHooks || (tView.initHooks = [])).push(index, doCheck);\\n        (tView.checkHooks || (tView.checkHooks = [])).push(index, doCheck);\\n    }\\n}\\n/**\\n * Loops through the directives on a node and queues all their hooks except ngOnInit\\n * and ngDoCheck, which are queued separately in directiveCreate.\\n */\\nfunction queueLifecycleHooks(flags, tView) {\\n    if (tView.firstTemplatePass) {\\n        var start = flags >> 15 /* DirectiveStartingIndexShift */;\\n        var count = flags & 4095 /* DirectiveCountMask */;\\n        var end = start + count;\\n        // It's necessary to loop through the directives at elementEnd() (rather than processing in\\n        // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\\n        // hooks for projected components and directives must be called *before* their hosts.\\n        for (var i = start; i < end; i++) {\\n            var def = tView.data[i];\\n            queueContentHooks(def, tView, i);\\n            queueViewHooks(def, tView, i);\\n            queueDestroyHooks(def, tView, i);\\n        }\\n    }\\n}\\n/** Queues afterContentInit and afterContentChecked hooks on TView */\\nfunction queueContentHooks(def, tView, i) {\\n    if (def.afterContentInit) {\\n        (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentInit);\\n    }\\n    if (def.afterContentChecked) {\\n        (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentChecked);\\n        (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, def.afterContentChecked);\\n    }\\n}\\n/** Queues afterViewInit and afterViewChecked hooks on TView */\\nfunction queueViewHooks(def, tView, i) {\\n    if (def.afterViewInit) {\\n        (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewInit);\\n    }\\n    if (def.afterViewChecked) {\\n        (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewChecked);\\n        (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, def.afterViewChecked);\\n    }\\n}\\n/** Queues onDestroy hooks on TView */\\nfunction queueDestroyHooks(def, tView, i) {\\n    if (def.onDestroy != null) {\\n        (tView.destroyHooks || (tView.destroyHooks = [])).push(i, def.onDestroy);\\n    }\\n}\\n/**\\n * Calls onInit and doCheck calls if they haven't already been called.\\n *\\n * @param currentView The current view\\n */\\nfunction executeInitHooks(currentView, tView, creationMode) {\\n    if (currentView[FLAGS] & 16 /* RunInit */) {\\n        executeHooks(currentView, tView.initHooks, tView.checkHooks, creationMode);\\n        currentView[FLAGS] &= ~16 /* RunInit */;\\n    }\\n}\\n/**\\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\\n *\\n * @param currentView The current view\\n */\\nfunction executeHooks(data, allHooks, checkHooks, creationMode) {\\n    var hooksToCall = creationMode ? allHooks : checkHooks;\\n    if (hooksToCall) {\\n        callHooks(data, hooksToCall);\\n    }\\n}\\n/**\\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\\n * creation mode.\\n *\\n * @param currentView The current view\\n * @param arr The array in which the hooks are found\\n */\\nfunction callHooks(currentView, arr) {\\n    for (var i = 0; i < arr.length; i += 2) {\\n        arr[i + 1].call(currentView[arr[i]]);\\n    }\\n}\\n\\n/** Called when directives inject each other (creating a circular dependency) */\\nfunction throwCyclicDependencyError(token) {\\n    throw new Error(\\\"Cannot instantiate cyclic dependency! \\\" + token);\\n}\\n/** Called when there are multiple component selectors that match a given node */\\nfunction throwMultipleComponentError(tNode) {\\n    throw new Error(\\\"Multiple components match node with tagname \\\" + tNode.tagName);\\n}\\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\\nfunction throwErrorIfNoChangesMode(creationMode, checkNoChangesMode, oldValue, currValue) {\\n    if (checkNoChangesMode) {\\n        var msg = \\\"ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '\\\" + oldValue + \\\"'. Current value: '\\\" + currValue + \\\"'.\\\";\\n        if (creationMode) {\\n            msg +=\\n                \\\" It seems like the view has been created after its parent and its children have been dirty checked.\\\" +\\n                    \\\" Has it been created in a change detection hook ?\\\";\\n        }\\n        // TODO: include debug context\\n        throw new Error(msg);\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar TNODE = 8;\\nvar PARENT_INJECTOR = 8;\\nvar INJECTOR_SIZE = 9;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// TODO: cleanup once the code is merged in angular/angular\\nvar RendererStyleFlags3;\\n(function (RendererStyleFlags3) {\\n    RendererStyleFlags3[RendererStyleFlags3[\\\"Important\\\"] = 1] = \\\"Important\\\";\\n    RendererStyleFlags3[RendererStyleFlags3[\\\"DashCase\\\"] = 2] = \\\"DashCase\\\";\\n})(RendererStyleFlags3 || (RendererStyleFlags3 = {}));\\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\\nfunction isProceduralRenderer(renderer) {\\n    return !!(renderer.listen);\\n}\\nvar domRendererFactory3 = {\\n    createRenderer: function (hostElement, rendererType) { return document; }\\n};\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction assertNodeType(tNode, type) {\\n    assertDefined(tNode, 'should be called with a TNode');\\n    assertEqual(tNode.type, type, \\\"should be a \\\" + typeName(type));\\n}\\nfunction assertNodeOfPossibleTypes(tNode) {\\n    var types = [];\\n    for (var _i = 1; _i < arguments.length; _i++) {\\n        types[_i - 1] = arguments[_i];\\n    }\\n    assertDefined(tNode, 'should be called with a TNode');\\n    var found = types.some(function (type) { return tNode.type === type; });\\n    assertEqual(found, true, \\\"Should be one of \\\" + types.map(typeName).join(', ') + \\\" but got \\\" + typeName(tNode.type));\\n}\\nfunction typeName(type) {\\n    if (type == 1 /* Projection */)\\n        return 'Projection';\\n    if (type == 0 /* Container */)\\n        return 'Container';\\n    if (type == 2 /* View */)\\n        return 'View';\\n    if (type == 3 /* Element */)\\n        return 'Element';\\n    if (type == 4 /* ElementContainer */)\\n        return 'ElementContainer';\\n    return '<unknown>';\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/** Retrieves the parent element of a given node. */\\nfunction getParentNative(tNode, currentView) {\\n    return tNode.parent == null ? getHostNative(currentView) :\\n        getNativeByTNode(tNode.parent, currentView);\\n}\\n/**\\n * Gets the host element given a view. Will return null if the current view is an embedded view,\\n * which does not have a host element.\\n */\\nfunction getHostNative(currentView) {\\n    var hostTNode = currentView[HOST_NODE];\\n    return hostTNode && hostTNode.type !== 2 /* View */ ?\\n        getNativeByTNode(hostTNode, currentView[PARENT]) :\\n        null;\\n}\\nfunction getLContainer(tNode, embeddedView) {\\n    if (tNode.index === -1) {\\n        // This is a dynamically created view inside a dynamic container.\\n        // If the host index is -1, the view has not yet been inserted, so it has no parent.\\n        var containerHostIndex = embeddedView[CONTAINER_INDEX];\\n        return containerHostIndex > -1 ? embeddedView[PARENT][containerHostIndex] : null;\\n    }\\n    else {\\n        // This is a inline view node (e.g. embeddedViewStart)\\n        return embeddedView[PARENT][tNode.parent.index];\\n    }\\n}\\n/**\\n * Retrieves render parent for a given view.\\n * Might be null if a view is not yet attached to any container.\\n */\\nfunction getContainerRenderParent(tViewNode, view) {\\n    var container = getLContainer(tViewNode, view);\\n    return container ? container[RENDER_PARENT] : null;\\n}\\n/**\\n * Stack used to keep track of projection nodes in walkTNodeTree.\\n *\\n * This is deliberately created outside of walkTNodeTree to avoid allocating\\n * a new array each time the function is called. Instead the array will be\\n * re-used by each invocation. This works because the function is not reentrant.\\n */\\nvar projectionNodeStack = [];\\n/**\\n * Walks a tree of TNodes, applying a transformation on the element nodes, either only on the first\\n * one found, or on all of them.\\n *\\n * @param viewToWalk the view to walk\\n * @param action identifies the action to be performed on the elements\\n * @param renderer the current renderer.\\n * @param renderParent Optional the render parent node to be set in all LContainers found,\\n * required for action modes Insert and Destroy.\\n * @param beforeNode Optional the node before which elements should be added, required for action\\n * Insert.\\n */\\nfunction walkTNodeTree(viewToWalk, action, renderer, renderParent, beforeNode) {\\n    var rootTNode = viewToWalk[TVIEW].node;\\n    var projectionNodeIndex = -1;\\n    var currentView = viewToWalk;\\n    var tNode = rootTNode.child;\\n    while (tNode) {\\n        var nextTNode = null;\\n        if (tNode.type === 3 /* Element */) {\\n            executeNodeAction(action, renderer, renderParent, getNativeByTNode(tNode, currentView), beforeNode);\\n            var nodeOrContainer = currentView[tNode.index];\\n            if (isLContainer(nodeOrContainer)) {\\n                // This element has an LContainer, and its comment needs to be handled\\n                executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], beforeNode);\\n            }\\n        }\\n        else if (tNode.type === 0 /* Container */) {\\n            var lContainer = currentView[tNode.index];\\n            executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], beforeNode);\\n            if (renderParent)\\n                lContainer[RENDER_PARENT] = renderParent;\\n            if (lContainer[VIEWS].length) {\\n                currentView = lContainer[VIEWS][0];\\n                nextTNode = currentView[TVIEW].node;\\n                // When the walker enters a container, then the beforeNode has to become the local native\\n                // comment node.\\n                beforeNode = lContainer[NATIVE];\\n            }\\n        }\\n        else if (tNode.type === 1 /* Projection */) {\\n            var componentView = findComponentView(currentView);\\n            var componentHost = componentView[HOST_NODE];\\n            var head = componentHost.projection[tNode.projection];\\n            // Must store both the TNode and the view because this projection node could be nested\\n            // deeply inside embedded views, and we need to get back down to this particular nested view.\\n            projectionNodeStack[++projectionNodeIndex] = tNode;\\n            projectionNodeStack[++projectionNodeIndex] = currentView;\\n            if (head) {\\n                currentView = componentView[PARENT];\\n                nextTNode = currentView[TVIEW].data[head.index];\\n            }\\n        }\\n        else {\\n            // Otherwise, this is a View or an ElementContainer\\n            nextTNode = tNode.child;\\n        }\\n        if (nextTNode === null) {\\n            // this last node was projected, we need to get back down to its projection node\\n            if (tNode.next === null && (tNode.flags & 8192 /* isProjected */)) {\\n                currentView = projectionNodeStack[projectionNodeIndex--];\\n                tNode = projectionNodeStack[projectionNodeIndex--];\\n            }\\n            nextTNode = tNode.next;\\n            /**\\n             * Find the next node in the TNode tree, taking into account the place where a node is\\n             * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\\n             *\\n             * If there is no sibling node, then it goes to the next sibling of the parent node...\\n             * until it reaches rootNode (at which point null is returned).\\n             */\\n            while (!nextTNode) {\\n                // If parent is null, we're crossing the view boundary, so we should get the host TNode.\\n                tNode = tNode.parent || currentView[TVIEW].node;\\n                if (tNode === null || tNode === rootTNode)\\n                    return null;\\n                // When exiting a container, the beforeNode must be restored to the previous value\\n                if (tNode.type === 0 /* Container */) {\\n                    currentView = currentView[PARENT];\\n                    beforeNode = currentView[tNode.index][NATIVE];\\n                }\\n                if (tNode.type === 2 /* View */ && currentView[NEXT]) {\\n                    currentView = currentView[NEXT];\\n                    nextTNode = currentView[TVIEW].node;\\n                }\\n                else {\\n                    nextTNode = tNode.next;\\n                }\\n            }\\n        }\\n        tNode = nextTNode;\\n    }\\n}\\n/**\\n * Given a current view, finds the nearest component's host (LElement).\\n *\\n * @param lViewData LViewData for which we want a host element node\\n * @returns The host node\\n */\\nfunction findComponentView(lViewData) {\\n    var rootTNode = lViewData[HOST_NODE];\\n    while (rootTNode && rootTNode.type === 2 /* View */) {\\n        ngDevMode && assertDefined(lViewData[PARENT], 'viewData.parent');\\n        lViewData = lViewData[PARENT];\\n        rootTNode = lViewData[HOST_NODE];\\n    }\\n    return lViewData;\\n}\\n/**\\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\\n * being passed as an argument.\\n */\\nfunction executeNodeAction(action, renderer, parent, node, beforeNode) {\\n    if (action === 0 /* Insert */) {\\n        isProceduralRenderer(renderer) ?\\n            renderer.insertBefore(parent, node, beforeNode) :\\n            parent.insertBefore(node, beforeNode, true);\\n    }\\n    else if (action === 1 /* Detach */) {\\n        isProceduralRenderer(renderer) ?\\n            renderer.removeChild(parent, node) :\\n            parent.removeChild(node);\\n    }\\n    else if (action === 2 /* Destroy */) {\\n        ngDevMode && ngDevMode.rendererDestroyNode++;\\n        renderer.destroyNode(node);\\n    }\\n}\\nfunction createTextNode(value, renderer) {\\n    return isProceduralRenderer(renderer) ? renderer.createText(stringify$1(value)) :\\n        renderer.createTextNode(stringify$1(value));\\n}\\nfunction addRemoveViewFromContainer(viewToWalk, insertMode, beforeNode) {\\n    var renderParent = getContainerRenderParent(viewToWalk[TVIEW].node, viewToWalk);\\n    ngDevMode && assertNodeType(viewToWalk[TVIEW].node, 2 /* View */);\\n    if (renderParent) {\\n        var renderer = viewToWalk[RENDERER];\\n        walkTNodeTree(viewToWalk, insertMode ? 0 /* Insert */ : 1 /* Detach */, renderer, renderParent, beforeNode);\\n    }\\n}\\n/**\\n * Traverses down and up the tree of views and containers to remove listeners and\\n * call onDestroy callbacks.\\n *\\n * Notes:\\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\\n *  - Must process containers instead of their views to avoid splicing\\n *  when views are destroyed and re-added.\\n *  - Using a while loop because it's faster than recursion\\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\\n *\\n *  @param rootView The view to destroy\\n */\\nfunction destroyViewTree(rootView) {\\n    // If the view has no children, we can clean it up and return early.\\n    if (rootView[TVIEW].childIndex === -1) {\\n        return cleanUpView(rootView);\\n    }\\n    var viewOrContainer = getLViewChild(rootView);\\n    while (viewOrContainer) {\\n        var next = null;\\n        if (viewOrContainer.length >= HEADER_OFFSET) {\\n            // If LViewData, traverse down to child.\\n            var view = viewOrContainer;\\n            if (view[TVIEW].childIndex > -1)\\n                next = getLViewChild(view);\\n        }\\n        else {\\n            // If container, traverse down to its first LViewData.\\n            var container = viewOrContainer;\\n            if (container[VIEWS].length)\\n                next = container[VIEWS][0];\\n        }\\n        if (next == null) {\\n            // Only clean up view when moving to the side or up, as destroy hooks\\n            // should be called in order from the bottom up.\\n            while (viewOrContainer && !viewOrContainer[NEXT] && viewOrContainer !== rootView) {\\n                cleanUpView(viewOrContainer);\\n                viewOrContainer = getParentState(viewOrContainer, rootView);\\n            }\\n            cleanUpView(viewOrContainer || rootView);\\n            next = viewOrContainer && viewOrContainer[NEXT];\\n        }\\n        viewOrContainer = next;\\n    }\\n}\\n/**\\n * Inserts a view into a container.\\n *\\n * This adds the view to the container's array of active views in the correct\\n * position. It also adds the view's elements to the DOM if the container isn't a\\n * root node of another view (in that case, the view's elements will be added when\\n * the container's parent view is added later).\\n *\\n * @param lView The view to insert\\n * @param lContainer The container into which the view should be inserted\\n * @param parentView The new parent of the inserted view\\n * @param index The index at which to insert the view\\n * @param containerIndex The index of the container node, if dynamic\\n */\\nfunction insertView(lView, lContainer, parentView, index, containerIndex) {\\n    var views = lContainer[VIEWS];\\n    if (index > 0) {\\n        // This is a new view, we need to add it to the children.\\n        views[index - 1][NEXT] = lView;\\n    }\\n    if (index < views.length) {\\n        lView[NEXT] = views[index];\\n        views.splice(index, 0, lView);\\n    }\\n    else {\\n        views.push(lView);\\n        lView[NEXT] = null;\\n    }\\n    // Dynamically inserted views need a reference to their parent container's host so it's\\n    // possible to jump from a view to its container's next when walking the node tree.\\n    if (containerIndex > -1) {\\n        lView[CONTAINER_INDEX] = containerIndex;\\n        lView[PARENT] = parentView;\\n    }\\n    // Notify query that a new view has been added\\n    if (lView[QUERIES]) {\\n        lView[QUERIES].insertView(index);\\n    }\\n    // Sets the attached flag\\n    lView[FLAGS] |= 8 /* Attached */;\\n}\\n/**\\n * Detaches a view from a container.\\n *\\n * This method splices the view from the container's array of active views. It also\\n * removes the view's elements from the DOM.\\n *\\n * @param lContainer The container from which to detach a view\\n * @param removeIndex The index of the view to detach\\n * @param detached Whether or not this view is already detached.\\n */\\nfunction detachView(lContainer, removeIndex, detached) {\\n    var views = lContainer[VIEWS];\\n    var viewToDetach = views[removeIndex];\\n    if (removeIndex > 0) {\\n        views[removeIndex - 1][NEXT] = viewToDetach[NEXT];\\n    }\\n    views.splice(removeIndex, 1);\\n    if (!detached) {\\n        addRemoveViewFromContainer(viewToDetach, false);\\n    }\\n    if (viewToDetach[QUERIES]) {\\n        viewToDetach[QUERIES].removeView();\\n    }\\n    viewToDetach[CONTAINER_INDEX] = -1;\\n    viewToDetach[PARENT] = null;\\n    // Unsets the attached flag\\n    viewToDetach[FLAGS] &= ~8 /* Attached */;\\n}\\n/**\\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\\n *\\n * @param lContainer The container from which to remove a view\\n * @param tContainer The TContainer node associated with the LContainer\\n * @param removeIndex The index of the view to remove\\n */\\nfunction removeView(lContainer, containerHost, removeIndex) {\\n    var view = lContainer[VIEWS][removeIndex];\\n    detachView(lContainer, removeIndex, !!containerHost.detached);\\n    destroyLView(view);\\n}\\n/** Gets the child of the given LViewData */\\nfunction getLViewChild(viewData) {\\n    var childIndex = viewData[TVIEW].childIndex;\\n    return childIndex === -1 ? null : viewData[childIndex];\\n}\\n/**\\n * A standalone function which destroys an LView,\\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\\n *\\n * @param view The view to be destroyed.\\n */\\nfunction destroyLView(view) {\\n    var renderer = view[RENDERER];\\n    if (isProceduralRenderer(renderer) && renderer.destroyNode) {\\n        walkTNodeTree(view, 2 /* Destroy */, renderer, null);\\n    }\\n    destroyViewTree(view);\\n    // Sets the destroyed flag\\n    view[FLAGS] |= 32 /* Destroyed */;\\n}\\n/**\\n * Determines which LViewOrLContainer to jump to when traversing back up the\\n * tree in destroyViewTree.\\n *\\n * Normally, the view's parent LView should be checked, but in the case of\\n * embedded views, the container (which is the view node's parent, but not the\\n * LView's parent) needs to be checked for a possible next property.\\n *\\n * @param state The LViewOrLContainer for which we need a parent state\\n * @param rootView The rootView, so we don't propagate too far up the view tree\\n * @returns The correct parent LViewOrLContainer\\n */\\nfunction getParentState(state, rootView) {\\n    var tNode;\\n    if (state.length >= HEADER_OFFSET && (tNode = state[HOST_NODE]) &&\\n        tNode.type === 2 /* View */) {\\n        // if it's an embedded view, the state needs to go up to the container, in case the\\n        // container has a next\\n        return getLContainer(tNode, state);\\n    }\\n    else {\\n        // otherwise, use parent view for containers or component views\\n        return state[PARENT] === rootView ? null : state[PARENT];\\n    }\\n}\\n/**\\n * Removes all listeners and call all onDestroys in a given view.\\n *\\n * @param view The LViewData to clean up\\n */\\nfunction cleanUpView(viewOrContainer) {\\n    if (viewOrContainer.length >= HEADER_OFFSET) {\\n        var view = viewOrContainer;\\n        removeListeners(view);\\n        executeOnDestroys(view);\\n        executePipeOnDestroys(view);\\n        // For component views only, the local renderer is destroyed as clean up time.\\n        if (view[TVIEW].id === -1 && isProceduralRenderer(view[RENDERER])) {\\n            ngDevMode && ngDevMode.rendererDestroy++;\\n            view[RENDERER].destroy();\\n        }\\n    }\\n}\\n/** Removes listeners and unsubscribes from output subscriptions */\\nfunction removeListeners(viewData) {\\n    var cleanup = viewData[TVIEW].cleanup;\\n    if (cleanup != null) {\\n        for (var i = 0; i < cleanup.length - 1; i += 2) {\\n            if (typeof cleanup[i] === 'string') {\\n                // This is a listener with the native renderer\\n                var native = readElementValue(viewData[cleanup[i + 1]]);\\n                var listener = viewData[CLEANUP][cleanup[i + 2]];\\n                native.removeEventListener(cleanup[i], listener, cleanup[i + 3]);\\n                i += 2;\\n            }\\n            else if (typeof cleanup[i] === 'number') {\\n                // This is a listener with renderer2 (cleanup fn can be found by index)\\n                var cleanupFn = viewData[CLEANUP][cleanup[i]];\\n                cleanupFn();\\n            }\\n            else {\\n                // This is a cleanup function that is grouped with the index of its context\\n                var context = viewData[CLEANUP][cleanup[i + 1]];\\n                cleanup[i].call(context);\\n            }\\n        }\\n        viewData[CLEANUP] = null;\\n    }\\n}\\n/** Calls onDestroy hooks for this view */\\nfunction executeOnDestroys(view) {\\n    var tView = view[TVIEW];\\n    var destroyHooks;\\n    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\\n        callHooks(view, destroyHooks);\\n    }\\n}\\n/** Calls pipe destroy hooks for this view */\\nfunction executePipeOnDestroys(viewData) {\\n    var pipeDestroyHooks = viewData[TVIEW] && viewData[TVIEW].pipeDestroyHooks;\\n    if (pipeDestroyHooks) {\\n        callHooks(viewData, pipeDestroyHooks);\\n    }\\n}\\nfunction getRenderParent(tNode, currentView) {\\n    if (canInsertNativeNode(tNode, currentView)) {\\n        var hostTNode = currentView[HOST_NODE];\\n        return tNode.parent == null && hostTNode.type === 2 /* View */ ?\\n            getContainerRenderParent(hostTNode, currentView) :\\n            getParentNative(tNode, currentView);\\n    }\\n    return null;\\n}\\nfunction canInsertNativeChildOfElement(tNode) {\\n    // If the parent is null, then we are inserting across views. This happens when we\\n    // insert a root element of the component view into the component host element and it\\n    // should always be eager.\\n    if (tNode.parent == null ||\\n        // We should also eagerly insert if the parent is a regular, non-component element\\n        // since we know that this relationship will never be broken.\\n        tNode.parent.type === 3 /* Element */ && !(tNode.parent.flags & 4096 /* isComponent */)) {\\n        return true;\\n    }\\n    // Parent is a Component. Component's content nodes are not inserted immediately\\n    // because they will be projected, and so doing insert at this point would be wasteful.\\n    // Since the projection would than move it to its final destination.\\n    return false;\\n}\\n/**\\n * We might delay insertion of children for a given view if it is disconnected.\\n * This might happen for 2 main reasons:\\n * - view is not inserted into any container (view was created but not inserted yet)\\n * - view is inserted into a container but the container itself is not inserted into the DOM\\n * (container might be part of projection or child of a view that is not inserted yet).\\n *\\n * In other words we can insert children of a given view if this view was inserted into a container\\n * and\\n * the container itself has its render parent determined.\\n */\\nfunction canInsertNativeChildOfView(viewTNode, view) {\\n    // Because we are inserting into a `View` the `View` may be disconnected.\\n    var container = getLContainer(viewTNode, view);\\n    if (container == null || container[RENDER_PARENT] == null) {\\n        // The `View` is not inserted into a `Container` or the parent `Container`\\n        // itself is disconnected. So we have to delay.\\n        return false;\\n    }\\n    // The parent `Container` is in inserted state, so we can eagerly insert into\\n    // this location.\\n    return true;\\n}\\n/**\\n * Returns whether a native element can be inserted into the given parent.\\n *\\n * There are two reasons why we may not be able to insert a element immediately.\\n * - Projection: When creating a child content element of a component, we have to skip the\\n *   insertion because the content of a component will be projected.\\n *   `<component><content>delayed due to projection</content></component>`\\n * - Parent container is disconnected: This can happen when we are inserting a view into\\n *   parent container, which itself is disconnected. For example the parent container is part\\n *   of a View which has not be inserted or is mare for projection but has not been inserted\\n *   into destination.\\n *\\n\\n *\\n * @param parent The parent where the child will be inserted into.\\n * @param currentView Current LView being processed.\\n * @return boolean Whether the child should be inserted now (or delayed until later).\\n */\\nfunction canInsertNativeNode(tNode, currentView) {\\n    var currentNode = tNode;\\n    var parent = tNode.parent;\\n    if (tNode.parent && tNode.parent.type === 4 /* ElementContainer */) {\\n        currentNode = getHighestElementContainer(tNode);\\n        parent = currentNode.parent;\\n    }\\n    if (parent === null)\\n        parent = currentView[HOST_NODE];\\n    if (parent && parent.type === 2 /* View */) {\\n        return canInsertNativeChildOfView(parent, currentView);\\n    }\\n    else {\\n        // Parent is a regular element or a component\\n        return canInsertNativeChildOfElement(currentNode);\\n    }\\n}\\n/**\\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\\n * This is a utility function that can be used when native nodes were determined - it abstracts an\\n * actual renderer being used.\\n */\\nfunction nativeInsertBefore(renderer, parent, child, beforeNode) {\\n    if (isProceduralRenderer(renderer)) {\\n        renderer.insertBefore(parent, child, beforeNode);\\n    }\\n    else {\\n        parent.insertBefore(child, beforeNode, true);\\n    }\\n}\\n/**\\n * Appends the `child` element to the `parent`.\\n *\\n * The element insertion might be delayed {@link canInsertNativeNode}.\\n *\\n * @param childEl The child that should be appended\\n * @param childTNode The TNode of the child element\\n * @param currentView The current LView\\n * @returns Whether or not the child was appended\\n */\\nfunction appendChild(childEl, childTNode, currentView) {\\n    if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\\n        var renderer = currentView[RENDERER];\\n        var parentEl = getParentNative(childTNode, currentView);\\n        var parentTNode = childTNode.parent || currentView[HOST_NODE];\\n        if (parentTNode.type === 2 /* View */) {\\n            var lContainer = getLContainer(parentTNode, currentView);\\n            var views = lContainer[VIEWS];\\n            var index = views.indexOf(currentView);\\n            nativeInsertBefore(renderer, lContainer[RENDER_PARENT], childEl, getBeforeNodeForView(index, views, lContainer[NATIVE]));\\n        }\\n        else if (parentTNode.type === 4 /* ElementContainer */) {\\n            var elementContainer = getHighestElementContainer(childTNode);\\n            var renderParent = getRenderParent(elementContainer, currentView);\\n            nativeInsertBefore(renderer, renderParent, childEl, parentEl);\\n        }\\n        else {\\n            isProceduralRenderer(renderer) ? renderer.appendChild(parentEl, childEl) :\\n                parentEl.appendChild(childEl);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n/**\\n * Gets the top-level ng-container if ng-containers are nested.\\n *\\n * @param ngContainer The TNode of the starting ng-container\\n * @returns tNode The TNode of the highest level ng-container\\n */\\nfunction getHighestElementContainer(ngContainer) {\\n    while (ngContainer.parent != null && ngContainer.parent.type === 4 /* ElementContainer */) {\\n        ngContainer = ngContainer.parent;\\n    }\\n    return ngContainer;\\n}\\nfunction getBeforeNodeForView(index, views, containerNative) {\\n    if (index + 1 < views.length) {\\n        var view = views[index + 1];\\n        var viewTNode = view[HOST_NODE];\\n        return viewTNode.child ? getNativeByTNode(viewTNode.child, view) : containerNative;\\n    }\\n    else {\\n        return containerNative;\\n    }\\n}\\n/**\\n * Removes the `child` element from the DOM if not in view and not projected.\\n *\\n * @param childTNode The TNode of the child to remove\\n * @param childEl The child that should be removed\\n * @param currentView The current LView\\n * @returns Whether or not the child was removed\\n */\\nfunction removeChild(childTNode, childEl, currentView) {\\n    // We only remove the element if not in View or not projected.\\n    if (childEl !== null && canInsertNativeNode(childTNode, currentView)) {\\n        var parentNative = getParentNative(childTNode, currentView);\\n        var renderer = currentView[RENDERER];\\n        isProceduralRenderer(renderer) ? renderer.removeChild(parentNative, childEl) :\\n            parentNative.removeChild(childEl);\\n        return true;\\n    }\\n    return false;\\n}\\n/**\\n * Appends a projected node to the DOM, or in the case of a projected container,\\n * appends the nodes from all of the container's active views to the DOM.\\n *\\n * @param projectedTNode The TNode to be projected\\n * @param tProjectionNode The projection (ng-content) TNode\\n * @param currentView Current LView\\n * @param projectionView Projection view (view above current)\\n */\\nfunction appendProjectedNode(projectedTNode, tProjectionNode, currentView, projectionView) {\\n    var native = getNativeByTNode(projectedTNode, projectionView);\\n    appendChild(native, tProjectionNode, currentView);\\n    // the projected contents are processed while in the shadow view (which is the currentView)\\n    // therefore we need to extract the view where the host element lives since it's the\\n    // logical container of the content projected views\\n    attachPatchData(native, projectionView);\\n    var renderParent = getRenderParent(tProjectionNode, currentView);\\n    var nodeOrContainer = projectionView[projectedTNode.index];\\n    if (projectedTNode.type === 0 /* Container */) {\\n        // The node we are adding is a container and we are adding it to an element which\\n        // is not a component (no more re-projection).\\n        // Alternatively a container is projected at the root of a component's template\\n        // and can't be re-projected (as not content of any component).\\n        // Assign the final projection location in those cases.\\n        nodeOrContainer[RENDER_PARENT] = renderParent;\\n        var views = nodeOrContainer[VIEWS];\\n        for (var i = 0; i < views.length; i++) {\\n            addRemoveViewFromContainer(views[i], true, nodeOrContainer[NATIVE]);\\n        }\\n    }\\n    else {\\n        if (projectedTNode.type === 4 /* ElementContainer */) {\\n            var ngContainerChildTNode = projectedTNode.child;\\n            while (ngContainerChildTNode) {\\n                appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);\\n                ngContainerChildTNode = ngContainerChildTNode.next;\\n            }\\n        }\\n        if (isLContainer(nodeOrContainer)) {\\n            nodeOrContainer[RENDER_PARENT] = renderParent;\\n            appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {\\n    var nodeClassesLen = nodeClassAttrVal.length;\\n    var matchIndex = nodeClassAttrVal.indexOf(cssClassToMatch);\\n    var matchEndIdx = matchIndex + cssClassToMatch.length;\\n    if (matchIndex === -1 // no match\\n        || (matchIndex > 0 && nodeClassAttrVal[matchIndex - 1] !== ' ') // no space before\\n        ||\\n            (matchEndIdx < nodeClassesLen && nodeClassAttrVal[matchEndIdx] !== ' ')) // no space after\\n     {\\n        return false;\\n    }\\n    return true;\\n}\\n/**\\n * A utility function to match an Ivy node static data against a simple CSS selector\\n *\\n * @param node static data to match\\n * @param selector\\n * @returns true if node matches the selector.\\n */\\nfunction isNodeMatchingSelector(tNode, selector) {\\n    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\\n    var mode = 4 /* ELEMENT */;\\n    var nodeAttrs = tNode.attrs;\\n    var selectOnlyMarkerIdx = nodeAttrs ? nodeAttrs.indexOf(1 /* SelectOnly */) : -1;\\n    // When processing \\\":not\\\" selectors, we skip to the next \\\":not\\\" if the\\n    // current one doesn't match\\n    var skipToNextSelector = false;\\n    for (var i = 0; i < selector.length; i++) {\\n        var current = selector[i];\\n        if (typeof current === 'number') {\\n            // If we finish processing a :not selector and it hasn't failed, return false\\n            if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\\n                return false;\\n            }\\n            // If we are skipping to the next :not() and this mode flag is positive,\\n            // it's a part of the current :not() selector, and we should keep skipping\\n            if (skipToNextSelector && isPositive(current))\\n                continue;\\n            skipToNextSelector = false;\\n            mode = current | (mode & 1 /* NOT */);\\n            continue;\\n        }\\n        if (skipToNextSelector)\\n            continue;\\n        if (mode & 4 /* ELEMENT */) {\\n            mode = 2 /* ATTRIBUTE */ | mode & 1 /* NOT */;\\n            if (current !== '' && current !== tNode.tagName) {\\n                if (isPositive(mode))\\n                    return false;\\n                skipToNextSelector = true;\\n            }\\n        }\\n        else {\\n            var attrName = mode & 8 /* CLASS */ ? 'class' : current;\\n            var attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs);\\n            if (attrIndexInNode === -1) {\\n                if (isPositive(mode))\\n                    return false;\\n                skipToNextSelector = true;\\n                continue;\\n            }\\n            var selectorAttrValue = mode & 8 /* CLASS */ ? current : selector[++i];\\n            if (selectorAttrValue !== '') {\\n                var nodeAttrValue = void 0;\\n                var maybeAttrName = nodeAttrs[attrIndexInNode];\\n                if (selectOnlyMarkerIdx > -1 && attrIndexInNode > selectOnlyMarkerIdx) {\\n                    nodeAttrValue = '';\\n                }\\n                else {\\n                    ngDevMode && assertNotEqual(maybeAttrName, 0 /* NamespaceURI */, 'We do not match directives on namespaced attributes');\\n                    nodeAttrValue = nodeAttrs[attrIndexInNode + 1];\\n                }\\n                if (mode & 8 /* CLASS */ &&\\n                    !isCssClassMatching(nodeAttrValue, selectorAttrValue) ||\\n                    mode & 2 /* ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\\n                    if (isPositive(mode))\\n                        return false;\\n                    skipToNextSelector = true;\\n                }\\n            }\\n        }\\n    }\\n    return isPositive(mode) || skipToNextSelector;\\n}\\nfunction isPositive(mode) {\\n    return (mode & 1 /* NOT */) === 0;\\n}\\n/**\\n * Examines an attributes definition array from a node to find the index of the\\n * attribute with the specified name.\\n *\\n * NOTE: Will not find namespaced attributes.\\n *\\n * @param name the name of the attribute to find\\n * @param attrs the attribute array to examine\\n */\\nfunction findAttrIndexInNode(name, attrs) {\\n    if (attrs === null)\\n        return -1;\\n    var selectOnlyMode = false;\\n    var i = 0;\\n    while (i < attrs.length) {\\n        var maybeAttrName = attrs[i];\\n        if (maybeAttrName === name) {\\n            return i;\\n        }\\n        else if (maybeAttrName === 0 /* NamespaceURI */) {\\n            // NOTE(benlesh): will not find namespaced attributes. This is by design.\\n            i += 4;\\n        }\\n        else {\\n            if (maybeAttrName === 1 /* SelectOnly */) {\\n                selectOnlyMode = true;\\n            }\\n            i += selectOnlyMode ? 1 : 2;\\n        }\\n    }\\n    return -1;\\n}\\nfunction isNodeMatchingSelectorList(tNode, selector) {\\n    for (var i = 0; i < selector.length; i++) {\\n        if (isNodeMatchingSelector(tNode, selector[i])) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\nfunction getProjectAsAttrValue(tNode) {\\n    var nodeAttrs = tNode.attrs;\\n    if (nodeAttrs != null) {\\n        var ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);\\n        // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\\n        // (attribute names are stored at even indexes)\\n        if ((ngProjectAsAttrIdx & 1) === 0) {\\n            return nodeAttrs[ngProjectAsAttrIdx + 1];\\n        }\\n    }\\n    return null;\\n}\\n/**\\n * Checks a given node against matching selectors and returns\\n * selector index (or 0 if none matched).\\n *\\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\\n */\\nfunction matchingSelectorIndex(tNode, selectors, textSelectors) {\\n    var ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\\n    for (var i = 0; i < selectors.length; i++) {\\n        // if a node has the ngProjectAs attribute match it against unparsed selector\\n        // match a node against a parsed selector only if ngProjectAs attribute is not present\\n        if (ngProjectAsAttrVal === textSelectors[i] ||\\n            ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\\n            return i + 1; // first matching selector \\\"captures\\\" a given node\\n        }\\n    }\\n    return 0;\\n}\\n\\n/**\\n * Combines the binding value and a factory for an animation player.\\n *\\n * Used to bind a player to an element template binding (currently only\\n * `[style]`, `[style.prop]`, `[class]` and `[class.name]` bindings\\n * supported). The provided `factoryFn` function will be run once all\\n * the associated bindings have been evaluated on the element and is\\n * designed to return a player which will then be placed on the element.\\n *\\n * @param factoryFn The function that is used to create a player\\n *   once all the rendering-related (styling values) have been\\n *   processed for the element binding.\\n * @param value The raw value that will be exposed to the binding\\n *   so that the binding can update its internal values when\\n *   any changes are evaluated.\\n */\\nfunction bindPlayerFactory(factoryFn, value) {\\n    return new BoundPlayerFactory(factoryFn, value);\\n}\\nvar BoundPlayerFactory = /** @class */ (function () {\\n    function BoundPlayerFactory(fn, value) {\\n        this.fn = fn;\\n        this.value = value;\\n    }\\n    return BoundPlayerFactory;\\n}());\\n\\nvar CorePlayerHandler = /** @class */ (function () {\\n    function CorePlayerHandler() {\\n        this._players = [];\\n    }\\n    CorePlayerHandler.prototype.flushPlayers = function () {\\n        for (var i = 0; i < this._players.length; i++) {\\n            var player = this._players[i];\\n            if (!player.parent && player.state === 0 /* Pending */) {\\n                player.play();\\n            }\\n        }\\n        this._players.length = 0;\\n    };\\n    CorePlayerHandler.prototype.queuePlayer = function (player) { this._players.push(player); };\\n    return CorePlayerHandler;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction createEmptyStylingContext(element, sanitizer, initialStylingValues) {\\n    return [\\n        null,\\n        sanitizer || null,\\n        initialStylingValues || [null],\\n        0,\\n        0,\\n        element || null,\\n        null,\\n        null // PreviousMultiStyleValue\\n    ];\\n}\\n/**\\n * Used clone a copy of a pre-computed template of a styling context.\\n *\\n * A pre-computed template is designed to be computed once for a given element\\n * (instructions.ts has logic for caching this).\\n */\\nfunction allocStylingContext(element, templateStyleContext) {\\n    // each instance gets a copy\\n    var context = templateStyleContext.slice();\\n    context[5 /* ElementPosition */] = element;\\n    return context;\\n}\\n/**\\n * Retrieve the `StylingContext` at a given index.\\n *\\n * This method lazily creates the `StylingContext`. This is because in most cases\\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\\n * every style declaration such as `<div style=\\\"color: red\\\">` would result `StyleContext`\\n * which would create unnecessary memory pressure.\\n *\\n * @param index Index of the style allocation. See: `elementStyling`.\\n * @param viewData The view to search for the styling context\\n */\\nfunction getStylingContext(index, viewData) {\\n    var storageIndex = index + HEADER_OFFSET;\\n    var slotValue = viewData[storageIndex];\\n    var wrapper = viewData;\\n    while (Array.isArray(slotValue)) {\\n        wrapper = slotValue;\\n        slotValue = slotValue[HOST];\\n    }\\n    if (isStylingContext(wrapper)) {\\n        return wrapper;\\n    }\\n    else {\\n        // This is an LViewData or an LContainer\\n        var stylingTemplate = getTNode(index, viewData).stylingTemplate;\\n        if (wrapper !== viewData) {\\n            storageIndex = HOST;\\n        }\\n        return wrapper[storageIndex] = stylingTemplate ?\\n            allocStylingContext(slotValue, stylingTemplate) :\\n            createEmptyStylingContext(slotValue);\\n    }\\n}\\nfunction isStylingContext(value) {\\n    // Not an LViewData or an LContainer\\n    return typeof value[FLAGS] !== 'number' && typeof value[ACTIVE_INDEX] !== 'number';\\n}\\nfunction addPlayerInternal(playerContext, rootContext, element, player, playerContextIndex, ref) {\\n    ref = ref || element;\\n    if (playerContextIndex) {\\n        playerContext[playerContextIndex] = player;\\n    }\\n    else {\\n        playerContext.push(player);\\n    }\\n    if (player) {\\n        player.addEventListener(200 /* Destroyed */, function () {\\n            var index = playerContext.indexOf(player);\\n            var nonFactoryPlayerIndex = playerContext[0 /* NonBuilderPlayersStart */];\\n            // if the player is being removed from the factory side of the context\\n            // (which is where the [style] and [class] bindings do their thing) then\\n            // that side of the array cannot be resized since the respective bindings\\n            // have pointer index values that point to the associated factory instance\\n            if (index) {\\n                if (index < nonFactoryPlayerIndex) {\\n                    playerContext[index] = null;\\n                }\\n                else {\\n                    playerContext.splice(index, 1);\\n                }\\n            }\\n            player.destroy();\\n        });\\n        var playerHandler = rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler());\\n        playerHandler.queuePlayer(player, ref);\\n        return true;\\n    }\\n    return false;\\n}\\nfunction getPlayersInternal(playerContext) {\\n    var players = [];\\n    var nonFactoryPlayersStart = playerContext[0 /* NonBuilderPlayersStart */];\\n    // add all factory-based players (which are apart of [style] and [class] bindings)\\n    for (var i = 1 /* PlayerBuildersStartPosition */ + 1 /* PlayerOffsetPosition */; i < nonFactoryPlayersStart; i += 2 /* PlayerAndPlayerBuildersTupleSize */) {\\n        var player = playerContext[i];\\n        if (player) {\\n            players.push(player);\\n        }\\n    }\\n    // add all custom players (not apart of [style] and [class] bindings)\\n    for (var i = nonFactoryPlayersStart; i < playerContext.length; i++) {\\n        players.push(playerContext[i]);\\n    }\\n    return players;\\n}\\nfunction getOrCreatePlayerContext(target, context) {\\n    context = context || getContext(target);\\n    if (!context) {\\n        ngDevMode && throwInvalidRefError();\\n        return null;\\n    }\\n    var lViewData = context.lViewData, nodeIndex = context.nodeIndex;\\n    var stylingContext = getStylingContext(nodeIndex - HEADER_OFFSET, lViewData);\\n    return getPlayerContext(stylingContext) || allocPlayerContext(stylingContext);\\n}\\nfunction getPlayerContext(stylingContext) {\\n    return stylingContext[0 /* PlayerContext */];\\n}\\nfunction allocPlayerContext(data) {\\n    return data[0 /* PlayerContext */] =\\n        [5 /* SinglePlayerBuildersStartPosition */, null, null, null, null];\\n}\\nfunction throwInvalidRefError() {\\n    throw new Error('Only elements that exist in an Angular application can be used for animations');\\n}\\n\\nvar EMPTY_ARR = [];\\nvar EMPTY_OBJ = {};\\n/**\\n * Creates a styling context template where styling information is stored.\\n * Any styles that are later referenced using `updateStyleProp` must be\\n * passed in within this function. Initial values for those styles are to\\n * be declared after all initial style properties are declared (this change in\\n * mode between declarations and initial styles is made possible using a special\\n * enum value found in `definition.ts`).\\n *\\n * @param initialStyleDeclarations a list of style declarations and initial style values\\n *    that are used later within the styling context.\\n *\\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\\n *       This implies that `width` and `height` will be later styled and that the `width`\\n *       property has an initial value of `100px`.\\n *\\n * @param initialClassDeclarations a list of class declarations and initial class values\\n *    that are used later within the styling context.\\n *\\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\\n *       class will be applied to the element as an initial class since it's true\\n */\\nfunction createStylingContextTemplate(initialClassDeclarations, initialStyleDeclarations, styleSanitizer) {\\n    var initialStylingValues = [null];\\n    var context = createEmptyStylingContext(null, styleSanitizer, initialStylingValues);\\n    // we use two maps since a class name might collide with a CSS style prop\\n    var stylesLookup = {};\\n    var classesLookup = {};\\n    var totalStyleDeclarations = 0;\\n    if (initialStyleDeclarations) {\\n        var hasPassedDeclarations = false;\\n        for (var i = 0; i < initialStyleDeclarations.length; i++) {\\n            var v = initialStyleDeclarations[i];\\n            // this flag value marks where the declarations end the initial values begin\\n            if (v === 1 /* VALUES_MODE */) {\\n                hasPassedDeclarations = true;\\n            }\\n            else {\\n                var prop = v;\\n                if (hasPassedDeclarations) {\\n                    var value = initialStyleDeclarations[++i];\\n                    initialStylingValues.push(value);\\n                    stylesLookup[prop] = initialStylingValues.length - 1;\\n                }\\n                else {\\n                    totalStyleDeclarations++;\\n                    stylesLookup[prop] = 0;\\n                }\\n            }\\n        }\\n    }\\n    // make where the class offsets begin\\n    context[4 /* ClassOffsetPosition */] = totalStyleDeclarations;\\n    if (initialClassDeclarations) {\\n        var hasPassedDeclarations = false;\\n        for (var i = 0; i < initialClassDeclarations.length; i++) {\\n            var v = initialClassDeclarations[i];\\n            // this flag value marks where the declarations end the initial values begin\\n            if (v === 1 /* VALUES_MODE */) {\\n                hasPassedDeclarations = true;\\n            }\\n            else {\\n                var className = v;\\n                if (hasPassedDeclarations) {\\n                    var value = initialClassDeclarations[++i];\\n                    initialStylingValues.push(value);\\n                    classesLookup[className] = initialStylingValues.length - 1;\\n                }\\n                else {\\n                    classesLookup[className] = 0;\\n                }\\n            }\\n        }\\n    }\\n    var styleProps = Object.keys(stylesLookup);\\n    var classNames = Object.keys(classesLookup);\\n    var classNamesIndexStart = styleProps.length;\\n    var totalProps = styleProps.length + classNames.length;\\n    // *2 because we are filling for both single and multi style spaces\\n    var maxLength = totalProps * 4 /* Size */ * 2 + 8 /* SingleStylesStartPosition */;\\n    // we need to fill the array from the start so that we can access\\n    // both the multi and the single array positions in the same loop block\\n    for (var i = 8 /* SingleStylesStartPosition */; i < maxLength; i++) {\\n        context.push(null);\\n    }\\n    var singleStart = 8 /* SingleStylesStartPosition */;\\n    var multiStart = totalProps * 4 /* Size */ + 8 /* SingleStylesStartPosition */;\\n    // fill single and multi-level styles\\n    for (var i = 0; i < totalProps; i++) {\\n        var isClassBased_1 = i >= classNamesIndexStart;\\n        var prop = isClassBased_1 ? classNames[i - classNamesIndexStart] : styleProps[i];\\n        var indexForInitial = isClassBased_1 ? classesLookup[prop] : stylesLookup[prop];\\n        var initialValue = initialStylingValues[indexForInitial];\\n        var indexForMulti = i * 4 /* Size */ + multiStart;\\n        var indexForSingle = i * 4 /* Size */ + singleStart;\\n        var initialFlag = prepareInitialFlag(prop, isClassBased_1, styleSanitizer || null);\\n        setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));\\n        setProp(context, indexForSingle, prop);\\n        setValue(context, indexForSingle, null);\\n        setPlayerBuilderIndex(context, indexForSingle, 0);\\n        var flagForMulti = initialFlag | (initialValue !== null ? 1 /* Dirty */ : 0 /* None */);\\n        setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));\\n        setProp(context, indexForMulti, prop);\\n        setValue(context, indexForMulti, null);\\n        setPlayerBuilderIndex(context, indexForMulti, 0);\\n    }\\n    // there is no initial value flag for the master index since it doesn't\\n    // reference an initial style value\\n    setFlag(context, 3 /* MasterFlagPosition */, pointers(0, 0, multiStart));\\n    setContextDirty(context, initialStylingValues.length > 1);\\n    return context;\\n}\\n/**\\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\\n * applied to the element once `renderStyleAndClassBindings` is called.\\n *\\n * All missing styles/class (any values that are not provided in the new `styles`\\n * or `classes` params) will resolve to `null` within their respective positions\\n * in the context.\\n *\\n * @param context The styling context that will be updated with the\\n *    newly provided style values.\\n * @param classesInput The key/value map of CSS class names that will be used for the update.\\n * @param stylesInput The key/value map of CSS styles that will be used for the update.\\n */\\nfunction updateStylingMap(context, classesInput, stylesInput) {\\n    stylesInput = stylesInput || null;\\n    var element = context[5 /* ElementPosition */];\\n    var classesPlayerBuilder = classesInput instanceof BoundPlayerFactory ?\\n        new ClassAndStylePlayerBuilder(classesInput, element, 2 /* Class */) :\\n        null;\\n    var stylesPlayerBuilder = stylesInput instanceof BoundPlayerFactory ?\\n        new ClassAndStylePlayerBuilder(stylesInput, element, 3 /* Style */) :\\n        null;\\n    var classesValue = classesPlayerBuilder ?\\n        classesInput.value :\\n        classesInput;\\n    var stylesValue = stylesPlayerBuilder ? stylesInput.value : stylesInput;\\n    // early exit (this is what's done to avoid using ctx.bind() to cache the value)\\n    var ignoreAllClassUpdates = classesValue === context[6 /* PreviousMultiClassValue */];\\n    var ignoreAllStyleUpdates = stylesValue === context[7 /* PreviousMultiStyleValue */];\\n    if (ignoreAllClassUpdates && ignoreAllStyleUpdates)\\n        return;\\n    context[6 /* PreviousMultiClassValue */] = classesValue;\\n    context[7 /* PreviousMultiStyleValue */] = stylesValue;\\n    var classNames = EMPTY_ARR;\\n    var applyAllClasses = false;\\n    var playerBuildersAreDirty = false;\\n    var classesPlayerBuilderIndex = classesPlayerBuilder ? 1 /* ClassMapPlayerBuilderPosition */ : 0;\\n    if (hasPlayerBuilderChanged(context, classesPlayerBuilder, 1 /* ClassMapPlayerBuilderPosition */)) {\\n        setPlayerBuilder(context, classesPlayerBuilder, 1 /* ClassMapPlayerBuilderPosition */);\\n        playerBuildersAreDirty = true;\\n    }\\n    var stylesPlayerBuilderIndex = stylesPlayerBuilder ? 3 /* StyleMapPlayerBuilderPosition */ : 0;\\n    if (hasPlayerBuilderChanged(context, stylesPlayerBuilder, 3 /* StyleMapPlayerBuilderPosition */)) {\\n        setPlayerBuilder(context, stylesPlayerBuilder, 3 /* StyleMapPlayerBuilderPosition */);\\n        playerBuildersAreDirty = true;\\n    }\\n    // each time a string-based value pops up then it shouldn't require a deep\\n    // check of what's changed.\\n    if (!ignoreAllClassUpdates) {\\n        if (typeof classesValue == 'string') {\\n            classNames = classesValue.split(/\\\\s+/);\\n            // this boolean is used to avoid having to create a key/value map of `true` values\\n            // since a classname string implies that all those classes are added\\n            applyAllClasses = true;\\n        }\\n        else {\\n            classNames = classesValue ? Object.keys(classesValue) : EMPTY_ARR;\\n        }\\n    }\\n    var classes = (classesValue || EMPTY_OBJ);\\n    var styleProps = stylesValue ? Object.keys(stylesValue) : EMPTY_ARR;\\n    var styles = stylesValue || EMPTY_OBJ;\\n    var classesStartIndex = styleProps.length;\\n    var multiStartIndex = getMultiStartIndex(context);\\n    var dirty = false;\\n    var ctxIndex = multiStartIndex;\\n    var propIndex = 0;\\n    var propLimit = styleProps.length + classNames.length;\\n    // the main loop here will try and figure out how the shape of the provided\\n    // styles differ with respect to the context. Later if the context/styles/classes\\n    // are off-balance then they will be dealt in another loop after this one\\n    while (ctxIndex < context.length && propIndex < propLimit) {\\n        var isClassBased_2 = propIndex >= classesStartIndex;\\n        var processValue = (!isClassBased_2 && !ignoreAllStyleUpdates) || (isClassBased_2 && !ignoreAllClassUpdates);\\n        // when there is a cache-hit for a string-based class then we should\\n        // avoid doing any work diffing any of the changes\\n        if (processValue) {\\n            var adjustedPropIndex = isClassBased_2 ? propIndex - classesStartIndex : propIndex;\\n            var newProp = isClassBased_2 ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\\n            var newValue = isClassBased_2 ? (applyAllClasses ? true : classes[newProp]) : styles[newProp];\\n            var playerBuilderIndex = isClassBased_2 ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\\n            var prop = getProp(context, ctxIndex);\\n            if (prop === newProp) {\\n                var value = getValue(context, ctxIndex);\\n                var flag = getPointers(context, ctxIndex);\\n                setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex);\\n                if (hasValueChanged(flag, value, newValue)) {\\n                    setValue(context, ctxIndex, newValue);\\n                    playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\\n                    var initialValue = getInitialValue(context, flag);\\n                    // there is no point in setting this to dirty if the previously\\n                    // rendered value was being referenced by the initial style (or null)\\n                    if (hasValueChanged(flag, initialValue, newValue)) {\\n                        setDirty(context, ctxIndex, true);\\n                        dirty = true;\\n                    }\\n                }\\n            }\\n            else {\\n                var indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);\\n                if (indexOfEntry > 0) {\\n                    // it was found at a later point ... just swap the values\\n                    var valueToCompare = getValue(context, indexOfEntry);\\n                    var flagToCompare = getPointers(context, indexOfEntry);\\n                    swapMultiContextEntries(context, ctxIndex, indexOfEntry);\\n                    if (hasValueChanged(flagToCompare, valueToCompare, newValue)) {\\n                        var initialValue = getInitialValue(context, flagToCompare);\\n                        setValue(context, ctxIndex, newValue);\\n                        if (hasValueChanged(flagToCompare, initialValue, newValue)) {\\n                            setDirty(context, ctxIndex, true);\\n                            playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\\n                            dirty = true;\\n                        }\\n                    }\\n                }\\n                else {\\n                    // we only care to do this if the insertion is in the middle\\n                    var newFlag = prepareInitialFlag(newProp, isClassBased_2, getStyleSanitizer(context));\\n                    playerBuildersAreDirty = playerBuildersAreDirty || !!playerBuilderIndex;\\n                    insertNewMultiProperty(context, ctxIndex, isClassBased_2, newProp, newFlag, newValue, playerBuilderIndex);\\n                    dirty = true;\\n                }\\n            }\\n        }\\n        ctxIndex += 4 /* Size */;\\n        propIndex++;\\n    }\\n    // this means that there are left-over values in the context that\\n    // were not included in the provided styles/classes and in this\\n    // case the  goal is to \\\"remove\\\" them from the context (by nullifying)\\n    while (ctxIndex < context.length) {\\n        var flag = getPointers(context, ctxIndex);\\n        var isClassBased_3 = (flag & 2 /* Class */) === 2 /* Class */;\\n        var processValue = (!isClassBased_3 && !ignoreAllStyleUpdates) || (isClassBased_3 && !ignoreAllClassUpdates);\\n        if (processValue) {\\n            var value = getValue(context, ctxIndex);\\n            var doRemoveValue = valueExists(value, isClassBased_3);\\n            if (doRemoveValue) {\\n                setDirty(context, ctxIndex, true);\\n                setValue(context, ctxIndex, null);\\n                // we keep the player factory the same so that the `nulled` value can\\n                // be instructed into the player because removing a style and/or a class\\n                // is a valid animation player instruction.\\n                var playerBuilderIndex = isClassBased_3 ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\\n                setPlayerBuilderIndex(context, ctxIndex, playerBuilderIndex);\\n                dirty = true;\\n            }\\n        }\\n        ctxIndex += 4 /* Size */;\\n    }\\n    // this means that there are left-over properties in the context that\\n    // were not detected in the context during the loop above. In that\\n    // case we want to add the new entries into the list\\n    var sanitizer = getStyleSanitizer(context);\\n    while (propIndex < propLimit) {\\n        var isClassBased_4 = propIndex >= classesStartIndex;\\n        var processValue = (!isClassBased_4 && !ignoreAllStyleUpdates) || (isClassBased_4 && !ignoreAllClassUpdates);\\n        if (processValue) {\\n            var adjustedPropIndex = isClassBased_4 ? propIndex - classesStartIndex : propIndex;\\n            var prop = isClassBased_4 ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\\n            var value = isClassBased_4 ? (applyAllClasses ? true : classes[prop]) : styles[prop];\\n            var flag = prepareInitialFlag(prop, isClassBased_4, sanitizer) | 1 /* Dirty */;\\n            var playerBuilderIndex = isClassBased_4 ? classesPlayerBuilderIndex : stylesPlayerBuilderIndex;\\n            context.push(flag, prop, value, playerBuilderIndex);\\n            dirty = true;\\n        }\\n        propIndex++;\\n    }\\n    if (dirty) {\\n        setContextDirty(context, true);\\n    }\\n    if (playerBuildersAreDirty) {\\n        setContextPlayersDirty(context, true);\\n    }\\n}\\n/**\\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\\n * that they can be applied to the element once `renderStyleAndClassBindings` is called.\\n *\\n * Note that prop-level styling values are considered higher priority than any styling that\\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\\n * then any styles/classes that have been applied using this function will be considered first\\n * (then multi values second and then initial values as a backup).\\n *\\n * @param context The styling context that will be updated with the\\n *    newly provided style value.\\n * @param index The index of the property which is being updated.\\n * @param value The CSS style value that will be assigned\\n */\\nfunction updateStyleProp(context, index, input) {\\n    var singleIndex = 8 /* SingleStylesStartPosition */ + index * 4 /* Size */;\\n    var currValue = getValue(context, singleIndex);\\n    var currFlag = getPointers(context, singleIndex);\\n    var value = (input instanceof BoundPlayerFactory) ? input.value : input;\\n    // didn't change ... nothing to make a note of\\n    if (hasValueChanged(currFlag, currValue, value)) {\\n        var isClassBased_5 = (currFlag & 2 /* Class */) === 2 /* Class */;\\n        var element = context[5 /* ElementPosition */];\\n        var playerBuilder = input instanceof BoundPlayerFactory ?\\n            new ClassAndStylePlayerBuilder(input, element, isClassBased_5 ? 2 /* Class */ : 3 /* Style */) :\\n            null;\\n        var value_1 = (playerBuilder ? input.value : input);\\n        var currPlayerIndex = getPlayerBuilderIndex(context, singleIndex);\\n        var playerBuildersAreDirty = false;\\n        var playerBuilderIndex = playerBuilder ? currPlayerIndex : 0;\\n        if (hasPlayerBuilderChanged(context, playerBuilder, currPlayerIndex)) {\\n            var newIndex = setPlayerBuilder(context, playerBuilder, currPlayerIndex);\\n            playerBuilderIndex = playerBuilder ? newIndex : 0;\\n            setPlayerBuilderIndex(context, singleIndex, playerBuilderIndex);\\n            playerBuildersAreDirty = true;\\n        }\\n        // the value will always get updated (even if the dirty flag is skipped)\\n        setValue(context, singleIndex, value_1);\\n        var indexForMulti = getMultiOrSingleIndex(currFlag);\\n        // if the value is the same in the multi-area then there's no point in re-assembling\\n        var valueForMulti = getValue(context, indexForMulti);\\n        if (!valueForMulti || hasValueChanged(currFlag, valueForMulti, value_1)) {\\n            var multiDirty = false;\\n            var singleDirty = true;\\n            // only when the value is set to `null` should the multi-value get flagged\\n            if (!valueExists(value_1, isClassBased_5) && valueExists(valueForMulti, isClassBased_5)) {\\n                multiDirty = true;\\n                singleDirty = false;\\n            }\\n            setDirty(context, indexForMulti, multiDirty);\\n            setDirty(context, singleIndex, singleDirty);\\n            setContextDirty(context, true);\\n        }\\n        if (playerBuildersAreDirty) {\\n            setContextPlayersDirty(context, true);\\n        }\\n    }\\n}\\n/**\\n * This method will toggle the referenced CSS class (by the provided index)\\n * within the given context.\\n *\\n * @param context The styling context that will be updated with the\\n *    newly provided class value.\\n * @param index The index of the CSS class which is being updated.\\n * @param addOrRemove Whether or not to add or remove the CSS class\\n */\\nfunction updateClassProp(context, index, addOrRemove) {\\n    var adjustedIndex = index + context[4 /* ClassOffsetPosition */];\\n    updateStyleProp(context, adjustedIndex, addOrRemove);\\n}\\n/**\\n * Renders all queued styling using a renderer onto the given element.\\n *\\n * This function works by rendering any styles (that have been applied\\n * using `updateStylingMap`) and any classes (that have been applied using\\n * `updateStyleProp`) onto the provided element using the provided renderer.\\n * Just before the styles/classes are rendered a final key/value style map\\n * will be assembled (if `styleStore` or `classStore` are provided).\\n *\\n * @param lElement the element that the styles will be rendered on\\n * @param context The styling context that will be used to determine\\n *      what styles will be rendered\\n * @param renderer the renderer that will be used to apply the styling\\n * @param classesStore if provided, the updated class values will be applied\\n *    to this key/value map instead of being renderered via the renderer.\\n * @param stylesStore if provided, the updated style values will be applied\\n *    to this key/value map instead of being renderered via the renderer.\\n * @returns number the total amount of players that got queued for animation (if any)\\n */\\nfunction renderStyleAndClassBindings(context, renderer, rootOrView, classesStore, stylesStore) {\\n    var totalPlayersQueued = 0;\\n    if (isContextDirty(context)) {\\n        var flushPlayerBuilders = context[3 /* MasterFlagPosition */] & 8 /* PlayerBuildersDirty */;\\n        var native = context[5 /* ElementPosition */];\\n        var multiStartIndex = getMultiStartIndex(context);\\n        var styleSanitizer = getStyleSanitizer(context);\\n        for (var i = 8 /* SingleStylesStartPosition */; i < context.length; i += 4 /* Size */) {\\n            // there is no point in rendering styles that have not changed on screen\\n            if (isDirty(context, i)) {\\n                var prop = getProp(context, i);\\n                var value = getValue(context, i);\\n                var flag = getPointers(context, i);\\n                var playerBuilder = getPlayerBuilder(context, i);\\n                var isClassBased_6 = flag & 2 /* Class */ ? true : false;\\n                var isInSingleRegion = i < multiStartIndex;\\n                var valueToApply = value;\\n                // VALUE DEFER CASE 1: Use a multi value instead of a null single value\\n                // this check implies that a single value was removed and we\\n                // should now defer to a multi value and use that (if set).\\n                if (isInSingleRegion && !valueExists(valueToApply, isClassBased_6)) {\\n                    // single values ALWAYS have a reference to a multi index\\n                    var multiIndex = getMultiOrSingleIndex(flag);\\n                    valueToApply = getValue(context, multiIndex);\\n                }\\n                // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)\\n                // the initial value will always be a string or null,\\n                // therefore we can safely adopt it incase there's nothing else\\n                // note that this should always be a falsy check since `false` is used\\n                // for both class and style comparisons (styles can't be false and false\\n                // classes are turned off and should therefore defer to their initial values)\\n                if (!valueExists(valueToApply, isClassBased_6)) {\\n                    valueToApply = getInitialValue(context, flag);\\n                }\\n                if (isClassBased_6) {\\n                    setClass(native, prop, valueToApply ? true : false, renderer, classesStore, playerBuilder);\\n                }\\n                else {\\n                    var sanitizer = (flag & 4 /* Sanitize */) ? styleSanitizer : null;\\n                    setStyle(native, prop, valueToApply, renderer, sanitizer, stylesStore, playerBuilder);\\n                }\\n                setDirty(context, i, false);\\n            }\\n        }\\n        if (flushPlayerBuilders) {\\n            var rootContext = Array.isArray(rootOrView) ? getRootContext(rootOrView) : rootOrView;\\n            var playerContext = getPlayerContext(context);\\n            var playersStartIndex = playerContext[0 /* NonBuilderPlayersStart */];\\n            for (var i = 1 /* PlayerBuildersStartPosition */; i < playersStartIndex; i += 2 /* PlayerAndPlayerBuildersTupleSize */) {\\n                var builder = playerContext[i];\\n                var playerInsertionIndex = i + 1 /* PlayerOffsetPosition */;\\n                var oldPlayer = playerContext[playerInsertionIndex];\\n                if (builder) {\\n                    var player = builder.buildPlayer(oldPlayer);\\n                    if (player !== undefined) {\\n                        if (player != null) {\\n                            var wasQueued = addPlayerInternal(playerContext, rootContext, native, player, playerInsertionIndex);\\n                            wasQueued && totalPlayersQueued++;\\n                        }\\n                        if (oldPlayer) {\\n                            oldPlayer.destroy();\\n                        }\\n                    }\\n                }\\n                else if (oldPlayer) {\\n                    // the player builder has been removed ... therefore we should delete the associated\\n                    // player\\n                    oldPlayer.destroy();\\n                }\\n            }\\n            setContextPlayersDirty(context, false);\\n        }\\n        setContextDirty(context, false);\\n    }\\n    return totalPlayersQueued;\\n}\\n/**\\n * This function renders a given CSS prop/value entry using the\\n * provided renderer. If a `store` value is provided then\\n * that will be used a render context instead of the provided\\n * renderer.\\n *\\n * @param native the DOM Element\\n * @param prop the CSS style property that will be rendered\\n * @param value the CSS style value that will be rendered\\n * @param renderer\\n * @param store an optional key/value map that will be used as a context to render styles on\\n */\\nfunction setStyle(native, prop, value, renderer, sanitizer, store, playerBuilder) {\\n    value = sanitizer && value ? sanitizer(prop, value) : value;\\n    if (store || playerBuilder) {\\n        if (store) {\\n            store.setValue(prop, value);\\n        }\\n        if (playerBuilder) {\\n            playerBuilder.setValue(prop, value);\\n        }\\n    }\\n    else if (value) {\\n        ngDevMode && ngDevMode.rendererSetStyle++;\\n        isProceduralRenderer(renderer) ?\\n            renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\\n            native['style'].setProperty(prop, value);\\n    }\\n    else {\\n        ngDevMode && ngDevMode.rendererRemoveStyle++;\\n        isProceduralRenderer(renderer) ?\\n            renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\\n            native['style'].removeProperty(prop);\\n    }\\n}\\n/**\\n * This function renders a given CSS class value using the provided\\n * renderer (by adding or removing it from the provided element).\\n * If a `store` value is provided then that will be used a render\\n * context instead of the provided renderer.\\n *\\n * @param native the DOM Element\\n * @param prop the CSS style property that will be rendered\\n * @param value the CSS style value that will be rendered\\n * @param renderer\\n * @param store an optional key/value map that will be used as a context to render styles on\\n */\\nfunction setClass(native, className, add, renderer, store, playerBuilder) {\\n    if (store || playerBuilder) {\\n        if (store) {\\n            store.setValue(className, add);\\n        }\\n        if (playerBuilder) {\\n            playerBuilder.setValue(className, add);\\n        }\\n    }\\n    else if (add) {\\n        ngDevMode && ngDevMode.rendererAddClass++;\\n        isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\\n            native['classList'].add(className);\\n    }\\n    else {\\n        ngDevMode && ngDevMode.rendererRemoveClass++;\\n        isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\\n            native['classList'].remove(className);\\n    }\\n}\\nfunction setDirty(context, index, isDirtyYes) {\\n    var adjustedIndex = index >= 8 /* SingleStylesStartPosition */ ? (index + 0 /* FlagsOffset */) : index;\\n    if (isDirtyYes) {\\n        context[adjustedIndex] |= 1 /* Dirty */;\\n    }\\n    else {\\n        context[adjustedIndex] &= ~1 /* Dirty */;\\n    }\\n}\\nfunction isDirty(context, index) {\\n    var adjustedIndex = index >= 8 /* SingleStylesStartPosition */ ? (index + 0 /* FlagsOffset */) : index;\\n    return (context[adjustedIndex] & 1 /* Dirty */) == 1 /* Dirty */;\\n}\\nfunction isClassBased(context, index) {\\n    var adjustedIndex = index >= 8 /* SingleStylesStartPosition */ ? (index + 0 /* FlagsOffset */) : index;\\n    return (context[adjustedIndex] & 2 /* Class */) == 2 /* Class */;\\n}\\nfunction isSanitizable(context, index) {\\n    var adjustedIndex = index >= 8 /* SingleStylesStartPosition */ ? (index + 0 /* FlagsOffset */) : index;\\n    return (context[adjustedIndex] & 4 /* Sanitize */) == 4 /* Sanitize */;\\n}\\nfunction pointers(configFlag, staticIndex, dynamicIndex) {\\n    return (configFlag & 15 /* BitMask */) | (staticIndex << 4 /* BitCountSize */) |\\n        (dynamicIndex << (14 /* BitCountSize */ + 4 /* BitCountSize */));\\n}\\nfunction getInitialValue(context, flag) {\\n    var index = getInitialIndex(flag);\\n    return context[2 /* InitialStylesPosition */][index];\\n}\\nfunction getInitialIndex(flag) {\\n    return (flag >> 4 /* BitCountSize */) & 16383 /* BitMask */;\\n}\\nfunction getMultiOrSingleIndex(flag) {\\n    var index = (flag >> (14 /* BitCountSize */ + 4 /* BitCountSize */)) & 16383 /* BitMask */;\\n    return index >= 8 /* SingleStylesStartPosition */ ? index : -1;\\n}\\nfunction getMultiStartIndex(context) {\\n    return getMultiOrSingleIndex(context[3 /* MasterFlagPosition */]);\\n}\\nfunction getStyleSanitizer(context) {\\n    return context[1 /* StyleSanitizerPosition */];\\n}\\nfunction setProp(context, index, prop) {\\n    context[index + 1 /* PropertyOffset */] = prop;\\n}\\nfunction setValue(context, index, value) {\\n    context[index + 2 /* ValueOffset */] = value;\\n}\\nfunction hasPlayerBuilderChanged(context, builder, index) {\\n    var playerContext = context[0 /* PlayerContext */];\\n    if (builder) {\\n        if (!playerContext || index === 0) {\\n            return true;\\n        }\\n    }\\n    else if (!playerContext) {\\n        return false;\\n    }\\n    return playerContext[index] !== builder;\\n}\\nfunction setPlayerBuilder(context, builder, insertionIndex) {\\n    var playerContext = context[0 /* PlayerContext */] || allocPlayerContext(context);\\n    if (insertionIndex > 0) {\\n        playerContext[insertionIndex] = builder;\\n    }\\n    else {\\n        insertionIndex = playerContext[0 /* NonBuilderPlayersStart */];\\n        playerContext.splice(insertionIndex, 0, builder, null);\\n        playerContext[0 /* NonBuilderPlayersStart */] +=\\n            2 /* PlayerAndPlayerBuildersTupleSize */;\\n    }\\n    return insertionIndex;\\n}\\nfunction setPlayerBuilderIndex(context, index, playerBuilderIndex) {\\n    context[index + 3 /* PlayerBuilderIndexOffset */] = playerBuilderIndex;\\n}\\nfunction getPlayerBuilderIndex(context, index) {\\n    return context[index + 3 /* PlayerBuilderIndexOffset */] || 0;\\n}\\nfunction getPlayerBuilder(context, index) {\\n    var playerBuilderIndex = getPlayerBuilderIndex(context, index);\\n    if (playerBuilderIndex) {\\n        var playerContext = context[0 /* PlayerContext */];\\n        if (playerContext) {\\n            return playerContext[playerBuilderIndex];\\n        }\\n    }\\n    return null;\\n}\\nfunction setFlag(context, index, flag) {\\n    var adjustedIndex = index === 3 /* MasterFlagPosition */ ? index : (index + 0 /* FlagsOffset */);\\n    context[adjustedIndex] = flag;\\n}\\nfunction getPointers(context, index) {\\n    var adjustedIndex = index === 3 /* MasterFlagPosition */ ? index : (index + 0 /* FlagsOffset */);\\n    return context[adjustedIndex];\\n}\\nfunction getValue(context, index) {\\n    return context[index + 2 /* ValueOffset */];\\n}\\nfunction getProp(context, index) {\\n    return context[index + 1 /* PropertyOffset */];\\n}\\nfunction isContextDirty(context) {\\n    return isDirty(context, 3 /* MasterFlagPosition */);\\n}\\nfunction setContextDirty(context, isDirtyYes) {\\n    setDirty(context, 3 /* MasterFlagPosition */, isDirtyYes);\\n}\\nfunction setContextPlayersDirty(context, isDirtyYes) {\\n    if (isDirtyYes) {\\n        context[3 /* MasterFlagPosition */] |= 8 /* PlayerBuildersDirty */;\\n    }\\n    else {\\n        context[3 /* MasterFlagPosition */] &= ~8 /* PlayerBuildersDirty */;\\n    }\\n}\\nfunction findEntryPositionByProp(context, prop, startIndex) {\\n    for (var i = (startIndex || 0) + 1 /* PropertyOffset */; i < context.length; i += 4 /* Size */) {\\n        var thisProp = context[i];\\n        if (thisProp == prop) {\\n            return i - 1 /* PropertyOffset */;\\n        }\\n    }\\n    return -1;\\n}\\nfunction swapMultiContextEntries(context, indexA, indexB) {\\n    var tmpValue = getValue(context, indexA);\\n    var tmpProp = getProp(context, indexA);\\n    var tmpFlag = getPointers(context, indexA);\\n    var tmpPlayerBuilderIndex = getPlayerBuilderIndex(context, indexA);\\n    var flagA = tmpFlag;\\n    var flagB = getPointers(context, indexB);\\n    var singleIndexA = getMultiOrSingleIndex(flagA);\\n    if (singleIndexA >= 0) {\\n        var _flag = getPointers(context, singleIndexA);\\n        var _initial = getInitialIndex(_flag);\\n        setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));\\n    }\\n    var singleIndexB = getMultiOrSingleIndex(flagB);\\n    if (singleIndexB >= 0) {\\n        var _flag = getPointers(context, singleIndexB);\\n        var _initial = getInitialIndex(_flag);\\n        setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));\\n    }\\n    setValue(context, indexA, getValue(context, indexB));\\n    setProp(context, indexA, getProp(context, indexB));\\n    setFlag(context, indexA, getPointers(context, indexB));\\n    setPlayerBuilderIndex(context, indexA, getPlayerBuilderIndex(context, indexB));\\n    setValue(context, indexB, tmpValue);\\n    setProp(context, indexB, tmpProp);\\n    setFlag(context, indexB, tmpFlag);\\n    setPlayerBuilderIndex(context, indexB, tmpPlayerBuilderIndex);\\n}\\nfunction updateSinglePointerValues(context, indexStartPosition) {\\n    for (var i = indexStartPosition; i < context.length; i += 4 /* Size */) {\\n        var multiFlag = getPointers(context, i);\\n        var singleIndex = getMultiOrSingleIndex(multiFlag);\\n        if (singleIndex > 0) {\\n            var singleFlag = getPointers(context, singleIndex);\\n            var initialIndexForSingle = getInitialIndex(singleFlag);\\n            var flagValue = (isDirty(context, singleIndex) ? 1 /* Dirty */ : 0 /* None */) |\\n                (isClassBased(context, singleIndex) ? 2 /* Class */ : 0 /* None */) |\\n                (isSanitizable(context, singleIndex) ? 4 /* Sanitize */ : 0 /* None */);\\n            var updatedFlag = pointers(flagValue, initialIndexForSingle, i);\\n            setFlag(context, singleIndex, updatedFlag);\\n        }\\n    }\\n}\\nfunction insertNewMultiProperty(context, index, classBased, name, flag, value, playerIndex) {\\n    var doShift = index < context.length;\\n    // prop does not exist in the list, add it in\\n    context.splice(index, 0, flag | 1 /* Dirty */ | (classBased ? 2 /* Class */ : 0 /* None */), name, value, playerIndex);\\n    if (doShift) {\\n        // because the value was inserted midway into the array then we\\n        // need to update all the shifted multi values' single value\\n        // pointers to point to the newly shifted location\\n        updateSinglePointerValues(context, index + 4 /* Size */);\\n    }\\n}\\nfunction valueExists(value, isClassBased) {\\n    if (isClassBased) {\\n        return value ? true : false;\\n    }\\n    return value !== null;\\n}\\nfunction prepareInitialFlag(name, isClassBased, sanitizer) {\\n    if (isClassBased) {\\n        return 2 /* Class */;\\n    }\\n    else if (sanitizer && sanitizer(name)) {\\n        return 4 /* Sanitize */;\\n    }\\n    return 0 /* None */;\\n}\\nfunction hasValueChanged(flag, a, b) {\\n    var isClassBased = flag & 2 /* Class */;\\n    var hasValues = a && b;\\n    var usesSanitizer = flag & 4 /* Sanitize */;\\n    // the toString() comparison ensures that a value is checked\\n    // ... otherwise (during sanitization bypassing) the === comparsion\\n    // would fail since a new String() instance is created\\n    if (!isClassBased && hasValues && usesSanitizer) {\\n        // we know for sure we're dealing with strings at this point\\n        return a.toString() !== b.toString();\\n    }\\n    // everything else is safe to check with a normal equality check\\n    return a !== b;\\n}\\nvar ClassAndStylePlayerBuilder = /** @class */ (function () {\\n    function ClassAndStylePlayerBuilder(factory, _element, _type) {\\n        this._element = _element;\\n        this._type = _type;\\n        this._values = {};\\n        this._dirty = false;\\n        this._factory = factory;\\n    }\\n    ClassAndStylePlayerBuilder.prototype.setValue = function (prop, value) {\\n        if (this._values[prop] !== value) {\\n            this._values[prop] = value;\\n            this._dirty = true;\\n        }\\n    };\\n    ClassAndStylePlayerBuilder.prototype.buildPlayer = function (currentPlayer) {\\n        // if no values have been set here then this means the binding didn't\\n        // change and therefore the binding values were not updated through\\n        // `setValue` which means no new player will be provided.\\n        if (this._dirty) {\\n            var player = this._factory.fn(this._element, this._type, this._values, currentPlayer || null);\\n            this._values = {};\\n            this._dirty = false;\\n            return player;\\n        }\\n        return undefined;\\n    };\\n    return ClassAndStylePlayerBuilder;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A permanent marker promise which signifies that the current CD tree is\\n * clean.\\n */\\nvar _CLEAN_PROMISE = Promise.resolve(null);\\n/**\\n * Token set in currentMatches while dependencies are being resolved.\\n *\\n * If we visit a directive that has a value set to CIRCULAR, we know we've\\n * already seen it, and thus have a circular dependency.\\n */\\nvar CIRCULAR$1 = '__CIRCULAR__';\\n/**\\n * This property gets set before entering a template.\\n *\\n * This renderer can be one of two varieties of Renderer3:\\n *\\n * - ObjectedOrientedRenderer3\\n *\\n * This is the native browser API style, e.g. operations are methods on individual objects\\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\\n * size).\\n *\\n * - ProceduralRenderer3\\n *\\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\\n * that enables element manipulation. This also facilitates backwards compatibility with\\n * Renderer2.\\n */\\nvar renderer;\\nfunction getRenderer() {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return renderer;\\n}\\nvar rendererFactory;\\nfunction getRendererFactory() {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return rendererFactory;\\n}\\nfunction getCurrentSanitizer() {\\n    return viewData && viewData[SANITIZER];\\n}\\n/**\\n * Store the element depth count. This is used to identify the root elements of the template\\n * so that we can than attach `LViewData` to only those elements.\\n */\\nvar elementDepthCount;\\n/**\\n * Stores whether directives should be matched to elements.\\n *\\n * When template contains `ngNonBindable` than we need to prevent the runtime form matching\\n * directives on children of that element.\\n *\\n * Example:\\n * ```\\n * <my-comp my-directive>\\n *   Should match component / directive.\\n * </my-comp>\\n * <div ngNonBindable>\\n *   <my-comp my-directive>\\n *     Should not match component / directive because we are in ngNonBindable.\\n *   </my-comp>\\n * </div>\\n * ```\\n */\\nvar bindingsEnabled;\\n/**\\n * Returns the current OpaqueViewState instance.\\n *\\n * Used in conjunction with the restoreView() instruction to save a snapshot\\n * of the current view and restore it when listeners are invoked. This allows\\n * walking the declaration view tree in listeners to get vars from parent views.\\n */\\nfunction getCurrentView() {\\n    return viewData;\\n}\\n/**\\n * Restores `contextViewData` to the given OpaqueViewState instance.\\n *\\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\\n * of the current view and restore it when listeners are invoked. This allows\\n * walking the declaration view tree in listeners to get vars from parent views.\\n *\\n * @param viewToRestore The OpaqueViewState instance to restore.\\n */\\nfunction restoreView(viewToRestore) {\\n    contextViewData = viewToRestore;\\n}\\n/** Used to set the parent property when nodes are created and track query results. */\\nvar previousOrParentTNode;\\nfunction getPreviousOrParentTNode() {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return previousOrParentTNode;\\n}\\nfunction setEnvironment(tNode, view) {\\n    previousOrParentTNode = tNode;\\n    viewData = view;\\n}\\n/**\\n * If `isParent` is:\\n *  - `true`: then `previousOrParentTNode` points to a parent node.\\n *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\\n */\\nvar isParent;\\nvar tView;\\nvar currentQueries;\\n/**\\n * Query instructions can ask for \\\"current queries\\\" in 2 different cases:\\n * - when creating view queries (at the root of a component view, before any node is created - in\\n * this case currentQueries points to view queries)\\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\\n * create content queries).\\n */\\nfunction getOrCreateCurrentQueries(QueryType) {\\n    // if this is the first content query on a node, any existing LQueries needs to be cloned\\n    // in subsequent template passes, the cloning occurs before directive instantiation.\\n    if (previousOrParentTNode && previousOrParentTNode !== viewData[HOST_NODE] &&\\n        !isContentQueryHost(previousOrParentTNode)) {\\n        currentQueries && (currentQueries = currentQueries.clone());\\n        previousOrParentTNode.flags |= 16384 /* hasContentQuery */;\\n    }\\n    return currentQueries || (currentQueries = new QueryType(null, null, null));\\n}\\n/**\\n * This property gets set before entering a template.\\n */\\nvar creationMode;\\nfunction getCreationMode() {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return creationMode;\\n}\\n/**\\n * State of the current view being processed.\\n *\\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\\n * any local variables that need to be stored between invocations.\\n */\\nvar viewData;\\n/**\\n * Internal function that returns the current LViewData instance.\\n *\\n * The getCurrentView() instruction should be used for anything public.\\n */\\nfunction _getViewData() {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return viewData;\\n}\\n/**\\n * The last viewData retrieved by nextContext().\\n * Allows building nextContext() and reference() calls.\\n *\\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\\n */\\nvar contextViewData = null;\\nfunction getCleanup(view) {\\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\\n    return view[CLEANUP] || (view[CLEANUP] = []);\\n}\\nfunction getTViewCleanup(view) {\\n    return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\\n}\\n/**\\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\\n *\\n * Necessary to support ChangeDetectorRef.checkNoChanges().\\n */\\nvar checkNoChangesMode = false;\\n/** Whether or not this is the first time the current view has been processed. */\\nvar firstTemplatePass = true;\\n/**\\n * The root index from which pure function instructions should calculate their binding\\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\\n * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\\n */\\nvar bindingRootIndex = -1;\\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\\nfunction getBindingRoot() {\\n    return bindingRootIndex;\\n}\\n/**\\n * Swap the current state with a new state.\\n *\\n * For performance reasons we store the state in the top level of the module.\\n * This way we minimize the number of properties to read. Whenever a new view\\n * is entered we have to store the state for later, and when the view is\\n * exited the state has to be restored\\n *\\n * @param newView New state to become active\\n * @param host Element to which the View is a child of\\n * @returns the previous state;\\n */\\nfunction enterView(newView, hostTNode) {\\n    var oldView = viewData;\\n    tView = newView && newView[TVIEW];\\n    creationMode = newView && (newView[FLAGS] & 1 /* CreationMode */) === 1 /* CreationMode */;\\n    firstTemplatePass = newView && tView.firstTemplatePass;\\n    bindingRootIndex = newView && tView.bindingStartIndex;\\n    renderer = newView && newView[RENDERER];\\n    previousOrParentTNode = hostTNode;\\n    isParent = true;\\n    viewData = contextViewData = newView;\\n    oldView && (oldView[QUERIES] = currentQueries);\\n    currentQueries = newView && newView[QUERIES];\\n    return oldView;\\n}\\n/**\\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\\n * the direction of traversal (up or down the view tree) a bit clearer.\\n *\\n * @param newView New state to become active\\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\\n */\\nfunction leaveView(newView, creationOnly) {\\n    if (!creationOnly) {\\n        if (!checkNoChangesMode) {\\n            executeHooks(viewData, tView.viewHooks, tView.viewCheckHooks, creationMode);\\n        }\\n        // Views are clean and in update mode after being checked, so these bits are cleared\\n        viewData[FLAGS] &= ~(1 /* CreationMode */ | 4 /* Dirty */);\\n    }\\n    viewData[FLAGS] |= 16 /* RunInit */;\\n    viewData[BINDING_INDEX] = tView.bindingStartIndex;\\n    enterView(newView, null);\\n}\\n/**\\n * Refreshes the view, executing the following steps in that order:\\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\\n * bindings, refreshes child components.\\n * Note: view hooks are triggered later when leaving the view.\\n */\\nfunction refreshDescendantViews() {\\n    setHostBindings();\\n    var parentFirstTemplatePass = firstTemplatePass;\\n    // This needs to be set before children are processed to support recursive components\\n    tView.firstTemplatePass = firstTemplatePass = false;\\n    if (!checkNoChangesMode) {\\n        executeInitHooks(viewData, tView, creationMode);\\n    }\\n    refreshDynamicEmbeddedViews(viewData);\\n    // Content query results must be refreshed before content hooks are called.\\n    refreshContentQueries(tView);\\n    if (!checkNoChangesMode) {\\n        executeHooks(viewData, tView.contentHooks, tView.contentCheckHooks, creationMode);\\n    }\\n    refreshChildComponents(tView.components, parentFirstTemplatePass);\\n}\\n/** Sets the host bindings for the current view. */\\nfunction setHostBindings() {\\n    if (tView.expandoInstructions) {\\n        bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\\n        var currentDirectiveIndex = -1;\\n        var currentElementIndex = -1;\\n        for (var i = 0; i < tView.expandoInstructions.length; i++) {\\n            var instruction = tView.expandoInstructions[i];\\n            if (typeof instruction === 'number') {\\n                if (instruction <= 0) {\\n                    // Negative numbers mean that we are starting new EXPANDO block and need to update\\n                    // the current element and directive index.\\n                    currentElementIndex = -instruction;\\n                    if (typeof viewData[bindingRootIndex] === 'number') {\\n                        // We've hit an injector. It may or may not exist depending on whether\\n                        // there is a public directive on this node.\\n                        bindingRootIndex += INJECTOR_SIZE;\\n                    }\\n                    currentDirectiveIndex = bindingRootIndex;\\n                }\\n                else {\\n                    // This is either the injector size (so the binding root can skip over directives\\n                    // and get to the first set of host bindings on this node) or the host var count\\n                    // (to get to the next set of host bindings on this node).\\n                    bindingRootIndex += instruction;\\n                }\\n            }\\n            else {\\n                // If it's not a number, it's a host binding function that needs to be executed.\\n                viewData[BINDING_INDEX] = bindingRootIndex;\\n                // We must subtract the header offset because the load() instruction\\n                // expects a raw, unadjusted index.\\n                instruction(currentDirectiveIndex - HEADER_OFFSET, currentElementIndex);\\n                currentDirectiveIndex++;\\n            }\\n        }\\n    }\\n}\\n/** Refreshes content queries for all directives in the given view. */\\nfunction refreshContentQueries(tView) {\\n    if (tView.contentQueries != null) {\\n        for (var i = 0; i < tView.contentQueries.length; i += 2) {\\n            var directiveDefIdx = tView.contentQueries[i];\\n            var directiveDef = tView.data[directiveDefIdx];\\n            directiveDef.contentQueriesRefresh(directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);\\n        }\\n    }\\n}\\n/** Refreshes child components in the current view. */\\nfunction refreshChildComponents(components, parentFirstTemplatePass) {\\n    if (components != null) {\\n        for (var i = 0; i < components.length; i++) {\\n            componentRefresh(components[i], parentFirstTemplatePass);\\n        }\\n    }\\n}\\nfunction executeInitAndContentHooks() {\\n    if (!checkNoChangesMode) {\\n        executeInitHooks(viewData, tView, creationMode);\\n        executeHooks(viewData, tView.contentHooks, tView.contentCheckHooks, creationMode);\\n    }\\n}\\nfunction createLViewData(renderer, tView, context, flags, sanitizer) {\\n    var instance = tView.blueprint.slice();\\n    instance[FLAGS] = flags | 1 /* CreationMode */ | 8 /* Attached */ | 16 /* RunInit */;\\n    instance[PARENT] = instance[DECLARATION_VIEW] = viewData;\\n    instance[CONTEXT] = context;\\n    instance[INJECTOR$1] = viewData ? viewData[INJECTOR$1] : null;\\n    instance[RENDERER] = renderer;\\n    instance[SANITIZER] = sanitizer || null;\\n    return instance;\\n}\\nfunction createNodeAtIndex(index, type, native, name, attrs) {\\n    var adjustedIndex = index + HEADER_OFFSET;\\n    ngDevMode &&\\n        assertLessThan(adjustedIndex, viewData.length, \\\"Slot should have been initialized with null\\\");\\n    viewData[adjustedIndex] = native;\\n    var tNode = tView.data[adjustedIndex];\\n    if (tNode == null) {\\n        tNode = tView.data[adjustedIndex] = createTNode(type, adjustedIndex, name, attrs, null);\\n        // Now link ourselves into the tree.\\n        if (previousOrParentTNode) {\\n            if (isParent && previousOrParentTNode.child == null &&\\n                (tNode.parent !== null || previousOrParentTNode.type === 2 /* View */)) {\\n                // We are in the same view, which means we are adding content node to the parent view.\\n                previousOrParentTNode.child = tNode;\\n            }\\n            else if (!isParent) {\\n                previousOrParentTNode.next = tNode;\\n            }\\n        }\\n    }\\n    if (tView.firstChild == null && type === 3 /* Element */) {\\n        tView.firstChild = tNode;\\n    }\\n    previousOrParentTNode = tNode;\\n    isParent = true;\\n    return tNode;\\n}\\nfunction createViewNode(index, view) {\\n    // View nodes are not stored in data because they can be added / removed at runtime (which\\n    // would cause indices to change). Their TNodes are instead stored in tView.node.\\n    if (view[TVIEW].node == null) {\\n        view[TVIEW].node = createTNode(2 /* View */, index, null, null, null);\\n    }\\n    isParent = true;\\n    return previousOrParentTNode = view[HOST_NODE] = view[TVIEW].node;\\n}\\n/**\\n * When elements are created dynamically after a view blueprint is created (e.g. through\\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\\n * template passes.\\n */\\nfunction adjustBlueprintForNewNode(view) {\\n    var tView = view[TVIEW];\\n    if (tView.firstTemplatePass) {\\n        tView.expandoStartIndex++;\\n        tView.blueprint.push(null);\\n        view.push(null);\\n    }\\n}\\n//////////////////////////\\n//// Render\\n//////////////////////////\\n/**\\n * Resets the application state.\\n */\\nfunction resetComponentState() {\\n    isParent = false;\\n    previousOrParentTNode = null;\\n    elementDepthCount = 0;\\n    bindingsEnabled = true;\\n}\\n/**\\n * Used for creating the LViewNode of a dynamic embedded view,\\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\\n */\\nfunction createEmbeddedViewAndNode(tView, context, declarationView, renderer, queries, injectorIndex) {\\n    var _isParent = isParent;\\n    var _previousOrParentTNode = previousOrParentTNode;\\n    isParent = true;\\n    previousOrParentTNode = null;\\n    var lView = createLViewData(renderer, tView, context, 2 /* CheckAlways */, getCurrentSanitizer());\\n    lView[DECLARATION_VIEW] = declarationView;\\n    if (queries) {\\n        lView[QUERIES] = queries.createView();\\n    }\\n    createViewNode(-1, lView);\\n    if (tView.firstTemplatePass) {\\n        tView.node.injectorIndex = injectorIndex;\\n    }\\n    isParent = _isParent;\\n    previousOrParentTNode = _previousOrParentTNode;\\n    return lView;\\n}\\n/**\\n * Used for rendering embedded views (e.g. dynamically created views)\\n *\\n * Dynamically created views must store/retrieve their TViews differently from component views\\n * because their template functions are nested in the template functions of their hosts, creating\\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\\n * TView for dynamically created views on their host TNode, which only has one instance.\\n */\\nfunction renderEmbeddedTemplate(viewToRender, tView, context, rf) {\\n    var _isParent = isParent;\\n    var _previousOrParentTNode = previousOrParentTNode;\\n    var oldView;\\n    if (viewToRender[FLAGS] & 64 /* IsRoot */) {\\n        // This is a root view inside the view tree\\n        tickRootContext(viewToRender[CONTEXT]);\\n    }\\n    else {\\n        try {\\n            isParent = true;\\n            previousOrParentTNode = null;\\n            oldView = enterView(viewToRender, viewToRender[HOST_NODE]);\\n            namespaceHTML();\\n            tView.template(rf, context);\\n            if (rf & 2 /* Update */) {\\n                refreshDescendantViews();\\n            }\\n            else {\\n                // This must be set to false immediately after the first creation run because in an\\n                // ngFor loop, all the views will be created together before update mode runs and turns\\n                // off firstTemplatePass. If we don't set it here, instances will perform directive\\n                // matching, etc again and again.\\n                viewToRender[TVIEW].firstTemplatePass = firstTemplatePass = false;\\n            }\\n        }\\n        finally {\\n            // renderEmbeddedTemplate() is called twice, once for creation only and then once for\\n            // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\\n            var isCreationOnly = (rf & 1 /* Create */) === 1 /* Create */;\\n            leaveView(oldView, isCreationOnly);\\n            isParent = _isParent;\\n            previousOrParentTNode = _previousOrParentTNode;\\n        }\\n    }\\n}\\n/**\\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\\n * Will get the next level up if level is not specified.\\n *\\n * This is used to save contexts of parent views so they can be bound in embedded views, or\\n * in conjunction with reference() to bind a ref from a parent view.\\n *\\n * @param level The relative level of the view from which to grab context compared to contextVewData\\n * @returns context\\n */\\nfunction nextContext(level) {\\n    if (level === void 0) { level = 1; }\\n    contextViewData = walkUpViews(level, contextViewData);\\n    return contextViewData[CONTEXT];\\n}\\nfunction renderComponentOrTemplate(hostView, componentOrContext, templateFn) {\\n    var oldView = enterView(hostView, hostView[HOST_NODE]);\\n    try {\\n        if (rendererFactory.begin) {\\n            rendererFactory.begin();\\n        }\\n        if (templateFn) {\\n            namespaceHTML();\\n            templateFn(getRenderFlags(hostView), componentOrContext);\\n            refreshDescendantViews();\\n        }\\n        else {\\n            executeInitAndContentHooks();\\n            // Element was stored at 0 in data and directive was stored at 0 in directives\\n            // in renderComponent()\\n            setHostBindings();\\n            componentRefresh(HEADER_OFFSET, false);\\n        }\\n    }\\n    finally {\\n        if (rendererFactory.end) {\\n            rendererFactory.end();\\n        }\\n        leaveView(oldView);\\n    }\\n}\\n/**\\n * This function returns the default configuration of rendering flags depending on when the\\n * template is in creation mode or update mode. By default, the update block is run with the\\n * creation block when the view is in creation mode. Otherwise, the update block is run\\n * alone.\\n *\\n * Dynamically created views do NOT use this configuration (update block and create block are\\n * always run separately).\\n */\\nfunction getRenderFlags(view) {\\n    return view[FLAGS] & 1 /* CreationMode */ ? 1 /* Create */ | 2 /* Update */ :\\n        2 /* Update */;\\n}\\n//////////////////////////\\n//// Namespace\\n//////////////////////////\\nvar _currentNamespace = null;\\nfunction namespaceSVG() {\\n    _currentNamespace = 'http://www.w3.org/2000/svg/';\\n}\\nfunction namespaceMathML() {\\n    _currentNamespace = 'http://www.w3.org/1998/MathML/';\\n}\\nfunction namespaceHTML() {\\n    _currentNamespace = null;\\n}\\n//////////////////////////\\n//// Element\\n//////////////////////////\\n/**\\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\\n *\\n * @param index Index of the element in the data array\\n * @param name Name of the DOM Node\\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\\n * @param localRefs A set of local reference bindings on the element.\\n */\\nfunction element(index, name, attrs, localRefs) {\\n    elementStart(index, name, attrs, localRefs);\\n    elementEnd();\\n}\\n/**\\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\\n * The instruction must later be followed by `elementContainerEnd()` call.\\n *\\n * @param index Index of the element in the LViewData array\\n * @param attrs Set of attributes to be used when matching directives.\\n * @param localRefs A set of local reference bindings on the element.\\n *\\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\\n * matching purposes and setting initial inputs of directives.\\n */\\nfunction elementContainerStart(index, attrs, localRefs) {\\n    ngDevMode && assertEqual(viewData[BINDING_INDEX], tView.bindingStartIndex, 'element containers should be created before any bindings');\\n    ngDevMode && ngDevMode.rendererCreateComment++;\\n    var native = renderer.createComment(ngDevMode ? 'ng-container' : '');\\n    ngDevMode && assertDataInRange(index - 1);\\n    var tNode = createNodeAtIndex(index, 4 /* ElementContainer */, native, null, attrs || null);\\n    appendChild(native, tNode, viewData);\\n    createDirectivesAndLocals(localRefs);\\n}\\n/** Mark the end of the <ng-container>. */\\nfunction elementContainerEnd() {\\n    if (isParent) {\\n        isParent = false;\\n    }\\n    else {\\n        ngDevMode && assertHasParent();\\n        previousOrParentTNode = previousOrParentTNode.parent;\\n    }\\n    ngDevMode && assertNodeType(previousOrParentTNode, 4 /* ElementContainer */);\\n    currentQueries &&\\n        (currentQueries = currentQueries.addNode(previousOrParentTNode));\\n    queueLifecycleHooks(previousOrParentTNode.flags, tView);\\n}\\n/**\\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\\n *\\n * @param index Index of the element in the LViewData array\\n * @param name Name of the DOM Node\\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\\n * @param localRefs A set of local reference bindings on the element.\\n *\\n * Attributes and localRefs are passed as an array of strings where elements with an even index\\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\\n * ['id', 'warning5', 'class', 'alert']\\n */\\nfunction elementStart(index, name, attrs, localRefs) {\\n    ngDevMode && assertEqual(viewData[BINDING_INDEX], tView.bindingStartIndex, 'elements should be created before any bindings ');\\n    ngDevMode && ngDevMode.rendererCreateElement++;\\n    var native = elementCreate(name);\\n    ngDevMode && assertDataInRange(index - 1);\\n    var tNode = createNodeAtIndex(index, 3 /* Element */, native, name, attrs || null);\\n    if (attrs) {\\n        setUpAttributes(native, attrs);\\n    }\\n    appendChild(native, tNode, viewData);\\n    createDirectivesAndLocals(localRefs);\\n    // any immediate children of a component or template container must be pre-emptively\\n    // monkey-patched with the component view data so that the element can be inspected\\n    // later on using any element discovery utility methods (see `element_discovery.ts`)\\n    if (elementDepthCount === 0) {\\n        attachPatchData(native, viewData);\\n    }\\n    elementDepthCount++;\\n}\\n/**\\n * Creates a native element from a tag name, using a renderer.\\n * @param name the tag name\\n * @param overriddenRenderer Optional A renderer to override the default one\\n * @returns the element created\\n */\\nfunction elementCreate(name, overriddenRenderer) {\\n    var native;\\n    var rendererToUse = overriddenRenderer || renderer;\\n    if (isProceduralRenderer(rendererToUse)) {\\n        native = rendererToUse.createElement(name, _currentNamespace);\\n    }\\n    else {\\n        if (_currentNamespace === null) {\\n            native = rendererToUse.createElement(name);\\n        }\\n        else {\\n            native = rendererToUse.createElementNS(_currentNamespace, name);\\n        }\\n    }\\n    return native;\\n}\\n/**\\n * Creates directive instances and populates local refs.\\n *\\n * @param localRefs Local refs of the node in question\\n * @param localRefExtractor mapping function that extracts local ref value from TNode\\n */\\nfunction createDirectivesAndLocals(localRefs, localRefExtractor) {\\n    if (localRefExtractor === void 0) { localRefExtractor = getNativeByTNode; }\\n    if (!bindingsEnabled)\\n        return;\\n    if (firstTemplatePass) {\\n        ngDevMode && ngDevMode.firstTemplatePass++;\\n        cacheMatchingDirectivesForNode(previousOrParentTNode, tView, localRefs || null);\\n    }\\n    else {\\n        instantiateDirectivesDirectly();\\n    }\\n    saveResolvedLocalsInData(localRefExtractor);\\n}\\n/**\\n * On first template pass, we match each node against available directive selectors and save\\n * the resulting defs in the correct instantiation order for subsequent change detection runs\\n * (so dependencies are always created before the directives that inject them).\\n */\\nfunction cacheMatchingDirectivesForNode(tNode, tView, localRefs) {\\n    // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\\n    var exportsMap = localRefs ? { '': -1 } : null;\\n    var matches = tView.currentMatches = findDirectiveMatches(tNode);\\n    generateExpandoBlock(tNode, matches);\\n    var totalHostVars = 0;\\n    if (matches) {\\n        for (var i = 0; i < matches.length; i += 2) {\\n            var def = matches[i];\\n            var valueIndex = i + 1;\\n            resolveDirective(def, valueIndex, matches);\\n            totalHostVars += def.hostVars;\\n            saveNameToExportMap(matches[valueIndex], def, exportsMap);\\n        }\\n    }\\n    if (exportsMap)\\n        cacheMatchingLocalNames(tNode, localRefs, exportsMap);\\n    prefillHostVars(totalHostVars);\\n}\\n/**\\n * Generates a new block in TView.expandoInstructions for this node.\\n *\\n * Each expando block starts with the element index (turned negative so we can distinguish\\n * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\\n */\\nfunction generateExpandoBlock(tNode, matches) {\\n    var directiveCount = matches ? matches.length / 2 : 0;\\n    var elementIndex = -(tNode.index - HEADER_OFFSET);\\n    if (directiveCount > 0) {\\n        (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, directiveCount);\\n    }\\n}\\n/**\\n * On the first template pass, we need to reserve space for host binding values\\n * after directives are matched (so all directives are saved, then bindings).\\n * Because we are updating the blueprint, we only need to do this once.\\n */\\nfunction prefillHostVars(totalHostVars) {\\n    for (var i = 0; i < totalHostVars; i++) {\\n        viewData.push(NO_CHANGE);\\n        tView.blueprint.push(NO_CHANGE);\\n        tView.data.push(null);\\n    }\\n}\\n/** Matches the current node against all available selectors. */\\nfunction findDirectiveMatches(tNode) {\\n    var registry = tView.directiveRegistry;\\n    var matches = null;\\n    if (registry) {\\n        for (var i = 0; i < registry.length; i++) {\\n            var def = registry[i];\\n            if (isNodeMatchingSelectorList(tNode, def.selectors)) {\\n                matches || (matches = []);\\n                if (def.diPublic)\\n                    def.diPublic(def);\\n                if (def.template) {\\n                    if (tNode.flags & 4096 /* isComponent */)\\n                        throwMultipleComponentError(tNode);\\n                    addComponentLogic(def);\\n                    // The component is always stored first with directives after.\\n                    matches.unshift(def, null);\\n                }\\n                else {\\n                    matches.push(def, null);\\n                }\\n            }\\n        }\\n    }\\n    return matches;\\n}\\nfunction resolveDirective(def, valueIndex, matches) {\\n    if (matches[valueIndex] === null) {\\n        matches[valueIndex] = CIRCULAR$1;\\n        var instance = def.factory();\\n        return directiveCreate(matches[valueIndex] = viewData.length, instance, def);\\n    }\\n    else if (matches[valueIndex] === CIRCULAR$1) {\\n        // If we revisit this directive before it's resolved, we know it's circular\\n        throwCyclicDependencyError(def.type);\\n    }\\n    return null;\\n}\\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\\nfunction queueComponentIndexForCheck() {\\n    if (firstTemplatePass) {\\n        (tView.components || (tView.components = [])).push(previousOrParentTNode.index);\\n    }\\n}\\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\\n */\\nfunction queueHostBindingForCheck(dirIndex, def) {\\n    ngDevMode &&\\n        assertEqual(firstTemplatePass, true, 'Should only be called in first template pass.');\\n    tView.expandoInstructions.push(def.hostBindings, def.hostVars);\\n}\\n/**\\n * This function instantiates the given directives.\\n */\\nfunction instantiateDirectivesDirectly() {\\n    ngDevMode && assertEqual(firstTemplatePass, false, \\\"Directives should only be instantiated directly after first template pass\\\");\\n    var count = previousOrParentTNode.flags & 4095 /* DirectiveCountMask */;\\n    if (isContentQueryHost(previousOrParentTNode) && currentQueries) {\\n        currentQueries = currentQueries.clone();\\n    }\\n    if (count > 0) {\\n        var start = previousOrParentTNode.flags >> 15 /* DirectiveStartingIndexShift */;\\n        var end = start + count;\\n        for (var i = start; i < end; i++) {\\n            var def = tView.data[i];\\n            // Component view must be set on node before the factory is created so\\n            // ChangeDetectorRefs have a way to store component view on creation.\\n            if (def.template) {\\n                addComponentLogic(def);\\n            }\\n            directiveCreate(i, def.factory(), def);\\n        }\\n    }\\n}\\n/** Caches local names and their matching directive indices for query and template lookups. */\\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\\n    if (localRefs) {\\n        var localNames = tNode.localNames = [];\\n        // Local names must be stored in tNode in the same order that localRefs are defined\\n        // in the template to ensure the data is loaded in the same slots as their refs\\n        // in the template (for template queries).\\n        for (var i = 0; i < localRefs.length; i += 2) {\\n            var index = exportsMap[localRefs[i + 1]];\\n            if (index == null)\\n                throw new Error(\\\"Export of name '\\\" + localRefs[i + 1] + \\\"' not found!\\\");\\n            localNames.push(localRefs[i], index);\\n        }\\n    }\\n}\\n/**\\n * Builds up an export map as directives are created, so local refs can be quickly mapped\\n * to their directive instances.\\n */\\nfunction saveNameToExportMap(index, def, exportsMap) {\\n    if (exportsMap) {\\n        if (def.exportAs)\\n            exportsMap[def.exportAs] = index;\\n        if (def.template)\\n            exportsMap[''] = index;\\n    }\\n}\\n/**\\n * Takes a list of local names and indices and pushes the resolved local variable values\\n * to LViewData in the same order as they are loaded in the template with load().\\n */\\nfunction saveResolvedLocalsInData(localRefExtractor) {\\n    var localNames = previousOrParentTNode.localNames;\\n    var tNode = previousOrParentTNode;\\n    if (localNames) {\\n        var localIndex = previousOrParentTNode.index + 1;\\n        for (var i = 0; i < localNames.length; i += 2) {\\n            var index = localNames[i + 1];\\n            var value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\\n            viewData[localIndex++] = value;\\n        }\\n    }\\n}\\n/**\\n * Gets TView from a template function or creates a new TView\\n * if it doesn't already exist.\\n *\\n * @param templateFn The template from which to get static data\\n * @param consts The number of nodes, local refs, and pipes in this view\\n * @param vars The number of bindings and pure function bindings in this view\\n * @param directives Directive defs that should be saved on TView\\n * @param pipes Pipe defs that should be saved on TView\\n * @returns TView\\n */\\nfunction getOrCreateTView(templateFn, consts, vars, directives, pipes, viewQuery) {\\n    // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\\n    // 1. It is a megamorphic call on each invocation.\\n    // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\\n    //    outer template invocation, which means that no such property will exist\\n    // Correct solution is to only put `ngPrivateData` on the Component template\\n    // and not on embedded templates.\\n    return templateFn.ngPrivateData ||\\n        (templateFn.ngPrivateData =\\n            createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery));\\n}\\n/**\\n * Creates a TView instance\\n *\\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\\n * @param templateFn Template function\\n * @param consts The number of nodes, local refs, and pipes in this template\\n * @param directives Registry of directives for this view\\n * @param pipes Registry of pipes for this view\\n */\\nfunction createTView(viewIndex, templateFn, consts, vars, directives, pipes, viewQuery) {\\n    ngDevMode && ngDevMode.tView++;\\n    var bindingStartIndex = HEADER_OFFSET + consts;\\n    // This length does not yet contain host bindings from child directives because at this point,\\n    // we don't know which directives are active on this template. As soon as a directive is matched\\n    // that has a host binding, we will update the blueprint with that def's hostVars count.\\n    var initialViewLength = bindingStartIndex + vars;\\n    var blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\\n    return blueprint[TVIEW] = {\\n        id: viewIndex,\\n        blueprint: blueprint,\\n        template: templateFn,\\n        viewQuery: viewQuery,\\n        node: null,\\n        data: blueprint.slice(),\\n        childIndex: -1,\\n        bindingStartIndex: bindingStartIndex,\\n        expandoStartIndex: initialViewLength,\\n        expandoInstructions: null,\\n        firstTemplatePass: true,\\n        initHooks: null,\\n        checkHooks: null,\\n        contentHooks: null,\\n        contentCheckHooks: null,\\n        viewHooks: null,\\n        viewCheckHooks: null,\\n        destroyHooks: null,\\n        pipeDestroyHooks: null,\\n        cleanup: null,\\n        contentQueries: null,\\n        components: null,\\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\\n        currentMatches: null,\\n        firstChild: null,\\n    };\\n}\\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\\n    var blueprint = new Array(initialViewLength)\\n        .fill(null, 0, bindingStartIndex)\\n        .fill(NO_CHANGE, bindingStartIndex);\\n    blueprint[CONTAINER_INDEX] = -1;\\n    blueprint[BINDING_INDEX] = bindingStartIndex;\\n    return blueprint;\\n}\\nfunction setUpAttributes(native, attrs) {\\n    var isProc = isProceduralRenderer(renderer);\\n    var i = 0;\\n    while (i < attrs.length) {\\n        var attrName = attrs[i];\\n        if (attrName === 1 /* SelectOnly */)\\n            break;\\n        if (attrName === NG_PROJECT_AS_ATTR_NAME) {\\n            i += 2;\\n        }\\n        else {\\n            ngDevMode && ngDevMode.rendererSetAttribute++;\\n            if (attrName === 0 /* NamespaceURI */) {\\n                // Namespaced attributes\\n                var namespaceURI = attrs[i + 1];\\n                var attrName_1 = attrs[i + 2];\\n                var attrVal = attrs[i + 3];\\n                isProc ?\\n                    renderer\\n                        .setAttribute(native, attrName_1, attrVal, namespaceURI) :\\n                    native.setAttributeNS(namespaceURI, attrName_1, attrVal);\\n                i += 4;\\n            }\\n            else {\\n                // Standard attributes\\n                var attrVal = attrs[i + 1];\\n                isProc ?\\n                    renderer\\n                        .setAttribute(native, attrName, attrVal) :\\n                    native.setAttribute(attrName, attrVal);\\n                i += 2;\\n            }\\n        }\\n    }\\n}\\nfunction createError(text, token) {\\n    return new Error(\\\"Renderer: \\\" + text + \\\" [\\\" + stringify$1(token) + \\\"]\\\");\\n}\\n/**\\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\\n *\\n * @param elementOrSelector Render element or CSS selector to locate the element.\\n */\\nfunction locateHostElement(factory, elementOrSelector) {\\n    ngDevMode && assertDataInRange(-1);\\n    rendererFactory = factory;\\n    var defaultRenderer = factory.createRenderer(null, null);\\n    var rNode = typeof elementOrSelector === 'string' ?\\n        (isProceduralRenderer(defaultRenderer) ?\\n            defaultRenderer.selectRootElement(elementOrSelector) :\\n            defaultRenderer.querySelector(elementOrSelector)) :\\n        elementOrSelector;\\n    if (ngDevMode && !rNode) {\\n        if (typeof elementOrSelector === 'string') {\\n            throw createError('Host node with selector not found:', elementOrSelector);\\n        }\\n        else {\\n            throw createError('Host node is required:', elementOrSelector);\\n        }\\n    }\\n    return rNode;\\n}\\n/**\\n * Adds an event listener to the current node.\\n *\\n * If an output exists on one of the node's directives, it also subscribes to the output\\n * and saves the subscription for later cleanup.\\n *\\n * @param eventName Name of the event\\n * @param listenerFn The function to be called when event emits\\n * @param useCapture Whether or not to use capture in event listener.\\n */\\nfunction listener(eventName, listenerFn, useCapture) {\\n    if (useCapture === void 0) { useCapture = false; }\\n    var tNode = previousOrParentTNode;\\n    ngDevMode && assertNodeOfPossibleTypes(tNode, 3 /* Element */, 0 /* Container */, 4 /* ElementContainer */);\\n    // add native event listener - applicable to elements only\\n    if (tNode.type === 3 /* Element */) {\\n        var native = getNativeByTNode(previousOrParentTNode, viewData);\\n        ngDevMode && ngDevMode.rendererAddEventListener++;\\n        // In order to match current behavior, native DOM event listeners must be added for all\\n        // events (including outputs).\\n        if (isProceduralRenderer(renderer)) {\\n            var cleanupFn = renderer.listen(native, eventName, listenerFn);\\n            storeCleanupFn(viewData, cleanupFn);\\n        }\\n        else {\\n            var wrappedListener = wrapListenerWithPreventDefault(listenerFn);\\n            native.addEventListener(eventName, wrappedListener, useCapture);\\n            var cleanupInstances = getCleanup(viewData);\\n            cleanupInstances.push(wrappedListener);\\n            if (firstTemplatePass) {\\n                getTViewCleanup(viewData).push(eventName, tNode.index, cleanupInstances.length - 1, useCapture);\\n            }\\n        }\\n    }\\n    // subscribe to directive outputs\\n    if (tNode.outputs === undefined) {\\n        // if we create TNode here, inputs must be undefined so we know they still need to be\\n        // checked\\n        tNode.outputs = generatePropertyAliases(tNode.flags, 1 /* Output */);\\n    }\\n    var outputs = tNode.outputs;\\n    var outputData;\\n    if (outputs && (outputData = outputs[eventName])) {\\n        createOutput(outputData, listenerFn);\\n    }\\n}\\n/**\\n * Iterates through the outputs associated with a particular event name and subscribes to\\n * each output.\\n */\\nfunction createOutput(outputs, listener) {\\n    for (var i = 0; i < outputs.length; i += 2) {\\n        ngDevMode && assertDataInRange(outputs[i], viewData);\\n        var subscription = viewData[outputs[i]][outputs[i + 1]].subscribe(listener);\\n        storeCleanupWithContext(viewData, subscription, subscription.unsubscribe);\\n    }\\n}\\n/**\\n * Saves context for this cleanup function in LView.cleanupInstances.\\n *\\n * On the first template pass, saves in TView:\\n * - Cleanup function\\n * - Index of context we just saved in LView.cleanupInstances\\n */\\nfunction storeCleanupWithContext(view, context, cleanupFn) {\\n    if (!view)\\n        view = viewData;\\n    getCleanup(view).push(context);\\n    if (view[TVIEW].firstTemplatePass) {\\n        getTViewCleanup(view).push(cleanupFn, view[CLEANUP].length - 1);\\n    }\\n}\\n/**\\n * Saves the cleanup function itself in LView.cleanupInstances.\\n *\\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\\n * listeners.\\n *\\n * On the first template pass, the index of the cleanup function is saved in TView.\\n */\\nfunction storeCleanupFn(view, cleanupFn) {\\n    getCleanup(view).push(cleanupFn);\\n    if (view[TVIEW].firstTemplatePass) {\\n        getTViewCleanup(view).push(view[CLEANUP].length - 1, null);\\n    }\\n}\\n/** Mark the end of the element. */\\nfunction elementEnd() {\\n    if (isParent) {\\n        isParent = false;\\n    }\\n    else {\\n        ngDevMode && assertHasParent();\\n        previousOrParentTNode = previousOrParentTNode.parent;\\n    }\\n    ngDevMode && assertNodeType(previousOrParentTNode, 3 /* Element */);\\n    currentQueries &&\\n        (currentQueries = currentQueries.addNode(previousOrParentTNode));\\n    queueLifecycleHooks(previousOrParentTNode.flags, tView);\\n    elementDepthCount--;\\n}\\n/**\\n * Updates the value of removes an attribute on an Element.\\n *\\n * @param number index The index of the element in the data array\\n * @param name name The name of the attribute.\\n * @param value value The attribute is removed when value is `null` or `undefined`.\\n *                  Otherwise the attribute value is set to the stringified value.\\n * @param sanitizer An optional function used to sanitize the value.\\n */\\nfunction elementAttribute(index, name, value, sanitizer) {\\n    if (value !== NO_CHANGE) {\\n        var element_1 = getNativeByIndex(index, viewData);\\n        if (value == null) {\\n            ngDevMode && ngDevMode.rendererRemoveAttribute++;\\n            isProceduralRenderer(renderer) ? renderer.removeAttribute(element_1, name) :\\n                element_1.removeAttribute(name);\\n        }\\n        else {\\n            ngDevMode && ngDevMode.rendererSetAttribute++;\\n            var strValue = sanitizer == null ? stringify$1(value) : sanitizer(value);\\n            isProceduralRenderer(renderer) ? renderer.setAttribute(element_1, name, strValue) :\\n                element_1.setAttribute(name, strValue);\\n        }\\n    }\\n}\\n/**\\n * Update a property on an Element.\\n *\\n * If the property name also exists as an input property on one of the element's directives,\\n * the component property will be set instead of the element property. This check must\\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\\n *\\n * @param index The index of the element to update in the data array\\n * @param propName Name of property. Because it is going to DOM, this is not subject to\\n *        renaming as part of minification.\\n * @param value New value to write.\\n * @param sanitizer An optional function used to sanitize the value.\\n */\\nfunction elementProperty(index, propName, value, sanitizer) {\\n    if (value === NO_CHANGE)\\n        return;\\n    var element = getNativeByIndex(index, viewData);\\n    var tNode = getTNode(index, viewData);\\n    // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\\n    // yet been checked\\n    if (tNode && tNode.inputs === undefined) {\\n        // mark inputs as checked\\n        tNode.inputs = generatePropertyAliases(tNode.flags, 0 /* Input */);\\n    }\\n    var inputData = tNode && tNode.inputs;\\n    var dataValue;\\n    if (inputData && (dataValue = inputData[propName])) {\\n        setInputsForProperty(dataValue, value);\\n        if (isComponent(tNode))\\n            markDirtyIfOnPush(index + HEADER_OFFSET);\\n    }\\n    else if (tNode.type === 3 /* Element */) {\\n        // It is assumed that the sanitizer is only added when the compiler determines that the property\\n        // is risky, so sanitization can be done without further checks.\\n        value = sanitizer != null ? sanitizer(value) : value;\\n        ngDevMode && ngDevMode.rendererSetProperty++;\\n        isProceduralRenderer(renderer) ?\\n            renderer.setProperty(element, propName, value) :\\n            (element.setProperty ? element.setProperty(propName, value) :\\n                element[propName] = value);\\n    }\\n}\\n/**\\n * Enables directive matching on elements.\\n *\\n *  * Example:\\n * ```\\n * <my-comp my-directive>\\n *   Should match component / directive.\\n * </my-comp>\\n * <div ngNonBindable>\\n *   \\x3c!-- disabledBindings() --\\x3e\\n *   <my-comp my-directive>\\n *     Should not match component / directive because we are in ngNonBindable.\\n *   </my-comp>\\n *   \\x3c!-- enableBindings() --\\x3e\\n * </div>\\n * ```\\n */\\nfunction enableBindings() {\\n    bindingsEnabled = true;\\n}\\n/**\\n * Disables directive matching on element.\\n *\\n *  * Example:\\n * ```\\n * <my-comp my-directive>\\n *   Should match component / directive.\\n * </my-comp>\\n * <div ngNonBindable>\\n *   \\x3c!-- disabledBindings() --\\x3e\\n *   <my-comp my-directive>\\n *     Should not match component / directive because we are in ngNonBindable.\\n *   </my-comp>\\n *   \\x3c!-- enableBindings() --\\x3e\\n * </div>\\n * ```\\n */\\nfunction disableBindings() {\\n    bindingsEnabled = false;\\n}\\n/**\\n * Constructs a TNode object from the arguments.\\n *\\n * @param type The type of the node\\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\\n * @param tagName The tag name of the node\\n * @param attrs The attributes defined on this node\\n * @param tViews Any TViews attached to this node\\n * @returns the TNode object\\n */\\nfunction createTNode(type, adjustedIndex, tagName, attrs, tViews) {\\n    ngDevMode && ngDevMode.tNode++;\\n    var parent = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\\n    // Parents cannot cross component boundaries because components will be used in multiple places,\\n    // so it's only set if the view is the same.\\n    var parentInSameView = parent && viewData && parent !== viewData[HOST_NODE];\\n    var tParent = parentInSameView ? parent : null;\\n    return {\\n        type: type,\\n        index: adjustedIndex,\\n        injectorIndex: tParent ? tParent.injectorIndex : -1,\\n        flags: 0,\\n        tagName: tagName,\\n        attrs: attrs,\\n        localNames: null,\\n        initialInputs: undefined,\\n        inputs: undefined,\\n        outputs: undefined,\\n        tViews: tViews,\\n        next: null,\\n        child: null,\\n        parent: tParent,\\n        detached: null,\\n        stylingTemplate: null,\\n        projection: null\\n    };\\n}\\n/**\\n * Given a list of directive indices and minified input names, sets the\\n * input properties on the corresponding directives.\\n */\\nfunction setInputsForProperty(inputs, value) {\\n    for (var i = 0; i < inputs.length; i += 2) {\\n        ngDevMode && assertDataInRange(inputs[i], viewData);\\n        viewData[inputs[i]][inputs[i + 1]] = value;\\n    }\\n}\\n/**\\n * Consolidates all inputs or outputs of all directives on this logical node.\\n *\\n * @param number tNodeFlags node flags\\n * @param Direction direction whether to consider inputs or outputs\\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\\n */\\nfunction generatePropertyAliases(tNodeFlags, direction) {\\n    var count = tNodeFlags & 4095 /* DirectiveCountMask */;\\n    var propStore = null;\\n    if (count > 0) {\\n        var start = tNodeFlags >> 15 /* DirectiveStartingIndexShift */;\\n        var end = start + count;\\n        var isInput = direction === 0 /* Input */;\\n        var defs = tView.data;\\n        for (var i = start; i < end; i++) {\\n            var directiveDef = defs[i];\\n            var propertyAliasMap = isInput ? directiveDef.inputs : directiveDef.outputs;\\n            for (var publicName in propertyAliasMap) {\\n                if (propertyAliasMap.hasOwnProperty(publicName)) {\\n                    propStore = propStore || {};\\n                    var internalName = propertyAliasMap[publicName];\\n                    var hasProperty = propStore.hasOwnProperty(publicName);\\n                    hasProperty ? propStore[publicName].push(i, internalName) :\\n                        (propStore[publicName] = [i, internalName]);\\n                }\\n            }\\n        }\\n    }\\n    return propStore;\\n}\\n/**\\n * Add or remove a class in a `classList` on a DOM element.\\n *\\n * This instruction is meant to handle the [class.foo]=\\\"exp\\\" case\\n *\\n * @param index The index of the element to update in the data array\\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\\n *        renaming as part of minification.\\n * @param value A value indicating if a given class should be added or removed.\\n */\\nfunction elementClassProp(index, stylingIndex, value) {\\n    var val = (value instanceof BoundPlayerFactory) ? value : (!!value);\\n    updateClassProp(getStylingContext(index, viewData), stylingIndex, val);\\n}\\n/**\\n * Assign any inline style values to the element during creation mode.\\n *\\n * This instruction is meant to be called during creation mode to apply all styling\\n * (e.g. `style=\\\"...\\\"`) values to the element. This is also where the provided index\\n * value is allocated for the styling details for its corresponding element (the element\\n * index is the previous index value from this one).\\n *\\n * (Note this function calls `elementStylingApply` immediately when called.)\\n *\\n *\\n * @param index Index value which will be allocated to store styling data for the element.\\n *        (Note that this is not the element index, but rather an index value allocated\\n *        specifically for element styling--the index must be the next index after the element\\n *        index.)\\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\\n *   Each individual style will be used on the element as long as it is not overridden\\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\\n *   class value that are passed in here will be applied to the element (if matched).\\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\\n *   Each individual style will be used on the element as long as it is not overridden\\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\\n *   bindings. If a style binding changes its value to null then the initial styling\\n *   values that are passed in here will be applied to the element (if matched).\\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\\n */\\nfunction elementStyling(classDeclarations, styleDeclarations, styleSanitizer) {\\n    var tNode = previousOrParentTNode;\\n    if (!tNode.stylingTemplate) {\\n        // initialize the styling template.\\n        tNode.stylingTemplate =\\n            createStylingContextTemplate(classDeclarations, styleDeclarations, styleSanitizer);\\n    }\\n    if (styleDeclarations && styleDeclarations.length ||\\n        classDeclarations && classDeclarations.length) {\\n        elementStylingApply(tNode.index - HEADER_OFFSET);\\n    }\\n}\\n/**\\n * Apply all styling values to the element which have been queued by any styling instructions.\\n *\\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\\n * have been issued against the element. This function will also determine if any styles have\\n * changed and will then skip the operation if there is nothing new to render.\\n *\\n * Once called then all queued styles will be flushed.\\n *\\n * @param index Index of the element's styling storage that will be rendered.\\n *        (Note that this is not the element index, but rather an index value allocated\\n *        specifically for element styling--the index must be the next index after the element\\n *        index.)\\n */\\nfunction elementStylingApply(index) {\\n    var totalPlayersQueued = renderStyleAndClassBindings(getStylingContext(index, viewData), renderer, viewData);\\n    if (totalPlayersQueued > 0) {\\n        var rootContext = getRootContext(viewData);\\n        scheduleTick(rootContext, 2 /* FlushPlayers */);\\n    }\\n}\\n/**\\n * Queue a given style to be rendered on an Element.\\n *\\n * If the style value is `null` then it will be removed from the element\\n * (or assigned a different value depending if there are any styles placed\\n * on the element with `elementStyle` or any styles that are present\\n * from when the element was created (with `elementStyling`).\\n *\\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\\n *\\n * @param index Index of the element's styling storage to change in the data array.\\n *        (Note that this is not the element index, but rather an index value allocated\\n *        specifically for element styling--the index must be the next index after the element\\n *        index.)\\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\\n * @param value New value to write (null to remove).\\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\\n *        Note that when a suffix is provided then the underlying sanitizer will\\n *        be ignored.\\n */\\nfunction elementStyleProp(index, styleIndex, value, suffix) {\\n    var valueToAdd = null;\\n    if (value) {\\n        if (suffix) {\\n            // when a suffix is applied then it will bypass\\n            // sanitization entirely (b/c a new string is created)\\n            valueToAdd = stringify$1(value) + suffix;\\n        }\\n        else {\\n            // sanitization happens by dealing with a String value\\n            // this means that the string value will be passed through\\n            // into the style rendering later (which is where the value\\n            // will be sanitized before it is applied)\\n            valueToAdd = value;\\n        }\\n    }\\n    updateStyleProp(getStylingContext(index, viewData), styleIndex, valueToAdd);\\n}\\n/**\\n * Queue a key/value map of styles to be rendered on an Element.\\n *\\n * This instruction is meant to handle the `[style]=\\\"exp\\\"` usage. When styles are applied to\\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\\n * If any styles are set to `null` then they will be removed from the element (unless the same\\n * style properties have been assigned to the element during creation using `elementStyling`).\\n *\\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\\n *\\n * @param index Index of the element's styling storage to change in the data array.\\n *        (Note that this is not the element index, but rather an index value allocated\\n *        specifically for element styling--the index must be the next index after the element\\n *        index.)\\n * @param classes A key/value style map of CSS classes that will be added to the given element.\\n *        Any missing classes (that have already been applied to the element beforehand) will be\\n *        removed (unset) from the element's list of CSS classes.\\n * @param styles A key/value style map of the styles that will be applied to the given element.\\n *        Any missing styles (that have already been applied to the element beforehand) will be\\n *        removed (unset) from the element's styling.\\n */\\nfunction elementStylingMap(index, classes, styles) {\\n    updateStylingMap(getStylingContext(index, viewData), classes, styles);\\n}\\n//////////////////////////\\n//// Text\\n//////////////////////////\\n/**\\n * Create static text node\\n *\\n * @param index Index of the node in the data array\\n * @param value Value to write. This value will be stringified.\\n */\\nfunction text(index, value) {\\n    ngDevMode && assertEqual(viewData[BINDING_INDEX], tView.bindingStartIndex, 'text nodes should be created before any bindings');\\n    ngDevMode && ngDevMode.rendererCreateTextNode++;\\n    var textNative = createTextNode(value, renderer);\\n    var tNode = createNodeAtIndex(index, 3 /* Element */, textNative, null, null);\\n    // Text nodes are self closing.\\n    isParent = false;\\n    appendChild(textNative, tNode, viewData);\\n}\\n/**\\n * Create text node with binding\\n * Bindings should be handled externally with the proper interpolation(1-8) method\\n *\\n * @param index Index of the node in the data array.\\n * @param value Stringified value to write.\\n */\\nfunction textBinding(index, value) {\\n    if (value !== NO_CHANGE) {\\n        ngDevMode && assertDataInRange(index + HEADER_OFFSET);\\n        var element_2 = getNativeByIndex(index, viewData);\\n        ngDevMode && assertDefined(element_2, 'native element should exist');\\n        ngDevMode && ngDevMode.rendererSetText++;\\n        isProceduralRenderer(renderer) ? renderer.setValue(element_2, stringify$1(value)) :\\n            element_2.textContent = stringify$1(value);\\n    }\\n}\\n//////////////////////////\\n//// Directive\\n//////////////////////////\\n/**\\n * Create a directive and their associated content queries.\\n *\\n * NOTE: directives can be created in order other than the index order. They can also\\n *       be retrieved before they are created in which case the value will be null.\\n *\\n * @param directive The directive instance.\\n * @param directiveDef DirectiveDef object which contains information about the template.\\n */\\nfunction directiveCreate(directiveDefIdx, directive, directiveDef) {\\n    var native = getNativeByTNode(previousOrParentTNode, viewData);\\n    var instance = baseDirectiveCreate(directiveDefIdx, directive, directiveDef, native);\\n    if (directiveDef.template) {\\n        var componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\\n        componentView[CONTEXT] = directive;\\n    }\\n    if (firstTemplatePass) {\\n        // Init hooks are queued now so ngOnInit is called in host components before\\n        // any projected components.\\n        queueInitHooks(directiveDefIdx, directiveDef.onInit, directiveDef.doCheck, tView);\\n    }\\n    ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\\n    if (previousOrParentTNode && previousOrParentTNode.attrs) {\\n        setInputsFromAttrs(directiveDefIdx, instance, directiveDef.inputs, previousOrParentTNode);\\n    }\\n    if (directiveDef.contentQueries) {\\n        directiveDef.contentQueries();\\n    }\\n    return instance;\\n}\\nfunction addComponentLogic(def) {\\n    var native = getNativeByTNode(previousOrParentTNode, viewData);\\n    var tView = getOrCreateTView(def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\\n    // Only component views should be added to the view tree directly. Embedded views are\\n    // accessed through their containers because they may be removed / re-added later.\\n    var componentView = addToViewTree(viewData, previousOrParentTNode.index, createLViewData(rendererFactory.createRenderer(native, def), tView, null, def.onPush ? 4 /* Dirty */ : 2 /* CheckAlways */, getCurrentSanitizer()));\\n    componentView[HOST_NODE] = previousOrParentTNode;\\n    // Component view will always be created before any injected LContainers,\\n    // so this is a regular element, wrap it with the component view\\n    componentView[HOST] = viewData[previousOrParentTNode.index];\\n    viewData[previousOrParentTNode.index] = componentView;\\n    if (firstTemplatePass) {\\n        queueComponentIndexForCheck();\\n        previousOrParentTNode.flags =\\n            viewData.length << 15 /* DirectiveStartingIndexShift */ | 4096 /* isComponent */;\\n    }\\n}\\n/**\\n * A lighter version of directiveCreate() that is used for the root component\\n *\\n * This version does not contain features that we don't already support at root in\\n * current Angular. Example: local refs and inputs on root component.\\n */\\nfunction baseDirectiveCreate(index, directive, directiveDef, native) {\\n    ngDevMode && assertEqual(viewData[BINDING_INDEX], tView.bindingStartIndex, 'directives should be created before any bindings');\\n    ngDevMode && assertPreviousIsParent();\\n    attachPatchData(directive, viewData);\\n    if (native) {\\n        attachPatchData(native, viewData);\\n    }\\n    viewData[index] = directive;\\n    if (firstTemplatePass) {\\n        var flags = previousOrParentTNode.flags;\\n        if (flags === 0) {\\n            // When the first directive is created:\\n            // - save the index,\\n            // - set the number of directives to 1\\n            previousOrParentTNode.flags =\\n                index << 15 /* DirectiveStartingIndexShift */ | flags & 4096 /* isComponent */ | 1;\\n        }\\n        else {\\n            // Only need to bump the size when subsequent directives are created\\n            ngDevMode && assertNotEqual(flags & 4095 /* DirectiveCountMask */, 4095 /* DirectiveCountMask */, 'Reached the max number of directives');\\n            previousOrParentTNode.flags++;\\n        }\\n        tView.data.push(directiveDef);\\n        tView.blueprint.push(null);\\n        if (directiveDef.hostBindings)\\n            queueHostBindingForCheck(index, directiveDef);\\n    }\\n    else {\\n        var diPublic = directiveDef.diPublic;\\n        if (diPublic)\\n            diPublic(directiveDef);\\n    }\\n    if (directiveDef.attributes != null && previousOrParentTNode.type == 3 /* Element */) {\\n        setUpAttributes(native, directiveDef.attributes);\\n    }\\n    return directive;\\n}\\n/**\\n * Sets initial input properties on directive instances from attribute data\\n *\\n * @param directiveIndex Index of the directive in directives array\\n * @param instance Instance of the directive on which to set the initial inputs\\n * @param inputs The list of inputs from the directive def\\n * @param tNode The static data for this node\\n */\\nfunction setInputsFromAttrs(directiveIndex, instance, inputs, tNode) {\\n    var initialInputData = tNode.initialInputs;\\n    if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\\n        initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\\n    }\\n    var initialInputs = initialInputData[directiveIndex];\\n    if (initialInputs) {\\n        for (var i = 0; i < initialInputs.length; i += 2) {\\n            instance[initialInputs[i]] = initialInputs[i + 1];\\n        }\\n    }\\n}\\n/**\\n * Generates initialInputData for a node and stores it in the template's static storage\\n * so subsequent template invocations don't have to recalculate it.\\n *\\n * initialInputData is an array containing values that need to be set as input properties\\n * for directives on this node, but only once on creation. We need this array to support\\n * the case where you set an @Input property of a directive using attribute-like syntax.\\n * e.g. if you have a `name` @Input, you can set it once like this:\\n *\\n * <my-component name=\\\"Bess\\\"></my-component>\\n *\\n * @param directiveIndex Index to store the initial input data\\n * @param inputs The list of inputs from the directive def\\n * @param tNode The static data on this node\\n */\\nfunction generateInitialInputs(directiveIndex, inputs, tNode) {\\n    var initialInputData = tNode.initialInputs || (tNode.initialInputs = []);\\n    initialInputData[directiveIndex] = null;\\n    var attrs = tNode.attrs;\\n    var i = 0;\\n    while (i < attrs.length) {\\n        var attrName = attrs[i];\\n        if (attrName === 1 /* SelectOnly */)\\n            break;\\n        if (attrName === 0 /* NamespaceURI */) {\\n            // We do not allow inputs on namespaced attributes.\\n            i += 4;\\n            continue;\\n        }\\n        var minifiedInputName = inputs[attrName];\\n        var attrValue = attrs[i + 1];\\n        if (minifiedInputName !== undefined) {\\n            var inputsToStore = initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\\n            inputsToStore.push(minifiedInputName, attrValue);\\n        }\\n        i += 2;\\n    }\\n    return initialInputData;\\n}\\n//////////////////////////\\n//// ViewContainer & View\\n//////////////////////////\\n/**\\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\\n *\\n * @param hostNative The host element for the LContainer\\n * @param hostTNode The host TNode for the LContainer\\n * @param currentView The parent view of the LContainer\\n * @param native The native comment element\\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\\n * @returns LContainer\\n */\\nfunction createLContainer(hostNative, hostTNode, currentView, native, isForViewContainerRef) {\\n    return [\\n        isForViewContainerRef ? -1 : 0,\\n        [],\\n        currentView,\\n        null,\\n        null,\\n        hostNative,\\n        native,\\n        getRenderParent(hostTNode, currentView) // renderParent\\n    ];\\n}\\n/**\\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\\n *\\n * <ng-template #foo>\\n *    <div></div>\\n * </ng-template>\\n *\\n * @param index The index of the container in the data array\\n * @param templateFn Inline template\\n * @param consts The number of nodes, local refs, and pipes for this template\\n * @param vars The number of bindings for this template\\n * @param tagName The name of the container element, if applicable\\n * @param attrs The attrs attached to the container, if applicable\\n * @param localRefs A set of local reference bindings on the element.\\n * @param localRefExtractor A function which extracts local-refs values from the template.\\n *        Defaults to the current element associated with the local-ref.\\n */\\nfunction template(index, templateFn, consts, vars, tagName, attrs, localRefs, localRefExtractor) {\\n    // TODO: consider a separate node type for templates\\n    var tNode = containerInternal(index, tagName || null, attrs || null);\\n    if (firstTemplatePass) {\\n        tNode.tViews = createTView(-1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\\n    }\\n    createDirectivesAndLocals(localRefs, localRefExtractor);\\n    currentQueries &&\\n        (currentQueries = currentQueries.addNode(previousOrParentTNode));\\n    queueLifecycleHooks(tNode.flags, tView);\\n    isParent = false;\\n}\\n/**\\n * Creates an LContainer for inline views, e.g.\\n *\\n * % if (showing) {\\n *   <div></div>\\n * % }\\n *\\n * @param index The index of the container in the data array\\n */\\nfunction container(index) {\\n    var tNode = containerInternal(index, null, null);\\n    firstTemplatePass && (tNode.tViews = []);\\n    isParent = false;\\n}\\nfunction containerInternal(index, tagName, attrs) {\\n    ngDevMode && assertEqual(viewData[BINDING_INDEX], tView.bindingStartIndex, 'container nodes should be created before any bindings');\\n    var adjustedIndex = index + HEADER_OFFSET;\\n    var comment = renderer.createComment(ngDevMode ? 'container' : '');\\n    ngDevMode && ngDevMode.rendererCreateComment++;\\n    var tNode = createNodeAtIndex(index, 0 /* Container */, comment, tagName, attrs);\\n    var lContainer = viewData[adjustedIndex] =\\n        createLContainer(viewData[adjustedIndex], tNode, viewData, comment);\\n    appendChild(comment, tNode, viewData);\\n    // Containers are added to the current view tree instead of their embedded views\\n    // because views can be removed and re-inserted.\\n    addToViewTree(viewData, index + HEADER_OFFSET, lContainer);\\n    if (currentQueries) {\\n        // prepare place for matching nodes from views inserted into a given container\\n        lContainer[QUERIES] = currentQueries.container();\\n    }\\n    ngDevMode && assertNodeType(previousOrParentTNode, 0 /* Container */);\\n    return tNode;\\n}\\n/**\\n * Sets a container up to receive views.\\n *\\n * @param index The index of the container in the data array\\n */\\nfunction containerRefreshStart(index) {\\n    previousOrParentTNode = loadInternal(index, tView.data);\\n    ngDevMode && assertNodeType(previousOrParentTNode, 0 /* Container */);\\n    isParent = true;\\n    viewData[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\\n    if (!checkNoChangesMode) {\\n        // We need to execute init hooks here so ngOnInit hooks are called in top level views\\n        // before they are called in embedded views (for backwards compatibility).\\n        executeInitHooks(viewData, tView, creationMode);\\n    }\\n}\\n/**\\n * Marks the end of the LContainer.\\n *\\n * Marking the end of LContainer is the time when to child views get inserted or removed.\\n */\\nfunction containerRefreshEnd() {\\n    if (isParent) {\\n        isParent = false;\\n    }\\n    else {\\n        ngDevMode && assertNodeType(previousOrParentTNode, 2 /* View */);\\n        ngDevMode && assertHasParent();\\n        previousOrParentTNode = previousOrParentTNode.parent;\\n    }\\n    ngDevMode && assertNodeType(previousOrParentTNode, 0 /* Container */);\\n    var lContainer = viewData[previousOrParentTNode.index];\\n    var nextIndex = lContainer[ACTIVE_INDEX];\\n    // remove extra views at the end of the container\\n    while (nextIndex < lContainer[VIEWS].length) {\\n        removeView(lContainer, previousOrParentTNode, nextIndex);\\n    }\\n}\\n/**\\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\\n * by executing an associated template function.\\n */\\nfunction refreshDynamicEmbeddedViews(lViewData) {\\n    for (var current = getLViewChild(lViewData); current !== null; current = current[NEXT]) {\\n        // Note: current can be an LViewData or an LContainer instance, but here we are only interested\\n        // in LContainer. We can tell it's an LContainer because its length is less than the LViewData\\n        // header.\\n        if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\\n            var container_1 = current;\\n            for (var i = 0; i < container_1[VIEWS].length; i++) {\\n                var dynamicViewData = container_1[VIEWS][i];\\n                // The directives and pipes are not needed here as an existing view is only being refreshed.\\n                ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\\n                renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT], 2 /* Update */);\\n            }\\n        }\\n    }\\n}\\n/**\\n * Looks for a view with a given view block id inside a provided LContainer.\\n * Removes views that need to be deleted in the process.\\n *\\n * @param lContainer to search for views\\n * @param tContainerNode to search for views\\n * @param startIdx starting index in the views array to search from\\n * @param viewBlockId exact view block id to look for\\n * @returns index of a found view or -1 if not found\\n */\\nfunction scanForView(lContainer, tContainerNode, startIdx, viewBlockId) {\\n    var views = lContainer[VIEWS];\\n    for (var i = startIdx; i < views.length; i++) {\\n        var viewAtPositionId = views[i][TVIEW].id;\\n        if (viewAtPositionId === viewBlockId) {\\n            return views[i];\\n        }\\n        else if (viewAtPositionId < viewBlockId) {\\n            // found a view that should not be at this position - remove\\n            removeView(lContainer, tContainerNode, i);\\n        }\\n        else {\\n            // found a view with id greater than the one we are searching for\\n            // which means that required view doesn't exist and can't be found at\\n            // later positions in the views array - stop the search here\\n            break;\\n        }\\n    }\\n    return null;\\n}\\n/**\\n * Marks the start of an embedded view.\\n *\\n * @param viewBlockId The ID of this view\\n * @return boolean Whether or not this view is in creation mode\\n */\\nfunction embeddedViewStart(viewBlockId, consts, vars) {\\n    // The previous node can be a view node if we are processing an inline for loop\\n    var containerTNode = previousOrParentTNode.type === 2 /* View */ ?\\n        previousOrParentTNode.parent :\\n        previousOrParentTNode;\\n    var lContainer = viewData[containerTNode.index];\\n    var currentView = viewData;\\n    ngDevMode && assertNodeType(containerTNode, 0 /* Container */);\\n    var viewToRender = scanForView(lContainer, containerTNode, lContainer[ACTIVE_INDEX], viewBlockId);\\n    if (viewToRender) {\\n        isParent = true;\\n        enterView(viewToRender, viewToRender[TVIEW].node);\\n    }\\n    else {\\n        // When we create a new LView, we always reset the state of the instructions.\\n        viewToRender = createLViewData(renderer, getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode), null, 2 /* CheckAlways */, getCurrentSanitizer());\\n        if (lContainer[QUERIES]) {\\n            viewToRender[QUERIES] = lContainer[QUERIES].createView();\\n        }\\n        createViewNode(viewBlockId, viewToRender);\\n        enterView(viewToRender, viewToRender[TVIEW].node);\\n    }\\n    if (lContainer) {\\n        if (creationMode) {\\n            // it is a new view, insert it into collection of views for a given container\\n            insertView(viewToRender, lContainer, currentView, lContainer[ACTIVE_INDEX], -1);\\n        }\\n        lContainer[ACTIVE_INDEX]++;\\n    }\\n    return getRenderFlags(viewToRender);\\n}\\n/**\\n * Initialize the TView (e.g. static data) for the active embedded view.\\n *\\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\\n * static data for a particular node would overwrite the static data for a node in the view above\\n * it with the same index (since it's in the same template).\\n *\\n * @param viewIndex The index of the TView in TNode.tViews\\n * @param consts The number of nodes, local refs, and pipes in this template\\n * @param vars The number of bindings and pure function bindings in this template\\n * @param container The parent container in which to look for the view's static data\\n * @returns TView\\n */\\nfunction getOrCreateEmbeddedTView(viewIndex, consts, vars, parent) {\\n    ngDevMode && assertNodeType(parent, 0 /* Container */);\\n    var containerTViews = parent.tViews;\\n    ngDevMode && assertDefined(containerTViews, 'TView expected');\\n    ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\\n    if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\\n        containerTViews[viewIndex] = createTView(viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\\n    }\\n    return containerTViews[viewIndex];\\n}\\n/** Marks the end of an embedded view. */\\nfunction embeddedViewEnd() {\\n    var viewHost = viewData[HOST_NODE];\\n    refreshDescendantViews();\\n    leaveView(viewData[PARENT]);\\n    previousOrParentTNode = viewHost;\\n    isParent = false;\\n}\\n/////////////\\n/**\\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\\n *\\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\\n */\\nfunction componentRefresh(adjustedElementIndex, parentFirstTemplatePass) {\\n    ngDevMode && assertDataInRange(adjustedElementIndex);\\n    var hostView = getComponentViewByIndex(adjustedElementIndex, viewData);\\n    ngDevMode && assertNodeType(tView.data[adjustedElementIndex], 3 /* Element */);\\n    // Only attached CheckAlways components or attached, dirty OnPush components should be checked\\n    if (viewAttached(hostView) && hostView[FLAGS] & (2 /* CheckAlways */ | 4 /* Dirty */)) {\\n        parentFirstTemplatePass && syncViewWithBlueprint(hostView);\\n        detectChangesInternal(hostView, hostView[CONTEXT]);\\n    }\\n}\\n/**\\n * Syncs an LViewData instance with its blueprint if they have gotten out of sync.\\n *\\n * Typically, blueprints and their view instances should always be in sync, so the loop here\\n * will be skipped. However, consider this case of two components side-by-side:\\n *\\n * App template:\\n * ```\\n * <comp></comp>\\n * <comp></comp>\\n * ```\\n *\\n * The following will happen:\\n * 1. App template begins processing.\\n * 2. First <comp> is matched as a component and its LViewData is created.\\n * 3. Second <comp> is matched as a component and its LViewData is created.\\n * 4. App template completes processing, so it's time to check child templates.\\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\\n * <comp> template, but its LViewData was created before this update, so it is out of sync.\\n *\\n * Note that embedded views inside ngFor loops will never be out of sync because these views\\n * are processed as soon as they are created.\\n *\\n * @param componentView The view to sync\\n */\\nfunction syncViewWithBlueprint(componentView) {\\n    var componentTView = componentView[TVIEW];\\n    for (var i = componentView.length; i < componentTView.blueprint.length; i++) {\\n        componentView[i] = componentTView.blueprint[i];\\n    }\\n}\\n/** Returns a boolean for whether the view is attached */\\nfunction viewAttached(view) {\\n    return (view[FLAGS] & 8 /* Attached */) === 8 /* Attached */;\\n}\\n/**\\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\\n * It takes all the selectors from the entire component's template and decides where\\n * each projected node belongs (it re-distributes nodes among \\\"buckets\\\" where each \\\"bucket\\\" is\\n * backed by a selector).\\n *\\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\\n * un-parsed form.\\n *\\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\\n *\\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\\n * drawbacks:\\n * - having only a textual form would require runtime parsing of CSS selectors;\\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\\n * template author).\\n *\\n * @param selectors A collection of parsed CSS selectors\\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\\n */\\nfunction projectionDef(selectors, textSelectors) {\\n    var componentNode = findComponentView(viewData)[HOST_NODE];\\n    if (!componentNode.projection) {\\n        var noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\\n        var pData = componentNode.projection =\\n            new Array(noOfNodeBuckets).fill(null);\\n        var tails = pData.slice();\\n        var componentChild = componentNode.child;\\n        while (componentChild !== null) {\\n            var bucketIndex = selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors) : 0;\\n            var nextNode = componentChild.next;\\n            if (tails[bucketIndex]) {\\n                tails[bucketIndex].next = componentChild;\\n            }\\n            else {\\n                pData[bucketIndex] = componentChild;\\n                componentChild.next = null;\\n            }\\n            tails[bucketIndex] = componentChild;\\n            componentChild = nextNode;\\n        }\\n    }\\n}\\n/**\\n * Stack used to keep track of projection nodes in projection() instruction.\\n *\\n * This is deliberately created outside of projection() to avoid allocating\\n * a new array each time the function is called. Instead the array will be\\n * re-used by each invocation. This works because the function is not reentrant.\\n */\\nvar projectionNodeStack$1 = [];\\n/**\\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\\n * to the projectionDef instruction.\\n *\\n * @param nodeIndex\\n * @param selectorIndex:\\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\\n *        - 1 based index of the selector from the {@link projectionDef}\\n */\\nfunction projection(nodeIndex, selectorIndex, attrs) {\\n    if (selectorIndex === void 0) { selectorIndex = 0; }\\n    var tProjectionNode = createNodeAtIndex(nodeIndex, 1 /* Projection */, null, null, attrs || null);\\n    // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\\n    if (tProjectionNode.projection === null)\\n        tProjectionNode.projection = selectorIndex;\\n    // `<ng-content>` has no content\\n    isParent = false;\\n    // re-distribution of projectable nodes is stored on a component's view level\\n    var componentView = findComponentView(viewData);\\n    var componentNode = componentView[HOST_NODE];\\n    var nodeToProject = componentNode.projection[selectorIndex];\\n    var projectedView = componentView[PARENT];\\n    var projectionNodeIndex = -1;\\n    while (nodeToProject) {\\n        if (nodeToProject.type === 1 /* Projection */) {\\n            // This node is re-projected, so we must go up the tree to get its projected nodes.\\n            var currentComponentView = findComponentView(projectedView);\\n            var currentComponentHost = currentComponentView[HOST_NODE];\\n            var firstProjectedNode = currentComponentHost.projection[nodeToProject.projection];\\n            if (firstProjectedNode) {\\n                projectionNodeStack$1[++projectionNodeIndex] = nodeToProject;\\n                projectionNodeStack$1[++projectionNodeIndex] = projectedView;\\n                nodeToProject = firstProjectedNode;\\n                projectedView = currentComponentView[PARENT];\\n                continue;\\n            }\\n        }\\n        else {\\n            // This flag must be set now or we won't know that this node is projected\\n            // if the nodes are inserted into a container later.\\n            nodeToProject.flags |= 8192 /* isProjected */;\\n            appendProjectedNode(nodeToProject, tProjectionNode, viewData, projectedView);\\n        }\\n        // If we are finished with a list of re-projected nodes, we need to get\\n        // back to the root projection node that was re-projected.\\n        if (nodeToProject.next === null && projectedView !== componentView[PARENT]) {\\n            projectedView = projectionNodeStack$1[projectionNodeIndex--];\\n            nodeToProject = projectionNodeStack$1[projectionNodeIndex--];\\n        }\\n        nodeToProject = nodeToProject.next;\\n    }\\n}\\n/**\\n * Adds LViewData or LContainer to the end of the current view tree.\\n *\\n * This structure will be used to traverse through nested views to remove listeners\\n * and call onDestroy callbacks.\\n *\\n * @param currentView The view where LViewData or LContainer should be added\\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\\n * @param state The LViewData or LContainer to add to the view tree\\n * @returns The state passed in\\n */\\nfunction addToViewTree(currentView, adjustedHostIndex, state) {\\n    if (currentView[TAIL]) {\\n        currentView[TAIL][NEXT] = state;\\n    }\\n    else if (firstTemplatePass) {\\n        tView.childIndex = adjustedHostIndex;\\n    }\\n    currentView[TAIL] = state;\\n    return state;\\n}\\n///////////////////////////////\\n//// Change detection\\n///////////////////////////////\\n/** If node is an OnPush component, marks its LViewData dirty. */\\nfunction markDirtyIfOnPush(viewIndex) {\\n    var view = getComponentViewByIndex(viewIndex, viewData);\\n    if (!(view[FLAGS] & 2 /* CheckAlways */)) {\\n        view[FLAGS] |= 4 /* Dirty */;\\n    }\\n}\\n/** Wraps an event listener with preventDefault behavior. */\\nfunction wrapListenerWithPreventDefault(listenerFn) {\\n    return function wrapListenerIn_preventDefault(e) {\\n        if (listenerFn(e) === false) {\\n            e.preventDefault();\\n            // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\\n            e.returnValue = false;\\n        }\\n    };\\n}\\n/** Marks current view and all ancestors dirty */\\nfunction markViewDirty(view) {\\n    var currentView = view;\\n    while (currentView && !(currentView[FLAGS] & 64 /* IsRoot */)) {\\n        currentView[FLAGS] |= 4 /* Dirty */;\\n        currentView = currentView[PARENT];\\n    }\\n    currentView[FLAGS] |= 4 /* Dirty */;\\n    ngDevMode && assertDefined(currentView[CONTEXT], 'rootContext should be defined');\\n    var rootContext = currentView[CONTEXT];\\n    scheduleTick(rootContext, 1 /* DetectChanges */);\\n}\\n/**\\n * Used to schedule change detection on the whole application.\\n *\\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\\n * It is usually called indirectly by calling `markDirty` when the view needs to be\\n * re-rendered.\\n *\\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\\n * `scheduleTick` requests. The scheduling function can be overridden in\\n * `renderComponent`'s `scheduler` option.\\n */\\nfunction scheduleTick(rootContext, flags) {\\n    var nothingScheduled = rootContext.flags === 0 /* Empty */;\\n    rootContext.flags |= flags;\\n    if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\\n        var res_1;\\n        rootContext.clean = new Promise(function (r) { return res_1 = r; });\\n        rootContext.scheduler(function () {\\n            if (rootContext.flags & 1 /* DetectChanges */) {\\n                rootContext.flags &= ~1 /* DetectChanges */;\\n                tickRootContext(rootContext);\\n            }\\n            if (rootContext.flags & 2 /* FlushPlayers */) {\\n                rootContext.flags &= ~2 /* FlushPlayers */;\\n                var playerHandler = rootContext.playerHandler;\\n                if (playerHandler) {\\n                    playerHandler.flushPlayers();\\n                }\\n            }\\n            rootContext.clean = _CLEAN_PROMISE;\\n            res_1(null);\\n        });\\n    }\\n}\\nfunction tickRootContext(rootContext) {\\n    for (var i = 0; i < rootContext.components.length; i++) {\\n        var rootComponent = rootContext.components[i];\\n        renderComponentOrTemplate(readPatchedLViewData(rootComponent), rootComponent);\\n    }\\n}\\n/**\\n * Synchronously perform change detection on a component (and possibly its sub-components).\\n *\\n * This function triggers change detection in a synchronous way on a component. There should\\n * be very little reason to call this function directly since a preferred way to do change\\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\\n * at some future point in time. This is because a single user action often results in many\\n * components being invalidated and calling change detection on each component synchronously\\n * would be inefficient. It is better to wait until all components are marked as dirty and\\n * then perform single change detection across all of the components\\n *\\n * @param component The component which the change detection should be performed on.\\n */\\nfunction detectChanges(component) {\\n    detectChangesInternal(getComponentViewByInstance(component), component);\\n}\\n/**\\n * Synchronously perform change detection on a root view and its components.\\n *\\n * @param lViewData The view which the change detection should be performed on.\\n */\\nfunction detectChangesInRootView(lViewData) {\\n    tickRootContext(lViewData[CONTEXT]);\\n}\\n/**\\n * Checks the change detector and its children, and throws if any changes are detected.\\n *\\n * This is used in development mode to verify that running change detection doesn't\\n * introduce other changes.\\n */\\nfunction checkNoChanges(component) {\\n    checkNoChangesMode = true;\\n    try {\\n        detectChanges(component);\\n    }\\n    finally {\\n        checkNoChangesMode = false;\\n    }\\n}\\n/**\\n * Checks the change detector on a root view and its components, and throws if any changes are\\n * detected.\\n *\\n * This is used in development mode to verify that running change detection doesn't\\n * introduce other changes.\\n *\\n * @param lViewData The view which the change detection should be checked on.\\n */\\nfunction checkNoChangesInRootView(lViewData) {\\n    checkNoChangesMode = true;\\n    try {\\n        detectChangesInRootView(lViewData);\\n    }\\n    finally {\\n        checkNoChangesMode = false;\\n    }\\n}\\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\\nfunction detectChangesInternal(hostView, component) {\\n    var hostTView = hostView[TVIEW];\\n    var oldView = enterView(hostView, hostView[HOST_NODE]);\\n    var templateFn = hostTView.template;\\n    var viewQuery = hostTView.viewQuery;\\n    try {\\n        namespaceHTML();\\n        createViewQuery(viewQuery, hostView[FLAGS], component);\\n        templateFn(getRenderFlags(hostView), component);\\n        refreshDescendantViews();\\n        updateViewQuery(viewQuery, component);\\n    }\\n    finally {\\n        leaveView(oldView);\\n    }\\n}\\nfunction createViewQuery(viewQuery, flags, component) {\\n    if (viewQuery && (flags & 1 /* CreationMode */)) {\\n        viewQuery(1 /* Create */, component);\\n    }\\n}\\nfunction updateViewQuery(viewQuery, component) {\\n    if (viewQuery) {\\n        viewQuery(2 /* Update */, component);\\n    }\\n}\\n/**\\n * Mark the component as dirty (needing change detection).\\n *\\n * Marking a component dirty will schedule a change detection on this\\n * component at some point in the future. Marking an already dirty\\n * component as dirty is a noop. Only one outstanding change detection\\n * can be scheduled per component tree. (Two components bootstrapped with\\n * separate `renderComponent` will have separate schedulers)\\n *\\n * When the root component is bootstrapped with `renderComponent`, a scheduler\\n * can be provided.\\n *\\n * @param component Component to mark as dirty.\\n */\\nfunction markDirty(component) {\\n    ngDevMode && assertDefined(component, 'component');\\n    markViewDirty(getComponentViewByInstance(component));\\n}\\n/** A special value which designates that a value has not changed. */\\nvar NO_CHANGE = {};\\n/**\\n * Creates a single value binding.\\n *\\n * @param value Value to diff\\n */\\nfunction bind(value) {\\n    return bindingUpdated(viewData[BINDING_INDEX]++, value) ? value : NO_CHANGE;\\n}\\n/**\\n * Create interpolation bindings with a variable number of expressions.\\n *\\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\\n * Those are faster because there is no need to create an array of expressions and iterate over it.\\n *\\n * `values`:\\n * - has static text at even indexes,\\n * - has evaluated expressions at odd indexes.\\n *\\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction interpolationV(values) {\\n    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\\n    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\\n    var different = false;\\n    for (var i = 1; i < values.length; i += 2) {\\n        // Check if bindings (odd indexes) have changed\\n        bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\\n    }\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    // Build the updated content\\n    var content = values[0];\\n    for (var i = 1; i < values.length; i += 2) {\\n        content += stringify$1(values[i]) + values[i + 1];\\n    }\\n    return content;\\n}\\n/**\\n * Creates an interpolation binding with 1 expression.\\n *\\n * @param prefix static value used for concatenation only.\\n * @param v0 value checked for change.\\n * @param suffix static value used for concatenation only.\\n */\\nfunction interpolation1(prefix, v0, suffix) {\\n    var different = bindingUpdated(viewData[BINDING_INDEX]++, v0);\\n    return different ? prefix + stringify$1(v0) + suffix : NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 2 expressions. */\\nfunction interpolation2(prefix, v0, i0, v1, suffix) {\\n    var different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\\n    viewData[BINDING_INDEX] += 2;\\n    return different ? prefix + stringify$1(v0) + i0 + stringify$1(v1) + suffix : NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 3 expressions. */\\nfunction interpolation3(prefix, v0, i0, v1, i1, v2, suffix) {\\n    var different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\\n    viewData[BINDING_INDEX] += 3;\\n    return different ? prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + suffix :\\n        NO_CHANGE;\\n}\\n/** Create an interpolation binding with 4 expressions. */\\nfunction interpolation4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    viewData[BINDING_INDEX] += 4;\\n    return different ?\\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) +\\n            suffix :\\n        NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 5 expressions. */\\nfunction interpolation5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\\n    viewData[BINDING_INDEX] += 5;\\n    return different ?\\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) + i3 +\\n            stringify$1(v4) + suffix :\\n        NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 6 expressions. */\\nfunction interpolation6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\\n    viewData[BINDING_INDEX] += 6;\\n    return different ?\\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) + i3 +\\n            stringify$1(v4) + i4 + stringify$1(v5) + suffix :\\n        NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 7 expressions. */\\nfunction interpolation7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\\n    viewData[BINDING_INDEX] += 7;\\n    return different ?\\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) + i3 +\\n            stringify$1(v4) + i4 + stringify$1(v5) + i5 + stringify$1(v6) + suffix :\\n        NO_CHANGE;\\n}\\n/** Creates an interpolation binding with 8 expressions. */\\nfunction interpolation8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\\n    viewData[BINDING_INDEX] += 8;\\n    return different ?\\n        prefix + stringify$1(v0) + i0 + stringify$1(v1) + i1 + stringify$1(v2) + i2 + stringify$1(v3) + i3 +\\n            stringify$1(v4) + i4 + stringify$1(v5) + i5 + stringify$1(v6) + i6 + stringify$1(v7) + suffix :\\n        NO_CHANGE;\\n}\\n/** Store a value in the `data` at a given `index`. */\\nfunction store(index, value) {\\n    // We don't store any static data for local variables, so the first time\\n    // we see the template, we should store as null to avoid a sparse array\\n    var adjustedIndex = index + HEADER_OFFSET;\\n    if (adjustedIndex >= tView.data.length) {\\n        tView.data[adjustedIndex] = null;\\n    }\\n    viewData[adjustedIndex] = value;\\n}\\n/**\\n * Retrieves a local reference from the current contextViewData.\\n *\\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\\n *\\n * @param index The index of the local ref in contextViewData.\\n */\\nfunction reference(index) {\\n    return loadInternal(index, contextViewData);\\n}\\nfunction walkUpViews(nestingLevel, currentView) {\\n    while (nestingLevel > 0) {\\n        ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\\n        currentView = currentView[DECLARATION_VIEW];\\n        nestingLevel--;\\n    }\\n    return currentView;\\n}\\nfunction loadQueryList(queryListIdx) {\\n    ngDevMode && assertDefined(viewData[CONTENT_QUERIES], 'Content QueryList array should be defined if reading a query.');\\n    ngDevMode && assertDataInRange(queryListIdx, viewData[CONTENT_QUERIES]);\\n    return viewData[CONTENT_QUERIES][queryListIdx];\\n}\\n/** Retrieves a value from current `viewData`. */\\nfunction load(index) {\\n    return loadInternal(index, viewData);\\n}\\n/** Gets the current binding value. */\\nfunction getBinding(bindingIndex) {\\n    ngDevMode && assertDataInRange(viewData[bindingIndex]);\\n    ngDevMode &&\\n        assertNotEqual(viewData[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\\n    return viewData[bindingIndex];\\n}\\n/** Updates binding if changed, then returns whether it was updated. */\\nfunction bindingUpdated(bindingIndex, value) {\\n    ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\\n    ngDevMode && assertLessThan(bindingIndex, viewData.length, \\\"Slot should have been initialized to NO_CHANGE\\\");\\n    if (viewData[bindingIndex] === NO_CHANGE) {\\n        viewData[bindingIndex] = value;\\n    }\\n    else if (isDifferent(viewData[bindingIndex], value, checkNoChangesMode)) {\\n        throwErrorIfNoChangesMode(creationMode, checkNoChangesMode, viewData[bindingIndex], value);\\n        viewData[bindingIndex] = value;\\n    }\\n    else {\\n        return false;\\n    }\\n    return true;\\n}\\n/** Updates binding and returns the value. */\\nfunction updateBinding(bindingIndex, value) {\\n    return viewData[bindingIndex] = value;\\n}\\n/** Updates 2 bindings if changed, then returns whether either was updated. */\\nfunction bindingUpdated2(bindingIndex, exp1, exp2) {\\n    var different = bindingUpdated(bindingIndex, exp1);\\n    return bindingUpdated(bindingIndex + 1, exp2) || different;\\n}\\n/** Updates 3 bindings if changed, then returns whether any was updated. */\\nfunction bindingUpdated3(bindingIndex, exp1, exp2, exp3) {\\n    var different = bindingUpdated2(bindingIndex, exp1, exp2);\\n    return bindingUpdated(bindingIndex + 2, exp3) || different;\\n}\\n/** Updates 4 bindings if changed, then returns whether any was updated. */\\nfunction bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4) {\\n    var different = bindingUpdated2(bindingIndex, exp1, exp2);\\n    return bindingUpdated2(bindingIndex + 2, exp3, exp4) || different;\\n}\\nfunction getTView() {\\n    return tView;\\n}\\n/**\\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\\n * refresh).\\n */\\nfunction registerContentQuery(queryList) {\\n    var savedContentQueriesLength = (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\\n    if (firstTemplatePass) {\\n        var currentDirectiveIndex = viewData.length - 1;\\n        var tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\\n        var lastSavedDirectiveIndex = tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\\n        if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\\n            tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\\n        }\\n    }\\n}\\nfunction assertPreviousIsParent() {\\n    assertEqual(isParent, true, 'previousOrParentTNode should be a parent');\\n}\\nfunction assertHasParent() {\\n    assertDefined(previousOrParentTNode.parent, 'previousOrParentTNode should have a parent');\\n}\\nfunction assertDataInRange(index, arr) {\\n    if (arr == null)\\n        arr = viewData;\\n    assertDataInRangeInternal(index, arr || viewData);\\n}\\nvar CLEAN_PROMISE = _CLEAN_PROMISE;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// Root component will always have an element index of 0 and an injector size of 1\\nvar ROOT_EXPANDO_INSTRUCTIONS = [0, 1];\\n/**\\n * Bootstraps a Component into an existing host element and returns an instance\\n * of the component.\\n *\\n * Use this function to bootstrap a component into the DOM tree. Each invocation\\n * of this function will create a separate tree of components, injectors and\\n * change detection cycles and lifetimes. To dynamically insert a new component\\n * into an existing tree such that it shares the same injection, change detection\\n * and object lifetime, use {@link ViewContainer#createComponent}.\\n *\\n * @param componentType Component to bootstrap\\n * @param options Optional parameters which control bootstrapping\\n */\\nfunction renderComponent(componentType /* Type as workaround for: Microsoft/TypeScript/issues/4881 */, opts) {\\n    if (opts === void 0) { opts = {}; }\\n    ngDevMode && assertComponentType(componentType);\\n    var rendererFactory = opts.rendererFactory || domRendererFactory3;\\n    var sanitizer = opts.sanitizer || null;\\n    var componentDef = getComponentDef(componentType);\\n    if (componentDef.type != componentType)\\n        componentDef.type = componentType;\\n    // The first index of the first selector is the tag name.\\n    var componentTag = componentDef.selectors[0][0];\\n    var hostRNode = locateHostElement(rendererFactory, opts.host || componentTag);\\n    var rootFlags = componentDef.onPush ? 4 /* Dirty */ | 64 /* IsRoot */ :\\n        2 /* CheckAlways */ | 64 /* IsRoot */;\\n    var rootContext = createRootContext(opts.scheduler || requestAnimationFrame.bind(window), opts.playerHandler || null);\\n    var renderer = rendererFactory.createRenderer(hostRNode, componentDef);\\n    var rootView = createLViewData(renderer, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags);\\n    rootView[INJECTOR$1] = opts.injector || null;\\n    var oldView = enterView(rootView, null);\\n    var component;\\n    try {\\n        if (rendererFactory.begin)\\n            rendererFactory.begin();\\n        var componentView = createRootComponentView(hostRNode, componentDef, rootView, renderer, sanitizer);\\n        component = createRootComponent(hostRNode, componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\\n        executeInitAndContentHooks();\\n        detectChangesInternal(componentView, component);\\n    }\\n    finally {\\n        leaveView(oldView);\\n        if (rendererFactory.end)\\n            rendererFactory.end();\\n    }\\n    return component;\\n}\\n/**\\n * Creates the root component view and the root component node.\\n *\\n * @param rNode Render host element.\\n * @param def ComponentDef\\n * @param rootView The parent view where the host node is stored\\n * @param renderer The current renderer\\n * @param sanitizer The sanitizer, if provided\\n *\\n * @returns Component view created\\n */\\nfunction createRootComponentView(rNode, def, rootView, renderer, sanitizer) {\\n    resetComponentState();\\n    var tView = rootView[TVIEW];\\n    var componentView = createLViewData(renderer, getOrCreateTView(def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery), null, def.onPush ? 4 /* Dirty */ : 2 /* CheckAlways */, sanitizer);\\n    var tNode = createNodeAtIndex(0, 3 /* Element */, rNode, null, null);\\n    if (tView.firstTemplatePass) {\\n        tView.expandoInstructions = ROOT_EXPANDO_INSTRUCTIONS.slice();\\n        if (def.diPublic)\\n            def.diPublic(def);\\n        tNode.flags =\\n            rootView.length << 15 /* DirectiveStartingIndexShift */ | 4096 /* isComponent */;\\n    }\\n    // Store component view at node index, with node as the HOST\\n    componentView[HOST] = rootView[HEADER_OFFSET];\\n    componentView[HOST_NODE] = tNode;\\n    return rootView[HEADER_OFFSET] = componentView;\\n}\\n/**\\n * Creates a root component and sets it up with features and host bindings. Shared by\\n * renderComponent() and ViewContainerRef.createComponent().\\n */\\nfunction createRootComponent(hostRNode, componentView, componentDef, rootView, rootContext, hostFeatures) {\\n    // Create directive instance with factory() and store at next index in viewData\\n    var component = baseDirectiveCreate(rootView.length, componentDef.factory(), componentDef, hostRNode);\\n    rootContext.components.push(component);\\n    componentView[CONTEXT] = component;\\n    hostFeatures && hostFeatures.forEach(function (feature) { return feature(component, componentDef); });\\n    if (rootView[TVIEW].firstTemplatePass)\\n        prefillHostVars(componentDef.hostVars);\\n    setHostBindings();\\n    return component;\\n}\\nfunction createRootContext(scheduler, playerHandler) {\\n    return {\\n        components: [],\\n        scheduler: scheduler,\\n        clean: CLEAN_PROMISE,\\n        playerHandler: playerHandler || null,\\n        flags: 0 /* Empty */\\n    };\\n}\\n/**\\n * Used to enable lifecycle hooks on the root component.\\n *\\n * Include this feature when calling `renderComponent` if the root component\\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\\n * be called properly.\\n *\\n * Example:\\n *\\n * ```\\n * renderComponent(AppComponent, {features: [RootLifecycleHooks]});\\n * ```\\n */\\nfunction LifecycleHooksFeature(component, def) {\\n    var rootTView = readPatchedLViewData(component)[TVIEW];\\n    var dirIndex = rootTView.data.length - 1;\\n    queueInitHooks(dirIndex, def.onInit, def.doCheck, rootTView);\\n    queueLifecycleHooks(dirIndex << 15 /* DirectiveStartingIndexShift */ | 1, rootTView);\\n}\\n/**\\n * Retrieve the root context for any component by walking the parent `LView` until\\n * reaching the root `LView`.\\n *\\n * @param component any component\\n */\\nfunction getRootContext$1(component) {\\n    var rootContext = getRootView(component)[CONTEXT];\\n    ngDevMode && assertDefined(rootContext, 'rootContext');\\n    return rootContext;\\n}\\n/**\\n * Wait on component until it is rendered.\\n *\\n * This function returns a `Promise` which is resolved when the component's\\n * change detection is executed. This is determined by finding the scheduler\\n * associated with the `component`'s render tree and waiting until the scheduler\\n * flushes. If nothing is scheduled, the function returns a resolved promise.\\n *\\n * Example:\\n * ```\\n * await whenRendered(myComponent);\\n * ```\\n *\\n * @param component Component to wait upon\\n * @returns Promise which resolves when the component is rendered.\\n */\\nfunction whenRendered(component) {\\n    return getRootContext$1(component).clean;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Determines if a definition is a {@link ComponentDef} or a {@link DirectiveDef}\\n * @param definition The definition to examine\\n */\\nfunction isComponentDef(definition) {\\n    var def = definition;\\n    return typeof def.template === 'function';\\n}\\nfunction getSuperType(type) {\\n    return Object.getPrototypeOf(type.prototype).constructor;\\n}\\n/**\\n * Merges the definition from a super class to a sub class.\\n * @param definition The definition that is a SubClass of another directive of component\\n */\\nfunction InheritDefinitionFeature(definition) {\\n    var superType = getSuperType(definition.type);\\n    var _loop_1 = function () {\\n        var e_1, _a;\\n        var superDef = undefined;\\n        if (isComponentDef(definition)) {\\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\\n            superDef = superType.ngComponentDef || superType.ngDirectiveDef;\\n        }\\n        else {\\n            if (superType.ngComponentDef) {\\n                throw new Error('Directives cannot inherit Components');\\n            }\\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\\n            superDef = superType.ngDirectiveDef;\\n        }\\n        var baseDef = superType.ngBaseDef;\\n        // Some fields in the definition may be empty, if there were no values to put in them that\\n        // would've justified object creation. Unwrap them if necessary.\\n        if (baseDef || superDef) {\\n            var writeableDef = definition;\\n            writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\\n            writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\\n            writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\\n        }\\n        if (baseDef) {\\n            // Merge inputs and outputs\\n            fillProperties(definition.inputs, baseDef.inputs);\\n            fillProperties(definition.declaredInputs, baseDef.declaredInputs);\\n            fillProperties(definition.outputs, baseDef.outputs);\\n        }\\n        if (superDef) {\\n            // Merge hostBindings\\n            var prevHostBindings_1 = definition.hostBindings;\\n            var superHostBindings_1 = superDef.hostBindings;\\n            if (superHostBindings_1) {\\n                if (prevHostBindings_1) {\\n                    definition.hostBindings = function (directiveIndex, elementIndex) {\\n                        superHostBindings_1(directiveIndex, elementIndex);\\n                        prevHostBindings_1(directiveIndex, elementIndex);\\n                    };\\n                }\\n                else {\\n                    definition.hostBindings = superHostBindings_1;\\n                }\\n            }\\n            // Merge View Queries\\n            if (isComponentDef(definition) && isComponentDef(superDef)) {\\n                var prevViewQuery_1 = definition.viewQuery;\\n                var superViewQuery_1 = superDef.viewQuery;\\n                if (superViewQuery_1) {\\n                    if (prevViewQuery_1) {\\n                        definition.viewQuery = function (rf, ctx) {\\n                            superViewQuery_1(rf, ctx);\\n                            prevViewQuery_1(rf, ctx);\\n                        };\\n                    }\\n                    else {\\n                        definition.viewQuery = superViewQuery_1;\\n                    }\\n                }\\n            }\\n            // Merge Content Queries\\n            var prevContentQueries_1 = definition.contentQueries;\\n            var superContentQueries_1 = superDef.contentQueries;\\n            if (superContentQueries_1) {\\n                if (prevContentQueries_1) {\\n                    definition.contentQueries = function () {\\n                        superContentQueries_1();\\n                        prevContentQueries_1();\\n                    };\\n                }\\n                else {\\n                    definition.contentQueries = superContentQueries_1;\\n                }\\n            }\\n            // Merge Content Queries Refresh\\n            var prevContentQueriesRefresh_1 = definition.contentQueriesRefresh;\\n            var superContentQueriesRefresh_1 = superDef.contentQueriesRefresh;\\n            if (superContentQueriesRefresh_1) {\\n                if (prevContentQueriesRefresh_1) {\\n                    definition.contentQueriesRefresh = function (directiveIndex, queryIndex) {\\n                        superContentQueriesRefresh_1(directiveIndex, queryIndex);\\n                        prevContentQueriesRefresh_1(directiveIndex, queryIndex);\\n                    };\\n                }\\n                else {\\n                    definition.contentQueriesRefresh = superContentQueriesRefresh_1;\\n                }\\n            }\\n            // Merge inputs and outputs\\n            fillProperties(definition.inputs, superDef.inputs);\\n            fillProperties(definition.declaredInputs, superDef.declaredInputs);\\n            fillProperties(definition.outputs, superDef.outputs);\\n            // Inherit hooks\\n            // Assume super class inheritance feature has already run.\\n            definition.afterContentChecked =\\n                definition.afterContentChecked || superDef.afterContentChecked;\\n            definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;\\n            definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;\\n            definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;\\n            definition.doCheck = definition.doCheck || superDef.doCheck;\\n            definition.onDestroy = definition.onDestroy || superDef.onDestroy;\\n            definition.onInit = definition.onInit || superDef.onInit;\\n            // Run parent features\\n            var features = superDef.features;\\n            if (features) {\\n                try {\\n                    for (var features_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __values */ \\\"h\\\"])(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {\\n                        var feature = features_1_1.value;\\n                        if (feature && feature !== InheritDefinitionFeature) {\\n                            feature(definition);\\n                        }\\n                    }\\n                }\\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n                finally {\\n                    try {\\n                        if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);\\n                    }\\n                    finally { if (e_1) throw e_1.error; }\\n                }\\n            }\\n            return \\\"break\\\";\\n        }\\n        else {\\n            // Even if we don't have a definition, check the type for the hooks and use those if need be\\n            var superPrototype = superType.prototype;\\n            if (superPrototype) {\\n                definition.afterContentChecked =\\n                    definition.afterContentChecked || superPrototype.afterContentChecked;\\n                definition.afterContentInit =\\n                    definition.afterContentInit || superPrototype.afterContentInit;\\n                definition.afterViewChecked =\\n                    definition.afterViewChecked || superPrototype.afterViewChecked;\\n                definition.afterViewInit = definition.afterViewInit || superPrototype.afterViewInit;\\n                definition.doCheck = definition.doCheck || superPrototype.doCheck;\\n                definition.onDestroy = definition.onDestroy || superPrototype.onDestroy;\\n                definition.onInit = definition.onInit || superPrototype.onInit;\\n            }\\n        }\\n        superType = Object.getPrototypeOf(superType);\\n    };\\n    while (superType) {\\n        var state_1 = _loop_1();\\n        if (state_1 === \\\"break\\\")\\n            break;\\n    }\\n}\\nfunction maybeUnwrapEmpty(value) {\\n    if (value === EMPTY$1) {\\n        return {};\\n    }\\n    else if (value === EMPTY_ARRAY) {\\n        return [];\\n    }\\n    else {\\n        return value;\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar PRIVATE_PREFIX = '__ngOnChanges_';\\n/**\\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\\n * lifecycle hook, so it should be included in any component that implements\\n * that hook.\\n *\\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\\n * inherited properties will not be propagated to the ngOnChanges lifecycle\\n * hook.\\n *\\n * Example usage:\\n *\\n * ```\\n * static ngComponentDef = defineComponent({\\n *   ...\\n *   inputs: {name: 'publicName'},\\n *   features: [NgOnChangesFeature]\\n * });\\n * ```\\n */\\nfunction NgOnChangesFeature(definition) {\\n    var declaredToMinifiedInputs = definition.declaredInputs;\\n    var proto = definition.type.prototype;\\n    var _loop_1 = function (declaredName) {\\n        if (declaredToMinifiedInputs.hasOwnProperty(declaredName)) {\\n            var minifiedKey = declaredToMinifiedInputs[declaredName];\\n            var privateMinKey_1 = PRIVATE_PREFIX + minifiedKey;\\n            // Walk the prototype chain to see if we find a property descriptor\\n            // That way we can honor setters and getters that were inherited.\\n            var originalProperty = undefined;\\n            var checkProto = proto;\\n            while (!originalProperty && checkProto &&\\n                Object.getPrototypeOf(checkProto) !== Object.getPrototypeOf(Object.prototype)) {\\n                originalProperty = Object.getOwnPropertyDescriptor(checkProto, minifiedKey);\\n                checkProto = Object.getPrototypeOf(checkProto);\\n            }\\n            var getter = originalProperty && originalProperty.get;\\n            var setter_1 = originalProperty && originalProperty.set;\\n            // create a getter and setter for property\\n            Object.defineProperty(proto, minifiedKey, {\\n                get: getter ||\\n                    (setter_1 ? undefined : function () { return this[privateMinKey_1]; }),\\n                set: function (value) {\\n                    var simpleChanges = this[PRIVATE_PREFIX];\\n                    if (!simpleChanges) {\\n                        simpleChanges = {};\\n                        // Place where we will store SimpleChanges if there is a change\\n                        Object.defineProperty(this, PRIVATE_PREFIX, { value: simpleChanges, writable: true });\\n                    }\\n                    var isFirstChange = !this.hasOwnProperty(privateMinKey_1);\\n                    var currentChange = simpleChanges[declaredName];\\n                    if (currentChange) {\\n                        currentChange.currentValue = value;\\n                    }\\n                    else {\\n                        simpleChanges[declaredName] =\\n                            new SimpleChange(this[privateMinKey_1], value, isFirstChange);\\n                    }\\n                    if (isFirstChange) {\\n                        // Create a place where the actual value will be stored and make it non-enumerable\\n                        Object.defineProperty(this, privateMinKey_1, { value: value, writable: true });\\n                    }\\n                    else {\\n                        this[privateMinKey_1] = value;\\n                    }\\n                    if (setter_1)\\n                        setter_1.call(this, value);\\n                },\\n                // Make the property configurable in dev mode to allow overriding in tests\\n                configurable: !!ngDevMode\\n            });\\n        }\\n    };\\n    for (var declaredName in declaredToMinifiedInputs) {\\n        _loop_1(declaredName);\\n    }\\n    // If an onInit hook is defined, it will need to wrap the ngOnChanges call\\n    // so the call order is changes-init-check in creation mode. In subsequent\\n    // change detection runs, only the check wrapper will be called.\\n    if (definition.onInit != null) {\\n        definition.onInit = onChangesWrapper(definition.onInit);\\n    }\\n    definition.doCheck = onChangesWrapper(definition.doCheck);\\n}\\nfunction onChangesWrapper(delegateHook) {\\n    return function () {\\n        var simpleChanges = this[PRIVATE_PREFIX];\\n        if (simpleChanges != null) {\\n            this.ngOnChanges(simpleChanges);\\n            this[PRIVATE_PREFIX] = null;\\n        }\\n        if (delegateHook)\\n            delegateHook.apply(this);\\n    };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\\n * directives that will share slots, and thus, the fewer false positives when checking for\\n * the existence of a directive.\\n */\\nvar BLOOM_SIZE = 256;\\nvar BLOOM_MASK = BLOOM_SIZE - 1;\\n/** Counter used to generate unique IDs for directives. */\\nvar nextNgElementId = 0;\\n/**\\n * Registers this directive as present in its node's injector by flipping the directive's\\n * corresponding bit in the injector's bloom filter.\\n *\\n * @param injectorIndex The index of the node injector where this token should be registered\\n * @param tView The TView for the injector's bloom filters\\n * @param type The directive token to register\\n */\\nfunction bloomAdd(injectorIndex, tView, type) {\\n    if (tView.firstTemplatePass) {\\n        var id = type[NG_ELEMENT_ID];\\n        // Set a unique ID on the directive type, so if something tries to inject the directive,\\n        // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\\n        if (id == null) {\\n            id = type[NG_ELEMENT_ID] = nextNgElementId++;\\n        }\\n        // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\\n        // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\\n        var bloomBit = id & BLOOM_MASK;\\n        // Create a mask that targets the specific bit associated with the directive.\\n        // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\\n        // to bit positions 0 - 31 in a 32 bit integer.\\n        var mask = 1 << bloomBit;\\n        // Use the raw bloomBit number to determine which bloom filter bucket we should check\\n        // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\\n        var b7 = bloomBit & 0x80;\\n        var b6 = bloomBit & 0x40;\\n        var b5 = bloomBit & 0x20;\\n        var tData = tView.data;\\n        if (b7) {\\n            b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\\n                (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\\n        }\\n        else {\\n            b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\\n                (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\\n        }\\n    }\\n}\\nfunction getOrCreateNodeInjector() {\\n    return getOrCreateNodeInjectorForNode(getPreviousOrParentTNode(), _getViewData());\\n}\\n/**\\n * Creates (or gets an existing) injector for a given element or container.\\n *\\n * @param tNode for which an injector should be retrieved / created.\\n * @param hostView View where the node is stored\\n * @returns Node injector\\n */\\nfunction getOrCreateNodeInjectorForNode(tNode, hostView) {\\n    var existingInjectorIndex = getInjectorIndex(tNode, hostView);\\n    if (existingInjectorIndex !== -1) {\\n        return existingInjectorIndex;\\n    }\\n    var tView = hostView[TVIEW];\\n    if (tView.firstTemplatePass) {\\n        tNode.injectorIndex = hostView.length;\\n        setUpBloom(tView.data, tNode); // foundation for node bloom\\n        setUpBloom(hostView, null); // foundation for cumulative bloom\\n        setUpBloom(tView.blueprint, null);\\n    }\\n    var parentLoc = getParentInjectorLocation(tNode, hostView);\\n    var parentIndex = parentLoc & 32767 /* InjectorIndexMask */;\\n    var parentView = getParentInjectorView(parentLoc, hostView);\\n    var parentData = parentView[TVIEW].data;\\n    var injectorIndex = tNode.injectorIndex;\\n    // If a parent injector can't be found, its location is set to -1.\\n    // In that case, we don't need to set up a cumulative bloom\\n    if (parentLoc !== -1) {\\n        for (var i = 0; i < PARENT_INJECTOR; i++) {\\n            var bloomIndex = parentIndex + i;\\n            // Creates a cumulative bloom filter that merges the parent's bloom filter\\n            // and its own cumulative bloom (which contains tokens for all ancestors)\\n            hostView[injectorIndex + i] = parentView[bloomIndex] | parentData[bloomIndex];\\n        }\\n    }\\n    hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\\n    return injectorIndex;\\n}\\nfunction setUpBloom(arr, footer) {\\n    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\\n}\\nfunction getInjectorIndex(tNode, hostView) {\\n    if (tNode.injectorIndex === -1 ||\\n        // If the injector index is the same as its parent's injector index, then the index has been\\n        // copied down from the parent node. No injector has been created yet on this node.\\n        (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\\n        // After the first template pass, the injector index might exist but the parent values\\n        // might not have been calculated yet for this instance\\n        hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\\n        return -1;\\n    }\\n    else {\\n        return tNode.injectorIndex;\\n    }\\n}\\n/**\\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\\n * parent injector initially.\\n */\\nfunction getParentInjectorLocation(tNode, view) {\\n    if (tNode.parent && tNode.parent.injectorIndex !== -1) {\\n        return tNode.parent.injectorIndex; // view offset is 0\\n    }\\n    // For most cases, the parent injector index can be found on the host node (e.g. for component\\n    // or container), so this loop will be skipped, but we must keep the loop here to support\\n    // the rarer case of deeply nested <ng-template> tags or inline views.\\n    var hostTNode = view[HOST_NODE];\\n    var viewOffset = 1;\\n    while (hostTNode && hostTNode.injectorIndex === -1) {\\n        view = view[DECLARATION_VIEW];\\n        hostTNode = view[HOST_NODE];\\n        viewOffset++;\\n    }\\n    return hostTNode ?\\n        hostTNode.injectorIndex | (viewOffset << 15 /* ViewOffsetShift */) :\\n        -1;\\n}\\n/**\\n * Unwraps a parent injector location number to find the view offset from the current injector,\\n * then walks up the declaration view tree until the view is found that contains the parent\\n * injector.\\n *\\n * @param location The location of the parent injector, which contains the view offset\\n * @param startView The LViewData instance from which to start walking up the view tree\\n * @returns The LViewData instance that contains the parent injector\\n */\\nfunction getParentInjectorView(location, startView) {\\n    var viewOffset = location >> 15 /* ViewOffsetShift */;\\n    var parentView = startView;\\n    // For most cases, the parent injector can be found on the host node (e.g. for component\\n    // or container), but we must keep the loop here to support the rarer case of deeply nested\\n    // <ng-template> tags or inline views, where the parent injector might live many views\\n    // above the child injector.\\n    while (viewOffset > 0) {\\n        parentView = parentView[DECLARATION_VIEW];\\n        viewOffset--;\\n    }\\n    return parentView;\\n}\\n/**\\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\\n *\\n * @param di The node injector in which a directive will be added\\n * @param def The definition of the directive to be made public\\n */\\nfunction diPublicInInjector(injectorIndex, view, def) {\\n    bloomAdd(injectorIndex, view[TVIEW], def.type);\\n}\\n/**\\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\\n *\\n * @param def The definition of the directive to be made public\\n */\\nfunction diPublic(def) {\\n    diPublicInInjector(getOrCreateNodeInjector(), _getViewData(), def);\\n}\\nfunction directiveInject(token, flags) {\\n    if (flags === void 0) { flags = 0 /* Default */; }\\n    var hostTNode = getPreviousOrParentTNode();\\n    return getOrCreateInjectable(hostTNode, _getViewData(), token, flags);\\n}\\n/**\\n * Inject static attribute value into directive constructor.\\n *\\n * This method is used with `factory` functions which are generated as part of\\n * `defineDirective` or `defineComponent`. The method retrieves the static value\\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\\n *  at the time of injection and can change over time.)\\n *\\n * # Example\\n * Given:\\n * ```\\n * @Component(...)\\n * class MyComponent {\\n *   constructor(@Attribute('title') title: string) { ... }\\n * }\\n * ```\\n * When instantiated with\\n * ```\\n * <my-component title=\\\"Hello\\\"></my-component>\\n * ```\\n *\\n * Then factory method generated is:\\n * ```\\n * MyComponent.ngComponentDef = defineComponent({\\n *   factory: () => new MyComponent(injectAttribute('title'))\\n *   ...\\n * })\\n * ```\\n *\\n * @publicApi\\n */\\nfunction injectAttribute(attrNameToInject) {\\n    var tNode = getPreviousOrParentTNode();\\n    ngDevMode && assertNodeOfPossibleTypes(tNode, 0 /* Container */, 3 /* Element */, 4 /* ElementContainer */);\\n    ngDevMode && assertDefined(tNode, 'expecting tNode');\\n    var attrs = tNode.attrs;\\n    if (attrs) {\\n        for (var i = 0; i < attrs.length; i = i + 2) {\\n            var attrName = attrs[i];\\n            if (attrName === 1 /* SelectOnly */)\\n                break;\\n            if (attrName == attrNameToInject) {\\n                return attrs[i + 1];\\n            }\\n        }\\n    }\\n    return undefined;\\n}\\n/**\\n * Returns the value associated to the given token from the injectors.\\n *\\n * Look for the injector providing the token by walking up the node injector tree and then\\n * the module injector tree.\\n *\\n * @param nodeInjector Node injector where the search should start\\n * @param token The token to look for\\n * @param flags Injection flags\\n * @returns the value from the injector or `null` when not found\\n */\\nfunction getOrCreateInjectable(hostTNode, hostView, token, flags) {\\n    if (flags === void 0) { flags = 0 /* Default */; }\\n    var bloomHash = bloomHashBitOrFactory(token);\\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\\n    // so just call the factory function to create it.\\n    if (typeof bloomHash === 'function')\\n        return bloomHash();\\n    // If the token has a bloom hash, then it is a directive that is public to the injection system\\n    // (diPublic) otherwise fall back to the module injector.\\n    if (bloomHash != null) {\\n        var startInjectorIndex = getInjectorIndex(hostTNode, hostView);\\n        var injectorIndex = startInjectorIndex;\\n        var injectorView = hostView;\\n        var parentLocation = -1;\\n        // If we should skip this injector or if an injector doesn't exist on this node (e.g. all\\n        // directives on this node are private), start by searching the parent injector.\\n        if (flags & 4 /* SkipSelf */ || injectorIndex === -1) {\\n            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(hostTNode, hostView) :\\n                injectorView[injectorIndex + PARENT_INJECTOR];\\n            if (shouldNotSearchParent(flags, parentLocation)) {\\n                injectorIndex = -1;\\n            }\\n            else {\\n                injectorIndex = parentLocation & 32767 /* InjectorIndexMask */;\\n                injectorView = getParentInjectorView(parentLocation, injectorView);\\n            }\\n        }\\n        while (injectorIndex !== -1) {\\n            // Traverse up the injector tree until we find a potential match or until we know there\\n            // *isn't* a match. Outer loop is necessary in case we get a false positive injector.\\n            while (injectorIndex !== -1) {\\n                // Check the current injector. If it matches, stop searching for an injector.\\n                if (injectorHasToken(bloomHash, injectorIndex, injectorView[TVIEW].data)) {\\n                    break;\\n                }\\n                parentLocation = injectorView[injectorIndex + PARENT_INJECTOR];\\n                if (shouldNotSearchParent(flags, parentLocation)) {\\n                    injectorIndex = -1;\\n                    break;\\n                }\\n                // If the ancestor bloom filter value has the bit corresponding to the directive, traverse\\n                // up to find the specific injector. If the ancestor bloom filter does not have the bit, we\\n                // can abort.\\n                if (injectorHasToken(bloomHash, injectorIndex, injectorView)) {\\n                    injectorIndex = parentLocation & 32767 /* InjectorIndexMask */;\\n                    injectorView = getParentInjectorView(parentLocation, injectorView);\\n                }\\n                else {\\n                    injectorIndex = -1;\\n                    break;\\n                }\\n            }\\n            // If no injector is found, we *know* that there is no ancestor injector that contains the\\n            // token, so we abort.\\n            if (injectorIndex === -1) {\\n                break;\\n            }\\n            // At this point, we have an injector which *may* contain the token, so we step through the\\n            // directives associated with the injector's corresponding node to get the directive instance.\\n            var instance = void 0;\\n            if (instance = searchDirectivesOnInjector(injectorIndex, injectorView, token)) {\\n                return instance;\\n            }\\n            // If we *didn't* find the directive for the token and we are searching the current node's\\n            // injector, it's possible the directive is on this node and hasn't been created yet.\\n            if (injectorIndex === startInjectorIndex && hostView === injectorView &&\\n                (instance = searchMatchesQueuedForCreation(token, injectorView[TVIEW]))) {\\n                return instance;\\n            }\\n            // The def wasn't found anywhere on this node, so it was a false positive.\\n            // Traverse up the tree and continue searching.\\n            injectorIndex = parentLocation & 32767 /* InjectorIndexMask */;\\n            injectorView = getParentInjectorView(parentLocation, injectorView);\\n        }\\n    }\\n    var moduleInjector = hostView[INJECTOR$1];\\n    var formerInjector = setCurrentInjector(moduleInjector);\\n    try {\\n        return inject(token, flags);\\n    }\\n    finally {\\n        setCurrentInjector(formerInjector);\\n    }\\n}\\nfunction searchMatchesQueuedForCreation(token, hostTView) {\\n    var matches = hostTView.currentMatches;\\n    if (matches) {\\n        for (var i = 0; i < matches.length; i += 2) {\\n            var def = matches[i];\\n            if (def.type === token) {\\n                return resolveDirective(def, i + 1, matches);\\n            }\\n        }\\n    }\\n    return null;\\n}\\nfunction searchDirectivesOnInjector(injectorIndex, injectorView, token) {\\n    var tNode = injectorView[TVIEW].data[injectorIndex + TNODE];\\n    var nodeFlags = tNode.flags;\\n    var count = nodeFlags & 4095 /* DirectiveCountMask */;\\n    if (count !== 0) {\\n        var start = nodeFlags >> 15 /* DirectiveStartingIndexShift */;\\n        var end = start + count;\\n        var defs = injectorView[TVIEW].data;\\n        for (var i = start; i < end; i++) {\\n            // Get the definition for the directive at this index and, if it is injectable (diPublic),\\n            // and matches the given token, return the directive instance.\\n            var directiveDef = defs[i];\\n            if (directiveDef.type === token && directiveDef.diPublic) {\\n                return injectorView[i];\\n            }\\n        }\\n    }\\n    return null;\\n}\\n/**\\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\\n * the directive might be provided by the injector.\\n *\\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\\n * is returned as the node injector can not possibly provide that token.\\n *\\n * @param token the injection token\\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\\n */\\nfunction bloomHashBitOrFactory(token) {\\n    ngDevMode && assertDefined(token, 'token must be defined');\\n    var tokenId = token[NG_ELEMENT_ID];\\n    return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;\\n}\\nfunction injectorHasToken(bloomHash, injectorIndex, injectorView) {\\n    // Create a mask that targets the specific bit associated with the directive we're looking for.\\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\\n    // to bit positions 0 - 31 in a 32 bit integer.\\n    var mask = 1 << bloomHash;\\n    var b7 = bloomHash & 0x80;\\n    var b6 = bloomHash & 0x40;\\n    var b5 = bloomHash & 0x20;\\n    // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\\n    // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\\n    // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\\n    var value;\\n    if (b7) {\\n        value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\\n            (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\\n    }\\n    else {\\n        value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\\n            (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\\n    }\\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\\n    // this injector is a potential match.\\n    return !!(value & mask);\\n}\\n/** Returns true if flags prevent parent injector from being searched for tokens */\\nfunction shouldNotSearchParent(flags, parentLocation) {\\n    return flags & 2 /* Self */ ||\\n        (flags & 1 /* Host */ && (parentLocation >> 15 /* ViewOffsetShift */) > 0);\\n}\\nvar NodeInjector = /** @class */ (function () {\\n    function NodeInjector(_tNode, _hostView) {\\n        this._tNode = _tNode;\\n        this._hostView = _hostView;\\n        this._injectorIndex = getOrCreateNodeInjectorForNode(_tNode, _hostView);\\n    }\\n    NodeInjector.prototype.get = function (token) {\\n        setEnvironment(this._tNode, this._hostView);\\n        return getOrCreateInjectable(this._tNode, this._hostView, token);\\n    };\\n    return NodeInjector;\\n}());\\nfunction getFactoryOf(type) {\\n    var typeAny = type;\\n    var def = getComponentDef(typeAny) || getDirectiveDef(typeAny) ||\\n        getPipeDef(typeAny) || getInjectableDef(typeAny) || getInjectorDef(typeAny);\\n    if (!def || def.factory === undefined) {\\n        return null;\\n    }\\n    return def.factory;\\n}\\nfunction getInheritedFactory(type) {\\n    var proto = Object.getPrototypeOf(type.prototype).constructor;\\n    var factory = getFactoryOf(proto);\\n    if (factory !== null) {\\n        return factory;\\n    }\\n    else {\\n        // There is no factory defined. Either this was improper usage of inheritance\\n        // (no Angular decorator on the superclass) or there is no constructor at all\\n        // in the inheritance chain. Since the two cases cannot be distinguished, the\\n        // latter has to be assumed.\\n        return function (t) { return new t(); };\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This feature publishes the directive (or component) into the DI system, making it visible to\\n * others for injection.\\n *\\n * @param definition\\n */\\nfunction PublicFeature(definition) {\\n    definition.diPublic = diPublic;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Represents a component created by a `ComponentFactory`.\\n * Provides access to the component instance and related objects,\\n * and provides the means of destroying the instance.\\n *\\n * @publicApi\\n */\\nvar ComponentRef = /** @class */ (function () {\\n    function ComponentRef() {\\n    }\\n    return ComponentRef;\\n}());\\n/**\\n * @publicApi\\n */\\nvar ComponentFactory = /** @class */ (function () {\\n    function ComponentFactory() {\\n    }\\n    return ComponentFactory;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction noComponentFactoryError(component) {\\n    var error = Error(\\\"No component factory found for \\\" + stringify(component) + \\\". Did you add it to @NgModule.entryComponents?\\\");\\n    error[ERROR_COMPONENT] = component;\\n    return error;\\n}\\nvar ERROR_COMPONENT = 'ngComponent';\\nvar _NullComponentFactoryResolver = /** @class */ (function () {\\n    function _NullComponentFactoryResolver() {\\n    }\\n    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\\n        throw noComponentFactoryError(component);\\n    };\\n    return _NullComponentFactoryResolver;\\n}());\\n/**\\n * @publicApi\\n */\\nvar ComponentFactoryResolver = /** @class */ (function () {\\n    function ComponentFactoryResolver() {\\n    }\\n    ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();\\n    return ComponentFactoryResolver;\\n}());\\nvar CodegenComponentFactoryResolver = /** @class */ (function () {\\n    function CodegenComponentFactoryResolver(factories, _parent, _ngModule) {\\n        this._parent = _parent;\\n        this._ngModule = _ngModule;\\n        this._factories = new Map();\\n        for (var i = 0; i < factories.length; i++) {\\n            var factory = factories[i];\\n            this._factories.set(factory.componentType, factory);\\n        }\\n    }\\n    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {\\n        var factory = this._factories.get(component);\\n        if (!factory && this._parent) {\\n            factory = this._parent.resolveComponentFactory(component);\\n        }\\n        if (!factory) {\\n            throw noComponentFactoryError(component);\\n        }\\n        return new ComponentFactoryBoundToModule(factory, this._ngModule);\\n    };\\n    return CodegenComponentFactoryResolver;\\n}());\\nvar ComponentFactoryBoundToModule = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentFactoryBoundToModule, _super);\\n    function ComponentFactoryBoundToModule(factory, ngModule) {\\n        var _this = _super.call(this) || this;\\n        _this.factory = factory;\\n        _this.ngModule = ngModule;\\n        _this.selector = factory.selector;\\n        _this.componentType = factory.componentType;\\n        _this.ngContentSelectors = factory.ngContentSelectors;\\n        _this.inputs = factory.inputs;\\n        _this.outputs = factory.outputs;\\n        return _this;\\n    }\\n    ComponentFactoryBoundToModule.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\\n        return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);\\n    };\\n    return ComponentFactoryBoundToModule;\\n}(ComponentFactory));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\\n *\\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\\n * NgModule Instance.\\n *\\n * @publicApi\\n */\\nvar NgModuleRef = /** @class */ (function () {\\n    function NgModuleRef() {\\n    }\\n    return NgModuleRef;\\n}());\\n/**\\n * @publicApi\\n */\\nvar NgModuleFactory = /** @class */ (function () {\\n    function NgModuleFactory() {\\n    }\\n    return NgModuleFactory;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar ViewRef = /** @class */ (function () {\\n    function ViewRef(_view, _context, _componentIndex) {\\n        this._context = _context;\\n        this._componentIndex = _componentIndex;\\n        this._appRef = null;\\n        this._viewContainerRef = null;\\n        /**\\n         * @internal\\n         */\\n        this._tViewNode = null;\\n        this._view = _view;\\n    }\\n    Object.defineProperty(ViewRef.prototype, \\\"context\\\", {\\n        get: function () { return this._context ? this._context : this._lookUpContext(); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ViewRef.prototype, \\\"destroyed\\\", {\\n        get: function () {\\n            return (this._view[FLAGS] & 32 /* Destroyed */) === 32 /* Destroyed */;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ViewRef.prototype.destroy = function () {\\n        if (this._viewContainerRef && viewAttached(this._view)) {\\n            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\\n            this._viewContainerRef = null;\\n        }\\n        destroyLView(this._view);\\n    };\\n    ViewRef.prototype.onDestroy = function (callback) { storeCleanupFn(this._view, callback); };\\n    /**\\n     * Marks a view and all of its ancestors dirty.\\n     *\\n     * It also triggers change detection by calling `scheduleTick` internally, which coalesces\\n     * multiple `markForCheck` calls to into one change detection run.\\n     *\\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\\n     *\\n     * \\x3c!-- TODO: Add a link to a chapter on OnPush components --\\x3e\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * ```typescript\\n     * @Component({\\n     *   selector: 'my-app',\\n     *   template: `Number of ticks: {{numberOfTicks}}`\\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\\n     * })\\n     * class AppComponent {\\n     *   numberOfTicks = 0;\\n     *\\n     *   constructor(private ref: ChangeDetectorRef) {\\n     *     setInterval(() => {\\n     *       this.numberOfTicks++;\\n     *       // the following is required, otherwise the view will not be updated\\n     *       this.ref.markForCheck();\\n     *     }, 1000);\\n     *   }\\n     * }\\n     * ```\\n     */\\n    ViewRef.prototype.markForCheck = function () { markViewDirty(this._view); };\\n    /**\\n     * Detaches the view from the change detection tree.\\n     *\\n     * Detached views will not be checked during change detection runs until they are\\n     * re-attached, even if they are dirty. `detach` can be used in combination with\\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\\n     * detection checks.\\n     *\\n     * \\x3c!-- TODO: Add a link to a chapter on detach/reattach/local digest --\\x3e\\n     * \\x3c!-- TODO: Add a live demo once ref.detectChanges is merged into master --\\x3e\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * The following example defines a component with a large list of readonly data.\\n     * Imagine the data changes constantly, many times per second. For performance reasons,\\n     * we want to check and update the list every five seconds. We can do that by detaching\\n     * the component's change detector and doing a local check every five seconds.\\n     *\\n     * ```typescript\\n     * class DataProvider {\\n     *   // in a real application the returned data will be different every time\\n     *   get data() {\\n     *     return [1,2,3,4,5];\\n     *   }\\n     * }\\n     *\\n     * @Component({\\n     *   selector: 'giant-list',\\n     *   template: `\\n     *     <li *ngFor=\\\"let d of dataProvider.data\\\">Data {{d}}</li>\\n     *   `,\\n     * })\\n     * class GiantList {\\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\\n     *     ref.detach();\\n     *     setInterval(() => {\\n     *       this.ref.detectChanges();\\n     *     }, 5000);\\n     *   }\\n     * }\\n     *\\n     * @Component({\\n     *   selector: 'app',\\n     *   providers: [DataProvider],\\n     *   template: `\\n     *     <giant-list><giant-list>\\n     *   `,\\n     * })\\n     * class App {\\n     * }\\n     * ```\\n     */\\n    ViewRef.prototype.detach = function () { this._view[FLAGS] &= ~8 /* Attached */; };\\n    /**\\n     * Re-attaches a view to the change detection tree.\\n     *\\n     * This can be used to re-attach views that were previously detached from the tree\\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\\n     *\\n     * \\x3c!-- TODO: Add a link to a chapter on detach/reattach/local digest --\\x3e\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * The following example creates a component displaying `live` data. The component will detach\\n     * its change detector from the main change detector tree when the component's live property\\n     * is set to false.\\n     *\\n     * ```typescript\\n     * class DataProvider {\\n     *   data = 1;\\n     *\\n     *   constructor() {\\n     *     setInterval(() => {\\n     *       this.data = this.data * 2;\\n     *     }, 500);\\n     *   }\\n     * }\\n     *\\n     * @Component({\\n     *   selector: 'live-data',\\n     *   inputs: ['live'],\\n     *   template: 'Data: {{dataProvider.data}}'\\n     * })\\n     * class LiveData {\\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\\n     *\\n     *   set live(value) {\\n     *     if (value) {\\n     *       this.ref.reattach();\\n     *     } else {\\n     *       this.ref.detach();\\n     *     }\\n     *   }\\n     * }\\n     *\\n     * @Component({\\n     *   selector: 'my-app',\\n     *   providers: [DataProvider],\\n     *   template: `\\n     *     Live Update: <input type=\\\"checkbox\\\" [(ngModel)]=\\\"live\\\">\\n     *     <live-data [live]=\\\"live\\\"><live-data>\\n     *   `,\\n     * })\\n     * class AppComponent {\\n     *   live = true;\\n     * }\\n     * ```\\n     */\\n    ViewRef.prototype.reattach = function () { this._view[FLAGS] |= 8 /* Attached */; };\\n    /**\\n     * Checks the view and its children.\\n     *\\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\\n     * local change detection checks.\\n     *\\n     * \\x3c!-- TODO: Add a link to a chapter on detach/reattach/local digest --\\x3e\\n     * \\x3c!-- TODO: Add a live demo once ref.detectChanges is merged into master --\\x3e\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * The following example defines a component with a large list of readonly data.\\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\\n     * we want to check and update the list every five seconds.\\n     *\\n     * We can do that by detaching the component's change detector and doing a local change detection\\n     * check every five seconds.\\n     *\\n     * See {@link ChangeDetectorRef#detach detach} for more information.\\n     */\\n    ViewRef.prototype.detectChanges = function () {\\n        var rendererFactory = getRendererFactory();\\n        if (rendererFactory.begin) {\\n            rendererFactory.begin();\\n        }\\n        detectChanges(this.context);\\n        if (rendererFactory.end) {\\n            rendererFactory.end();\\n        }\\n    };\\n    /**\\n     * Checks the change detector and its children, and throws if any changes are detected.\\n     *\\n     * This is used in development mode to verify that running change detection doesn't\\n     * introduce other changes.\\n     */\\n    ViewRef.prototype.checkNoChanges = function () { checkNoChanges(this.context); };\\n    ViewRef.prototype.attachToViewContainerRef = function (vcRef) { this._viewContainerRef = vcRef; };\\n    ViewRef.prototype.detachFromAppRef = function () { this._appRef = null; };\\n    ViewRef.prototype.attachToAppRef = function (appRef) { this._appRef = appRef; };\\n    ViewRef.prototype._lookUpContext = function () {\\n        return this._context = this._view[PARENT][this._componentIndex];\\n    };\\n    return ViewRef;\\n}());\\n/** @internal */\\nvar RootViewRef = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(RootViewRef, _super);\\n    function RootViewRef(_view) {\\n        var _this = _super.call(this, _view, null, -1) || this;\\n        _this._view = _view;\\n        return _this;\\n    }\\n    RootViewRef.prototype.detectChanges = function () { detectChangesInRootView(this._view); };\\n    RootViewRef.prototype.checkNoChanges = function () { checkNoChangesInRootView(this._view); };\\n    return RootViewRef;\\n}(ViewRef));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Creates an ElementRef from the most recent node.\\n *\\n * @returns The ElementRef instance to use\\n */\\nfunction injectElementRef(ElementRefToken) {\\n    return createElementRef(ElementRefToken, getPreviousOrParentTNode(), _getViewData());\\n}\\nvar R3ElementRef;\\n/**\\n * Creates an ElementRef given a node.\\n *\\n * @param ElementRefToken The ElementRef type\\n * @param tNode The node for which you'd like an ElementRef\\n * @param view The view to which the node belongs\\n * @returns The ElementRef instance to use\\n */\\nfunction createElementRef(ElementRefToken, tNode, view) {\\n    if (!R3ElementRef) {\\n        // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug\\n        R3ElementRef = /** @class */ (function (_super) {\\n            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ElementRef_, _super);\\n            function ElementRef_() {\\n                return _super !== null && _super.apply(this, arguments) || this;\\n            }\\n            return ElementRef_;\\n        }(ElementRefToken));\\n    }\\n    return new R3ElementRef(getNativeByTNode(tNode, view));\\n}\\nvar R3TemplateRef;\\n/**\\n * Creates a TemplateRef given a node.\\n *\\n * @returns The TemplateRef instance to use\\n */\\nfunction injectTemplateRef(TemplateRefToken, ElementRefToken) {\\n    return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), _getViewData());\\n}\\n/**\\n * Creates a TemplateRef and stores it on the injector.\\n *\\n * @param TemplateRefToken The TemplateRef type\\n * @param ElementRefToken The ElementRef type\\n * @param hostTNode The node that is requesting a TemplateRef\\n * @param hostView The view to which the node belongs\\n * @returns The TemplateRef instance to use\\n */\\nfunction createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {\\n    if (!R3TemplateRef) {\\n        // TODO: Fix class name, should be TemplateRef, but there appears to be a rollup bug\\n        R3TemplateRef = /** @class */ (function (_super) {\\n            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(TemplateRef_, _super);\\n            function TemplateRef_(_declarationParentView, elementRef, _tView, _renderer, _queries, _injectorIndex) {\\n                var _this = _super.call(this) || this;\\n                _this._declarationParentView = _declarationParentView;\\n                _this.elementRef = elementRef;\\n                _this._tView = _tView;\\n                _this._renderer = _renderer;\\n                _this._queries = _queries;\\n                _this._injectorIndex = _injectorIndex;\\n                return _this;\\n            }\\n            TemplateRef_.prototype.createEmbeddedView = function (context, container$$1, hostTNode, hostView, index) {\\n                var lView = createEmbeddedViewAndNode(this._tView, context, this._declarationParentView, this._renderer, this._queries, this._injectorIndex);\\n                if (container$$1) {\\n                    insertView(lView, container$$1, hostView, index, hostTNode.index);\\n                }\\n                renderEmbeddedTemplate(lView, this._tView, context, 1 /* Create */);\\n                var viewRef = new ViewRef(lView, context, -1);\\n                viewRef._tViewNode = lView[HOST_NODE];\\n                return viewRef;\\n            };\\n            return TemplateRef_;\\n        }(TemplateRefToken));\\n    }\\n    var hostContainer = hostView[hostTNode.index];\\n    ngDevMode && assertNodeType(hostTNode, 0 /* Container */);\\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\\n    return new R3TemplateRef(hostView, createElementRef(ElementRefToken, hostTNode, hostView), hostTNode.tViews, getRenderer(), hostContainer[QUERIES], hostTNode.injectorIndex);\\n}\\nvar R3ViewContainerRef;\\n/**\\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\\n * already exists, retrieves the existing ViewContainerRef.\\n *\\n * @returns The ViewContainerRef instance to use\\n */\\nfunction injectViewContainerRef(ViewContainerRefToken, ElementRefToken) {\\n    var previousTNode = getPreviousOrParentTNode();\\n    return createContainerRef(ViewContainerRefToken, ElementRefToken, previousTNode, _getViewData());\\n}\\n/**\\n * Creates a ViewContainerRef and stores it on the injector.\\n *\\n * @param ViewContainerRefToken The ViewContainerRef type\\n * @param ElementRefToken The ElementRef type\\n * @param hostTNode The node that is requesting a ViewContainerRef\\n * @param hostView The view to which the node belongs\\n * @returns The ViewContainerRef instance to use\\n */\\nfunction createContainerRef(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {\\n    if (!R3ViewContainerRef) {\\n        // TODO: Fix class name, should be ViewContainerRef, but there appears to be a rollup bug\\n        R3ViewContainerRef = /** @class */ (function (_super) {\\n            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ViewContainerRef_, _super);\\n            function ViewContainerRef_(_lContainer, _hostTNode, _hostView) {\\n                var _this = _super.call(this) || this;\\n                _this._lContainer = _lContainer;\\n                _this._hostTNode = _hostTNode;\\n                _this._hostView = _hostView;\\n                _this._viewRefs = [];\\n                return _this;\\n            }\\n            Object.defineProperty(ViewContainerRef_.prototype, \\\"element\\\", {\\n                get: function () {\\n                    return createElementRef(ElementRefToken, this._hostTNode, this._hostView);\\n                },\\n                enumerable: true,\\n                configurable: true\\n            });\\n            Object.defineProperty(ViewContainerRef_.prototype, \\\"injector\\\", {\\n                get: function () { return new NodeInjector(this._hostTNode, this._hostView); },\\n                enumerable: true,\\n                configurable: true\\n            });\\n            Object.defineProperty(ViewContainerRef_.prototype, \\\"parentInjector\\\", {\\n                /** @deprecated No replacement */\\n                get: function () {\\n                    var parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView);\\n                    var parentView = getParentInjectorView(parentLocation, this._hostView);\\n                    var parentIndex = parentLocation & 32767 /* InjectorIndexMask */;\\n                    var parentTNode = parentView[TVIEW].data[parentIndex];\\n                    return parentLocation === -1 ? new NullInjector() :\\n                        new NodeInjector(parentTNode, parentView);\\n                },\\n                enumerable: true,\\n                configurable: true\\n            });\\n            ViewContainerRef_.prototype.clear = function () {\\n                while (this._lContainer[VIEWS].length) {\\n                    this.remove(0);\\n                }\\n            };\\n            ViewContainerRef_.prototype.get = function (index) { return this._viewRefs[index] || null; };\\n            Object.defineProperty(ViewContainerRef_.prototype, \\\"length\\\", {\\n                get: function () { return this._lContainer[VIEWS].length; },\\n                enumerable: true,\\n                configurable: true\\n            });\\n            ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\\n                var adjustedIdx = this._adjustIndex(index);\\n                var viewRef = templateRef\\n                    .createEmbeddedView(context || {}, this._lContainer, this._hostTNode, this._hostView, adjustedIdx);\\n                viewRef.attachToViewContainerRef(this);\\n                this._viewRefs.splice(adjustedIdx, 0, viewRef);\\n                return viewRef;\\n            };\\n            ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {\\n                var contextInjector = injector || this.parentInjector;\\n                if (!ngModuleRef && contextInjector) {\\n                    ngModuleRef = contextInjector.get(NgModuleRef, null);\\n                }\\n                var componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\\n                this.insert(componentRef.hostView, index);\\n                return componentRef;\\n            };\\n            ViewContainerRef_.prototype.insert = function (viewRef, index) {\\n                if (viewRef.destroyed) {\\n                    throw new Error('Cannot insert a destroyed View in a ViewContainer!');\\n                }\\n                var lView = viewRef._view;\\n                var adjustedIdx = this._adjustIndex(index);\\n                insertView(lView, this._lContainer, this._hostView, adjustedIdx, this._hostTNode.index);\\n                var beforeNode = getBeforeNodeForView(adjustedIdx, this._lContainer[VIEWS], this._lContainer[NATIVE]);\\n                addRemoveViewFromContainer(lView, true, beforeNode);\\n                viewRef.attachToViewContainerRef(this);\\n                this._viewRefs.splice(adjustedIdx, 0, viewRef);\\n                return viewRef;\\n            };\\n            ViewContainerRef_.prototype.move = function (viewRef, newIndex) {\\n                var index = this.indexOf(viewRef);\\n                this.detach(index);\\n                this.insert(viewRef, this._adjustIndex(newIndex));\\n                return viewRef;\\n            };\\n            ViewContainerRef_.prototype.indexOf = function (viewRef) { return this._viewRefs.indexOf(viewRef); };\\n            ViewContainerRef_.prototype.remove = function (index) {\\n                var adjustedIdx = this._adjustIndex(index, -1);\\n                removeView(this._lContainer, this._hostTNode, adjustedIdx);\\n                this._viewRefs.splice(adjustedIdx, 1);\\n            };\\n            ViewContainerRef_.prototype.detach = function (index) {\\n                var adjustedIdx = this._adjustIndex(index, -1);\\n                detachView(this._lContainer, adjustedIdx, !!this._hostTNode.detached);\\n                return this._viewRefs.splice(adjustedIdx, 1)[0] || null;\\n            };\\n            ViewContainerRef_.prototype._adjustIndex = function (index, shift) {\\n                if (shift === void 0) { shift = 0; }\\n                if (index == null) {\\n                    return this._lContainer[VIEWS].length + shift;\\n                }\\n                if (ngDevMode) {\\n                    assertGreaterThan(index, -1, 'index must be positive');\\n                    // +1 because it's legal to insert at the end.\\n                    assertLessThan(index, this._lContainer[VIEWS].length + 1 + shift, 'index');\\n                }\\n                return index;\\n            };\\n            return ViewContainerRef_;\\n        }(ViewContainerRefToken));\\n    }\\n    ngDevMode && assertNodeOfPossibleTypes(hostTNode, 0 /* Container */, 3 /* Element */, 4 /* ElementContainer */);\\n    var lContainer;\\n    var slotValue = hostView[hostTNode.index];\\n    if (isLContainer(slotValue)) {\\n        // If the host is a container, we don't need to create a new LContainer\\n        lContainer = slotValue;\\n        lContainer[ACTIVE_INDEX] = -1;\\n    }\\n    else {\\n        var comment = hostView[RENDERER].createComment(ngDevMode ? 'container' : '');\\n        ngDevMode && ngDevMode.rendererCreateComment++;\\n        hostView[hostTNode.index] = lContainer =\\n            createLContainer(slotValue, hostTNode, hostView, comment, true);\\n        appendChild(comment, hostTNode, hostView);\\n        addToViewTree(hostView, hostTNode.index, lContainer);\\n    }\\n    return new R3ViewContainerRef(lContainer, hostTNode, hostView);\\n}\\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\\nfunction injectChangeDetectorRef() {\\n    return createViewRef(getPreviousOrParentTNode(), _getViewData(), null);\\n}\\n/**\\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\\n *\\n * @param hostTNode The node that is requesting a ChangeDetectorRef\\n * @param hostView The view to which the node belongs\\n * @param context The context for this change detector ref\\n * @returns The ChangeDetectorRef to use\\n */\\nfunction createViewRef(hostTNode, hostView, context) {\\n    if (isComponent(hostTNode)) {\\n        var componentIndex = hostTNode.flags >> 15 /* DirectiveStartingIndexShift */;\\n        var componentView = getComponentViewByIndex(hostTNode.index, hostView);\\n        return new ViewRef(componentView, context, componentIndex);\\n    }\\n    else if (hostTNode.type === 3 /* Element */) {\\n        var hostComponentView = findComponentView(hostView);\\n        return new ViewRef(hostComponentView, hostComponentView[CONTEXT], -1);\\n    }\\n    return null;\\n}\\nfunction getOrCreateRenderer2(view) {\\n    var renderer = view[RENDERER];\\n    if (isProceduralRenderer(renderer)) {\\n        return renderer;\\n    }\\n    else {\\n        throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\\n    }\\n}\\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\\nfunction injectRenderer2() {\\n    return getOrCreateRenderer2(_getViewData());\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar R3_ELEMENT_REF_FACTORY = injectElementRef;\\nvar R3_TEMPLATE_REF_FACTORY = injectTemplateRef;\\nvar R3_CHANGE_DETECTOR_REF_FACTORY = injectChangeDetectorRef;\\nvar R3_VIEW_CONTAINER_REF_FACTORY = injectViewContainerRef;\\nvar R3_RENDERER2_FACTORY = injectRenderer2;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction noopFactory() {\\n    var tokens = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        tokens[_i] = arguments[_i];\\n    }\\n}\\nvar R3_ELEMENT_REF_FACTORY__POST_NGCC__ = R3_ELEMENT_REF_FACTORY;\\nvar R3_TEMPLATE_REF_FACTORY__POST_NGCC__ = R3_TEMPLATE_REF_FACTORY;\\nvar R3_CHANGE_DETECTOR_REF_FACTORY__POST_NGCC__ = R3_CHANGE_DETECTOR_REF_FACTORY;\\nvar R3_VIEW_CONTAINER_REF_FACTORY__POST_NGCC__ = R3_VIEW_CONTAINER_REF_FACTORY;\\nvar R3_RENDERER2_FACTORY__POST_NGCC__ = R3_RENDERER2_FACTORY;\\nvar R3_ELEMENT_REF_FACTORY__PRE_NGCC__ = noopFactory;\\nvar R3_TEMPLATE_REF_FACTORY__PRE_NGCC__ = noopFactory;\\nvar R3_CHANGE_DETECTOR_REF_FACTORY__PRE_NGCC__ = noopFactory;\\nvar R3_VIEW_CONTAINER_REF_FACTORY__PRE_NGCC__ = noopFactory;\\nvar R3_RENDERER2_FACTORY__PRE_NGCC__ = noopFactory;\\nvar R3_ELEMENT_REF_FACTORY$1 = R3_ELEMENT_REF_FACTORY__PRE_NGCC__;\\nvar R3_TEMPLATE_REF_FACTORY$1 = R3_TEMPLATE_REF_FACTORY__PRE_NGCC__;\\nvar R3_CHANGE_DETECTOR_REF_FACTORY$1 = R3_CHANGE_DETECTOR_REF_FACTORY__PRE_NGCC__;\\nvar R3_VIEW_CONTAINER_REF_FACTORY$1 = R3_VIEW_CONTAINER_REF_FACTORY__PRE_NGCC__;\\nvar R3_RENDERER2_FACTORY$1 = R3_RENDERER2_FACTORY__PRE_NGCC__;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A wrapper around a native element inside of a View.\\n *\\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\\n * element.\\n *\\n * @security Permitting direct access to the DOM can make your application more vulnerable to\\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\\n * [Security Guide](http://g.co/ng/security).\\n *\\n * @publicApi\\n */\\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\\n// and could do better codegen in the future.\\nvar ElementRef = /** @class */ (function () {\\n    function ElementRef(nativeElement) {\\n        this.nativeElement = nativeElement;\\n    }\\n    /** @internal */\\n    ElementRef.__NG_ELEMENT_ID__ = function () { return R3_ELEMENT_REF_FACTORY$1(ElementRef); };\\n    return ElementRef;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @deprecated Use `RendererType2` (and `Renderer2`) instead.\\n * @publicApi\\n */\\nvar RenderComponentType = /** @class */ (function () {\\n    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {\\n        this.id = id;\\n        this.templateUrl = templateUrl;\\n        this.slotCount = slotCount;\\n        this.encapsulation = encapsulation;\\n        this.styles = styles;\\n        this.animations = animations;\\n    }\\n    return RenderComponentType;\\n}());\\n/**\\n * @deprecated Debug info is handled internally in the view engine now.\\n */\\nvar RenderDebugInfo = /** @class */ (function () {\\n    function RenderDebugInfo() {\\n    }\\n    return RenderDebugInfo;\\n}());\\n/**\\n * @deprecated Use the `Renderer2` instead.\\n * @publicApi\\n */\\nvar Renderer = /** @class */ (function () {\\n    function Renderer() {\\n    }\\n    return Renderer;\\n}());\\nvar Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');\\n/**\\n * Injectable service that provides a low-level interface for modifying the UI.\\n *\\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\\n * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\\n * {@link Renderer#setElementAttribute setElementAttribute} respectively.\\n *\\n * If you are implementing a custom renderer, you must implement this interface.\\n *\\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\\n *\\n * @deprecated Use `RendererFactory2` instead.\\n * @publicApi\\n */\\nvar RootRenderer = /** @class */ (function () {\\n    function RootRenderer() {\\n    }\\n    return RootRenderer;\\n}());\\n/**\\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\\n *\\n * @publicApi\\n */\\nvar RendererFactory2 = /** @class */ (function () {\\n    function RendererFactory2() {\\n    }\\n    return RendererFactory2;\\n}());\\n/**\\n * Flags for renderer-specific style modifiers.\\n * @publicApi\\n */\\nvar RendererStyleFlags2;\\n(function (RendererStyleFlags2) {\\n    /**\\n     * Marks a style as important.\\n     */\\n    RendererStyleFlags2[RendererStyleFlags2[\\\"Important\\\"] = 1] = \\\"Important\\\";\\n    /**\\n     * Marks a style as using dash case naming (this-is-dash-case).\\n     */\\n    RendererStyleFlags2[RendererStyleFlags2[\\\"DashCase\\\"] = 2] = \\\"DashCase\\\";\\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\\n/**\\n * Extend this base class to implement custom rendering. By default, Angular\\n * renders a template into DOM. You can use custom rendering to intercept\\n * rendering calls, or to render to something other than DOM.\\n *\\n * Create your custom renderer using `RendererFactory2`.\\n *\\n * Use a custom renderer to bypass Angular's templating and\\n * make custom UI changes that can't be expressed declaratively.\\n * For example if you need to set a property or an attribute whose name is\\n * not statically known, use the `setProperty()` or\\n * `setAttribute()` method.\\n *\\n * @publicApi\\n */\\nvar Renderer2 = /** @class */ (function () {\\n    function Renderer2() {\\n    }\\n    /** @internal */\\n    Renderer2.__NG_ELEMENT_ID__ = function () { return R3_RENDERER2_FACTORY$1(); };\\n    return Renderer2;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar ComponentFactoryResolver$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentFactoryResolver$$1, _super);\\n    function ComponentFactoryResolver$$1() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    ComponentFactoryResolver$$1.prototype.resolveComponentFactory = function (component) {\\n        ngDevMode && assertComponentType(component);\\n        var componentDef = getComponentDef(component);\\n        return new ComponentFactory$1(componentDef);\\n    };\\n    return ComponentFactoryResolver$$1;\\n}(ComponentFactoryResolver));\\nfunction toRefArray(map) {\\n    var array = [];\\n    for (var nonMinified in map) {\\n        if (map.hasOwnProperty(nonMinified)) {\\n            var minified = map[nonMinified];\\n            array.push({ propName: minified, templateName: nonMinified });\\n        }\\n    }\\n    return array;\\n}\\n/**\\n * Default {@link RootContext} for all components rendered with {@link renderComponent}.\\n */\\nvar ROOT_CONTEXT = new InjectionToken('ROOT_CONTEXT_TOKEN', { providedIn: 'root', factory: function () { return createRootContext(inject(SCHEDULER)); } });\\n/**\\n * A change detection scheduler token for {@link RootContext}. This token is the default value used\\n * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\\n */\\nvar SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {\\n    providedIn: 'root',\\n    factory: function () {\\n        var useRaf = typeof requestAnimationFrame !== 'undefined' && typeof window !== 'undefined';\\n        return useRaf ? requestAnimationFrame.bind(window) : setTimeout;\\n    },\\n});\\n/**\\n * A function used to wrap the `RendererFactory2`.\\n * Used in tests to change the `RendererFactory2` into a `DebugRendererFactory2`.\\n */\\nvar WRAP_RENDERER_FACTORY2 = new InjectionToken('WRAP_RENDERER_FACTORY2');\\n/**\\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\\n */\\nvar ComponentFactory$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentFactory$$1, _super);\\n    function ComponentFactory$$1(componentDef) {\\n        var _this = _super.call(this) || this;\\n        _this.componentDef = componentDef;\\n        _this.componentType = componentDef.type;\\n        _this.selector = componentDef.selectors[0][0];\\n        _this.ngContentSelectors = [];\\n        return _this;\\n    }\\n    Object.defineProperty(ComponentFactory$$1.prototype, \\\"inputs\\\", {\\n        get: function () {\\n            return toRefArray(this.componentDef.inputs);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ComponentFactory$$1.prototype, \\\"outputs\\\", {\\n        get: function () {\\n            return toRefArray(this.componentDef.outputs);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ComponentFactory$$1.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\\n        var isInternalRootView = rootSelectorOrNode === undefined;\\n        var rendererFactory;\\n        if (ngModule) {\\n            var wrapper = ngModule.injector.get(WRAP_RENDERER_FACTORY2, function (v) { return v; });\\n            rendererFactory = wrapper(ngModule.injector.get(RendererFactory2));\\n        }\\n        else {\\n            rendererFactory = domRendererFactory3;\\n        }\\n        var hostRNode = isInternalRootView ?\\n            elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef)) :\\n            locateHostElement(rendererFactory, rootSelectorOrNode);\\n        // The first index of the first selector is the tag name.\\n        var componentTag = this.componentDef.selectors[0][0];\\n        var rootFlags = this.componentDef.onPush ? 4 /* Dirty */ | 64 /* IsRoot */ :\\n            2 /* CheckAlways */ | 64 /* IsRoot */;\\n        var rootContext = ngModule && !isInternalRootView ?\\n            ngModule.injector.get(ROOT_CONTEXT) :\\n            createRootContext(requestAnimationFrame.bind(window));\\n        var renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);\\n        // Create the root view. Uses empty TView and ContentTemplate.\\n        var rootView = createLViewData(renderer, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags);\\n        rootView[INJECTOR$1] = ngModule && ngModule.injector || null;\\n        // rootView is the parent when bootstrapping\\n        var oldView = enterView(rootView, null);\\n        var component;\\n        var tElementNode;\\n        try {\\n            if (rendererFactory.begin)\\n                rendererFactory.begin();\\n            var componentView = createRootComponentView(hostRNode, this.componentDef, rootView, renderer);\\n            tElementNode = getTNode(0, rootView);\\n            // Transform the arrays of native nodes into a structure that can be consumed by the\\n            // projection instruction. This is needed to support the reprojection of these nodes.\\n            if (projectableNodes) {\\n                var index = 0;\\n                var projection$$1 = tElementNode.projection = [];\\n                for (var i = 0; i < projectableNodes.length; i++) {\\n                    var nodeList = projectableNodes[i];\\n                    var firstTNode = null;\\n                    var previousTNode = null;\\n                    for (var j = 0; j < nodeList.length; j++) {\\n                        adjustBlueprintForNewNode(rootView);\\n                        var tNode = createNodeAtIndex(++index, 3 /* Element */, nodeList[j], null, null);\\n                        previousTNode ? (previousTNode.next = tNode) : (firstTNode = tNode);\\n                        previousTNode = tNode;\\n                    }\\n                    projection$$1.push(firstTNode);\\n                }\\n            }\\n            // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\\n            // executed here?\\n            // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\\n            component = createRootComponent(hostRNode, componentView, this.componentDef, rootView, rootContext, [LifecycleHooksFeature]);\\n            // Execute the template in creation mode only, and then turn off the CreationMode flag\\n            renderEmbeddedTemplate(componentView, componentView[TVIEW], component, 1 /* Create */);\\n            componentView[FLAGS] &= ~1 /* CreationMode */;\\n        }\\n        finally {\\n            enterView(oldView, null);\\n            if (rendererFactory.end)\\n                rendererFactory.end();\\n        }\\n        var componentRef = new ComponentRef$1(this.componentType, component, rootView, injector, createElementRef(ElementRef, tElementNode, rootView));\\n        if (isInternalRootView) {\\n            // The host element of the internal root view is attached to the component's host view node\\n            componentRef.hostView._tViewNode.child = tElementNode;\\n        }\\n        return componentRef;\\n    };\\n    return ComponentFactory$$1;\\n}(ComponentFactory));\\nvar componentFactoryResolver = new ComponentFactoryResolver$1();\\n/**\\n * Represents an instance of a Component created via a {@link ComponentFactory}.\\n *\\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\\n * method.\\n *\\n */\\nvar ComponentRef$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentRef$$1, _super);\\n    function ComponentRef$$1(componentType, instance, rootView, injector, location) {\\n        var _this = _super.call(this) || this;\\n        _this.location = location;\\n        _this.destroyCbs = [];\\n        _this.instance = instance;\\n        _this.hostView = _this.changeDetectorRef = new RootViewRef(rootView);\\n        _this.hostView._tViewNode = createViewNode(-1, rootView);\\n        _this.injector = injector;\\n        _this.componentType = componentType;\\n        return _this;\\n    }\\n    ComponentRef$$1.prototype.destroy = function () {\\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\\n        this.destroyCbs.forEach(function (fn) { return fn(); });\\n        this.destroyCbs = null;\\n    };\\n    ComponentRef$$1.prototype.onDestroy = function (callback) {\\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\\n        this.destroyCbs.push(callback);\\n    };\\n    return ComponentRef$$1;\\n}(ComponentRef));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar i18nTagRegex = /{\\\\$([^}]+)}/g;\\n/**\\n * Takes a translation string, the initial list of placeholders (elements and expressions) and the\\n * indexes of their corresponding expression nodes to return a list of instructions for each\\n * template function.\\n *\\n * Because embedded templates have different indexes for each placeholder, each parameter (except\\n * the translation) is an array, where each value corresponds to a different template, by order of\\n * appearance.\\n *\\n * @param translation A translation string where placeholders are represented by `{$name}`\\n * @param elements An array containing, for each template, the maps of element placeholders and\\n * their indexes.\\n * @param expressions An array containing, for each template, the maps of expression placeholders\\n * and their indexes.\\n * @param templateRoots An array of template roots whose content should be ignored when\\n * generating the instructions for their parent template.\\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\\n * an ng-container.\\n *\\n * @returns A list of instructions used to translate each template.\\n */\\nfunction i18nMapping(translation, elements, expressions, templateRoots, lastChildIndex) {\\n    var translationParts = translation.split(i18nTagRegex);\\n    var nbTemplates = templateRoots ? templateRoots.length + 1 : 1;\\n    var instructions = (new Array(nbTemplates)).fill(undefined);\\n    generateMappingInstructions(0, 0, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex);\\n    return instructions;\\n}\\n/**\\n * Internal function that reads the translation parts and generates a set of instructions for each\\n * template.\\n *\\n * See `i18nMapping()` for more details.\\n *\\n * @param tmplIndex The order of appearance of the template.\\n * 0 for the root template, following indexes match the order in `templateRoots`.\\n * @param partIndex The current index in `translationParts`.\\n * @param translationParts The translation string split into an array of placeholders and text\\n * elements.\\n * @param instructions The current list of instructions to update.\\n * @param elements An array containing, for each template, the maps of element placeholders and\\n * their indexes.\\n * @param expressions An array containing, for each template, the maps of expression placeholders\\n * and their indexes.\\n * @param templateRoots An array of template roots whose content should be ignored when\\n * generating the instructions for their parent template.\\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\\n * an ng-container.\\n *\\n * @returns the current index in `translationParts`\\n */\\nfunction generateMappingInstructions(tmplIndex, partIndex, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex) {\\n    var tmplInstructions = [];\\n    var phVisited = [];\\n    var openedTagCount = 0;\\n    var maxIndex = 0;\\n    var currentElements = elements && elements[tmplIndex] ? elements[tmplIndex] : null;\\n    var currentExpressions = expressions && expressions[tmplIndex] ? expressions[tmplIndex] : null;\\n    instructions[tmplIndex] = tmplInstructions;\\n    for (; partIndex < translationParts.length; partIndex++) {\\n        // The value can either be text or the name of a placeholder (element/template root/expression)\\n        var value = translationParts[partIndex];\\n        // Odd indexes are placeholders\\n        if (partIndex & 1) {\\n            var phIndex = void 0;\\n            if (currentElements && currentElements[value] !== undefined) {\\n                phIndex = currentElements[value];\\n                // The placeholder represents a DOM element, add an instruction to move it\\n                var templateRootIndex = templateRoots ? templateRoots.indexOf(value) : -1;\\n                if (templateRootIndex !== -1 && (templateRootIndex + 1) !== tmplIndex) {\\n                    // This is a template root, it has no closing tag, not treating it as an element\\n                    tmplInstructions.push(phIndex | -2147483648 /* TemplateRoot */);\\n                }\\n                else {\\n                    tmplInstructions.push(phIndex | 1073741824 /* Element */);\\n                    openedTagCount++;\\n                }\\n                phVisited.push(value);\\n            }\\n            else if (currentExpressions && currentExpressions[value] !== undefined) {\\n                phIndex = currentExpressions[value];\\n                // The placeholder represents an expression, add an instruction to move it\\n                tmplInstructions.push(phIndex | 1610612736 /* Expression */);\\n                phVisited.push(value);\\n            }\\n            else {\\n                // It is a closing tag\\n                tmplInstructions.push(-1073741824 /* CloseNode */);\\n                if (tmplIndex > 0) {\\n                    openedTagCount--;\\n                    // If we have reached the closing tag for this template, exit the loop\\n                    if (openedTagCount === 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (phIndex !== undefined && phIndex > maxIndex) {\\n                maxIndex = phIndex;\\n            }\\n            if (templateRoots) {\\n                var newTmplIndex = templateRoots.indexOf(value) + 1;\\n                if (newTmplIndex !== 0 && newTmplIndex !== tmplIndex) {\\n                    partIndex = generateMappingInstructions(newTmplIndex, partIndex, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex);\\n                }\\n            }\\n        }\\n        else if (value) {\\n            // It's a non-empty string, create a text node\\n            tmplInstructions.push(536870912 /* Text */, value);\\n        }\\n    }\\n    // Add instructions to remove elements that are not used in the translation\\n    if (elements) {\\n        var tmplElements = elements[tmplIndex];\\n        if (tmplElements) {\\n            var phKeys = Object.keys(tmplElements);\\n            for (var i = 0; i < phKeys.length; i++) {\\n                var ph = phKeys[i];\\n                if (phVisited.indexOf(ph) === -1) {\\n                    var index = tmplElements[ph];\\n                    // Add an instruction to remove the element\\n                    tmplInstructions.push(index | -536870912 /* RemoveNode */);\\n                    if (index > maxIndex) {\\n                        maxIndex = index;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    // Add instructions to remove expressions that are not used in the translation\\n    if (expressions) {\\n        var tmplExpressions = expressions[tmplIndex];\\n        if (tmplExpressions) {\\n            var phKeys = Object.keys(tmplExpressions);\\n            for (var i = 0; i < phKeys.length; i++) {\\n                var ph = phKeys[i];\\n                if (phVisited.indexOf(ph) === -1) {\\n                    var index = tmplExpressions[ph];\\n                    if (ngDevMode) {\\n                        assertLessThan(index.toString(2).length, 28, \\\"Index \\\" + index + \\\" is too big and will overflow\\\");\\n                    }\\n                    // Add an instruction to remove the expression\\n                    tmplInstructions.push(index | -536870912 /* RemoveNode */);\\n                    if (index > maxIndex) {\\n                        maxIndex = index;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    if (tmplIndex === 0 && typeof lastChildIndex === 'number') {\\n        // The current parent is an ng-container and it has more children after the translation that we\\n        // need to append to keep the order of the DOM nodes correct\\n        for (var i = maxIndex + 1; i <= lastChildIndex; i++) {\\n            if (ngDevMode) {\\n                assertLessThan(i.toString(2).length, 28, \\\"Index \\\" + i + \\\" is too big and will overflow\\\");\\n            }\\n            tmplInstructions.push(i | -1610612736 /* Any */);\\n        }\\n    }\\n    return partIndex;\\n}\\nfunction appendI18nNode(tNode, parentTNode, previousTNode) {\\n    if (ngDevMode) {\\n        ngDevMode.rendererMoveNode++;\\n    }\\n    var viewData = _getViewData();\\n    // On first pass, re-organize node tree to put this node in the correct position.\\n    var firstTemplatePass = viewData[TVIEW].firstTemplatePass;\\n    if (firstTemplatePass) {\\n        if (previousTNode === parentTNode && tNode !== parentTNode.child) {\\n            tNode.next = parentTNode.child;\\n            parentTNode.child = tNode;\\n        }\\n        else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\\n            tNode.next = previousTNode.next;\\n            previousTNode.next = tNode;\\n        }\\n        else {\\n            tNode.next = null;\\n        }\\n        if (parentTNode !== viewData[HOST_NODE]) {\\n            tNode.parent = parentTNode;\\n        }\\n    }\\n    appendChild(getNativeByTNode(tNode, viewData), tNode, viewData);\\n    var slotValue = viewData[tNode.index];\\n    if (tNode.type !== 0 /* Container */ && isLContainer(slotValue)) {\\n        // Nodes that inject ViewContainerRef also have a comment node that should be moved\\n        appendChild(slotValue[NATIVE], tNode, viewData);\\n    }\\n    return tNode;\\n}\\nfunction i18nAttribute(index, attrs) {\\n    // placeholder for i18nAttribute function\\n}\\nfunction i18nExp(expression) {\\n    // placeholder for i18nExp function\\n}\\nfunction i18nStart(index, message, subTemplateIndex) {\\n    if (subTemplateIndex === void 0) { subTemplateIndex = 0; }\\n    // placeholder for i18nExp function\\n}\\nfunction i18nEnd() {\\n    // placeholder for i18nEnd function\\n}\\n/**\\n * Takes a list of instructions generated by `i18nMapping()` to transform the template accordingly.\\n *\\n * @param startIndex Index of the first element to translate (for instance the first child of the\\n * element with the i18n attribute).\\n * @param instructions The list of instructions to apply on the current view.\\n */\\nfunction i18nApply(startIndex, instructions) {\\n    var viewData = _getViewData();\\n    if (ngDevMode) {\\n        assertEqual(viewData[BINDING_INDEX], viewData[TVIEW].bindingStartIndex, 'i18nApply should be called before any binding');\\n    }\\n    if (!instructions) {\\n        return;\\n    }\\n    var renderer = getRenderer();\\n    var startTNode = getTNode(startIndex, viewData);\\n    var localParentTNode = startTNode.parent || viewData[HOST_NODE];\\n    var localPreviousTNode = localParentTNode;\\n    resetComponentState(); // We don't want to add to the tree with the wrong previous node\\n    for (var i = 0; i < instructions.length; i++) {\\n        var instruction = instructions[i];\\n        switch (instruction & -536870912 /* InstructionMask */) {\\n            case 1073741824 /* Element */:\\n                var elementTNode = getTNode(instruction & 536870911 /* IndexMask */, viewData);\\n                localPreviousTNode = appendI18nNode(elementTNode, localParentTNode, localPreviousTNode);\\n                localParentTNode = elementTNode;\\n                break;\\n            case 1610612736 /* Expression */:\\n            case -2147483648 /* TemplateRoot */:\\n            case -1610612736 /* Any */:\\n                var nodeIndex = instruction & 536870911 /* IndexMask */;\\n                localPreviousTNode =\\n                    appendI18nNode(getTNode(nodeIndex, viewData), localParentTNode, localPreviousTNode);\\n                break;\\n            case 536870912 /* Text */:\\n                if (ngDevMode) {\\n                    ngDevMode.rendererCreateTextNode++;\\n                }\\n                var value = instructions[++i];\\n                var textRNode = createTextNode(value, renderer);\\n                // If we were to only create a `RNode` then projections won't move the text.\\n                // Create text node at the current end of viewData. Must subtract header offset because\\n                // createNodeAtIndex takes a raw index (not adjusted by header offset).\\n                adjustBlueprintForNewNode(viewData);\\n                var textTNode = createNodeAtIndex(viewData.length - 1 - HEADER_OFFSET, 3 /* Element */, textRNode, null, null);\\n                localPreviousTNode = appendI18nNode(textTNode, localParentTNode, localPreviousTNode);\\n                resetComponentState();\\n                break;\\n            case -1073741824 /* CloseNode */:\\n                localPreviousTNode = localParentTNode;\\n                localParentTNode = localParentTNode.parent || viewData[HOST_NODE];\\n                break;\\n            case -536870912 /* RemoveNode */:\\n                if (ngDevMode) {\\n                    ngDevMode.rendererRemoveNode++;\\n                }\\n                var removeIndex = instruction & 536870911 /* IndexMask */;\\n                var removedElement = getNativeByIndex(removeIndex, viewData);\\n                var removedTNode = getTNode(removeIndex, viewData);\\n                removeChild(removedTNode, removedElement || null, viewData);\\n                var slotValue = load(removeIndex);\\n                if (isLContainer(slotValue)) {\\n                    var lContainer = slotValue;\\n                    if (removedTNode.type !== 0 /* Container */) {\\n                        removeChild(removedTNode, lContainer[NATIVE] || null, viewData);\\n                    }\\n                    removedTNode.detached = true;\\n                    lContainer[RENDER_PARENT] = null;\\n                }\\n                break;\\n        }\\n    }\\n}\\n/**\\n * Takes a translation string and the initial list of expressions and returns a list of instructions\\n * that will be used to translate an attribute.\\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\\n * value will be concatenated into the final translation.\\n */\\nfunction i18nExpMapping(translation, placeholders) {\\n    var staticText = translation.split(i18nTagRegex);\\n    // odd indexes are placeholders\\n    for (var i = 1; i < staticText.length; i += 2) {\\n        staticText[i] = placeholders[staticText[i]];\\n    }\\n    return staticText;\\n}\\n/**\\n * Checks if the value of an expression has changed and replaces it by its value in a translation,\\n * or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation1(instructions, v0) {\\n    var different = bindingUpdated(_getViewData()[BINDING_INDEX]++, v0);\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            res += stringify$1(v0);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 2 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation2(instructions, v0, v1) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\\n    viewData[BINDING_INDEX] += 2;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b1 ? v1 : v0;\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 3 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation3(instructions, v0, v1, v2) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\\n    viewData[BINDING_INDEX] += 3;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b2 ? v2 : (b1 ? v1 : v0);\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 4 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n * @param v3 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation4(instructions, v0, v1, v2, v3) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    viewData[BINDING_INDEX] += 4;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0);\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 5 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n * @param v3 value checked for change.\\n * @param v4 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation5(instructions, v0, v1, v2, v3, v4) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\\n    viewData[BINDING_INDEX] += 5;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b4 = idx & 4;\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b4 ? v4 : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 6 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n * @param v3 value checked for change.\\n * @param v4 value checked for change.\\n * @param v5 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */ function i18nInterpolation6(instructions, v0, v1, v2, v3, v4, v5) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\\n    viewData[BINDING_INDEX] += 6;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b4 = idx & 4;\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b4 ? (b1 ? v5 : v4) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 7 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n * @param v3 value checked for change.\\n * @param v4 value checked for change.\\n * @param v5 value checked for change.\\n * @param v6 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation7(instructions, v0, v1, v2, v3, v4, v5, v6) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\\n    viewData[BINDING_INDEX] += 7;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b4 = idx & 4;\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b4 ? (b2 ? v6 : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Checks if the values of up to 8 expressions have changed and replaces them by their values in a\\n * translation, or returns NO_CHANGE.\\n *\\n * @param instructions A list of instructions that will be used to translate an attribute.\\n * @param v0 value checked for change.\\n * @param v1 value checked for change.\\n * @param v2 value checked for change.\\n * @param v3 value checked for change.\\n * @param v4 value checked for change.\\n * @param v5 value checked for change.\\n * @param v6 value checked for change.\\n * @param v7 value checked for change.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolation8(instructions, v0, v1, v2, v3, v4, v5, v6, v7) {\\n    var viewData = _getViewData();\\n    var different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\\n    different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\\n    viewData[BINDING_INDEX] += 8;\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are bindings\\n        if (i & 1) {\\n            // Extract bits\\n            var idx = instructions[i];\\n            var b4 = idx & 4;\\n            var b2 = idx & 2;\\n            var b1 = idx & 1;\\n            // Get the value from the argument vx where x = idx\\n            var value = b4 ? (b2 ? (b1 ? v7 : v6) : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\\n            res += stringify$1(value);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n/**\\n * Create a translated interpolation binding with a variable number of expressions.\\n *\\n * If there are 1 to 8 expressions then `i18nInterpolation()` should be used instead. It is faster\\n * because there is no need to create an array of expressions and iterate over it.\\n *\\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\\n */\\nfunction i18nInterpolationV(instructions, values) {\\n    var viewData = _getViewData();\\n    var different = false;\\n    for (var i = 0; i < values.length; i++) {\\n        // Check if bindings have changed\\n        bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\\n    }\\n    if (!different) {\\n        return NO_CHANGE;\\n    }\\n    var res = '';\\n    for (var i = 0; i < instructions.length; i++) {\\n        // Odd indexes are placeholders\\n        if (i & 1) {\\n            res += stringify$1(values[instructions[i]]);\\n        }\\n        else {\\n            res += instructions[i];\\n        }\\n    }\\n    return res;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * An internal token whose presence in an injector indicates that the injector should treat itself\\n * as a root scoped injector when processing requests for unknown tokens which may indicate\\n * they are provided in the root scope.\\n */\\nvar APP_ROOT = new InjectionToken('The presence of this token marks an injector as being the root injector.');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Marker which indicates that a value has not yet been created from the factory function.\\n */\\nvar NOT_YET = {};\\n/**\\n * Marker which indicates that the factory function for a token is in the process of being called.\\n *\\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\\n * injection of a dependency has recursively attempted to inject the original token, and there is\\n * a circular dependency among the providers.\\n */\\nvar CIRCULAR$2 = {};\\nvar EMPTY_ARRAY$1 = [];\\n/**\\n * A lazily initialized NullInjector.\\n */\\nvar NULL_INJECTOR$2 = undefined;\\nfunction getNullInjector() {\\n    if (NULL_INJECTOR$2 === undefined) {\\n        NULL_INJECTOR$2 = new NullInjector();\\n    }\\n    return NULL_INJECTOR$2;\\n}\\n/**\\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\\n *\\n * @publicApi\\n */\\nfunction createInjector(defType, parent, additionalProviders) {\\n    if (parent === void 0) { parent = null; }\\n    if (additionalProviders === void 0) { additionalProviders = null; }\\n    parent = parent || getNullInjector();\\n    return new R3Injector(defType, additionalProviders, parent);\\n}\\nvar R3Injector = /** @class */ (function () {\\n    function R3Injector(def, additionalProviders, parent) {\\n        var _this = this;\\n        this.parent = parent;\\n        /**\\n         * Map of tokens to records which contain the instances of those tokens.\\n         */\\n        this.records = new Map();\\n        /**\\n         * The transitive set of `InjectorType`s which define this injector.\\n         */\\n        this.injectorDefTypes = new Set();\\n        /**\\n         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\\n         */\\n        this.onDestroy = new Set();\\n        /**\\n         * Flag indicating that this injector was previously destroyed.\\n         */\\n        this.destroyed = false;\\n        // Start off by creating Records for every provider declared in every InjectorType\\n        // included transitively in `def`.\\n        deepForEach([def], function (injectorDef) { return _this.processInjectorType(injectorDef, new Set()); });\\n        additionalProviders &&\\n            deepForEach(additionalProviders, function (provider) { return _this.processProvider(provider); });\\n        // Make sure the INJECTOR token provides this injector.\\n        this.records.set(INJECTOR, makeRecord(undefined, this));\\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\\n        // any injectable scoped to APP_ROOT_SCOPE.\\n        this.isRootInjector = this.records.has(APP_ROOT);\\n        // Eagerly instantiate the InjectorType classes themselves.\\n        this.injectorDefTypes.forEach(function (defType) { return _this.get(defType); });\\n    }\\n    /**\\n     * Destroy the injector and release references to every instance or provider associated with it.\\n     *\\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\\n     * hook was found.\\n     */\\n    R3Injector.prototype.destroy = function () {\\n        this.assertNotDestroyed();\\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\\n        this.destroyed = true;\\n        try {\\n            // Call all the lifecycle hooks.\\n            this.onDestroy.forEach(function (service) { return service.ngOnDestroy(); });\\n        }\\n        finally {\\n            // Release all references.\\n            this.records.clear();\\n            this.onDestroy.clear();\\n            this.injectorDefTypes.clear();\\n        }\\n    };\\n    R3Injector.prototype.get = function (token, notFoundValue, flags) {\\n        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\\n        if (flags === void 0) { flags = 0 /* Default */; }\\n        this.assertNotDestroyed();\\n        // Set the injection context.\\n        var previousInjector = setCurrentInjector(this);\\n        try {\\n            // Check for the SkipSelf flag.\\n            if (!(flags & 4 /* SkipSelf */)) {\\n                // SkipSelf isn't set, check if the record belongs to this injector.\\n                var record = this.records.get(token);\\n                if (record === undefined) {\\n                    // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\\n                    // with a scope matching this injector.\\n                    var def = couldBeInjectableType(token) && getInjectableDef(token);\\n                    if (def && this.injectableDefInScope(def)) {\\n                        // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\\n                        // all along.\\n                        record = injectableDefRecord(token);\\n                        this.records.set(token, record);\\n                    }\\n                }\\n                // If a record was found, get the instance for it and return it.\\n                if (record !== undefined) {\\n                    return this.hydrate(token, record);\\n                }\\n            }\\n            // Select the next injector based on the Self flag - if self is set, the next injector is\\n            // the NullInjector, otherwise it's the parent.\\n            var next = !(flags & 2 /* Self */) ? this.parent : getNullInjector();\\n            return this.parent.get(token, notFoundValue);\\n        }\\n        finally {\\n            // Lastly, clean up the state by restoring the previous injector.\\n            setCurrentInjector(previousInjector);\\n        }\\n    };\\n    R3Injector.prototype.assertNotDestroyed = function () {\\n        if (this.destroyed) {\\n            throw new Error('Injector has already been destroyed.');\\n        }\\n    };\\n    /**\\n     * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\\n     * to this injector.\\n     */\\n    R3Injector.prototype.processInjectorType = function (defOrWrappedDef, parents) {\\n        var _this = this;\\n        defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\\n        // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\\n        // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\\n        // read, so care is taken to only do the read once.\\n        // First attempt to read the ngInjectorDef.\\n        var def = getInjectorDef(defOrWrappedDef);\\n        // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\\n        var ngModule = (def == null) && defOrWrappedDef.ngModule || undefined;\\n        // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\\n        // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\\n        // is the `ngModule`.\\n        var defType = (ngModule === undefined) ? defOrWrappedDef : ngModule;\\n        // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\\n        // extra providers.\\n        var providers = (ngModule !== undefined) && defOrWrappedDef.providers ||\\n            EMPTY_ARRAY$1;\\n        // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\\n        // `InjectorDef` is on its `ngModule`.\\n        if (ngModule !== undefined) {\\n            def = getInjectorDef(ngModule);\\n        }\\n        // If no definition was found, it might be from exports. Remove it.\\n        if (def == null) {\\n            return;\\n        }\\n        // Check for circular dependencies.\\n        if (parents.has(defType)) {\\n            throw new Error(\\\"Circular dependency: type \\\" + stringify(defType) + \\\" ends up importing itself.\\\");\\n        }\\n        // Track the InjectorType and add a provider for it.\\n        this.injectorDefTypes.add(defType);\\n        this.records.set(defType, makeRecord(def.factory));\\n        // Add providers in the same way that @NgModule resolution did:\\n        // First, include providers from any imports.\\n        if (def.imports != null) {\\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\\n            // up deeply importing itself, this can be detected.\\n            parents.add(defType);\\n            try {\\n                deepForEach(def.imports, function (imported) { return _this.processInjectorType(imported, parents); });\\n            }\\n            finally {\\n                // Remove it from the parents set when finished.\\n                parents.delete(defType);\\n            }\\n        }\\n        // Next, include providers listed on the definition itself.\\n        if (def.providers != null) {\\n            deepForEach(def.providers, function (provider) { return _this.processProvider(provider); });\\n        }\\n        // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\\n        deepForEach(providers, function (provider) { return _this.processProvider(provider); });\\n    };\\n    /**\\n     * Process a `SingleProvider` and add it.\\n     */\\n    R3Injector.prototype.processProvider = function (provider) {\\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\\n        // property.\\n        provider = resolveForwardRef(provider);\\n        var token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\\n        // Construct a `Record` for the provider.\\n        var record = providerToRecord(provider);\\n        if (!isTypeProvider(provider) && provider.multi === true) {\\n            // If the provider indicates that it's a multi-provider, process it specially.\\n            // First check whether it's been defined already.\\n            var multiRecord_1 = this.records.get(token);\\n            if (multiRecord_1) {\\n                // It has. Throw a nice error if\\n                if (multiRecord_1.multi === undefined) {\\n                    throw new Error(\\\"Mixed multi-provider for \\\" + token + \\\".\\\");\\n                }\\n            }\\n            else {\\n                multiRecord_1 = makeRecord(undefined, NOT_YET, true);\\n                multiRecord_1.factory = function () { return injectArgs(multiRecord_1.multi); };\\n                this.records.set(token, multiRecord_1);\\n            }\\n            token = provider;\\n            multiRecord_1.multi.push(provider);\\n        }\\n        else {\\n            var existing = this.records.get(token);\\n            if (existing && existing.multi !== undefined) {\\n                throw new Error(\\\"Mixed multi-provider for \\\" + stringify(token));\\n            }\\n        }\\n        this.records.set(token, record);\\n    };\\n    R3Injector.prototype.hydrate = function (token, record) {\\n        if (record.value === CIRCULAR$2) {\\n            throw new Error(\\\"Circular dep for \\\" + stringify(token));\\n        }\\n        else if (record.value === NOT_YET) {\\n            record.value = CIRCULAR$2;\\n            record.value = record.factory();\\n        }\\n        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\\n            this.onDestroy.add(record.value);\\n        }\\n        return record.value;\\n    };\\n    R3Injector.prototype.injectableDefInScope = function (def) {\\n        if (!def.providedIn) {\\n            return false;\\n        }\\n        else if (typeof def.providedIn === 'string') {\\n            return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\\n        }\\n        else {\\n            return this.injectorDefTypes.has(def.providedIn);\\n        }\\n    };\\n    return R3Injector;\\n}());\\nfunction injectableDefRecord(token) {\\n    var injectableDef = getInjectableDef(token);\\n    if (injectableDef === null) {\\n        if (token instanceof InjectionToken) {\\n            throw new Error(\\\"Token \\\" + stringify(token) + \\\" is missing an ngInjectableDef definition.\\\");\\n        }\\n        // TODO(alxhub): there should probably be a strict mode which throws here instead of assuming a\\n        // no-args constructor.\\n        return makeRecord(function () { return new token(); });\\n    }\\n    return makeRecord(injectableDef.factory);\\n}\\nfunction providerToRecord(provider) {\\n    var token = resolveForwardRef(provider);\\n    var value = NOT_YET;\\n    var factory = undefined;\\n    if (isTypeProvider(provider)) {\\n        return injectableDefRecord(provider);\\n    }\\n    else {\\n        token = resolveForwardRef(provider.provide);\\n        if (isValueProvider(provider)) {\\n            value = provider.useValue;\\n        }\\n        else if (isExistingProvider(provider)) {\\n            factory = function () { return inject(provider.useExisting); };\\n        }\\n        else if (isFactoryProvider(provider)) {\\n            factory = function () { return provider.useFactory.apply(provider, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(injectArgs(provider.deps || []))); };\\n        }\\n        else {\\n            var classRef_1 = provider.useClass || token;\\n            if (hasDeps(provider)) {\\n                factory = function () { return new ((classRef_1).bind.apply((classRef_1), Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], injectArgs(provider.deps))))(); };\\n            }\\n            else {\\n                return injectableDefRecord(classRef_1);\\n            }\\n        }\\n    }\\n    return makeRecord(factory, value);\\n}\\nfunction makeRecord(factory, value, multi) {\\n    if (value === void 0) { value = NOT_YET; }\\n    if (multi === void 0) { multi = false; }\\n    return {\\n        factory: factory,\\n        value: value,\\n        multi: multi ? [] : undefined,\\n    };\\n}\\nfunction deepForEach(input, fn) {\\n    input.forEach(function (value) { return Array.isArray(value) ? deepForEach(value, fn) : fn(value); });\\n}\\nfunction isValueProvider(value) {\\n    return USE_VALUE in value;\\n}\\nfunction isExistingProvider(value) {\\n    return !!value.useExisting;\\n}\\nfunction isFactoryProvider(value) {\\n    return !!value.useFactory;\\n}\\nfunction isTypeProvider(value) {\\n    return typeof value === 'function';\\n}\\nfunction hasDeps(value) {\\n    return !!value.deps;\\n}\\nfunction hasOnDestroy(value) {\\n    return typeof value === 'object' && value != null && value.ngOnDestroy &&\\n        typeof value.ngOnDestroy === 'function';\\n}\\nfunction couldBeInjectableType(value) {\\n    return (typeof value === 'function') ||\\n        (typeof value === 'object' && value instanceof InjectionToken);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar COMPONENT_FACTORY_RESOLVER = {\\n    provide: ComponentFactoryResolver,\\n    useFactory: function () { return new ComponentFactoryResolver$1(); },\\n    deps: [],\\n};\\nvar NgModuleRef$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(NgModuleRef$$1, _super);\\n    function NgModuleRef$$1(ngModuleType, parentInjector) {\\n        var _this = _super.call(this) || this;\\n        // tslint:disable-next-line:require-internal-with-underscore\\n        _this._bootstrapComponents = [];\\n        _this.destroyCbs = [];\\n        var ngModuleDef = getNgModuleDef(ngModuleType);\\n        ngDevMode && assertDefined(ngModuleDef, \\\"NgModule '\\\" + stringify(ngModuleType) + \\\"' is not a subtype of 'NgModuleType'.\\\");\\n        _this._bootstrapComponents = ngModuleDef.bootstrap;\\n        var additionalProviders = [\\n            COMPONENT_FACTORY_RESOLVER, {\\n                provide: NgModuleRef,\\n                useValue: _this,\\n            }\\n        ];\\n        _this.injector = createInjector(ngModuleType, parentInjector, additionalProviders);\\n        _this.instance = _this.injector.get(ngModuleType);\\n        _this.componentFactoryResolver = new ComponentFactoryResolver$1();\\n        return _this;\\n    }\\n    NgModuleRef$$1.prototype.destroy = function () {\\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\\n        this.destroyCbs.forEach(function (fn) { return fn(); });\\n        this.destroyCbs = null;\\n    };\\n    NgModuleRef$$1.prototype.onDestroy = function (callback) {\\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\\n        this.destroyCbs.push(callback);\\n    };\\n    return NgModuleRef$$1;\\n}(NgModuleRef));\\nvar NgModuleFactory$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(NgModuleFactory$$1, _super);\\n    function NgModuleFactory$$1(moduleType) {\\n        var _this = _super.call(this) || this;\\n        _this.moduleType = moduleType;\\n        return _this;\\n    }\\n    NgModuleFactory$$1.prototype.create = function (parentInjector) {\\n        return new NgModuleRef$1(this.moduleType, parentInjector);\\n    };\\n    return NgModuleFactory$$1;\\n}(NgModuleFactory));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Bindings for pure functions are stored after regular bindings.\\n *\\n * |------consts------|---------vars---------|                 |----- hostVars (dir1) ------|\\n * ------------------------------------------------------------------------------------------\\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\\n * ------------------------------------------------------------------------------------------\\n *                    ^                      ^\\n *      TView.bindingStartIndex      TView.expandoStartIndex\\n *\\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\\n * binding root gives the first index where the bindings are stored. In component views, the binding\\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\\n * any directive instances + any hostVars in directives evaluated before it.\\n *\\n * See VIEW_DATA.md for more information about host binding resolution.\\n */\\n/**\\n * If the value hasn't been saved, calls the pure function to store and return the\\n * value. If it has been saved, returns the saved value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn Function that returns a value\\n * @param thisArg Optional calling context of pureFn\\n * @returns value\\n */\\nfunction pureFunction0(slotOffset, pureFn, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    return getCreationMode() ?\\n        updateBinding(bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\\n        getBinding(bindingIndex);\\n}\\n/**\\n * If the value of the provided exp has changed, calls the pure function to return\\n * an updated value. Or if the value has not changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn Function that returns an updated value\\n * @param exp Updated expression value\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction1(slotOffset, pureFn, exp, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    return bindingUpdated(bindingIndex, exp) ?\\n        updateBinding(bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\\n        getBinding(bindingIndex + 1);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    return bindingUpdated2(bindingIndex, exp1, exp2) ?\\n        updateBinding(bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\\n        getBinding(bindingIndex + 2);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    return bindingUpdated3(bindingIndex, exp1, exp2, exp3) ?\\n        updateBinding(bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\\n        getBinding(bindingIndex + 3);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param exp4\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    return bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4) ?\\n        updateBinding(bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\\n        getBinding(bindingIndex + 4);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param exp4\\n * @param exp5\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    var different = bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4);\\n    return bindingUpdated(bindingIndex + 4, exp5) || different ?\\n        updateBinding(bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\\n            pureFn(exp1, exp2, exp3, exp4, exp5)) :\\n        getBinding(bindingIndex + 5);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param exp4\\n * @param exp5\\n * @param exp6\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    var different = bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4);\\n    return bindingUpdated2(bindingIndex + 4, exp5, exp6) || different ?\\n        updateBinding(bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\\n        getBinding(bindingIndex + 6);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param exp4\\n * @param exp5\\n * @param exp6\\n * @param exp7\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    var different = bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4);\\n    return bindingUpdated3(bindingIndex + 4, exp5, exp6, exp7) || different ?\\n        updateBinding(bindingIndex + 7, thisArg ?\\n            pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\\n        getBinding(bindingIndex + 7);\\n}\\n/**\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn\\n * @param exp1\\n * @param exp2\\n * @param exp3\\n * @param exp4\\n * @param exp5\\n * @param exp6\\n * @param exp7\\n * @param exp8\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    var different = bindingUpdated4(bindingIndex, exp1, exp2, exp3, exp4);\\n    return bindingUpdated4(bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\\n        updateBinding(bindingIndex + 8, thisArg ?\\n            pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\\n        getBinding(bindingIndex + 8);\\n}\\n/**\\n * pureFunction instruction that can support any number of bindings.\\n *\\n * If the value of any provided exp has changed, calls the pure function to return\\n * an updated value. Or if no values have changed, returns cached value.\\n *\\n * @param slotOffset the offset from binding root to the reserved slot\\n * @param pureFn A pure function that takes binding values and builds an object or array\\n * containing those values.\\n * @param exps An array of binding values\\n * @param thisArg Optional calling context of pureFn\\n * @returns Updated or cached value\\n */\\nfunction pureFunctionV(slotOffset, pureFn, exps, thisArg) {\\n    // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings\\n    var bindingIndex = getBindingRoot() + slotOffset;\\n    var different = false;\\n    for (var i = 0; i < exps.length; i++) {\\n        bindingUpdated(bindingIndex++, exps[i]) && (different = true);\\n    }\\n    return different ? updateBinding(bindingIndex, pureFn.apply(thisArg, exps)) :\\n        getBinding(bindingIndex);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Create a pipe.\\n *\\n * @param index Pipe index where the pipe will be stored.\\n * @param pipeName The name of the pipe\\n * @returns T the instance of the pipe.\\n */\\nfunction pipe(index, pipeName) {\\n    var tView = getTView();\\n    var pipeDef;\\n    var adjustedIndex = index + HEADER_OFFSET;\\n    if (tView.firstTemplatePass) {\\n        pipeDef = getPipeDef$1(pipeName, tView.pipeRegistry);\\n        tView.data[adjustedIndex] = pipeDef;\\n        if (pipeDef.onDestroy) {\\n            (tView.pipeDestroyHooks || (tView.pipeDestroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\\n        }\\n    }\\n    else {\\n        pipeDef = tView.data[adjustedIndex];\\n    }\\n    var pipeInstance = pipeDef.factory();\\n    store(index, pipeInstance);\\n    return pipeInstance;\\n}\\n/**\\n * Searches the pipe registry for a pipe with the given name. If one is found,\\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\\n *\\n * @param name Name of pipe to resolve\\n * @param registry Full list of available pipes\\n * @returns Matching PipeDef\\n */\\nfunction getPipeDef$1(name, registry) {\\n    if (registry) {\\n        for (var i = 0; i < registry.length; i++) {\\n            var pipeDef = registry[i];\\n            if (name === pipeDef.name) {\\n                return pipeDef;\\n            }\\n        }\\n    }\\n    throw new Error(\\\"Pipe with name '\\\" + name + \\\"' not found!\\\");\\n}\\n/**\\n * Invokes a pipe with 1 arguments.\\n *\\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\\n * the pipe only when an input to the pipe changes.\\n *\\n * @param index Pipe index where the pipe was stored on creation.\\n * @param slotOffset the offset in the reserved slot space\\n * @param v1 1st argument to {@link PipeTransform#transform}.\\n */\\nfunction pipeBind1(index, slotOffset, v1) {\\n    var pipeInstance = load(index);\\n    return isPure(index) ? pureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) :\\n        pipeInstance.transform(v1);\\n}\\n/**\\n * Invokes a pipe with 2 arguments.\\n *\\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\\n * the pipe only when an input to the pipe changes.\\n *\\n * @param index Pipe index where the pipe was stored on creation.\\n * @param slotOffset the offset in the reserved slot space\\n * @param v1 1st argument to {@link PipeTransform#transform}.\\n * @param v2 2nd argument to {@link PipeTransform#transform}.\\n */\\nfunction pipeBind2(index, slotOffset, v1, v2) {\\n    var pipeInstance = load(index);\\n    return isPure(index) ? pureFunction2(slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\\n        pipeInstance.transform(v1, v2);\\n}\\n/**\\n * Invokes a pipe with 3 arguments.\\n *\\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\\n * the pipe only when an input to the pipe changes.\\n *\\n * @param index Pipe index where the pipe was stored on creation.\\n * @param slotOffset the offset in the reserved slot space\\n * @param v1 1st argument to {@link PipeTransform#transform}.\\n * @param v2 2nd argument to {@link PipeTransform#transform}.\\n * @param v3 4rd argument to {@link PipeTransform#transform}.\\n */\\nfunction pipeBind3(index, slotOffset, v1, v2, v3) {\\n    var pipeInstance = load(index);\\n    return isPure(index) ?\\n        pureFunction3(slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\\n        pipeInstance.transform(v1, v2, v3);\\n}\\n/**\\n * Invokes a pipe with 4 arguments.\\n *\\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\\n * the pipe only when an input to the pipe changes.\\n *\\n * @param index Pipe index where the pipe was stored on creation.\\n * @param slotOffset the offset in the reserved slot space\\n * @param v1 1st argument to {@link PipeTransform#transform}.\\n * @param v2 2nd argument to {@link PipeTransform#transform}.\\n * @param v3 3rd argument to {@link PipeTransform#transform}.\\n * @param v4 4th argument to {@link PipeTransform#transform}.\\n */\\nfunction pipeBind4(index, slotOffset, v1, v2, v3, v4) {\\n    var pipeInstance = load(index);\\n    return isPure(index) ?\\n        pureFunction4(slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\\n        pipeInstance.transform(v1, v2, v3, v4);\\n}\\n/**\\n * Invokes a pipe with variable number of arguments.\\n *\\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\\n * the pipe only when an input to the pipe changes.\\n *\\n * @param index Pipe index where the pipe was stored on creation.\\n * @param slotOffset the offset in the reserved slot space\\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\\n */\\nfunction pipeBindV(index, slotOffset, values) {\\n    var pipeInstance = load(index);\\n    return isPure(index) ? pureFunctionV(slotOffset, pipeInstance.transform, values, pipeInstance) :\\n        pipeInstance.transform.apply(pipeInstance, values);\\n}\\nfunction isPure(index) {\\n    return getTView().data[index + HEADER_OFFSET].pure;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Use in directives and components to emit custom events synchronously\\n * or asynchronously, and register handlers for those events by subscribing\\n * to an instance.\\n *\\n * @usageNotes\\n *\\n * In the following example, a component defines two output properties\\n * that create event emitters. When the title is clicked, the emitter\\n * emits an open or close event to toggle the current visibility state.\\n *\\n * ```\\n * @Component({\\n *   selector: 'zippy',\\n *   template: `\\n *   <div class=\\\"zippy\\\">\\n *     <div (click)=\\\"toggle()\\\">Toggle</div>\\n *     <div [hidden]=\\\"!visible\\\">\\n *       <ng-content></ng-content>\\n *     </div>\\n *  </div>`})\\n * export class Zippy {\\n *   visible: boolean = true;\\n *   @Output() open: EventEmitter<any> = new EventEmitter();\\n *   @Output() close: EventEmitter<any> = new EventEmitter();\\n *\\n *   toggle() {\\n *     this.visible = !this.visible;\\n *     if (this.visible) {\\n *       this.open.emit(null);\\n *     } else {\\n *       this.close.emit(null);\\n *     }\\n *   }\\n * }\\n * ```\\n *\\n * Access the event object with the `$event` argument passed to the output event\\n * handler:\\n *\\n * ```\\n * <zippy (open)=\\\"onOpen($event)\\\" (close)=\\\"onClose($event)\\\"></zippy>\\n * ```\\n *\\n * ### Notes\\n *\\n * Uses Rx.Observable but provides an adapter to make it work as specified here:\\n * https://github.com/jhusain/observable-spec\\n *\\n * Once a reference implementation of the spec is available, switch to it.\\n *\\n * @publicApi\\n */\\nvar EventEmitter = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(EventEmitter, _super);\\n    /**\\n     * Creates an instance of this class that can\\n     * deliver events synchronously or asynchronously.\\n     *\\n     * @param isAsync When true, deliver events asynchronously.\\n     *\\n     */\\n    function EventEmitter(isAsync) {\\n        if (isAsync === void 0) { isAsync = false; }\\n        var _this = _super.call(this) || this;\\n        _this.__isAsync = isAsync;\\n        return _this;\\n    }\\n    /**\\n     * Emits an event containing a given value.\\n     * @param value The value to emit.\\n     */\\n    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\\n    /**\\n     * Registers handlers for events emitted by this instance.\\n     * @param generatorOrNext When supplied, a custom handler for emitted events.\\n     * @param error When supplied, a custom handler for an error notification\\n     * from this emitter.\\n     * @param complete When supplied, a custom handler for a completion\\n     * notification from this emitter.\\n     */\\n    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\\n        var schedulerFn;\\n        var errorFn = function (err) { return null; };\\n        var completeFn = function () { return null; };\\n        if (generatorOrNext && typeof generatorOrNext === 'object') {\\n            schedulerFn = this.__isAsync ? function (value) {\\n                setTimeout(function () { return generatorOrNext.next(value); });\\n            } : function (value) { generatorOrNext.next(value); };\\n            if (generatorOrNext.error) {\\n                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\\n                    function (err) { generatorOrNext.error(err); };\\n            }\\n            if (generatorOrNext.complete) {\\n                completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\\n                    function () { generatorOrNext.complete(); };\\n            }\\n        }\\n        else {\\n            schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :\\n                function (value) { generatorOrNext(value); };\\n            if (error) {\\n                errorFn =\\n                    this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\\n            }\\n            if (complete) {\\n                completeFn =\\n                    this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\\n            }\\n        }\\n        var sink = _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\\n        if (generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ \\\"a\\\"]) {\\n            generatorOrNext.add(sink);\\n        }\\n        return sink;\\n    };\\n    return EventEmitter;\\n}(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* Subject */ \\\"a\\\"]));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Represents an embedded template that can be used to instantiate embedded views.\\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\\n * method `createEmbeddedView()`.\\n *\\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\\n * is injected into the constructor of the directive,\\n * using the `TemplateRef` token.\\n *\\n * You can also use a `Query` to find a `TemplateRef` associated with\\n * a component or a directive.\\n *\\n * @see `ViewContainerRef`\\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\\n *\\n * @publicApi\\n */\\nvar TemplateRef = /** @class */ (function () {\\n    function TemplateRef() {\\n    }\\n    /** @internal */\\n    TemplateRef.__NG_ELEMENT_ID__ = function () { return R3_TEMPLATE_REF_FACTORY$1(TemplateRef, ElementRef); };\\n    return TemplateRef;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar LQueries_ = /** @class */ (function () {\\n    function LQueries_(parent, shallow, deep) {\\n        this.parent = parent;\\n        this.shallow = shallow;\\n        this.deep = deep;\\n    }\\n    LQueries_.prototype.track = function (queryList, predicate, descend, read) {\\n        if (descend) {\\n            this.deep = createQuery(this.deep, queryList, predicate, read != null ? read : null);\\n        }\\n        else {\\n            this.shallow = createQuery(this.shallow, queryList, predicate, read != null ? read : null);\\n        }\\n    };\\n    LQueries_.prototype.clone = function () { return new LQueries_(this, null, this.deep); };\\n    LQueries_.prototype.container = function () {\\n        var shallowResults = copyQueriesToContainer(this.shallow);\\n        var deepResults = copyQueriesToContainer(this.deep);\\n        return shallowResults || deepResults ? new LQueries_(this, shallowResults, deepResults) : null;\\n    };\\n    LQueries_.prototype.createView = function () {\\n        var shallowResults = copyQueriesToView(this.shallow);\\n        var deepResults = copyQueriesToView(this.deep);\\n        return shallowResults || deepResults ? new LQueries_(this, shallowResults, deepResults) : null;\\n    };\\n    LQueries_.prototype.insertView = function (index) {\\n        insertView$1(index, this.shallow);\\n        insertView$1(index, this.deep);\\n    };\\n    LQueries_.prototype.addNode = function (tNode) {\\n        add(this.deep, tNode);\\n        if (isContentQueryHost(tNode)) {\\n            add(this.shallow, tNode);\\n            if (tNode.parent && isContentQueryHost(tNode.parent)) {\\n                // if node has a content query and parent also has a content query\\n                // both queries need to check this node for shallow matches\\n                add(this.parent.shallow, tNode);\\n            }\\n            return this.parent;\\n        }\\n        isRootNodeOfQuery(tNode) && add(this.shallow, tNode);\\n        return this;\\n    };\\n    LQueries_.prototype.removeView = function () {\\n        removeView$1(this.shallow);\\n        removeView$1(this.deep);\\n    };\\n    return LQueries_;\\n}());\\nfunction isRootNodeOfQuery(tNode) {\\n    return tNode.parent === null || isContentQueryHost(tNode.parent);\\n}\\nfunction copyQueriesToContainer(query) {\\n    var result = null;\\n    while (query) {\\n        var containerValues = []; // prepare room for views\\n        query.values.push(containerValues);\\n        var clonedQuery = {\\n            next: result,\\n            list: query.list,\\n            predicate: query.predicate,\\n            values: containerValues,\\n            containerValues: null\\n        };\\n        result = clonedQuery;\\n        query = query.next;\\n    }\\n    return result;\\n}\\nfunction copyQueriesToView(query) {\\n    var result = null;\\n    while (query) {\\n        var clonedQuery = {\\n            next: result,\\n            list: query.list,\\n            predicate: query.predicate,\\n            values: [],\\n            containerValues: query.values\\n        };\\n        result = clonedQuery;\\n        query = query.next;\\n    }\\n    return result;\\n}\\nfunction insertView$1(index, query) {\\n    while (query) {\\n        ngDevMode &&\\n            assertDefined(query.containerValues, 'View queries need to have a pointer to container values.');\\n        query.containerValues.splice(index, 0, query.values);\\n        query = query.next;\\n    }\\n}\\nfunction removeView$1(query) {\\n    while (query) {\\n        ngDevMode &&\\n            assertDefined(query.containerValues, 'View queries need to have a pointer to container values.');\\n        var containerValues = query.containerValues;\\n        var viewValuesIdx = containerValues.indexOf(query.values);\\n        var removed = containerValues.splice(viewValuesIdx, 1);\\n        // mark a query as dirty only when removed view had matching modes\\n        ngDevMode && assertEqual(removed.length, 1, 'removed.length');\\n        if (removed[0].length) {\\n            query.list.setDirty();\\n        }\\n        query = query.next;\\n    }\\n}\\n/**\\n * Iterates over local names for a given node and returns directive index\\n * (or -1 if a local name points to an element).\\n *\\n * @param tNode static data of a node to check\\n * @param selector selector to match\\n * @returns directive index, -1 or null if a selector didn't match any of the local names\\n */\\nfunction getIdxOfMatchingSelector(tNode, selector) {\\n    var localNames = tNode.localNames;\\n    if (localNames) {\\n        for (var i = 0; i < localNames.length; i += 2) {\\n            if (localNames[i] === selector) {\\n                return localNames[i + 1];\\n            }\\n        }\\n    }\\n    return null;\\n}\\n/**\\n * Iterates over all the directives for a node and returns index of a directive for a given type.\\n *\\n * @param tNode TNode on which directives are present.\\n * @param currentView The view we are currently processing\\n * @param type Type of a directive to look for.\\n * @returns Index of a found directive or null when none found.\\n */\\nfunction getIdxOfMatchingDirective(tNode, currentView, type) {\\n    var defs = currentView[TVIEW].data;\\n    if (defs) {\\n        var flags = tNode.flags;\\n        var count = flags & 4095 /* DirectiveCountMask */;\\n        var start = flags >> 15 /* DirectiveStartingIndexShift */;\\n        var end = start + count;\\n        for (var i = start; i < end; i++) {\\n            var def = defs[i];\\n            if (def.type === type && def.diPublic) {\\n                return i;\\n            }\\n        }\\n    }\\n    return null;\\n}\\n// TODO: \\\"read\\\" should be an AbstractType (FW-486)\\nfunction queryRead(tNode, currentView, read) {\\n    var factoryFn = read[NG_ELEMENT_ID];\\n    if (typeof factoryFn === 'function') {\\n        return factoryFn();\\n    }\\n    else {\\n        var matchingIdx = getIdxOfMatchingDirective(tNode, currentView, read);\\n        if (matchingIdx !== null) {\\n            return currentView[matchingIdx];\\n        }\\n    }\\n    return null;\\n}\\nfunction queryReadByTNodeType(tNode, currentView) {\\n    if (tNode.type === 3 /* Element */ || tNode.type === 4 /* ElementContainer */) {\\n        return createElementRef(ElementRef, tNode, currentView);\\n    }\\n    if (tNode.type === 0 /* Container */) {\\n        return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);\\n    }\\n    return null;\\n}\\nfunction add(query, tNode) {\\n    var currentView = _getViewData();\\n    while (query) {\\n        var predicate = query.predicate;\\n        var type = predicate.type;\\n        if (type) {\\n            // if read token and / or strategy is not specified, use type as read token\\n            var result = queryRead(tNode, currentView, predicate.read || type);\\n            if (result !== null) {\\n                addMatch(query, result);\\n            }\\n        }\\n        else {\\n            var selector = predicate.selector;\\n            for (var i = 0; i < selector.length; i++) {\\n                var directiveIdx = getIdxOfMatchingSelector(tNode, selector[i]);\\n                if (directiveIdx !== null) {\\n                    var result = null;\\n                    if (predicate.read) {\\n                        result = queryRead(tNode, currentView, predicate.read);\\n                    }\\n                    else {\\n                        if (directiveIdx > -1) {\\n                            result = currentView[directiveIdx];\\n                        }\\n                        else {\\n                            // if read token and / or strategy is not specified,\\n                            // detect it using appropriate tNode type\\n                            result = queryReadByTNodeType(tNode, currentView);\\n                        }\\n                    }\\n                    if (result !== null) {\\n                        addMatch(query, result);\\n                    }\\n                }\\n            }\\n        }\\n        query = query.next;\\n    }\\n}\\nfunction addMatch(query, matchingValue) {\\n    query.values.push(matchingValue);\\n    query.list.setDirty();\\n}\\nfunction createPredicate(predicate, read) {\\n    var isArray = Array.isArray(predicate);\\n    return {\\n        type: isArray ? null : predicate,\\n        selector: isArray ? predicate : null,\\n        read: read\\n    };\\n}\\nfunction createQuery(previous, queryList, predicate, read) {\\n    return {\\n        next: previous,\\n        list: queryList,\\n        predicate: createPredicate(predicate, read),\\n        values: queryList._valuesTree,\\n        containerValues: null\\n    };\\n}\\nvar QueryList_ = /** @class */ (function () {\\n    function QueryList_() {\\n        this.dirty = true;\\n        this.changes = new EventEmitter();\\n        this._values = [];\\n        /** @internal */\\n        this._valuesTree = [];\\n    }\\n    Object.defineProperty(QueryList_.prototype, \\\"length\\\", {\\n        get: function () { return this._values.length; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(QueryList_.prototype, \\\"first\\\", {\\n        get: function () {\\n            var values = this._values;\\n            return values.length ? values[0] : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(QueryList_.prototype, \\\"last\\\", {\\n        get: function () {\\n            var values = this._values;\\n            return values.length ? values[values.length - 1] : null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * See\\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\\n     */\\n    QueryList_.prototype.map = function (fn) { return this._values.map(fn); };\\n    /**\\n     * See\\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\\n     */\\n    QueryList_.prototype.filter = function (fn) {\\n        return this._values.filter(fn);\\n    };\\n    /**\\n     * See\\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\\n     */\\n    QueryList_.prototype.find = function (fn) {\\n        return this._values.find(fn);\\n    };\\n    /**\\n     * See\\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\\n     */\\n    QueryList_.prototype.reduce = function (fn, init) {\\n        return this._values.reduce(fn, init);\\n    };\\n    /**\\n     * See\\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\\n     */\\n    QueryList_.prototype.forEach = function (fn) { this._values.forEach(fn); };\\n    /**\\n     * See\\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\\n     */\\n    QueryList_.prototype.some = function (fn) {\\n        return this._values.some(fn);\\n    };\\n    QueryList_.prototype.toArray = function () { return this._values.slice(0); };\\n    QueryList_.prototype[getSymbolIterator()] = function () { return this._values[getSymbolIterator()](); };\\n    QueryList_.prototype.toString = function () { return this._values.toString(); };\\n    QueryList_.prototype.reset = function (res) {\\n        this._values = flatten(res);\\n        this.dirty = false;\\n    };\\n    QueryList_.prototype.notifyOnChanges = function () { this.changes.emit(this); };\\n    QueryList_.prototype.setDirty = function () { this.dirty = true; };\\n    QueryList_.prototype.destroy = function () {\\n        this.changes.complete();\\n        this.changes.unsubscribe();\\n    };\\n    return QueryList_;\\n}());\\nvar QueryList = QueryList_;\\n/**\\n * Creates and returns a QueryList.\\n *\\n * @param memoryIndex The index in memory where the QueryList should be saved. If null,\\n * this is is a content query and the QueryList will be saved later through directiveCreate.\\n * @param predicate The type for which the query will search\\n * @param descend Whether or not to descend into children\\n * @param read What to save in the query\\n * @returns QueryList<T>\\n */\\nfunction query(memoryIndex, predicate, descend, \\n// TODO: \\\"read\\\" should be an AbstractType (FW-486)\\nread) {\\n    ngDevMode && assertPreviousIsParent();\\n    var queryList = new QueryList();\\n    var queries = getOrCreateCurrentQueries(LQueries_);\\n    queries.track(queryList, predicate, descend, read);\\n    storeCleanupWithContext(null, queryList, queryList.destroy);\\n    if (memoryIndex != null) {\\n        store(memoryIndex, queryList);\\n    }\\n    return queryList;\\n}\\n/**\\n * Refreshes a query by combining matches from all active views and removing matches from deleted\\n * views.\\n * Returns true if a query got dirty during change detection, false otherwise.\\n */\\nfunction queryRefresh(queryList) {\\n    var queryListImpl = queryList;\\n    if (queryList.dirty) {\\n        queryList.reset(queryListImpl._valuesTree);\\n        queryList.notifyOnChanges();\\n        return true;\\n    }\\n    return false;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\\n * `<ng-template>` element.\\n */\\nfunction templateRefExtractor(tNode, currentView) {\\n    return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar BRAND = '__SANITIZER_TRUSTED_BRAND__';\\nfunction allowSanitizationBypass(value, type) {\\n    return (value instanceof String && value[BRAND] === type) ? true : false;\\n}\\n/**\\n * Mark `html` string as trusted.\\n *\\n * This function wraps the trusted string in `String` and brands it in a way which makes it\\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\\n *\\n * @param trustedHtml `html` string which needs to be implicitly trusted.\\n * @returns a `html` `String` which has been branded to be implicitly trusted.\\n */\\nfunction bypassSanitizationTrustHtml(trustedHtml) {\\n    return bypassSanitizationTrustString(trustedHtml, \\\"Html\\\" /* Html */);\\n}\\n/**\\n * Mark `style` string as trusted.\\n *\\n * This function wraps the trusted string in `String` and brands it in a way which makes it\\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\\n *\\n * @param trustedStyle `style` string which needs to be implicitly trusted.\\n * @returns a `style` `String` which has been branded to be implicitly trusted.\\n */\\nfunction bypassSanitizationTrustStyle(trustedStyle) {\\n    return bypassSanitizationTrustString(trustedStyle, \\\"Style\\\" /* Style */);\\n}\\n/**\\n * Mark `script` string as trusted.\\n *\\n * This function wraps the trusted string in `String` and brands it in a way which makes it\\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\\n *\\n * @param trustedScript `script` string which needs to be implicitly trusted.\\n * @returns a `script` `String` which has been branded to be implicitly trusted.\\n */\\nfunction bypassSanitizationTrustScript(trustedScript) {\\n    return bypassSanitizationTrustString(trustedScript, \\\"Script\\\" /* Script */);\\n}\\n/**\\n * Mark `url` string as trusted.\\n *\\n * This function wraps the trusted string in `String` and brands it in a way which makes it\\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\\n *\\n * @param trustedUrl `url` string which needs to be implicitly trusted.\\n * @returns a `url` `String` which has been branded to be implicitly trusted.\\n */\\nfunction bypassSanitizationTrustUrl(trustedUrl) {\\n    return bypassSanitizationTrustString(trustedUrl, \\\"Url\\\" /* Url */);\\n}\\n/**\\n * Mark `url` string as trusted.\\n *\\n * This function wraps the trusted string in `String` and brands it in a way which makes it\\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\\n *\\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\\n * @returns a `url` `String` which has been branded to be implicitly trusted.\\n */\\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\\n    return bypassSanitizationTrustString(trustedResourceUrl, \\\"ResourceUrl\\\" /* ResourceUrl */);\\n}\\nfunction bypassSanitizationTrustString(trustedString, mode) {\\n    var trusted = new String(trustedString);\\n    trusted[BRAND] = mode;\\n    return trusted;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\\n *\\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\\n * please see [BAZEL.md](./docs/BAZEL.md).\\n */\\nvar _devMode = true;\\nvar _runModeLocked = false;\\n/**\\n * Returns whether Angular is in development mode. After called once,\\n * the value is locked and won't change any more.\\n *\\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\\n *\\n * @publicApi\\n */\\nfunction isDevMode() {\\n    _runModeLocked = true;\\n    return _devMode;\\n}\\n/**\\n * Disable Angular's development mode, which turns off assertions and other\\n * checks within the framework.\\n *\\n * One important assertion this disables verifies that a change detection pass\\n * does not result in additional changes to any bindings (also known as\\n * unidirectional data flow).\\n *\\n * @publicApi\\n */\\nfunction enableProdMode() {\\n    if (_runModeLocked) {\\n        throw new Error('Cannot enable prod mode after platform setup.');\\n    }\\n    _devMode = false;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\\n * that needs sanitizing.\\n * Depending upon browser support we must use one of three strategies for doing this.\\n * Support: Safari 10.x -> XHR strategy\\n * Support: Firefox -> DomParser strategy\\n * Default: InertDocument strategy\\n */\\nvar InertBodyHelper = /** @class */ (function () {\\n    function InertBodyHelper(defaultDoc) {\\n        this.defaultDoc = defaultDoc;\\n        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\\n        this.inertBodyElement = this.inertDocument.body;\\n        if (this.inertBodyElement == null) {\\n            // usually there should be only one body element in the document, but IE doesn't have any, so\\n            // we need to create one.\\n            var inertHtml = this.inertDocument.createElement('html');\\n            this.inertDocument.appendChild(inertHtml);\\n            this.inertBodyElement = this.inertDocument.createElement('body');\\n            inertHtml.appendChild(this.inertBodyElement);\\n        }\\n        this.inertBodyElement.innerHTML = '<svg><g onload=\\\"this.parentNode.remove()\\\"></g></svg>';\\n        if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\\n            // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\\n            // so use the XHR strategy.\\n            this.getInertBodyElement = this.getInertBodyElement_XHR;\\n            return;\\n        }\\n        this.inertBodyElement.innerHTML =\\n            '<svg><p><style><img src=\\\"</style><img src=x onerror=alert(1)//\\\">';\\n        if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\\n            // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\\n            // so use the DOMParser strategy, if it is available.\\n            // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\\n            // fall through to the default strategy below.\\n            if (isDOMParserAvailable()) {\\n                this.getInertBodyElement = this.getInertBodyElement_DOMParser;\\n                return;\\n            }\\n        }\\n        // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\\n        this.getInertBodyElement = this.getInertBodyElement_InertDocument;\\n    }\\n    /**\\n     * Use XHR to create and fill an inert body element (on Safari 10.1)\\n     * See\\n     * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\\n     */\\n    InertBodyHelper.prototype.getInertBodyElement_XHR = function (html) {\\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\\n        // `<head>` tag.\\n        html = '<body><remove></remove>' + html + '</body>';\\n        try {\\n            html = encodeURI(html);\\n        }\\n        catch (e) {\\n            return null;\\n        }\\n        var xhr = new XMLHttpRequest();\\n        xhr.responseType = 'document';\\n        xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\\n        xhr.send(undefined);\\n        var body = xhr.response.body;\\n        body.removeChild(body.firstChild);\\n        return body;\\n    };\\n    /**\\n     * Use DOMParser to create and fill an inert body element (on Firefox)\\n     * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\\n     *\\n     */\\n    InertBodyHelper.prototype.getInertBodyElement_DOMParser = function (html) {\\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\\n        // `<head>` tag.\\n        html = '<body><remove></remove>' + html + '</body>';\\n        try {\\n            var body = new window\\n                .DOMParser()\\n                .parseFromString(html, 'text/html')\\n                .body;\\n            body.removeChild(body.firstChild);\\n            return body;\\n        }\\n        catch (e) {\\n            return null;\\n        }\\n    };\\n    /**\\n     * Use an HTML5 `template` element, if supported, or an inert body element created via\\n     * `createHtmlDocument` to create and fill an inert DOM element.\\n     * This is the default sane strategy to use if the browser does not require one of the specialised\\n     * strategies above.\\n     */\\n    InertBodyHelper.prototype.getInertBodyElement_InertDocument = function (html) {\\n        // Prefer using <template> element if supported.\\n        var templateEl = this.inertDocument.createElement('template');\\n        if ('content' in templateEl) {\\n            templateEl.innerHTML = html;\\n            return templateEl;\\n        }\\n        this.inertBodyElement.innerHTML = html;\\n        // Support: IE 9-11 only\\n        // strip custom-namespaced attributes on IE<=11\\n        if (this.defaultDoc.documentMode) {\\n            this.stripCustomNsAttrs(this.inertBodyElement);\\n        }\\n        return this.inertBodyElement;\\n    };\\n    /**\\n     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\\n     * 'ns1:xlink:foo').\\n     *\\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\\n     * strips them all.\\n     */\\n    InertBodyHelper.prototype.stripCustomNsAttrs = function (el) {\\n        var elAttrs = el.attributes;\\n        // loop backwards so that we can support removals.\\n        for (var i = elAttrs.length - 1; 0 < i; i--) {\\n            var attrib = elAttrs.item(i);\\n            var attrName = attrib.name;\\n            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\\n                el.removeAttribute(attrName);\\n            }\\n        }\\n        var childNode = el.firstChild;\\n        while (childNode) {\\n            if (childNode.nodeType === Node.ELEMENT_NODE)\\n                this.stripCustomNsAttrs(childNode);\\n            childNode = childNode.nextSibling;\\n        }\\n    };\\n    return InertBodyHelper;\\n}());\\n/**\\n * We need to determine whether the DOMParser exists in the global context.\\n * The try-catch is because, on some browsers, trying to access this property\\n * on window can actually throw an error.\\n *\\n * @suppress {uselessCode}\\n */\\nfunction isDOMParserAvailable() {\\n    try {\\n        return !!window.DOMParser;\\n    }\\n    catch (e) {\\n        return false;\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\\n *\\n * This regular expression matches a subset of URLs that will not cause script\\n * execution if used in URL context within a HTML document. Specifically, this\\n * regular expression matches if (comment from here on and regex copied from\\n * Soy's EscapingConventions):\\n * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\\n * (2) or no protocol.  A protocol must be followed by a colon. The below\\n *     allows that by allowing colons only after one of the characters [/?#].\\n *     A colon after a hash (#) must be in the fragment.\\n *     Otherwise, a colon after a (?) must be in a query.\\n *     Otherwise, a colon after a single solidus (/) must be in a path.\\n *     Otherwise, a colon after a double solidus (//) must be in the authority\\n *     (before port).\\n *\\n * The pattern disallows &, used in HTML entity declarations before\\n * one of the characters in [/?#]. This disallows HTML entities used in the\\n * protocol name, which should never happen, e.g. \\\"h&#116;tp\\\" for \\\"http\\\".\\n * It also disallows HTML entities in the first path part of a relative path,\\n * e.g. \\\"foo&lt;bar/baz\\\".  Our existing escaping functions should not produce\\n * that. More importantly, it disallows masking of a colon,\\n * e.g. \\\"javascript&#58;...\\\".\\n *\\n * This regular expression was taken from the Closure sanitization library.\\n */\\nvar SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\\nvar DATA_URL_PATTERN = /^data:(?:image\\\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\\\/(?:mpeg|mp4|ogg|webm)|audio\\\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\\\/]+=*$/i;\\nfunction _sanitizeUrl(url) {\\n    url = String(url);\\n    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))\\n        return url;\\n    if (isDevMode()) {\\n        console.warn(\\\"WARNING: sanitizing unsafe URL value \\\" + url + \\\" (see http://g.co/ng/security#xss)\\\");\\n    }\\n    return 'unsafe:' + url;\\n}\\nfunction sanitizeSrcset(srcset) {\\n    srcset = String(srcset);\\n    return srcset.split(',').map(function (srcset) { return _sanitizeUrl(srcset.trim()); }).join(', ');\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction tagSet(tags) {\\n    var e_1, _a;\\n    var res = {};\\n    try {\\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __values */ \\\"h\\\"])(tags.split(',')), _c = _b.next(); !_c.done; _c = _b.next()) {\\n            var t = _c.value;\\n            res[t] = true;\\n        }\\n    }\\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n    finally {\\n        try {\\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\\n        }\\n        finally { if (e_1) throw e_1.error; }\\n    }\\n    return res;\\n}\\nfunction merge$1() {\\n    var sets = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        sets[_i] = arguments[_i];\\n    }\\n    var e_2, _a;\\n    var res = {};\\n    try {\\n        for (var sets_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __values */ \\\"h\\\"])(sets), sets_1_1 = sets_1.next(); !sets_1_1.done; sets_1_1 = sets_1.next()) {\\n            var s = sets_1_1.value;\\n            for (var v in s) {\\n                if (s.hasOwnProperty(v))\\n                    res[v] = true;\\n            }\\n        }\\n    }\\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\\n    finally {\\n        try {\\n            if (sets_1_1 && !sets_1_1.done && (_a = sets_1.return)) _a.call(sets_1);\\n        }\\n        finally { if (e_2) throw e_2.error; }\\n    }\\n    return res;\\n}\\n// Good source of info about elements and attributes\\n// http://dev.w3.org/html5/spec/Overview.html#semantics\\n// http://simon.html5.org/html-elements\\n// Safe Void Elements - HTML5\\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\\nvar VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\\n// Elements that you can, intentionally, leave open (and which close themselves)\\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\\nvar OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\\nvar OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\\nvar OPTIONAL_END_TAG_ELEMENTS = merge$1(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\\n// Safe Block Elements - HTML5\\nvar BLOCK_ELEMENTS = merge$1(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\\n    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\\n    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\\n// Inline Elements - HTML5\\nvar INLINE_ELEMENTS = merge$1(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\\n    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\\n    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\\nvar VALID_ELEMENTS = merge$1(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\\n// Attributes that have href and hence need to be sanitized\\nvar URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\\n// Attributes that have special href set hence need to be sanitized\\nvar SRCSET_ATTRS = tagSet('srcset');\\nvar HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\\n    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\\n    'valign,value,vspace,width');\\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\\n// innerHTML is required, SVG attributes should be added here.\\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\\n// are left out here.\\nvar VALID_ATTRS = merge$1(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);\\n/**\\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\\n * attributes.\\n */\\nvar SanitizingHtmlSerializer = /** @class */ (function () {\\n    function SanitizingHtmlSerializer() {\\n        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\\n        // because characters were re-encoded.\\n        this.sanitizedSomething = false;\\n        this.buf = [];\\n    }\\n    SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {\\n        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\\n        // However this code never accesses properties off of `document` before deleting its contents\\n        // again, so it shouldn't be vulnerable to DOM clobbering.\\n        var current = el.firstChild;\\n        while (current) {\\n            if (current.nodeType === Node.ELEMENT_NODE) {\\n                this.startElement(current);\\n            }\\n            else if (current.nodeType === Node.TEXT_NODE) {\\n                this.chars(current.nodeValue);\\n            }\\n            else {\\n                // Strip non-element, non-text nodes.\\n                this.sanitizedSomething = true;\\n            }\\n            if (current.firstChild) {\\n                current = current.firstChild;\\n                continue;\\n            }\\n            while (current) {\\n                // Leaving the element. Walk up and to the right, closing tags as we go.\\n                if (current.nodeType === Node.ELEMENT_NODE) {\\n                    this.endElement(current);\\n                }\\n                var next = this.checkClobberedElement(current, current.nextSibling);\\n                if (next) {\\n                    current = next;\\n                    break;\\n                }\\n                current = this.checkClobberedElement(current, current.parentNode);\\n            }\\n        }\\n        return this.buf.join('');\\n    };\\n    SanitizingHtmlSerializer.prototype.startElement = function (element) {\\n        var tagName = element.nodeName.toLowerCase();\\n        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\\n            this.sanitizedSomething = true;\\n            return;\\n        }\\n        this.buf.push('<');\\n        this.buf.push(tagName);\\n        var elAttrs = element.attributes;\\n        for (var i = 0; i < elAttrs.length; i++) {\\n            var elAttr = elAttrs.item(i);\\n            var attrName = elAttr.name;\\n            var lower = attrName.toLowerCase();\\n            if (!VALID_ATTRS.hasOwnProperty(lower)) {\\n                this.sanitizedSomething = true;\\n                continue;\\n            }\\n            var value = elAttr.value;\\n            // TODO(martinprobst): Special case image URIs for data:image/...\\n            if (URI_ATTRS[lower])\\n                value = _sanitizeUrl(value);\\n            if (SRCSET_ATTRS[lower])\\n                value = sanitizeSrcset(value);\\n            this.buf.push(' ', attrName, '=\\\"', encodeEntities(value), '\\\"');\\n        }\\n        this.buf.push('>');\\n    };\\n    SanitizingHtmlSerializer.prototype.endElement = function (current) {\\n        var tagName = current.nodeName.toLowerCase();\\n        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\\n            this.buf.push('</');\\n            this.buf.push(tagName);\\n            this.buf.push('>');\\n        }\\n    };\\n    SanitizingHtmlSerializer.prototype.chars = function (chars) { this.buf.push(encodeEntities(chars)); };\\n    SanitizingHtmlSerializer.prototype.checkClobberedElement = function (node, nextNode) {\\n        if (nextNode &&\\n            (node.compareDocumentPosition(nextNode) &\\n                Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\\n            throw new Error(\\\"Failed to sanitize html because the element is clobbered: \\\" + node.outerHTML);\\n        }\\n        return nextNode;\\n    };\\n    return SanitizingHtmlSerializer;\\n}());\\n// Regular Expressions for parsing tags and attributes\\nvar SURROGATE_PAIR_REGEXP = /[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]/g;\\n// ! to ~ is the ASCII range.\\nvar NON_ALPHANUMERIC_REGEXP = /([^\\\\#-~ |!])/g;\\n/**\\n * Escapes all potentially dangerous characters, so that the\\n * resulting string can be safely inserted into attribute or\\n * element text.\\n * @param value\\n */\\nfunction encodeEntities(value) {\\n    return value.replace(/&/g, '&amp;')\\n        .replace(SURROGATE_PAIR_REGEXP, function (match) {\\n        var hi = match.charCodeAt(0);\\n        var low = match.charCodeAt(1);\\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\\n    })\\n        .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })\\n        .replace(/</g, '&lt;')\\n        .replace(/>/g, '&gt;');\\n}\\nvar inertBodyHelper;\\n/**\\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\\n * the DOM in a browser environment.\\n */\\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\\n    var inertBodyElement = null;\\n    try {\\n        inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);\\n        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\\n        var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\\n        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\\n        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\\n        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\\n        var mXSSAttempts = 5;\\n        var parsedHtml = unsafeHtml;\\n        do {\\n            if (mXSSAttempts === 0) {\\n                throw new Error('Failed to sanitize html because the input is unstable');\\n            }\\n            mXSSAttempts--;\\n            unsafeHtml = parsedHtml;\\n            parsedHtml = inertBodyElement.innerHTML;\\n            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\\n        } while (unsafeHtml !== parsedHtml);\\n        var sanitizer = new SanitizingHtmlSerializer();\\n        var safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\\n        if (isDevMode() && sanitizer.sanitizedSomething) {\\n            console.warn('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');\\n        }\\n        return safeHtml;\\n    }\\n    finally {\\n        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\\n        if (inertBodyElement) {\\n            var parent_1 = getTemplateContent(inertBodyElement) || inertBodyElement;\\n            while (parent_1.firstChild) {\\n                parent_1.removeChild(parent_1.firstChild);\\n            }\\n        }\\n    }\\n}\\nfunction getTemplateContent(el) {\\n    return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ?\\n        el.content :\\n        null;\\n}\\nfunction isTemplateElement(el) {\\n    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\\n * handled.\\n *\\n * See DomSanitizer for more details on security in Angular applications.\\n *\\n * @publicApi\\n */\\nvar SecurityContext;\\n(function (SecurityContext) {\\n    SecurityContext[SecurityContext[\\\"NONE\\\"] = 0] = \\\"NONE\\\";\\n    SecurityContext[SecurityContext[\\\"HTML\\\"] = 1] = \\\"HTML\\\";\\n    SecurityContext[SecurityContext[\\\"STYLE\\\"] = 2] = \\\"STYLE\\\";\\n    SecurityContext[SecurityContext[\\\"SCRIPT\\\"] = 3] = \\\"SCRIPT\\\";\\n    SecurityContext[SecurityContext[\\\"URL\\\"] = 4] = \\\"URL\\\";\\n    SecurityContext[SecurityContext[\\\"RESOURCE_URL\\\"] = 5] = \\\"RESOURCE_URL\\\";\\n})(SecurityContext || (SecurityContext = {}));\\n/**\\n * Sanitizer is used by the views to sanitize potentially dangerous values.\\n *\\n * @publicApi\\n */\\nvar Sanitizer = /** @class */ (function () {\\n    function Sanitizer() {\\n    }\\n    return Sanitizer;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Regular expression for safe style values.\\n *\\n * Quotes (\\\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\\n *\\n * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\\n * font-family) and hence could allow multiple values to get injected, but that should pose no risk\\n * of XSS.\\n *\\n * The function expression checks only for XSS safety, not for CSS validity.\\n *\\n * This regular expression was taken from the Closure sanitization library, and augmented for\\n * transformation values.\\n */\\nvar VALUES = '[-,.\\\"\\\\'%_!# a-zA-Z0-9]+';\\nvar TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';\\nvar COLOR_FNS = '(?:rgb|hsl)a?';\\nvar GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\\nvar CSS3_FNS = '(?:calc|attr)';\\nvar FN_ARGS = '\\\\\\\\([-0-9.%, #a-zA-Z]+\\\\\\\\)';\\nvar SAFE_STYLE_VALUE = new RegExp(\\\"^(\\\" + VALUES + \\\"|\\\" +\\n    (\\\"(?:\\\" + TRANSFORMATION_FNS + \\\"|\\\" + COLOR_FNS + \\\"|\\\" + GRADIENTS + \\\"|\\\" + CSS3_FNS + \\\")\\\") +\\n    (FN_ARGS + \\\")$\\\"), 'g');\\n/**\\n * Matches a `url(...)` value with an arbitrary argument as long as it does\\n * not contain parentheses.\\n *\\n * The URL value still needs to be sanitized separately.\\n *\\n * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\\n * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\\n * by observing whether scroll bars are displayed, or character ranges used by a font face\\n * definition.\\n *\\n * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\\n * binding a URL value without further cooperation from the page will cause an information leak, and\\n * if so, it is just a leak, not a full blown XSS vulnerability.\\n *\\n * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\\n * code is permissive and allows URLs that sanitize otherwise.\\n */\\nvar URL_RE = /^url\\\\(([^)]+)\\\\)$/;\\n/**\\n * Checks that quotes (\\\" and ') are properly balanced inside a string. Assumes\\n * that neither escape (\\\\) nor any other character that could result in\\n * breaking out of a string parsing context are allowed;\\n * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\\n *\\n * This code was taken from the Closure sanitization library.\\n */\\nfunction hasBalancedQuotes(value) {\\n    var outsideSingle = true;\\n    var outsideDouble = true;\\n    for (var i = 0; i < value.length; i++) {\\n        var c = value.charAt(i);\\n        if (c === '\\\\'' && outsideDouble) {\\n            outsideSingle = !outsideSingle;\\n        }\\n        else if (c === '\\\"' && outsideSingle) {\\n            outsideDouble = !outsideDouble;\\n        }\\n    }\\n    return outsideSingle && outsideDouble;\\n}\\n/**\\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\\n * value) and returns a value that is safe to use in a browser environment.\\n */\\nfunction _sanitizeStyle(value) {\\n    value = String(value).trim(); // Make sure it's actually a string.\\n    if (!value)\\n        return '';\\n    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\\n    // reasoning behind this.\\n    var urlMatch = value.match(URL_RE);\\n    if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\\n        value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\\n        return value; // Safe style values.\\n    }\\n    if (isDevMode()) {\\n        console.warn(\\\"WARNING: sanitizing unsafe style value \\\" + value + \\\" (see http://g.co/ng/security#xss).\\\");\\n    }\\n    return 'unsafe';\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\\n * dangerous content.\\n *\\n * This method parses the `html` and locates potentially dangerous content (such as urls and\\n * javascript) and removes it.\\n *\\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\\n *\\n * @param unsafeHtml untrusted `html`, typically from the user.\\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\\n * and urls have been removed.\\n */\\nfunction sanitizeHtml(unsafeHtml) {\\n    var s = getCurrentSanitizer();\\n    if (s) {\\n        return s.sanitize(SecurityContext.HTML, unsafeHtml) || '';\\n    }\\n    if (allowSanitizationBypass(unsafeHtml, \\\"Html\\\" /* Html */)) {\\n        return unsafeHtml.toString();\\n    }\\n    return _sanitizeHtml(document, stringify$1(unsafeHtml));\\n}\\n/**\\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\\n * dangerous content.\\n *\\n * This method parses the `style` and locates potentially dangerous content (such as urls and\\n * javascript) and removes it.\\n *\\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\\n *\\n * @param unsafeStyle untrusted `style`, typically from the user.\\n * @returns `style` string which is safe to bind to the `style` properties, because all of the\\n * dangerous javascript and urls have been removed.\\n */\\nfunction sanitizeStyle(unsafeStyle) {\\n    var s = getCurrentSanitizer();\\n    if (s) {\\n        return s.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\\n    }\\n    if (allowSanitizationBypass(unsafeStyle, \\\"Style\\\" /* Style */)) {\\n        return unsafeStyle.toString();\\n    }\\n    return _sanitizeStyle(stringify$1(unsafeStyle));\\n}\\n/**\\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\\n * dangerous\\n * content.\\n *\\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\\n * removes it.\\n *\\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\\n *\\n * @param unsafeUrl untrusted `url`, typically from the user.\\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\\n * all of the dangerous javascript has been removed.\\n */\\nfunction sanitizeUrl(unsafeUrl) {\\n    var s = getCurrentSanitizer();\\n    if (s) {\\n        return s.sanitize(SecurityContext.URL, unsafeUrl) || '';\\n    }\\n    if (allowSanitizationBypass(unsafeUrl, \\\"Url\\\" /* Url */)) {\\n        return unsafeUrl.toString();\\n    }\\n    return _sanitizeUrl(stringify$1(unsafeUrl));\\n}\\n/**\\n * A `url` sanitizer which only lets trusted `url`s through.\\n *\\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\\n *\\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\\n * only trusted `url`s have been allowed to pass.\\n */\\nfunction sanitizeResourceUrl(unsafeResourceUrl) {\\n    var s = getCurrentSanitizer();\\n    if (s) {\\n        return s.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';\\n    }\\n    if (allowSanitizationBypass(unsafeResourceUrl, \\\"ResourceUrl\\\" /* ResourceUrl */)) {\\n        return unsafeResourceUrl.toString();\\n    }\\n    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\\n}\\n/**\\n * A `script` sanitizer which only lets trusted javascript through.\\n *\\n * This passes only `script`s marked trusted by calling {@link bypassSanitizationTrustScript}.\\n *\\n * @param unsafeScript untrusted `script`, typically from the user.\\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\\n * because only trusted `scripts`s have been allowed to pass.\\n */\\nfunction sanitizeScript(unsafeScript) {\\n    var s = getCurrentSanitizer();\\n    if (s) {\\n        return s.sanitize(SecurityContext.SCRIPT, unsafeScript) || '';\\n    }\\n    if (allowSanitizationBypass(unsafeScript, \\\"Script\\\" /* Script */)) {\\n        return unsafeScript.toString();\\n    }\\n    throw new Error('unsafe value used in a script context');\\n}\\n/**\\n * The default style sanitizer will handle sanitization for style properties by\\n * sanitizing any CSS property that can include a `url` value (usually image-based properties)\\n */\\nvar defaultStyleSanitizer = function (prop, value) {\\n    if (value === undefined) {\\n        return prop === 'background-image' || prop === 'background' || prop === 'border-image' ||\\n            prop === 'filter' || prop === 'filter' || prop === 'list-style' ||\\n            prop === 'list-style-image';\\n    }\\n    return sanitizeStyle(value);\\n};\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\\n *\\n * This should be kept up to date with the public exports of @angular/core.\\n */\\nvar angularCoreEnv = {\\n    'ɵdefineBase': defineBase,\\n    'ɵdefineComponent': defineComponent,\\n    'ɵdefineDirective': defineDirective,\\n    'defineInjectable': defineInjectable,\\n    'defineInjector': defineInjector,\\n    'ɵdefineNgModule': defineNgModule,\\n    'ɵdefinePipe': definePipe,\\n    'ɵdirectiveInject': directiveInject,\\n    'ɵgetFactoryOf': getFactoryOf,\\n    'ɵgetInheritedFactory': getInheritedFactory,\\n    'inject': inject,\\n    'ɵinjectAttribute': injectAttribute,\\n    'ɵtemplateRefExtractor': templateRefExtractor,\\n    'ɵNgOnChangesFeature': NgOnChangesFeature,\\n    'ɵPublicFeature': PublicFeature,\\n    'ɵInheritDefinitionFeature': InheritDefinitionFeature,\\n    'ɵelementAttribute': elementAttribute,\\n    'ɵbind': bind,\\n    'ɵcontainer': container,\\n    'ɵnextContext': nextContext,\\n    'ɵcontainerRefreshStart': containerRefreshStart,\\n    'ɵcontainerRefreshEnd': containerRefreshEnd,\\n    'ɵloadQueryList': loadQueryList,\\n    'ɵnamespaceHTML': namespaceHTML,\\n    'ɵnamespaceMathML': namespaceMathML,\\n    'ɵnamespaceSVG': namespaceSVG,\\n    'ɵenableBindings': enableBindings,\\n    'ɵdisableBindings': disableBindings,\\n    'ɵelementStart': elementStart,\\n    'ɵelementEnd': elementEnd,\\n    'ɵelement': element,\\n    'ɵEC': elementContainerStart,\\n    'ɵeC': elementContainerEnd,\\n    'ɵpureFunction0': pureFunction0,\\n    'ɵpureFunction1': pureFunction1,\\n    'ɵpureFunction2': pureFunction2,\\n    'ɵpureFunction3': pureFunction3,\\n    'ɵpureFunction4': pureFunction4,\\n    'ɵpureFunction5': pureFunction5,\\n    'ɵpureFunction6': pureFunction6,\\n    'ɵpureFunction7': pureFunction7,\\n    'ɵpureFunction8': pureFunction8,\\n    'ɵpureFunctionV': pureFunctionV,\\n    'ɵgetCurrentView': getCurrentView,\\n    'ɵrestoreView': restoreView,\\n    'ɵinterpolation1': interpolation1,\\n    'ɵinterpolation2': interpolation2,\\n    'ɵinterpolation3': interpolation3,\\n    'ɵinterpolation4': interpolation4,\\n    'ɵinterpolation5': interpolation5,\\n    'ɵinterpolation6': interpolation6,\\n    'ɵinterpolation7': interpolation7,\\n    'ɵinterpolation8': interpolation8,\\n    'ɵinterpolationV': interpolationV,\\n    'ɵelementClassProp': elementClassProp,\\n    'ɵlistener': listener,\\n    'ɵload': load,\\n    'ɵprojection': projection,\\n    'ɵelementProperty': elementProperty,\\n    'ɵpipeBind1': pipeBind1,\\n    'ɵpipeBind2': pipeBind2,\\n    'ɵpipeBind3': pipeBind3,\\n    'ɵpipeBind4': pipeBind4,\\n    'ɵpipeBindV': pipeBindV,\\n    'ɵprojectionDef': projectionDef,\\n    'ɵpipe': pipe,\\n    'ɵquery': query,\\n    'ɵqueryRefresh': queryRefresh,\\n    'ɵregisterContentQuery': registerContentQuery,\\n    'ɵreference': reference,\\n    'ɵelementStyling': elementStyling,\\n    'ɵelementStylingMap': elementStylingMap,\\n    'ɵelementStyleProp': elementStyleProp,\\n    'ɵelementStylingApply': elementStylingApply,\\n    'ɵtemplate': template,\\n    'ɵtext': text,\\n    'ɵtextBinding': textBinding,\\n    'ɵembeddedViewStart': embeddedViewStart,\\n    'ɵembeddedViewEnd': embeddedViewEnd,\\n    'ɵi18nAttribute': i18nAttribute,\\n    'ɵi18nExp': i18nExp,\\n    'ɵi18nStart': i18nStart,\\n    'ɵi18nEnd': i18nEnd,\\n    'ɵi18nApply': i18nApply,\\n    'ɵsanitizeHtml': sanitizeHtml,\\n    'ɵsanitizeStyle': sanitizeStyle,\\n    'ɵdefaultStyleSanitizer': defaultStyleSanitizer,\\n    'ɵsanitizeResourceUrl': sanitizeResourceUrl,\\n    'ɵsanitizeScript': sanitizeScript,\\n    'ɵsanitizeUrl': sanitizeUrl\\n};\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar _reflect = null;\\nfunction getReflect() {\\n    return (_reflect = _reflect || new ReflectionCapabilities());\\n}\\nfunction reflectDependencies(type) {\\n    return convertDependencies(getReflect().parameters(type));\\n}\\nfunction convertDependencies(deps) {\\n    var compiler = getCompilerFacade();\\n    return deps.map(function (dep) { return reflectDependency(compiler, dep); });\\n}\\nfunction reflectDependency(compiler, dep) {\\n    var meta = {\\n        token: null,\\n        host: false,\\n        optional: false,\\n        resolved: compiler.R3ResolvedDependencyType.Token,\\n        self: false,\\n        skipSelf: false,\\n    };\\n    function setTokenAndResolvedType(token) {\\n        meta.resolved = compiler.R3ResolvedDependencyType.Token;\\n        meta.token = token;\\n    }\\n    if (Array.isArray(dep)) {\\n        if (dep.length === 0) {\\n            throw new Error('Dependency array must have arguments.');\\n        }\\n        for (var j = 0; j < dep.length; j++) {\\n            var param = dep[j];\\n            if (param instanceof Optional || param.__proto__.ngMetadataName === 'Optional') {\\n                meta.optional = true;\\n            }\\n            else if (param instanceof SkipSelf || param.__proto__.ngMetadataName === 'SkipSelf') {\\n                meta.skipSelf = true;\\n            }\\n            else if (param instanceof Self || param.__proto__.ngMetadataName === 'Self') {\\n                meta.self = true;\\n            }\\n            else if (param instanceof Host || param.__proto__.ngMetadataName === 'Host') {\\n                meta.host = true;\\n            }\\n            else if (param instanceof Inject) {\\n                meta.token = param.token;\\n            }\\n            else if (param instanceof Attribute) {\\n                if (param.attributeName === undefined) {\\n                    throw new Error(\\\"Attribute name must be defined.\\\");\\n                }\\n                meta.token = param.attributeName;\\n                meta.resolved = compiler.R3ResolvedDependencyType.Attribute;\\n            }\\n            else {\\n                setTokenAndResolvedType(param);\\n            }\\n        }\\n    }\\n    else {\\n        setTokenAndResolvedType(dep);\\n    }\\n    return meta;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar EMPTY_ARRAY$2 = [];\\n/**\\n * Compiles a module in JIT mode.\\n *\\n * This function automatically gets called when a class has a `@NgModule` decorator.\\n */\\nfunction compileNgModule(moduleType, ngModule) {\\n    compileNgModuleDefs(moduleType, ngModule);\\n    setScopeOnDeclaredComponents(moduleType, ngModule);\\n}\\n/**\\n * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.\\n */\\nfunction compileNgModuleDefs(moduleType, ngModule) {\\n    var declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY$2);\\n    var ngModuleDef = null;\\n    Object.defineProperty(moduleType, NG_MODULE_DEF, {\\n        configurable: true,\\n        get: function () {\\n            if (ngModuleDef === null) {\\n                ngModuleDef = getCompilerFacade().compileNgModule(angularCoreEnv, \\\"ng://\\\" + moduleType.name + \\\"/ngModuleDef.js\\\", {\\n                    type: moduleType,\\n                    bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY$2),\\n                    declarations: declarations,\\n                    imports: flatten$1(ngModule.imports || EMPTY_ARRAY$2).map(expandModuleWithProviders),\\n                    exports: flatten$1(ngModule.exports || EMPTY_ARRAY$2).map(expandModuleWithProviders),\\n                    emitInline: true,\\n                });\\n            }\\n            return ngModuleDef;\\n        }\\n    });\\n    var ngInjectorDef = null;\\n    Object.defineProperty(moduleType, NG_INJECTOR_DEF, {\\n        get: function () {\\n            if (ngInjectorDef === null) {\\n                var meta = {\\n                    name: moduleType.name,\\n                    type: moduleType,\\n                    deps: reflectDependencies(moduleType),\\n                    providers: ngModule.providers || EMPTY_ARRAY$2,\\n                    imports: [\\n                        ngModule.imports || EMPTY_ARRAY$2,\\n                        ngModule.exports || EMPTY_ARRAY$2,\\n                    ],\\n                };\\n                ngInjectorDef = getCompilerFacade().compileInjector(angularCoreEnv, \\\"ng://\\\" + moduleType.name + \\\"/ngInjectorDef.js\\\", meta);\\n            }\\n            return ngInjectorDef;\\n        },\\n        // Make the property configurable in dev mode to allow overriding in tests\\n        configurable: !!ngDevMode,\\n    });\\n}\\n/**\\n * Some declared components may be compiled asynchronously, and thus may not have their\\n * ngComponentDef set yet. If this is the case, then a reference to the module is written into\\n * the `ngSelectorScope` property of the declared type.\\n */\\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\\n    var declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY$2);\\n    var transitiveScopes = transitiveScopesFor(moduleType);\\n    declarations.forEach(function (declaration) {\\n        if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {\\n            // An `ngComponentDef` field exists - go ahead and patch the component directly.\\n            var component = declaration;\\n            var componentDef = getComponentDef(component);\\n            patchComponentDefWithScope(componentDef, transitiveScopes);\\n        }\\n        else if (!declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\\n            // Set `ngSelectorScope` for future reference when the component compilation finishes.\\n            declaration.ngSelectorScope = moduleType;\\n        }\\n    });\\n}\\n/**\\n * Patch the definition of a component with directives and pipes from the compilation scope of\\n * a given module.\\n */\\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\\n    componentDef.directiveDefs = function () { return Array.from(transitiveScopes.compilation.directives)\\n        .map(function (dir) { return getDirectiveDef(dir) || getComponentDef(dir); })\\n        .filter(function (def) { return !!def; }); };\\n    componentDef.pipeDefs = function () {\\n        return Array.from(transitiveScopes.compilation.pipes).map(function (pipe) { return getPipeDef(pipe); });\\n    };\\n}\\n/**\\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\\n *\\n * This operation is memoized and the result is cached on the module's definition. It can be called\\n * on modules with components that have not fully compiled yet, but the result should not be used\\n * until they have.\\n */\\nfunction transitiveScopesFor(moduleType) {\\n    if (!isNgModule(moduleType)) {\\n        throw new Error(moduleType.name + \\\" does not have an ngModuleDef\\\");\\n    }\\n    var def = getNgModuleDef(moduleType);\\n    if (def.transitiveCompileScopes !== null) {\\n        return def.transitiveCompileScopes;\\n    }\\n    var scopes = {\\n        compilation: {\\n            directives: new Set(),\\n            pipes: new Set(),\\n        },\\n        exported: {\\n            directives: new Set(),\\n            pipes: new Set(),\\n        },\\n    };\\n    def.declarations.forEach(function (declared) {\\n        var declaredWithDefs = declared;\\n        if (getPipeDef(declaredWithDefs)) {\\n            scopes.compilation.pipes.add(declared);\\n        }\\n        else {\\n            // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't\\n            // had its template compiled yet. In either case, it gets added to the compilation's\\n            // directives.\\n            scopes.compilation.directives.add(declared);\\n        }\\n    });\\n    def.imports.forEach(function (imported) {\\n        var importedTyped = imported;\\n        if (!isNgModule(importedTyped)) {\\n            throw new Error(\\\"Importing \\\" + importedTyped.name + \\\" which does not have an ngModuleDef\\\");\\n        }\\n        // When this module imports another, the imported module's exported directives and pipes are\\n        // added to the compilation scope of this module.\\n        var importedScope = transitiveScopesFor(importedTyped);\\n        importedScope.exported.directives.forEach(function (entry) { return scopes.compilation.directives.add(entry); });\\n        importedScope.exported.pipes.forEach(function (entry) { return scopes.compilation.pipes.add(entry); });\\n    });\\n    def.exports.forEach(function (exported) {\\n        var exportedTyped = exported;\\n        // Either the type is a module, a pipe, or a component/directive (which may not have an\\n        // ngComponentDef as it might be compiled asynchronously).\\n        if (isNgModule(exportedTyped)) {\\n            // When this module exports another, the exported module's exported directives and pipes are\\n            // added to both the compilation and exported scopes of this module.\\n            var exportedScope = transitiveScopesFor(exportedTyped);\\n            exportedScope.exported.directives.forEach(function (entry) {\\n                scopes.compilation.directives.add(entry);\\n                scopes.exported.directives.add(entry);\\n            });\\n            exportedScope.exported.pipes.forEach(function (entry) {\\n                scopes.compilation.pipes.add(entry);\\n                scopes.exported.pipes.add(entry);\\n            });\\n        }\\n        else if (getNgModuleDef(exportedTyped)) {\\n            scopes.exported.pipes.add(exportedTyped);\\n        }\\n        else {\\n            scopes.exported.directives.add(exportedTyped);\\n        }\\n    });\\n    def.transitiveCompileScopes = scopes;\\n    return scopes;\\n}\\nfunction flatten$1(values) {\\n    var out = [];\\n    values.forEach(function (value) {\\n        if (Array.isArray(value)) {\\n            out.push.apply(out, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(flatten$1(value)));\\n        }\\n        else {\\n            out.push(value);\\n        }\\n    });\\n    return out;\\n}\\nfunction expandModuleWithProviders(value) {\\n    if (isModuleWithProviders(value)) {\\n        return value.ngModule;\\n    }\\n    return value;\\n}\\nfunction isModuleWithProviders(value) {\\n    return value.ngModule !== undefined;\\n}\\nfunction isNgModule(value) {\\n    return !!getNgModuleDef(value);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Compile an Angular component according to its decorator metadata, and patch the resulting\\n * ngComponentDef onto the component type.\\n *\\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\\n * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`\\n * until the global queue has been resolved with a call to `resolveComponentResources`.\\n */\\nfunction compileComponent(type, metadata) {\\n    var ngComponentDef = null;\\n    // Metadata may have resources which need to be resolved.\\n    maybeQueueResolutionOfComponentResources(metadata);\\n    Object.defineProperty(type, NG_COMPONENT_DEF, {\\n        get: function () {\\n            var compiler = getCompilerFacade();\\n            if (ngComponentDef === null) {\\n                if (componentNeedsResolution(metadata)) {\\n                    var error = [\\\"Component '\\\" + stringify(type) + \\\"' is not resolved:\\\"];\\n                    if (metadata.templateUrl) {\\n                        error.push(\\\" - templateUrl: \\\" + stringify(metadata.templateUrl));\\n                    }\\n                    if (metadata.styleUrls && metadata.styleUrls.length) {\\n                        error.push(\\\" - styleUrls: \\\" + JSON.stringify(metadata.styleUrls));\\n                    }\\n                    error.push(\\\"Did you run and wait for 'resolveComponentResources()'?\\\");\\n                    throw new Error(error.join('\\\\n'));\\n                }\\n                var meta = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({}, directiveMetadata(type, metadata), { template: metadata.template || '', preserveWhitespaces: metadata.preserveWhitespaces || false, styles: metadata.styles || EMPTY_ARRAY, animations: metadata.animations, viewQueries: extractQueriesMetadata(getReflect().propMetadata(type), isViewQuery), directives: new Map(), pipes: new Map(), encapsulation: metadata.encapsulation || ViewEncapsulation.Emulated, viewProviders: metadata.viewProviders || null });\\n                ngComponentDef = compiler.compileComponent(angularCoreEnv, \\\"ng://\\\" + stringify(type) + \\\"/template.html\\\", meta);\\n                // If component compilation is async, then the @NgModule annotation which declares the\\n                // component may execute and set an ngSelectorScope property on the component type. This\\n                // allows the component to patch itself with directiveDefs from the module after it\\n                // finishes compiling.\\n                if (hasSelectorScope(type)) {\\n                    var scopes = transitiveScopesFor(type.ngSelectorScope);\\n                    patchComponentDefWithScope(ngComponentDef, scopes);\\n                }\\n            }\\n            return ngComponentDef;\\n        },\\n        // Make the property configurable in dev mode to allow overriding in tests\\n        configurable: !!ngDevMode,\\n    });\\n}\\nfunction hasSelectorScope(component) {\\n    return component.ngSelectorScope !== undefined;\\n}\\n/**\\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\\n * ngDirectiveDef onto the component type.\\n *\\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\\n * will resolve when compilation completes and the directive becomes usable.\\n */\\nfunction compileDirective(type, directive) {\\n    var ngDirectiveDef = null;\\n    Object.defineProperty(type, NG_DIRECTIVE_DEF, {\\n        get: function () {\\n            if (ngDirectiveDef === null) {\\n                var facade = directiveMetadata(type, directive);\\n                ngDirectiveDef = getCompilerFacade().compileDirective(angularCoreEnv, \\\"ng://\\\" + (type && type.name) + \\\"/ngDirectiveDef.js\\\", facade);\\n            }\\n            return ngDirectiveDef;\\n        },\\n        // Make the property configurable in dev mode to allow overriding in tests\\n        configurable: !!ngDevMode,\\n    });\\n}\\nfunction extendsDirectlyFromObject(type) {\\n    return Object.getPrototypeOf(type.prototype) === Object.prototype;\\n}\\n/**\\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\\n * `Component`).\\n */\\nfunction directiveMetadata(type, metadata) {\\n    // Reflect inputs and outputs.\\n    var propMetadata = getReflect().propMetadata(type);\\n    return {\\n        name: type.name,\\n        type: type,\\n        typeArgumentCount: 0,\\n        selector: metadata.selector,\\n        deps: reflectDependencies(type),\\n        host: metadata.host || EMPTY_OBJ$1,\\n        propMetadata: propMetadata,\\n        inputs: metadata.inputs || EMPTY_ARRAY,\\n        outputs: metadata.outputs || EMPTY_ARRAY,\\n        queries: extractQueriesMetadata(propMetadata, isContentQuery),\\n        lifecycle: {\\n            usesOnChanges: type.prototype.ngOnChanges !== undefined,\\n        },\\n        typeSourceSpan: null,\\n        usesInheritance: !extendsDirectlyFromObject(type),\\n        exportAs: metadata.exportAs || null,\\n        providers: metadata.providers || null,\\n    };\\n}\\nvar EMPTY_OBJ$1 = {};\\nfunction convertToR3QueryPredicate(selector) {\\n    return typeof selector === 'string' ? splitByComma(selector) : selector;\\n}\\nfunction convertToR3QueryMetadata(propertyName, ann) {\\n    return {\\n        propertyName: propertyName,\\n        predicate: convertToR3QueryPredicate(ann.selector),\\n        descendants: ann.descendants,\\n        first: ann.first,\\n        read: ann.read ? ann.read : null\\n    };\\n}\\nfunction extractQueriesMetadata(propMetadata, isQueryAnn) {\\n    var queriesMeta = [];\\n    var _loop_1 = function (field) {\\n        if (propMetadata.hasOwnProperty(field)) {\\n            propMetadata[field].forEach(function (ann) {\\n                if (isQueryAnn(ann)) {\\n                    queriesMeta.push(convertToR3QueryMetadata(field, ann));\\n                }\\n            });\\n        }\\n    };\\n    for (var field in propMetadata) {\\n        _loop_1(field);\\n    }\\n    return queriesMeta;\\n}\\nfunction isContentQuery(value) {\\n    var name = value.ngMetadataName;\\n    return name === 'ContentChild' || name === 'ContentChildren';\\n}\\nfunction isViewQuery(value) {\\n    var name = value.ngMetadataName;\\n    return name === 'ViewChild' || name === 'ViewChildren';\\n}\\nfunction splitByComma(value) {\\n    return value.split(',').map(function (piece) { return piece.trim(); });\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\\n * `ngInjectableDef` onto the injectable type.\\n */\\nfunction compileInjectable(type, srcMeta) {\\n    var def = null;\\n    Object.defineProperty(type, NG_INJECTABLE_DEF, {\\n        get: function () {\\n            if (def === null) {\\n                var meta_1 = srcMeta || { providedIn: null };\\n                var hasAProvider = isUseClassProvider(meta_1) || isUseFactoryProvider(meta_1) ||\\n                    isUseValueProvider(meta_1) || isUseExistingProvider(meta_1);\\n                var compilerMeta = {\\n                    name: type.name,\\n                    type: type,\\n                    providedIn: meta_1.providedIn,\\n                    ctorDeps: reflectDependencies(type),\\n                    userDeps: undefined\\n                };\\n                if ((isUseClassProvider(meta_1) || isUseFactoryProvider(meta_1)) && meta_1.deps !== undefined) {\\n                    compilerMeta.userDeps = convertDependencies(meta_1.deps);\\n                }\\n                if (!hasAProvider) {\\n                    // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\\n                    // The deps will have been reflected above, causing the factory to create the class by\\n                    // calling\\n                    // its constructor with injected deps.\\n                    compilerMeta.useClass = type;\\n                }\\n                else if (isUseClassProvider(meta_1)) {\\n                    // The user explicitly specified useClass, and may or may not have provided deps.\\n                    compilerMeta.useClass = meta_1.useClass;\\n                }\\n                else if (isUseValueProvider(meta_1)) {\\n                    // The user explicitly specified useValue.\\n                    compilerMeta.useValue = meta_1.useValue;\\n                }\\n                else if (isUseFactoryProvider(meta_1)) {\\n                    // The user explicitly specified useFactory.\\n                    compilerMeta.useFactory = meta_1.useFactory;\\n                }\\n                else if (isUseExistingProvider(meta_1)) {\\n                    // The user explicitly specified useExisting.\\n                    compilerMeta.useExisting = meta_1.useExisting;\\n                }\\n                else {\\n                    // Can't happen - either hasAProvider will be false, or one of the providers will be set.\\n                    throw new Error(\\\"Unreachable state.\\\");\\n                }\\n                def = getCompilerFacade().compileInjectable(angularCoreEnv, \\\"ng://\\\" + type.name + \\\"/ngInjectableDef.js\\\", compilerMeta);\\n            }\\n            return def;\\n        },\\n    });\\n}\\nvar ɵ0$1 = getClosureSafeProperty;\\nvar USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: ɵ0$1 });\\nfunction isUseClassProvider(meta) {\\n    return meta.useClass !== undefined;\\n}\\nfunction isUseValueProvider(meta) {\\n    return USE_VALUE$1 in meta;\\n}\\nfunction isUseFactoryProvider(meta) {\\n    return meta.useFactory !== undefined;\\n}\\nfunction isUseExistingProvider(meta) {\\n    return meta.useExisting !== undefined;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction compilePipe(type, meta) {\\n    var ngPipeDef = null;\\n    Object.defineProperty(type, NG_PIPE_DEF, {\\n        get: function () {\\n            if (ngPipeDef === null) {\\n                ngPipeDef = getCompilerFacade().compilePipe(angularCoreEnv, \\\"ng://\\\" + stringify$1(type) + \\\"/ngPipeDef.js\\\", {\\n                    type: type,\\n                    name: type.name,\\n                    deps: reflectDependencies(type),\\n                    pipeName: meta.name,\\n                    pure: meta.pure !== undefined ? meta.pure : true\\n                });\\n            }\\n            return ngPipeDef;\\n        },\\n        // Make the property configurable in dev mode to allow overriding in tests\\n        configurable: !!ngDevMode,\\n    });\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar ivyEnabled = true;\\nvar R3_COMPILE_COMPONENT = compileComponent;\\nvar R3_COMPILE_DIRECTIVE = compileDirective;\\nvar R3_COMPILE_INJECTABLE = compileInjectable;\\nvar R3_COMPILE_NGMODULE = compileNgModule;\\nvar R3_COMPILE_PIPE = compilePipe;\\nvar R3_COMPILE_NGMODULE_DEFS = compileNgModuleDefs;\\nvar R3_PATCH_COMPONENT_DEF_WTIH_SCOPE = patchComponentDefWithScope;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction noop() { }\\nvar R3_COMPILE_COMPONENT__POST_NGCC__ = R3_COMPILE_COMPONENT;\\nvar R3_COMPILE_DIRECTIVE__POST_NGCC__ = R3_COMPILE_DIRECTIVE;\\nvar R3_COMPILE_INJECTABLE__POST_NGCC__ = R3_COMPILE_INJECTABLE;\\nvar R3_COMPILE_NGMODULE__POST_NGCC__ = R3_COMPILE_NGMODULE;\\nvar R3_COMPILE_PIPE__POST_NGCC__ = R3_COMPILE_PIPE;\\nvar ivyEnable__POST_NGCC__ = ivyEnabled;\\nvar R3_COMPILE_COMPONENT__PRE_NGCC__ = noop;\\nvar R3_COMPILE_DIRECTIVE__PRE_NGCC__ = noop;\\nvar R3_COMPILE_INJECTABLE__PRE_NGCC__ = preR3InjectableCompile;\\nvar R3_COMPILE_NGMODULE__PRE_NGCC__ = preR3NgModuleCompile;\\nvar R3_COMPILE_PIPE__PRE_NGCC__ = noop;\\nvar ivyEnable__PRE_NGCC__ = false;\\nvar ivyEnabled$1 = ivyEnable__PRE_NGCC__;\\nvar R3_COMPILE_COMPONENT$1 = R3_COMPILE_COMPONENT__PRE_NGCC__;\\nvar R3_COMPILE_DIRECTIVE$1 = R3_COMPILE_DIRECTIVE__PRE_NGCC__;\\nvar R3_COMPILE_INJECTABLE$1 = R3_COMPILE_INJECTABLE__PRE_NGCC__;\\nvar R3_COMPILE_NGMODULE$1 = R3_COMPILE_NGMODULE__PRE_NGCC__;\\nvar R3_COMPILE_PIPE$1 = R3_COMPILE_PIPE__PRE_NGCC__;\\n////////////////////////////////////////////////////////////\\n// Glue code which should be removed after Ivy is default //\\n////////////////////////////////////////////////////////////\\nfunction preR3NgModuleCompile(moduleType, metadata) {\\n    var imports = (metadata && metadata.imports) || [];\\n    if (metadata && metadata.exports) {\\n        imports = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(imports, [metadata.exports]);\\n    }\\n    moduleType.ngInjectorDef = defineInjector({\\n        factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),\\n        providers: metadata && metadata.providers,\\n        imports: imports,\\n    });\\n}\\nvar ɵ0$2 = getClosureSafeProperty;\\nvar USE_VALUE$2 = getClosureSafeProperty({ provide: String, useValue: ɵ0$2 });\\nvar EMPTY_ARRAY$3 = [];\\nfunction convertInjectableProviderToFactory(type, provider) {\\n    if (!provider) {\\n        var reflectionCapabilities = new ReflectionCapabilities();\\n        var deps_1 = reflectionCapabilities.parameters(type);\\n        // TODO - convert to flags.\\n        return function () { return new (type.bind.apply(type, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], injectArgs(deps_1))))(); };\\n    }\\n    if (USE_VALUE$2 in provider) {\\n        var valueProvider_1 = provider;\\n        return function () { return valueProvider_1.useValue; };\\n    }\\n    else if (provider.useExisting) {\\n        var existingProvider_1 = provider;\\n        return function () { return inject(existingProvider_1.useExisting); };\\n    }\\n    else if (provider.useFactory) {\\n        var factoryProvider_1 = provider;\\n        return function () { return factoryProvider_1.useFactory.apply(factoryProvider_1, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(injectArgs(factoryProvider_1.deps || EMPTY_ARRAY$3))); };\\n    }\\n    else if (provider.useClass) {\\n        var classProvider_1 = provider;\\n        var deps_2 = provider.deps;\\n        if (!deps_2) {\\n            var reflectionCapabilities = new ReflectionCapabilities();\\n            deps_2 = reflectionCapabilities.parameters(type);\\n        }\\n        return function () {\\n            var _a;\\n            return new ((_a = classProvider_1.useClass).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], injectArgs(deps_2))))();\\n        };\\n    }\\n    else {\\n        var deps_3 = provider.deps;\\n        if (!deps_3) {\\n            var reflectionCapabilities = new ReflectionCapabilities();\\n            deps_3 = reflectionCapabilities.parameters(type);\\n        }\\n        return function () { return new (type.bind.apply(type, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], injectArgs(deps_3))))(); };\\n    }\\n}\\n/**\\n * Supports @Injectable() in JIT mode for Render2.\\n */\\nfunction preR3InjectableCompile(injectableType, options) {\\n    if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {\\n        injectableType.ngInjectableDef = defineInjectable({\\n            providedIn: options.providedIn,\\n            factory: convertInjectableProviderToFactory(injectableType, options),\\n        });\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Type of the Directive metadata.\\n *\\n * @publicApi\\n */\\nvar Directive = makeDecorator('Directive', function (dir) {\\n    if (dir === void 0) { dir = {}; }\\n    return dir;\\n}, undefined, undefined, function (type, meta) { return R3_COMPILE_DIRECTIVE$1(type, meta); });\\n/**\\n * Component decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Component = makeDecorator('Component', function (c) {\\n    if (c === void 0) { c = {}; }\\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ changeDetection: ChangeDetectionStrategy.Default }, c));\\n}, Directive, undefined, function (type, meta) { return R3_COMPILE_COMPONENT$1(type, meta); });\\n/**\\n * @Annotation\\n * @publicApi\\n */\\nvar Pipe = makeDecorator('Pipe', function (p) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({ pure: true }, p)); }, undefined, undefined, function (type, meta) { return R3_COMPILE_PIPE$1(type, meta); });\\nvar initializeBaseDef = function (target) {\\n    var constructor = target.constructor;\\n    var inheritedBaseDef = constructor.ngBaseDef;\\n    var baseDef = constructor.ngBaseDef = {\\n        inputs: {},\\n        outputs: {},\\n        declaredInputs: {},\\n    };\\n    if (inheritedBaseDef) {\\n        fillProperties(baseDef.inputs, inheritedBaseDef.inputs);\\n        fillProperties(baseDef.outputs, inheritedBaseDef.outputs);\\n        fillProperties(baseDef.declaredInputs, inheritedBaseDef.declaredInputs);\\n    }\\n};\\n/**\\n * Does the work of creating the `ngBaseDef` property for the @Input and @Output decorators.\\n * @param key \\\"inputs\\\" or \\\"outputs\\\"\\n */\\nvar updateBaseDefFromIOProp = function (getProp) {\\n    return function (target, name) {\\n        var args = [];\\n        for (var _i = 2; _i < arguments.length; _i++) {\\n            args[_i - 2] = arguments[_i];\\n        }\\n        var constructor = target.constructor;\\n        if (!constructor.hasOwnProperty(NG_BASE_DEF)) {\\n            initializeBaseDef(target);\\n        }\\n        var baseDef = constructor.ngBaseDef;\\n        var defProp = getProp(baseDef);\\n        defProp[name] = args[0];\\n    };\\n};\\n/**\\n * @Annotation\\n * @publicApi\\n */\\nvar Input = makePropDecorator('Input', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); }, undefined, updateBaseDefFromIOProp(function (baseDef) { return baseDef.inputs || {}; }));\\n/**\\n * @Annotation\\n * @publicApi\\n */\\nvar Output = makePropDecorator('Output', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); }, undefined, updateBaseDefFromIOProp(function (baseDef) { return baseDef.outputs || {}; }));\\n/**\\n * @Annotation\\n * @publicApi\\n */\\nvar HostBinding = makePropDecorator('HostBinding', function (hostPropertyName) { return ({ hostPropertyName: hostPropertyName }); });\\n/**\\n * Binds a CSS event to a host listener and supplies configuration metadata.\\n * Angular invokes the supplied handler method when the host element emits the specified event,\\n * and updates the bound element with the result.\\n * If the handler method returns false, applies `preventDefault` on the bound element.\\n *\\n * @usageNotes\\n *\\n * The following example declares a directive\\n * that attaches a click listener to a button and counts clicks.\\n *\\n * ```\\n * @Directive({selector: 'button[counting]'})\\n * class CountClicks {\\n *   numberOfClicks = 0;\\n *\\n *   @HostListener('click', ['$event.target'])\\n *   onClick(btn) {\\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\\n *  }\\n * }\\n *\\n * @Component({\\n *   selector: 'app',\\n *   template: '<button counting>Increment</button>',\\n * })\\n * class App {}\\n * ```\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar HostListener = makePropDecorator('HostListener', function (eventName, args) { return ({ eventName: eventName, args: args }); });\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Defines a schema that allows an NgModule to contain the following:\\n * - Non-Angular elements named with dash case (`-`).\\n * - Element properties named with dash case (`-`).\\n * Dash case is the naming convention for custom elements.\\n *\\n * @publicApi\\n */\\nvar CUSTOM_ELEMENTS_SCHEMA = {\\n    name: 'custom-elements'\\n};\\n/**\\n * Defines a schema that allows any property on any element.\\n *\\n * @publicApi\\n */\\nvar NO_ERRORS_SCHEMA = {\\n    name: 'no-errors-schema'\\n};\\n/**\\n * @Annotation\\n * @publicApi\\n */\\nvar NgModule = makeDecorator('NgModule', function (ngModule) { return ngModule; }, undefined, undefined, \\n/**\\n * Decorator that marks the following class as an NgModule, and supplies\\n * configuration metadata for it.\\n *\\n * * The `declarations` and `entryComponents` options configure the compiler\\n * with information about what belongs to the NgModule.\\n * * The `providers` options configures the NgModule's injector to provide\\n * dependencies the NgModule members.\\n * * The `imports` and `exports` options bring in members from other modules, and make\\n * this module's members available to others.\\n */\\nfunction (type, meta) { return R3_COMPILE_NGMODULE$1(type, meta); });\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description Represents the version of Angular\\n *\\n * @publicApi\\n */\\nvar Version = /** @class */ (function () {\\n    function Version(full) {\\n        this.full = full;\\n        this.major = full.split('.')[0];\\n        this.minor = full.split('.')[1];\\n        this.patch = full.split('.').slice(2).join('.');\\n    }\\n    return Version;\\n}());\\n/**\\n * @publicApi\\n */\\nvar VERSION = new Version('7.0.4');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Injectable decorator and metadata.\\n *\\n * @Annotation\\n * @publicApi\\n */\\nvar Injectable = makeDecorator('Injectable', undefined, undefined, undefined, function (type, meta) { return R3_COMPILE_INJECTABLE$1(type, meta); });\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar ERROR_DEBUG_CONTEXT = 'ngDebugContext';\\nvar ERROR_ORIGINAL_ERROR = 'ngOriginalError';\\nvar ERROR_LOGGER = 'ngErrorLogger';\\nfunction getDebugContext(error) {\\n    return error[ERROR_DEBUG_CONTEXT];\\n}\\nfunction getOriginalError(error) {\\n    return error[ERROR_ORIGINAL_ERROR];\\n}\\nfunction getErrorLogger(error) {\\n    return error[ERROR_LOGGER] || defaultErrorLogger;\\n}\\nfunction defaultErrorLogger(console) {\\n    var values = [];\\n    for (var _i = 1; _i < arguments.length; _i++) {\\n        values[_i - 1] = arguments[_i];\\n    }\\n    console.error.apply(console, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(values));\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Provides a hook for centralized exception handling.\\n *\\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\\n * intercept error handling, write a custom exception handler that replaces this default as\\n * appropriate for your app.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * class MyErrorHandler implements ErrorHandler {\\n *   handleError(error) {\\n *     // do something with the exception\\n *   }\\n * }\\n *\\n * @NgModule({\\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\\n * })\\n * class MyModule {}\\n * ```\\n *\\n * @publicApi\\n */\\nvar ErrorHandler = /** @class */ (function () {\\n    function ErrorHandler() {\\n        /**\\n         * @internal\\n         */\\n        this._console = console;\\n    }\\n    ErrorHandler.prototype.handleError = function (error) {\\n        var originalError = this._findOriginalError(error);\\n        var context = this._findContext(error);\\n        // Note: Browser consoles show the place from where console.error was called.\\n        // We can use this to give users additional information about the error.\\n        var errorLogger = getErrorLogger(error);\\n        errorLogger(this._console, \\\"ERROR\\\", error);\\n        if (originalError) {\\n            errorLogger(this._console, \\\"ORIGINAL ERROR\\\", originalError);\\n        }\\n        if (context) {\\n            errorLogger(this._console, 'ERROR CONTEXT', context);\\n        }\\n    };\\n    /** @internal */\\n    ErrorHandler.prototype._findContext = function (error) {\\n        if (error) {\\n            return getDebugContext(error) ? getDebugContext(error) :\\n                this._findContext(getOriginalError(error));\\n        }\\n        return null;\\n    };\\n    /** @internal */\\n    ErrorHandler.prototype._findOriginalError = function (error) {\\n        var e = getOriginalError(error);\\n        while (e && getOriginalError(e)) {\\n            e = getOriginalError(e);\\n        }\\n        return e;\\n    };\\n    return ErrorHandler;\\n}());\\nfunction wrappedError(message, originalError) {\\n    var msg = message + \\\" caused by: \\\" + (originalError instanceof Error ? originalError.message : originalError);\\n    var error = Error(msg);\\n    error[ERROR_ORIGINAL_ERROR] = originalError;\\n    return error;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction findFirstClosedCycle(keys) {\\n    var res = [];\\n    for (var i = 0; i < keys.length; ++i) {\\n        if (res.indexOf(keys[i]) > -1) {\\n            res.push(keys[i]);\\n            return res;\\n        }\\n        res.push(keys[i]);\\n    }\\n    return res;\\n}\\nfunction constructResolvingPath(keys) {\\n    if (keys.length > 1) {\\n        var reversed = findFirstClosedCycle(keys.slice().reverse());\\n        var tokenStrs = reversed.map(function (k) { return stringify(k.token); });\\n        return ' (' + tokenStrs.join(' -> ') + ')';\\n    }\\n    return '';\\n}\\nfunction injectionError(injector, key, constructResolvingMessage, originalError) {\\n    var keys = [key];\\n    var errMsg = constructResolvingMessage(keys);\\n    var error = (originalError ? wrappedError(errMsg, originalError) : Error(errMsg));\\n    error.addKey = addKey;\\n    error.keys = keys;\\n    error.injectors = [injector];\\n    error.constructResolvingMessage = constructResolvingMessage;\\n    error[ERROR_ORIGINAL_ERROR] = originalError;\\n    return error;\\n}\\nfunction addKey(injector, key) {\\n    this.injectors.push(injector);\\n    this.keys.push(key);\\n    // Note: This updated message won't be reflected in the `.stack` property\\n    this.message = this.constructResolvingMessage(this.keys);\\n}\\n/**\\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\\n * {@link Injector} does not have a {@link Provider} for the given key.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * class A {\\n *   constructor(b:B) {}\\n * }\\n *\\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\\n * ```\\n */\\nfunction noProviderError(injector, key) {\\n    return injectionError(injector, key, function (keys) {\\n        var first = stringify(keys[0].token);\\n        return \\\"No provider for \\\" + first + \\\"!\\\" + constructResolvingPath(keys);\\n    });\\n}\\n/**\\n * Thrown when dependencies form a cycle.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * var injector = Injector.resolveAndCreate([\\n *   {provide: \\\"one\\\", useFactory: (two) => \\\"two\\\", deps: [[new Inject(\\\"two\\\")]]},\\n *   {provide: \\\"two\\\", useFactory: (one) => \\\"one\\\", deps: [[new Inject(\\\"one\\\")]]}\\n * ]);\\n *\\n * expect(() => injector.get(\\\"one\\\")).toThrowError();\\n * ```\\n *\\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\\n */\\nfunction cyclicDependencyError(injector, key) {\\n    return injectionError(injector, key, function (keys) {\\n        return \\\"Cannot instantiate cyclic dependency!\\\" + constructResolvingPath(keys);\\n    });\\n}\\n/**\\n * Thrown when a constructing type returns with an Error.\\n *\\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\\n * this object to be instantiated.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * class A {\\n *   constructor() {\\n *     throw new Error('message');\\n *   }\\n * }\\n *\\n * var injector = Injector.resolveAndCreate([A]);\\n\\n * try {\\n *   injector.get(A);\\n * } catch (e) {\\n *   expect(e instanceof InstantiationError).toBe(true);\\n *   expect(e.originalException.message).toEqual(\\\"message\\\");\\n *   expect(e.originalStack).toBeDefined();\\n * }\\n * ```\\n */\\nfunction instantiationError(injector, originalException, originalStack, key) {\\n    return injectionError(injector, key, function (keys) {\\n        var first = stringify(keys[0].token);\\n        return originalException.message + \\\": Error during instantiation of \\\" + first + \\\"!\\\" + constructResolvingPath(keys) + \\\".\\\";\\n    }, originalException);\\n}\\n/**\\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\\n * creation.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * expect(() => Injector.resolveAndCreate([\\\"not a type\\\"])).toThrowError();\\n * ```\\n */\\nfunction invalidProviderError(provider) {\\n    return Error(\\\"Invalid provider - only instances of Provider and Type are allowed, got: \\\" + provider);\\n}\\n/**\\n * Thrown when the class has no annotation information.\\n *\\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\\n * need to be injected into the constructor.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * class A {\\n *   constructor(b) {}\\n * }\\n *\\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\\n * ```\\n *\\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\\n *\\n * ```typescript\\n * class B {}\\n *\\n * class A {\\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\\n * }\\n *\\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\\n * ```\\n *\\n */\\nfunction noAnnotationError(typeOrFunc, params) {\\n    var signature = [];\\n    for (var i = 0, ii = params.length; i < ii; i++) {\\n        var parameter = params[i];\\n        if (!parameter || parameter.length == 0) {\\n            signature.push('?');\\n        }\\n        else {\\n            signature.push(parameter.map(stringify).join(' '));\\n        }\\n    }\\n    return Error('Cannot resolve all parameters for \\\\'' + stringify(typeOrFunc) + '\\\\'(' +\\n        signature.join(', ') + '). ' +\\n        'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\\\'' +\\n        stringify(typeOrFunc) + '\\\\' is decorated with Injectable.');\\n}\\n/**\\n * Thrown when getting an object by index.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * class A {}\\n *\\n * var injector = Injector.resolveAndCreate([A]);\\n *\\n * expect(() => injector.getAt(100)).toThrowError();\\n * ```\\n *\\n */\\nfunction outOfBoundsError(index) {\\n    return Error(\\\"Index \\\" + index + \\\" is out-of-bounds.\\\");\\n}\\n// TODO: add a working example after alpha38 is released\\n/**\\n * Thrown when a multi provider and a regular provider are bound to the same token.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * expect(() => Injector.resolveAndCreate([\\n *   { provide: \\\"Strings\\\", useValue: \\\"string1\\\", multi: true},\\n *   { provide: \\\"Strings\\\", useValue: \\\"string2\\\", multi: false}\\n * ])).toThrowError();\\n * ```\\n */\\nfunction mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\\n    return Error(\\\"Cannot mix multi providers and regular providers, got: \\\" + provider1 + \\\" \\\" + provider2);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\\n *\\n * Keys have:\\n * - a system-wide unique `id`.\\n * - a `token`.\\n *\\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\\n * the\\n * injector to store created objects in a more efficient way.\\n *\\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\\n * resolving\\n * providers.\\n *\\n * @deprecated No replacement\\n * @publicApi\\n */\\nvar ReflectiveKey = /** @class */ (function () {\\n    /**\\n     * Private\\n     */\\n    function ReflectiveKey(token, id) {\\n        this.token = token;\\n        this.id = id;\\n        if (!token) {\\n            throw new Error('Token must be defined!');\\n        }\\n        this.displayName = stringify(this.token);\\n    }\\n    /**\\n     * Retrieves a `Key` for a token.\\n     */\\n    ReflectiveKey.get = function (token) {\\n        return _globalKeyRegistry.get(resolveForwardRef(token));\\n    };\\n    Object.defineProperty(ReflectiveKey, \\\"numberOfKeys\\\", {\\n        /**\\n         * @returns the number of keys registered in the system.\\n         */\\n        get: function () { return _globalKeyRegistry.numberOfKeys; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return ReflectiveKey;\\n}());\\nvar KeyRegistry = /** @class */ (function () {\\n    function KeyRegistry() {\\n        this._allKeys = new Map();\\n    }\\n    KeyRegistry.prototype.get = function (token) {\\n        if (token instanceof ReflectiveKey)\\n            return token;\\n        if (this._allKeys.has(token)) {\\n            return this._allKeys.get(token);\\n        }\\n        var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\\n        this._allKeys.set(token, newKey);\\n        return newKey;\\n    };\\n    Object.defineProperty(KeyRegistry.prototype, \\\"numberOfKeys\\\", {\\n        get: function () { return this._allKeys.size; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return KeyRegistry;\\n}());\\nvar _globalKeyRegistry = new KeyRegistry();\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Provides access to reflection data about symbols. Used internally by Angular\\n * to power dependency injection and compilation.\\n */\\nvar Reflector = /** @class */ (function () {\\n    function Reflector(reflectionCapabilities) {\\n        this.reflectionCapabilities = reflectionCapabilities;\\n    }\\n    Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };\\n    Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };\\n    Reflector.prototype.parameters = function (typeOrFunc) {\\n        return this.reflectionCapabilities.parameters(typeOrFunc);\\n    };\\n    Reflector.prototype.annotations = function (typeOrFunc) {\\n        return this.reflectionCapabilities.annotations(typeOrFunc);\\n    };\\n    Reflector.prototype.propMetadata = function (typeOrFunc) {\\n        return this.reflectionCapabilities.propMetadata(typeOrFunc);\\n    };\\n    Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {\\n        return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\\n    };\\n    Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };\\n    Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };\\n    Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };\\n    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };\\n    Reflector.prototype.resourceUri = function (type) { return this.reflectionCapabilities.resourceUri(type); };\\n    Reflector.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\\n        return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\\n    };\\n    Reflector.prototype.resolveEnum = function (identifier, name) {\\n        return this.reflectionCapabilities.resolveEnum(identifier, name);\\n    };\\n    return Reflector;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * The {@link Reflector} used internally in Angular to access metadata\\n * about symbols.\\n */\\nvar reflector = new Reflector(new ReflectionCapabilities());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * `Dependency` is used by the framework to extend DI.\\n * This is internal to Angular and should not be used directly.\\n */\\nvar ReflectiveDependency = /** @class */ (function () {\\n    function ReflectiveDependency(key, optional, visibility) {\\n        this.key = key;\\n        this.optional = optional;\\n        this.visibility = visibility;\\n    }\\n    ReflectiveDependency.fromKey = function (key) {\\n        return new ReflectiveDependency(key, false, null);\\n    };\\n    return ReflectiveDependency;\\n}());\\nvar _EMPTY_LIST = [];\\nvar ResolvedReflectiveProvider_ = /** @class */ (function () {\\n    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {\\n        this.key = key;\\n        this.resolvedFactories = resolvedFactories;\\n        this.multiProvider = multiProvider;\\n        this.resolvedFactory = this.resolvedFactories[0];\\n    }\\n    return ResolvedReflectiveProvider_;\\n}());\\n/**\\n * An internal resolved representation of a factory function created by resolving `Provider`.\\n * @publicApi\\n */\\nvar ResolvedReflectiveFactory = /** @class */ (function () {\\n    function ResolvedReflectiveFactory(\\n    /**\\n     * Factory function which can return an instance of an object represented by a key.\\n     */\\n    factory, \\n    /**\\n     * Arguments (dependencies) to the `factory` function.\\n     */\\n    dependencies) {\\n        this.factory = factory;\\n        this.dependencies = dependencies;\\n    }\\n    return ResolvedReflectiveFactory;\\n}());\\n/**\\n * Resolve a single provider.\\n */\\nfunction resolveReflectiveFactory(provider) {\\n    var factoryFn;\\n    var resolvedDeps;\\n    if (provider.useClass) {\\n        var useClass = resolveForwardRef(provider.useClass);\\n        factoryFn = reflector.factory(useClass);\\n        resolvedDeps = _dependenciesFor(useClass);\\n    }\\n    else if (provider.useExisting) {\\n        factoryFn = function (aliasInstance) { return aliasInstance; };\\n        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\\n    }\\n    else if (provider.useFactory) {\\n        factoryFn = provider.useFactory;\\n        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\\n    }\\n    else {\\n        factoryFn = function () { return provider.useValue; };\\n        resolvedDeps = _EMPTY_LIST;\\n    }\\n    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\\n}\\n/**\\n * Converts the `Provider` into `ResolvedProvider`.\\n *\\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\\n * syntax.\\n */\\nfunction resolveReflectiveProvider(provider) {\\n    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);\\n}\\n/**\\n * Resolve a list of Providers.\\n */\\nfunction resolveReflectiveProviders(providers) {\\n    var normalized = _normalizeProviders(providers, []);\\n    var resolved = normalized.map(resolveReflectiveProvider);\\n    var resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\\n    return Array.from(resolvedProviderMap.values());\\n}\\n/**\\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\\n * multi providers have been merged.\\n */\\nfunction mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\\n    for (var i = 0; i < providers.length; i++) {\\n        var provider = providers[i];\\n        var existing = normalizedProvidersMap.get(provider.key.id);\\n        if (existing) {\\n            if (provider.multiProvider !== existing.multiProvider) {\\n                throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\\n            }\\n            if (provider.multiProvider) {\\n                for (var j = 0; j < provider.resolvedFactories.length; j++) {\\n                    existing.resolvedFactories.push(provider.resolvedFactories[j]);\\n                }\\n            }\\n            else {\\n                normalizedProvidersMap.set(provider.key.id, provider);\\n            }\\n        }\\n        else {\\n            var resolvedProvider = void 0;\\n            if (provider.multiProvider) {\\n                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\\n            }\\n            else {\\n                resolvedProvider = provider;\\n            }\\n            normalizedProvidersMap.set(provider.key.id, resolvedProvider);\\n        }\\n    }\\n    return normalizedProvidersMap;\\n}\\nfunction _normalizeProviders(providers, res) {\\n    providers.forEach(function (b) {\\n        if (b instanceof Type) {\\n            res.push({ provide: b, useClass: b });\\n        }\\n        else if (b && typeof b == 'object' && b.provide !== undefined) {\\n            res.push(b);\\n        }\\n        else if (b instanceof Array) {\\n            _normalizeProviders(b, res);\\n        }\\n        else {\\n            throw invalidProviderError(b);\\n        }\\n    });\\n    return res;\\n}\\nfunction constructDependencies(typeOrFunc, dependencies) {\\n    if (!dependencies) {\\n        return _dependenciesFor(typeOrFunc);\\n    }\\n    else {\\n        var params_1 = dependencies.map(function (t) { return [t]; });\\n        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });\\n    }\\n}\\nfunction _dependenciesFor(typeOrFunc) {\\n    var params = reflector.parameters(typeOrFunc);\\n    if (!params)\\n        return [];\\n    if (params.some(function (p) { return p == null; })) {\\n        throw noAnnotationError(typeOrFunc, params);\\n    }\\n    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });\\n}\\nfunction _extractToken(typeOrFunc, metadata, params) {\\n    var token = null;\\n    var optional = false;\\n    if (!Array.isArray(metadata)) {\\n        if (metadata instanceof Inject) {\\n            return _createDependency(metadata.token, optional, null);\\n        }\\n        else {\\n            return _createDependency(metadata, optional, null);\\n        }\\n    }\\n    var visibility = null;\\n    for (var i = 0; i < metadata.length; ++i) {\\n        var paramMetadata = metadata[i];\\n        if (paramMetadata instanceof Type) {\\n            token = paramMetadata;\\n        }\\n        else if (paramMetadata instanceof Inject) {\\n            token = paramMetadata.token;\\n        }\\n        else if (paramMetadata instanceof Optional) {\\n            optional = true;\\n        }\\n        else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\\n            visibility = paramMetadata;\\n        }\\n        else if (paramMetadata instanceof InjectionToken) {\\n            token = paramMetadata;\\n        }\\n    }\\n    token = resolveForwardRef(token);\\n    if (token != null) {\\n        return _createDependency(token, optional, visibility);\\n    }\\n    else {\\n        throw noAnnotationError(typeOrFunc, params);\\n    }\\n}\\nfunction _createDependency(token, optional, visibility) {\\n    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// Threshold for the dynamic version\\nvar UNDEFINED = new Object();\\n/**\\n * A ReflectiveDependency injection container used for instantiating objects and resolving\\n * dependencies.\\n *\\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\\n * constructor dependencies.\\n *\\n * In typical use, application code asks for the dependencies in the constructor and they are\\n * resolved by the `Injector`.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\\n *\\n * ```typescript\\n * @Injectable()\\n * class Engine {\\n * }\\n *\\n * @Injectable()\\n * class Car {\\n *   constructor(public engine:Engine) {}\\n * }\\n *\\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\\n * var car = injector.get(Car);\\n * expect(car instanceof Car).toBe(true);\\n * expect(car.engine instanceof Engine).toBe(true);\\n * ```\\n *\\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\\n * resolve all of the object's dependencies automatically.\\n *\\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\\n * @publicApi\\n */\\nvar ReflectiveInjector = /** @class */ (function () {\\n    function ReflectiveInjector() {\\n    }\\n    /**\\n     * Turns an array of provider definitions into an array of resolved providers.\\n     *\\n     * A resolution is a process of flattening multiple nested arrays and converting individual\\n     * providers into an array of `ResolvedReflectiveProvider`s.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * ```typescript\\n     * @Injectable()\\n     * class Engine {\\n     * }\\n     *\\n     * @Injectable()\\n     * class Car {\\n     *   constructor(public engine:Engine) {}\\n     * }\\n     *\\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\\n     *\\n     * expect(providers.length).toEqual(2);\\n     *\\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\\n     * expect(providers[0].key.displayName).toBe(\\\"Car\\\");\\n     * expect(providers[0].dependencies.length).toEqual(1);\\n     * expect(providers[0].factory).toBeDefined();\\n     *\\n     * expect(providers[1].key.displayName).toBe(\\\"Engine\\\");\\n     * });\\n     * ```\\n     *\\n     */\\n    ReflectiveInjector.resolve = function (providers) {\\n        return resolveReflectiveProviders(providers);\\n    };\\n    /**\\n     * Resolves an array of providers and creates an injector from those providers.\\n     *\\n     * The passed-in providers can be an array of `Type`, `Provider`,\\n     * or a recursive array of more providers.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * ```typescript\\n     * @Injectable()\\n     * class Engine {\\n     * }\\n     *\\n     * @Injectable()\\n     * class Car {\\n     *   constructor(public engine:Engine) {}\\n     * }\\n     *\\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\\n     * expect(injector.get(Car) instanceof Car).toBe(true);\\n     * ```\\n     */\\n    ReflectiveInjector.resolveAndCreate = function (providers, parent) {\\n        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\\n        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\\n    };\\n    /**\\n     * Creates an injector from previously resolved providers.\\n     *\\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * ```typescript\\n     * @Injectable()\\n     * class Engine {\\n     * }\\n     *\\n     * @Injectable()\\n     * class Car {\\n     *   constructor(public engine:Engine) {}\\n     * }\\n     *\\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\\n     * expect(injector.get(Car) instanceof Car).toBe(true);\\n     * ```\\n     */\\n    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {\\n        return new ReflectiveInjector_(providers, parent);\\n    };\\n    return ReflectiveInjector;\\n}());\\nvar ReflectiveInjector_ = /** @class */ (function () {\\n    /**\\n     * Private\\n     */\\n    function ReflectiveInjector_(_providers, _parent) {\\n        /** @internal */\\n        this._constructionCounter = 0;\\n        this._providers = _providers;\\n        this.parent = _parent || null;\\n        var len = _providers.length;\\n        this.keyIds = new Array(len);\\n        this.objs = new Array(len);\\n        for (var i = 0; i < len; i++) {\\n            this.keyIds[i] = _providers[i].key.id;\\n            this.objs[i] = UNDEFINED;\\n        }\\n    }\\n    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {\\n        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }\\n        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\\n    };\\n    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {\\n        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\\n        return this.createChildFromResolved(ResolvedReflectiveProviders);\\n    };\\n    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {\\n        var inj = new ReflectiveInjector_(providers);\\n        inj.parent = this;\\n        return inj;\\n    };\\n    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {\\n        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\\n    };\\n    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {\\n        return this._instantiateProvider(provider);\\n    };\\n    ReflectiveInjector_.prototype.getProviderAtIndex = function (index) {\\n        if (index < 0 || index >= this._providers.length) {\\n            throw outOfBoundsError(index);\\n        }\\n        return this._providers[index];\\n    };\\n    /** @internal */\\n    ReflectiveInjector_.prototype._new = function (provider) {\\n        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\\n            throw cyclicDependencyError(this, provider.key);\\n        }\\n        return this._instantiateProvider(provider);\\n    };\\n    ReflectiveInjector_.prototype._getMaxNumberOfObjects = function () { return this.objs.length; };\\n    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {\\n        if (provider.multiProvider) {\\n            var res = new Array(provider.resolvedFactories.length);\\n            for (var i = 0; i < provider.resolvedFactories.length; ++i) {\\n                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\\n            }\\n            return res;\\n        }\\n        else {\\n            return this._instantiate(provider, provider.resolvedFactories[0]);\\n        }\\n    };\\n    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory$$1) {\\n        var _this = this;\\n        var factory = ResolvedReflectiveFactory$$1.factory;\\n        var deps;\\n        try {\\n            deps =\\n                ResolvedReflectiveFactory$$1.dependencies.map(function (dep) { return _this._getByReflectiveDependency(dep); });\\n        }\\n        catch (e) {\\n            if (e.addKey) {\\n                e.addKey(this, provider.key);\\n            }\\n            throw e;\\n        }\\n        var obj;\\n        try {\\n            obj = factory.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(deps));\\n        }\\n        catch (e) {\\n            throw instantiationError(this, e, e.stack, provider.key);\\n        }\\n        return obj;\\n    };\\n    ReflectiveInjector_.prototype._getByReflectiveDependency = function (dep) {\\n        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\\n    };\\n    ReflectiveInjector_.prototype._getByKey = function (key, visibility, notFoundValue) {\\n        if (key === ReflectiveInjector_.INJECTOR_KEY) {\\n            return this;\\n        }\\n        if (visibility instanceof Self) {\\n            return this._getByKeySelf(key, notFoundValue);\\n        }\\n        else {\\n            return this._getByKeyDefault(key, notFoundValue, visibility);\\n        }\\n    };\\n    ReflectiveInjector_.prototype._getObjByKeyId = function (keyId) {\\n        for (var i = 0; i < this.keyIds.length; i++) {\\n            if (this.keyIds[i] === keyId) {\\n                if (this.objs[i] === UNDEFINED) {\\n                    this.objs[i] = this._new(this._providers[i]);\\n                }\\n                return this.objs[i];\\n            }\\n        }\\n        return UNDEFINED;\\n    };\\n    /** @internal */\\n    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {\\n        if (notFoundValue !== THROW_IF_NOT_FOUND) {\\n            return notFoundValue;\\n        }\\n        else {\\n            throw noProviderError(this, key);\\n        }\\n    };\\n    /** @internal */\\n    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {\\n        var obj = this._getObjByKeyId(key.id);\\n        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\\n    };\\n    /** @internal */\\n    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, visibility) {\\n        var inj;\\n        if (visibility instanceof SkipSelf) {\\n            inj = this.parent;\\n        }\\n        else {\\n            inj = this;\\n        }\\n        while (inj instanceof ReflectiveInjector_) {\\n            var inj_ = inj;\\n            var obj = inj_._getObjByKeyId(key.id);\\n            if (obj !== UNDEFINED)\\n                return obj;\\n            inj = inj_.parent;\\n        }\\n        if (inj !== null) {\\n            return inj.get(key.token, notFoundValue);\\n        }\\n        else {\\n            return this._throwOrNull(key, notFoundValue);\\n        }\\n    };\\n    Object.defineProperty(ReflectiveInjector_.prototype, \\\"displayName\\\", {\\n        get: function () {\\n            var providers = _mapProviders(this, function (b) { return ' \\\"' + b.key.displayName + '\\\" '; })\\n                .join(', ');\\n            return \\\"ReflectiveInjector(providers: [\\\" + providers + \\\"])\\\";\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };\\n    ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);\\n    return ReflectiveInjector_;\\n}());\\nfunction _mapProviders(injector, fn) {\\n    var res = new Array(injector._providers.length);\\n    for (var i = 0; i < injector._providers.length; ++i) {\\n        res[i] = fn(injector.getProviderAtIndex(i));\\n    }\\n    return res;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Determine if the argument is shaped like a Promise\\n */\\nfunction isPromise(obj) {\\n    // allow any Promise/A+ compliant thenable.\\n    // It's up to the caller to ensure that obj.then conforms to the spec\\n    return !!obj && typeof obj.then === 'function';\\n}\\n/**\\n * Determine if the argument is an Observable\\n */\\nfunction isObservable(obj) {\\n    // TODO: use isObservable once we update pass rxjs 6.1\\n    // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03\\n    return !!obj && typeof obj.subscribe === 'function';\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A function that will be executed when an application is initialized.\\n *\\n * @publicApi\\n */\\nvar APP_INITIALIZER = new InjectionToken('Application Initializer');\\n/**\\n * A class that reflects the state of running {@link APP_INITIALIZER}s.\\n *\\n * @publicApi\\n */\\nvar ApplicationInitStatus = /** @class */ (function () {\\n    function ApplicationInitStatus(appInits) {\\n        var _this = this;\\n        this.appInits = appInits;\\n        this.initialized = false;\\n        this.done = false;\\n        this.donePromise = new Promise(function (res, rej) {\\n            _this.resolve = res;\\n            _this.reject = rej;\\n        });\\n    }\\n    /** @internal */\\n    ApplicationInitStatus.prototype.runInitializers = function () {\\n        var _this = this;\\n        if (this.initialized) {\\n            return;\\n        }\\n        var asyncInitPromises = [];\\n        var complete = function () {\\n            _this.done = true;\\n            _this.resolve();\\n        };\\n        if (this.appInits) {\\n            for (var i = 0; i < this.appInits.length; i++) {\\n                var initResult = this.appInits[i]();\\n                if (isPromise(initResult)) {\\n                    asyncInitPromises.push(initResult);\\n                }\\n            }\\n        }\\n        Promise.all(asyncInitPromises).then(function () { complete(); }).catch(function (e) { _this.reject(e); });\\n        if (asyncInitPromises.length === 0) {\\n            complete();\\n        }\\n        this.initialized = true;\\n    };\\n    ApplicationInitStatus = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __param */ \\\"e\\\"])(0, Inject(APP_INITIALIZER)), Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __param */ \\\"e\\\"])(0, Optional()),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [Array])\\n    ], ApplicationInitStatus);\\n    return ApplicationInitStatus;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A DI Token representing a unique string id assigned to the application by Angular and used\\n * primarily for prefixing application attributes and CSS styles when\\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\\n *\\n * If you need to avoid randomly generated value to be used as an application id, you can provide\\n * a custom value via a DI provider \\x3c!-- TODO: provider --\\x3e configuring the root {@link Injector}\\n * using this token.\\n * @publicApi\\n */\\nvar APP_ID = new InjectionToken('AppId');\\nfunction _appIdRandomProviderFactory() {\\n    return \\\"\\\" + _randomChar() + _randomChar() + _randomChar();\\n}\\n/**\\n * Providers that will generate a random APP_ID_TOKEN.\\n * @publicApi\\n */\\nvar APP_ID_RANDOM_PROVIDER = {\\n    provide: APP_ID,\\n    useFactory: _appIdRandomProviderFactory,\\n    deps: [],\\n};\\nfunction _randomChar() {\\n    return String.fromCharCode(97 + Math.floor(Math.random() * 25));\\n}\\n/**\\n * A function that will be executed when a platform is initialized.\\n * @publicApi\\n */\\nvar PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');\\n/**\\n * A token that indicates an opaque platform id.\\n * @publicApi\\n */\\nvar PLATFORM_ID = new InjectionToken('Platform ID');\\n/**\\n * All callbacks provided via this token will be called for every component that is bootstrapped.\\n * Signature of the callback:\\n *\\n * `(componentRef: ComponentRef) => void`.\\n *\\n * @publicApi\\n */\\nvar APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');\\n/**\\n * A token which indicates the root directory of the application\\n * @publicApi\\n */\\nvar PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar Console = /** @class */ (function () {\\n    function Console() {\\n    }\\n    Console.prototype.log = function (message) {\\n        // tslint:disable-next-line:no-console\\n        console.log(message);\\n    };\\n    // Note: for reporting errors use `DOM.logError()` as it is platform specific\\n    Console.prototype.warn = function (message) {\\n        // tslint:disable-next-line:no-console\\n        console.warn(message);\\n    };\\n    Console = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable()\\n    ], Console);\\n    return Console;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Combination of NgModuleFactory and ComponentFactorys.\\n *\\n * @publicApi\\n */\\nvar ModuleWithComponentFactories = /** @class */ (function () {\\n    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {\\n        this.ngModuleFactory = ngModuleFactory;\\n        this.componentFactories = componentFactories;\\n    }\\n    return ModuleWithComponentFactories;\\n}());\\nfunction _throwError() {\\n    throw new Error(\\\"Runtime compiler is not loaded\\\");\\n}\\n/**\\n * Low-level service for running the angular compiler during runtime\\n * to create {@link ComponentFactory}s, which\\n * can later be used to create and render a Component instance.\\n *\\n * Each `@NgModule` provides an own `Compiler` to its injector,\\n * that will use the directives/pipes of the ng module for compilation\\n * of components.\\n *\\n * @publicApi\\n */\\nvar Compiler = /** @class */ (function () {\\n    function Compiler() {\\n    }\\n    /**\\n     * Compiles the given NgModule and all of its components. All templates of the components listed\\n     * in `entryComponents` have to be inlined.\\n     */\\n    Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };\\n    /**\\n     * Compiles the given NgModule and all of its components\\n     */\\n    Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };\\n    /**\\n     * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\\n     */\\n    Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\\n        throw _throwError();\\n    };\\n    /**\\n     * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\\n     */\\n    Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\\n        throw _throwError();\\n    };\\n    /**\\n     * Clears all caches.\\n     */\\n    Compiler.prototype.clearCache = function () { };\\n    /**\\n     * Clears the cache for the given component/ngModule.\\n     */\\n    Compiler.prototype.clearCacheFor = function (type) { };\\n    /**\\n     * Returns the id for a given NgModule, if one is defined and known to the compiler.\\n     */\\n    Compiler.prototype.getModuleId = function (moduleType) { return undefined; };\\n    Compiler = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable()\\n    ], Compiler);\\n    return Compiler;\\n}());\\n/**\\n * Token to provide CompilerOptions in the platform injector.\\n *\\n * @publicApi\\n */\\nvar COMPILER_OPTIONS = new InjectionToken('compilerOptions');\\n/**\\n * A factory for creating a Compiler\\n *\\n * @publicApi\\n */\\nvar CompilerFactory = /** @class */ (function () {\\n    function CompilerFactory() {\\n    }\\n    return CompilerFactory;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar trace;\\nvar events;\\nfunction detectWTF() {\\n    var wtf = _global /** TODO #9100 */['wtf'];\\n    if (wtf) {\\n        trace = wtf['trace'];\\n        if (trace) {\\n            events = trace['events'];\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\nfunction createScope(signature, flags) {\\n    if (flags === void 0) { flags = null; }\\n    return events.createScope(signature, flags);\\n}\\nfunction leave(scope, returnValue) {\\n    trace.leaveScope(scope, returnValue);\\n    return returnValue;\\n}\\nfunction startTimeRange(rangeType, action) {\\n    return trace.beginTimeRange(rangeType, action);\\n}\\nfunction endTimeRange(range) {\\n    trace.endTimeRange(range);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * True if WTF is enabled.\\n */\\nvar wtfEnabled = detectWTF();\\nfunction noopScope(arg0, arg1) {\\n    return null;\\n}\\n/**\\n * Create trace scope.\\n *\\n * Scopes must be strictly nested and are analogous to stack frames, but\\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\\n * nesting. You may want to use\\n * [Event\\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\\n * as they are defined in WTF.\\n *\\n * Used to mark scope entry. The return value is used to leave the scope.\\n *\\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\\n *\\n *     someMethod() {\\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\\n *        // DO SOME WORK HERE\\n *        return wtfLeave(s, 123); // Return value 123\\n *     }\\n *\\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\\n * negatively impact the performance of your application. For this reason we recommend that\\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\\n * an exception is expected during normal execution while profiling.\\n *\\n * @publicApi\\n */\\nvar wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };\\n/**\\n * Used to mark end of Scope.\\n *\\n * - `scope` to end.\\n * - `returnValue` (optional) to be passed to the WTF.\\n *\\n * Returns the `returnValue for easy chaining.\\n * @publicApi\\n */\\nvar wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };\\n/**\\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\\n * enabled.\\n *\\n *     someMethod() {\\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\\n *        var future = new Future.delay(5).then((_) {\\n *          wtfEndTimeRange(s);\\n *        });\\n *     }\\n * @publicApi\\n */\\nvar wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };\\n/**\\n * Ends a async time range operation.\\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\\n * enabled.\\n * @publicApi\\n */\\nvar wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * An injectable service for executing work inside or outside of the Angular zone.\\n *\\n * The most common use of this service is to optimize performance when starting a work consisting of\\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\\n * can reenter the Angular zone via {@link #run}.\\n *\\n * \\x3c!-- TODO: add/fix links to:\\n *   - docs explaining zones and the use of zones in Angular and change-detection\\n *   - link to runOutsideAngular/run (throughout this file!)\\n *   --\\x3e\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * import {Component, NgZone} from '@angular/core';\\n * import {NgIf} from '@angular/common';\\n *\\n * @Component({\\n *   selector: 'ng-zone-demo',\\n *   template: `\\n *     <h2>Demo: NgZone</h2>\\n *\\n *     <p>Progress: {{progress}}%</p>\\n *     <p *ngIf=\\\"progress >= 100\\\">Done processing {{label}} of Angular zone!</p>\\n *\\n *     <button (click)=\\\"processWithinAngularZone()\\\">Process within Angular zone</button>\\n *     <button (click)=\\\"processOutsideOfAngularZone()\\\">Process outside of Angular zone</button>\\n *   `,\\n * })\\n * export class NgZoneDemo {\\n *   progress: number = 0;\\n *   label: string;\\n *\\n *   constructor(private _ngZone: NgZone) {}\\n *\\n *   // Loop inside the Angular zone\\n *   // so the UI DOES refresh after each setTimeout cycle\\n *   processWithinAngularZone() {\\n *     this.label = 'inside';\\n *     this.progress = 0;\\n *     this._increaseProgress(() => console.log('Inside Done!'));\\n *   }\\n *\\n *   // Loop outside of the Angular zone\\n *   // so the UI DOES NOT refresh after each setTimeout cycle\\n *   processOutsideOfAngularZone() {\\n *     this.label = 'outside';\\n *     this.progress = 0;\\n *     this._ngZone.runOutsideAngular(() => {\\n *       this._increaseProgress(() => {\\n *         // reenter the Angular zone and display done\\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\\n *       });\\n *     });\\n *   }\\n *\\n *   _increaseProgress(doneCallback: () => void) {\\n *     this.progress += 1;\\n *     console.log(`Current progress: ${this.progress}%`);\\n *\\n *     if (this.progress < 100) {\\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\\n *     } else {\\n *       doneCallback();\\n *     }\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar NgZone = /** @class */ (function () {\\n    function NgZone(_a) {\\n        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;\\n        this.hasPendingMicrotasks = false;\\n        this.hasPendingMacrotasks = false;\\n        /**\\n         * Whether there are no outstanding microtasks or macrotasks.\\n         */\\n        this.isStable = true;\\n        /**\\n         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\\n         */\\n        this.onUnstable = new EventEmitter(false);\\n        /**\\n         * Notifies when there is no more microtasks enqueued in the current VM Turn.\\n         * This is a hint for Angular to do change detection, which may enqueue more microtasks.\\n         * For this reason this event can fire multiple times per VM Turn.\\n         */\\n        this.onMicrotaskEmpty = new EventEmitter(false);\\n        /**\\n         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\\n         * implies we are about to relinquish VM turn.\\n         * This event gets called just once.\\n         */\\n        this.onStable = new EventEmitter(false);\\n        /**\\n         * Notifies that an error has been delivered.\\n         */\\n        this.onError = new EventEmitter(false);\\n        if (typeof Zone == 'undefined') {\\n            throw new Error(\\\"In this configuration Angular requires Zone.js\\\");\\n        }\\n        Zone.assertZonePatched();\\n        var self = this;\\n        self._nesting = 0;\\n        self._outer = self._inner = Zone.current;\\n        if (Zone['wtfZoneSpec']) {\\n            self._inner = self._inner.fork(Zone['wtfZoneSpec']);\\n        }\\n        if (Zone['TaskTrackingZoneSpec']) {\\n            self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']);\\n        }\\n        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {\\n            self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);\\n        }\\n        forkInnerZoneWithAngularBehavior(self);\\n    }\\n    NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };\\n    NgZone.assertInAngularZone = function () {\\n        if (!NgZone.isInAngularZone()) {\\n            throw new Error('Expected to be in Angular Zone, but it is not!');\\n        }\\n    };\\n    NgZone.assertNotInAngularZone = function () {\\n        if (NgZone.isInAngularZone()) {\\n            throw new Error('Expected to not be in Angular Zone, but it is!');\\n        }\\n    };\\n    /**\\n     * Executes the `fn` function synchronously within the Angular zone and returns value returned by\\n     * the function.\\n     *\\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\\n     *\\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\\n     * within the Angular zone.\\n     *\\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\\n     */\\n    NgZone.prototype.run = function (fn, applyThis, applyArgs) {\\n        return this._inner.run(fn, applyThis, applyArgs);\\n    };\\n    /**\\n     * Executes the `fn` function synchronously within the Angular zone as a task and returns value\\n     * returned by the function.\\n     *\\n     * Running functions via `run` allows you to reenter Angular zone from a task that was executed\\n     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\\n     *\\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\\n     * within the Angular zone.\\n     *\\n     * If a synchronous error happens it will be rethrown and not reported via `onError`.\\n     */\\n    NgZone.prototype.runTask = function (fn, applyThis, applyArgs, name) {\\n        var zone = this._inner;\\n        var task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);\\n        try {\\n            return zone.runTask(task, applyThis, applyArgs);\\n        }\\n        finally {\\n            zone.cancelTask(task);\\n        }\\n    };\\n    /**\\n     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\\n     * rethrown.\\n     */\\n    NgZone.prototype.runGuarded = function (fn, applyThis, applyArgs) {\\n        return this._inner.runGuarded(fn, applyThis, applyArgs);\\n    };\\n    /**\\n     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\\n     * the function.\\n     *\\n     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\\n     * work that\\n     * doesn't trigger Angular change-detection or is subject to Angular's error handling.\\n     *\\n     * Any future tasks or microtasks scheduled from within this function will continue executing from\\n     * outside of the Angular zone.\\n     *\\n     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\\n     */\\n    NgZone.prototype.runOutsideAngular = function (fn) {\\n        return this._outer.run(fn);\\n    };\\n    return NgZone;\\n}());\\nfunction noop$1() { }\\nvar EMPTY_PAYLOAD = {};\\nfunction checkStable(zone) {\\n    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\\n        try {\\n            zone._nesting++;\\n            zone.onMicrotaskEmpty.emit(null);\\n        }\\n        finally {\\n            zone._nesting--;\\n            if (!zone.hasPendingMicrotasks) {\\n                try {\\n                    zone.runOutsideAngular(function () { return zone.onStable.emit(null); });\\n                }\\n                finally {\\n                    zone.isStable = true;\\n                }\\n            }\\n        }\\n    }\\n}\\nfunction forkInnerZoneWithAngularBehavior(zone) {\\n    zone._inner = zone._inner.fork({\\n        name: 'angular',\\n        properties: { 'isAngularZone': true },\\n        onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {\\n            try {\\n                onEnter(zone);\\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\\n            }\\n            finally {\\n                onLeave(zone);\\n            }\\n        },\\n        onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {\\n            try {\\n                onEnter(zone);\\n                return delegate.invoke(target, callback, applyThis, applyArgs, source);\\n            }\\n            finally {\\n                onLeave(zone);\\n            }\\n        },\\n        onHasTask: function (delegate, current, target, hasTaskState) {\\n            delegate.hasTask(target, hasTaskState);\\n            if (current === target) {\\n                // We are only interested in hasTask events which originate from our zone\\n                // (A child hasTask event is not interesting to us)\\n                if (hasTaskState.change == 'microTask') {\\n                    zone.hasPendingMicrotasks = hasTaskState.microTask;\\n                    checkStable(zone);\\n                }\\n                else if (hasTaskState.change == 'macroTask') {\\n                    zone.hasPendingMacrotasks = hasTaskState.macroTask;\\n                }\\n            }\\n        },\\n        onHandleError: function (delegate, current, target, error) {\\n            delegate.handleError(target, error);\\n            zone.runOutsideAngular(function () { return zone.onError.emit(error); });\\n            return false;\\n        }\\n    });\\n}\\nfunction onEnter(zone) {\\n    zone._nesting++;\\n    if (zone.isStable) {\\n        zone.isStable = false;\\n        zone.onUnstable.emit(null);\\n    }\\n}\\nfunction onLeave(zone) {\\n    zone._nesting--;\\n    checkStable(zone);\\n}\\n/**\\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\\n * to framework to perform rendering.\\n */\\nvar NoopNgZone = /** @class */ (function () {\\n    function NoopNgZone() {\\n        this.hasPendingMicrotasks = false;\\n        this.hasPendingMacrotasks = false;\\n        this.isStable = true;\\n        this.onUnstable = new EventEmitter();\\n        this.onMicrotaskEmpty = new EventEmitter();\\n        this.onStable = new EventEmitter();\\n        this.onError = new EventEmitter();\\n    }\\n    NoopNgZone.prototype.run = function (fn) { return fn(); };\\n    NoopNgZone.prototype.runGuarded = function (fn) { return fn(); };\\n    NoopNgZone.prototype.runOutsideAngular = function (fn) { return fn(); };\\n    NoopNgZone.prototype.runTask = function (fn) { return fn(); };\\n    return NoopNgZone;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * The Testability service provides testing hooks that can be accessed from\\n * the browser and by services such as Protractor. Each bootstrapped Angular\\n * application on the page will have an instance of Testability.\\n * @publicApi\\n */\\nvar Testability = /** @class */ (function () {\\n    function Testability(_ngZone) {\\n        var _this = this;\\n        this._ngZone = _ngZone;\\n        this._pendingCount = 0;\\n        this._isZoneStable = true;\\n        /**\\n         * Whether any work was done since the last 'whenStable' callback. This is\\n         * useful to detect if this could have potentially destabilized another\\n         * component while it is stabilizing.\\n         * @internal\\n         */\\n        this._didWork = false;\\n        this._callbacks = [];\\n        this._watchAngularEvents();\\n        _ngZone.run(function () { _this.taskTrackingZone = Zone.current.get('TaskTrackingZone'); });\\n    }\\n    Testability.prototype._watchAngularEvents = function () {\\n        var _this = this;\\n        this._ngZone.onUnstable.subscribe({\\n            next: function () {\\n                _this._didWork = true;\\n                _this._isZoneStable = false;\\n            }\\n        });\\n        this._ngZone.runOutsideAngular(function () {\\n            _this._ngZone.onStable.subscribe({\\n                next: function () {\\n                    NgZone.assertNotInAngularZone();\\n                    scheduleMicroTask(function () {\\n                        _this._isZoneStable = true;\\n                        _this._runCallbacksIfReady();\\n                    });\\n                }\\n            });\\n        });\\n    };\\n    /**\\n     * Increases the number of pending request\\n     * @deprecated pending requests are now tracked with zones.\\n     */\\n    Testability.prototype.increasePendingRequestCount = function () {\\n        this._pendingCount += 1;\\n        this._didWork = true;\\n        return this._pendingCount;\\n    };\\n    /**\\n     * Decreases the number of pending request\\n     * @deprecated pending requests are now tracked with zones\\n     */\\n    Testability.prototype.decreasePendingRequestCount = function () {\\n        this._pendingCount -= 1;\\n        if (this._pendingCount < 0) {\\n            throw new Error('pending async requests below zero');\\n        }\\n        this._runCallbacksIfReady();\\n        return this._pendingCount;\\n    };\\n    /**\\n     * Whether an associated application is stable\\n     */\\n    Testability.prototype.isStable = function () {\\n        return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\\n    };\\n    Testability.prototype._runCallbacksIfReady = function () {\\n        var _this = this;\\n        if (this.isStable()) {\\n            // Schedules the call backs in a new frame so that it is always async.\\n            scheduleMicroTask(function () {\\n                while (_this._callbacks.length !== 0) {\\n                    var cb = _this._callbacks.pop();\\n                    clearTimeout(cb.timeoutId);\\n                    cb.doneCb(_this._didWork);\\n                }\\n                _this._didWork = false;\\n            });\\n        }\\n        else {\\n            // Still not stable, send updates.\\n            var pending_1 = this.getPendingTasks();\\n            this._callbacks = this._callbacks.filter(function (cb) {\\n                if (cb.updateCb && cb.updateCb(pending_1)) {\\n                    clearTimeout(cb.timeoutId);\\n                    return false;\\n                }\\n                return true;\\n            });\\n            this._didWork = true;\\n        }\\n    };\\n    Testability.prototype.getPendingTasks = function () {\\n        if (!this.taskTrackingZone) {\\n            return [];\\n        }\\n        // Copy the tasks data so that we don't leak tasks.\\n        return this.taskTrackingZone.macroTasks.map(function (t) {\\n            return {\\n                source: t.source,\\n                // From TaskTrackingZone:\\n                // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\\n                creationLocation: t.creationLocation,\\n                data: t.data\\n            };\\n        });\\n    };\\n    Testability.prototype.addCallback = function (cb, timeout, updateCb) {\\n        var _this = this;\\n        var timeoutId = -1;\\n        if (timeout && timeout > 0) {\\n            timeoutId = setTimeout(function () {\\n                _this._callbacks = _this._callbacks.filter(function (cb) { return cb.timeoutId !== timeoutId; });\\n                cb(_this._didWork, _this.getPendingTasks());\\n            }, timeout);\\n        }\\n        this._callbacks.push({ doneCb: cb, timeoutId: timeoutId, updateCb: updateCb });\\n    };\\n    /**\\n     * Wait for the application to be stable with a timeout. If the timeout is reached before that\\n     * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\\n     *\\n     * @param doneCb The callback to invoke when Angular is stable or the timeout expires\\n     *    whichever comes first.\\n     * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\\n     *    specified, whenStable() will wait forever.\\n     * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\\n     *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\\n     *    and no further updates will be issued.\\n     */\\n    Testability.prototype.whenStable = function (doneCb, timeout, updateCb) {\\n        if (updateCb && !this.taskTrackingZone) {\\n            throw new Error('Task tracking zone is required when passing an update callback to ' +\\n                'whenStable(). Is \\\"zone.js/dist/task-tracking.js\\\" loaded?');\\n        }\\n        // These arguments are 'Function' above to keep the public API simple.\\n        this.addCallback(doneCb, timeout, updateCb);\\n        this._runCallbacksIfReady();\\n    };\\n    /**\\n     * Get the number of pending requests\\n     * @deprecated pending requests are now tracked with zones\\n     */\\n    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };\\n    /**\\n     * Find providers by name\\n     * @param using The root element to search from\\n     * @param provider The name of binding variable\\n     * @param exactMatch Whether using exactMatch\\n     */\\n    Testability.prototype.findProviders = function (using, provider, exactMatch) {\\n        // TODO(juliemr): implement.\\n        return [];\\n    };\\n    Testability = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [NgZone])\\n    ], Testability);\\n    return Testability;\\n}());\\n/**\\n * A global registry of {@link Testability} instances for specific elements.\\n * @publicApi\\n */\\nvar TestabilityRegistry = /** @class */ (function () {\\n    function TestabilityRegistry() {\\n        /** @internal */\\n        this._applications = new Map();\\n        _testabilityGetter.addToWindow(this);\\n    }\\n    /**\\n     * Registers an application with a testability hook so that it can be tracked\\n     * @param token token of application, root element\\n     * @param testability Testability hook\\n     */\\n    TestabilityRegistry.prototype.registerApplication = function (token, testability) {\\n        this._applications.set(token, testability);\\n    };\\n    /**\\n     * Unregisters an application.\\n     * @param token token of application, root element\\n     */\\n    TestabilityRegistry.prototype.unregisterApplication = function (token) { this._applications.delete(token); };\\n    /**\\n     * Unregisters all applications\\n     */\\n    TestabilityRegistry.prototype.unregisterAllApplications = function () { this._applications.clear(); };\\n    /**\\n     * Get a testability hook associated with the application\\n     * @param elem root element\\n     */\\n    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem) || null; };\\n    /**\\n     * Get all registered testabilities\\n     */\\n    TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };\\n    /**\\n     * Get all registered applications(root elements)\\n     */\\n    TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };\\n    /**\\n     * Find testability of a node in the Tree\\n     * @param elem node\\n     * @param findInAncestors whether finding testability in ancestors if testability was not found in\\n     * current node\\n     */\\n    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {\\n        if (findInAncestors === void 0) { findInAncestors = true; }\\n        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\\n    };\\n    TestabilityRegistry = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [])\\n    ], TestabilityRegistry);\\n    return TestabilityRegistry;\\n}());\\nvar _NoopGetTestability = /** @class */ (function () {\\n    function _NoopGetTestability() {\\n    }\\n    _NoopGetTestability.prototype.addToWindow = function (registry) { };\\n    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {\\n        return null;\\n    };\\n    return _NoopGetTestability;\\n}());\\n/**\\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\\n * @publicApi\\n */\\nfunction setTestabilityGetter(getter) {\\n    _testabilityGetter = getter;\\n}\\nvar _testabilityGetter = new _NoopGetTestability();\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar _platform;\\nvar compileNgModuleFactory = compileNgModuleFactory__PRE_NGCC__;\\nfunction compileNgModuleFactory__PRE_NGCC__(injector, options, moduleType) {\\n    var compilerFactory = injector.get(CompilerFactory);\\n    var compiler = compilerFactory.createCompiler([options]);\\n    return compiler.compileModuleAsync(moduleType);\\n}\\nfunction compileNgModuleFactory__POST_NGCC__(injector, options, moduleType) {\\n    ngDevMode && assertNgModuleType(moduleType);\\n    return Promise.resolve(new NgModuleFactory$1(moduleType));\\n}\\nvar ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');\\n/**\\n * A token for third-party components that can register themselves with NgProbe.\\n *\\n * @publicApi\\n */\\nvar NgProbeToken = /** @class */ (function () {\\n    function NgProbeToken(name, token) {\\n        this.name = name;\\n        this.token = token;\\n    }\\n    return NgProbeToken;\\n}());\\n/**\\n * Creates a platform.\\n * Platforms have to be eagerly created via this function.\\n *\\n * @publicApi\\n */\\nfunction createPlatform(injector) {\\n    if (_platform && !_platform.destroyed &&\\n        !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\\n        throw new Error('There can be only one platform. Destroy the previous one to create a new one.');\\n    }\\n    _platform = injector.get(PlatformRef);\\n    var inits = injector.get(PLATFORM_INITIALIZER, null);\\n    if (inits)\\n        inits.forEach(function (init) { return init(); });\\n    return _platform;\\n}\\n/**\\n * Creates a factory for a platform\\n *\\n * @publicApi\\n */\\nfunction createPlatformFactory(parentPlatformFactory, name, providers) {\\n    if (providers === void 0) { providers = []; }\\n    var desc = \\\"Platform: \\\" + name;\\n    var marker = new InjectionToken(desc);\\n    return function (extraProviders) {\\n        if (extraProviders === void 0) { extraProviders = []; }\\n        var platform = getPlatform();\\n        if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\\n            if (parentPlatformFactory) {\\n                parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));\\n            }\\n            else {\\n                var injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true });\\n                createPlatform(Injector.create({ providers: injectedProviders, name: desc }));\\n            }\\n        }\\n        return assertPlatform(marker);\\n    };\\n}\\n/**\\n * Checks that there currently is a platform which contains the given token as a provider.\\n *\\n * @publicApi\\n */\\nfunction assertPlatform(requiredToken) {\\n    var platform = getPlatform();\\n    if (!platform) {\\n        throw new Error('No platform exists!');\\n    }\\n    if (!platform.injector.get(requiredToken, null)) {\\n        throw new Error('A platform with a different configuration has been created. Please destroy it first.');\\n    }\\n    return platform;\\n}\\n/**\\n * Destroy the existing platform.\\n *\\n * @publicApi\\n */\\nfunction destroyPlatform() {\\n    if (_platform && !_platform.destroyed) {\\n        _platform.destroy();\\n    }\\n}\\n/**\\n * Returns the current platform.\\n *\\n * @publicApi\\n */\\nfunction getPlatform() {\\n    return _platform && !_platform.destroyed ? _platform : null;\\n}\\n/**\\n * The Angular platform is the entry point for Angular on a web page. Each page\\n * has exactly one platform, and services (such as reflection) which are common\\n * to every Angular application running on the page are bound in its scope.\\n *\\n * A page's platform is initialized implicitly when a platform is created via a platform factory\\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\\n *\\n * @publicApi\\n */\\nvar PlatformRef = /** @class */ (function () {\\n    /** @internal */\\n    function PlatformRef(_injector) {\\n        this._injector = _injector;\\n        this._modules = [];\\n        this._destroyListeners = [];\\n        this._destroyed = false;\\n    }\\n    /**\\n     * Creates an instance of an `@NgModule` for the given platform\\n     * for offline compilation.\\n     *\\n     * @usageNotes\\n     * ### Simple Example\\n     *\\n     * ```typescript\\n     * my_module.ts:\\n     *\\n     * @NgModule({\\n     *   imports: [BrowserModule]\\n     * })\\n     * class MyModule {}\\n     *\\n     * main.ts:\\n     * import {MyModuleNgFactory} from './my_module.ngfactory';\\n     * import {platformBrowser} from '@angular/platform-browser';\\n     *\\n     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\\n     * ```\\n     */\\n    PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory, options) {\\n        var _this = this;\\n        // Note: We need to create the NgZone _before_ we instantiate the module,\\n        // as instantiating the module creates some providers eagerly.\\n        // So we create a mini parent injector that just contains the new NgZone and\\n        // pass that as parent to the NgModuleFactory.\\n        var ngZoneOption = options ? options.ngZone : undefined;\\n        var ngZone = getNgZone(ngZoneOption);\\n        var providers = [{ provide: NgZone, useValue: ngZone }];\\n        // Attention: Don't use ApplicationRef.run here,\\n        // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\\n        return ngZone.run(function () {\\n            var ngZoneInjector = Injector.create({ providers: providers, parent: _this.injector, name: moduleFactory.moduleType.name });\\n            var moduleRef = moduleFactory.create(ngZoneInjector);\\n            var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);\\n            if (!exceptionHandler) {\\n                throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\\n            }\\n            moduleRef.onDestroy(function () { return remove(_this._modules, moduleRef); });\\n            ngZone.runOutsideAngular(function () { return ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } }); });\\n            return _callAndReportToErrorHandler(exceptionHandler, ngZone, function () {\\n                var initStatus = moduleRef.injector.get(ApplicationInitStatus);\\n                initStatus.runInitializers();\\n                return initStatus.donePromise.then(function () {\\n                    _this._moduleDoBootstrap(moduleRef);\\n                    return moduleRef;\\n                });\\n            });\\n        });\\n    };\\n    /**\\n     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\\n     *\\n     * @usageNotes\\n     * ### Simple Example\\n     *\\n     * ```typescript\\n     * @NgModule({\\n     *   imports: [BrowserModule]\\n     * })\\n     * class MyModule {}\\n     *\\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\\n     * ```\\n     *\\n     */\\n    PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {\\n        var _this = this;\\n        if (compilerOptions === void 0) { compilerOptions = []; }\\n        var options = optionsReducer({}, compilerOptions);\\n        return compileNgModuleFactory(this.injector, options, moduleType)\\n            .then(function (moduleFactory) { return _this.bootstrapModuleFactory(moduleFactory, options); });\\n    };\\n    PlatformRef.prototype._moduleDoBootstrap = function (moduleRef) {\\n        var appRef = moduleRef.injector.get(ApplicationRef);\\n        if (moduleRef._bootstrapComponents.length > 0) {\\n            moduleRef._bootstrapComponents.forEach(function (f) { return appRef.bootstrap(f); });\\n        }\\n        else if (moduleRef.instance.ngDoBootstrap) {\\n            moduleRef.instance.ngDoBootstrap(appRef);\\n        }\\n        else {\\n            throw new Error(\\\"The module \\\" + stringify(moduleRef.instance.constructor) + \\\" was bootstrapped, but it does not declare \\\\\\\"@NgModule.bootstrap\\\\\\\" components nor a \\\\\\\"ngDoBootstrap\\\\\\\" method. \\\" +\\n                \\\"Please define one of these.\\\");\\n        }\\n        this._modules.push(moduleRef);\\n    };\\n    /**\\n     * Register a listener to be called when the platform is disposed.\\n     */\\n    PlatformRef.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\\n    Object.defineProperty(PlatformRef.prototype, \\\"injector\\\", {\\n        /**\\n         * Retrieve the platform {@link Injector}, which is the parent injector for\\n         * every Angular application on the page and provides singleton providers.\\n         */\\n        get: function () { return this._injector; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Destroy the Angular platform and all Angular applications on the page.\\n     */\\n    PlatformRef.prototype.destroy = function () {\\n        if (this._destroyed) {\\n            throw new Error('The platform has already been destroyed!');\\n        }\\n        this._modules.slice().forEach(function (module) { return module.destroy(); });\\n        this._destroyListeners.forEach(function (listener) { return listener(); });\\n        this._destroyed = true;\\n    };\\n    Object.defineProperty(PlatformRef.prototype, \\\"destroyed\\\", {\\n        get: function () { return this._destroyed; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    PlatformRef = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [Injector])\\n    ], PlatformRef);\\n    return PlatformRef;\\n}());\\nfunction getNgZone(ngZoneOption) {\\n    var ngZone;\\n    if (ngZoneOption === 'noop') {\\n        ngZone = new NoopNgZone();\\n    }\\n    else {\\n        ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) ||\\n            new NgZone({ enableLongStackTrace: isDevMode() });\\n    }\\n    return ngZone;\\n}\\nfunction _callAndReportToErrorHandler(errorHandler, ngZone, callback) {\\n    try {\\n        var result = callback();\\n        if (isPromise(result)) {\\n            return result.catch(function (e) {\\n                ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });\\n                // rethrow as the exception handler might not do it\\n                throw e;\\n            });\\n        }\\n        return result;\\n    }\\n    catch (e) {\\n        ngZone.runOutsideAngular(function () { return errorHandler.handleError(e); });\\n        // rethrow as the exception handler might not do it\\n        throw e;\\n    }\\n}\\nfunction optionsReducer(dst, objs) {\\n    if (Array.isArray(objs)) {\\n        dst = objs.reduce(optionsReducer, dst);\\n    }\\n    else {\\n        dst = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \\\"a\\\"])({}, dst, objs);\\n    }\\n    return dst;\\n}\\n/**\\n * A reference to an Angular application running on a page.\\n *\\n * @publicApi\\n */\\nvar ApplicationRef = /** @class */ (function () {\\n    /** @internal */\\n    function ApplicationRef(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {\\n        var _this = this;\\n        this._zone = _zone;\\n        this._console = _console;\\n        this._injector = _injector;\\n        this._exceptionHandler = _exceptionHandler;\\n        this._componentFactoryResolver = _componentFactoryResolver;\\n        this._initStatus = _initStatus;\\n        this._bootstrapListeners = [];\\n        this._views = [];\\n        this._runningTick = false;\\n        this._enforceNoNewChanges = false;\\n        this._stable = true;\\n        /**\\n         * Get a list of component types registered to this application.\\n         * This list is populated even before the component is created.\\n         */\\n        this.componentTypes = [];\\n        /**\\n         * Get a list of components registered to this application.\\n         */\\n        this.components = [];\\n        this._enforceNoNewChanges = isDevMode();\\n        this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });\\n        var isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_3__[/* Observable */ \\\"a\\\"](function (observer) {\\n            _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks &&\\n                !_this._zone.hasPendingMicrotasks;\\n            _this._zone.runOutsideAngular(function () {\\n                observer.next(_this._stable);\\n                observer.complete();\\n            });\\n        });\\n        var isStable = new rxjs__WEBPACK_IMPORTED_MODULE_3__[/* Observable */ \\\"a\\\"](function (observer) {\\n            // Create the subscription to onStable outside the Angular Zone so that\\n            // the callback is run outside the Angular Zone.\\n            var stableSub;\\n            _this._zone.runOutsideAngular(function () {\\n                stableSub = _this._zone.onStable.subscribe(function () {\\n                    NgZone.assertNotInAngularZone();\\n                    // Check whether there are no pending macro/micro tasks in the next tick\\n                    // to allow for NgZone to update the state.\\n                    scheduleMicroTask(function () {\\n                        if (!_this._stable && !_this._zone.hasPendingMacrotasks &&\\n                            !_this._zone.hasPendingMicrotasks) {\\n                            _this._stable = true;\\n                            observer.next(true);\\n                        }\\n                    });\\n                });\\n            });\\n            var unstableSub = _this._zone.onUnstable.subscribe(function () {\\n                NgZone.assertInAngularZone();\\n                if (_this._stable) {\\n                    _this._stable = false;\\n                    _this._zone.runOutsideAngular(function () { observer.next(false); });\\n                }\\n            });\\n            return function () {\\n                stableSub.unsubscribe();\\n                unstableSub.unsubscribe();\\n            };\\n        });\\n        this.isStable =\\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[/* merge */ \\\"a\\\"])(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* share */ \\\"a\\\"])()));\\n    }\\n    ApplicationRef_1 = ApplicationRef;\\n    /**\\n     * Bootstrap a new component at the root level of the application.\\n     *\\n     * @usageNotes\\n     * ### Bootstrap process\\n     *\\n     * When bootstrapping a new root component into an application, Angular mounts the\\n     * specified application component onto DOM elements identified by the componentType's\\n     * selector and kicks off automatic change detection to finish initializing the component.\\n     *\\n     * Optionally, a component can be mounted onto a DOM element that does not match the\\n     * componentType's selector.\\n     *\\n     * ### Example\\n     * {@example core/ts/platform/platform.ts region='longform'}\\n     */\\n    ApplicationRef.prototype.bootstrap = function (componentOrFactory, rootSelectorOrNode) {\\n        var _this = this;\\n        if (!this._initStatus.done) {\\n            throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\\n        }\\n        var componentFactory;\\n        if (componentOrFactory instanceof ComponentFactory) {\\n            componentFactory = componentOrFactory;\\n        }\\n        else {\\n            componentFactory =\\n                this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\\n        }\\n        this.componentTypes.push(componentFactory.componentType);\\n        // Create a factory associated with the current module if it's not bound to some other\\n        var ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?\\n            null :\\n            this._injector.get(NgModuleRef);\\n        var selectorOrNode = rootSelectorOrNode || componentFactory.selector;\\n        var compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\\n        compRef.onDestroy(function () { _this._unloadComponent(compRef); });\\n        var testability = compRef.injector.get(Testability, null);\\n        if (testability) {\\n            compRef.injector.get(TestabilityRegistry)\\n                .registerApplication(compRef.location.nativeElement, testability);\\n        }\\n        this._loadComponent(compRef);\\n        if (isDevMode()) {\\n            this._console.log(\\\"Angular is running in the development mode. Call enableProdMode() to enable the production mode.\\\");\\n        }\\n        return compRef;\\n    };\\n    /**\\n     * Invoke this method to explicitly process change detection and its side-effects.\\n     *\\n     * In development mode, `tick()` also performs a second change detection cycle to ensure that no\\n     * further changes are detected. If additional changes are picked up during this second cycle,\\n     * bindings in the app have side-effects that cannot be resolved in a single change detection\\n     * pass.\\n     * In this case, Angular throws an error, since an Angular application can only have one change\\n     * detection pass during which all change detection must complete.\\n     */\\n    ApplicationRef.prototype.tick = function () {\\n        var _this = this;\\n        if (this._runningTick) {\\n            throw new Error('ApplicationRef.tick is called recursively');\\n        }\\n        var scope = ApplicationRef_1._tickScope();\\n        try {\\n            this._runningTick = true;\\n            this._views.forEach(function (view) { return view.detectChanges(); });\\n            if (this._enforceNoNewChanges) {\\n                this._views.forEach(function (view) { return view.checkNoChanges(); });\\n            }\\n        }\\n        catch (e) {\\n            // Attention: Don't rethrow as it could cancel subscriptions to Observables!\\n            this._zone.runOutsideAngular(function () { return _this._exceptionHandler.handleError(e); });\\n        }\\n        finally {\\n            this._runningTick = false;\\n            wtfLeave(scope);\\n        }\\n    };\\n    /**\\n     * Attaches a view so that it will be dirty checked.\\n     * The view will be automatically detached when it is destroyed.\\n     * This will throw if the view is already attached to a ViewContainer.\\n     */\\n    ApplicationRef.prototype.attachView = function (viewRef) {\\n        var view = viewRef;\\n        this._views.push(view);\\n        view.attachToAppRef(this);\\n    };\\n    /**\\n     * Detaches a view from dirty checking again.\\n     */\\n    ApplicationRef.prototype.detachView = function (viewRef) {\\n        var view = viewRef;\\n        remove(this._views, view);\\n        view.detachFromAppRef();\\n    };\\n    ApplicationRef.prototype._loadComponent = function (componentRef) {\\n        this.attachView(componentRef.hostView);\\n        this.tick();\\n        this.components.push(componentRef);\\n        // Get the listeners lazily to prevent DI cycles.\\n        var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);\\n        listeners.forEach(function (listener) { return listener(componentRef); });\\n    };\\n    ApplicationRef.prototype._unloadComponent = function (componentRef) {\\n        this.detachView(componentRef.hostView);\\n        remove(this.components, componentRef);\\n    };\\n    /** @internal */\\n    ApplicationRef.prototype.ngOnDestroy = function () {\\n        // TODO(alxhub): Dispose of the NgZone.\\n        this._views.slice().forEach(function (view) { return view.destroy(); });\\n    };\\n    Object.defineProperty(ApplicationRef.prototype, \\\"viewCount\\\", {\\n        /**\\n         * Returns the number of attached views.\\n         */\\n        get: function () { return this._views.length; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    var ApplicationRef_1;\\n    /** @internal */\\n    ApplicationRef._tickScope = wtfCreateScope('ApplicationRef#tick()');\\n    ApplicationRef = ApplicationRef_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [NgZone, Console, Injector,\\n            ErrorHandler,\\n            ComponentFactoryResolver,\\n            ApplicationInitStatus])\\n    ], ApplicationRef);\\n    return ApplicationRef;\\n}());\\nfunction remove(list, el) {\\n    var index = list.indexOf(el);\\n    if (index > -1) {\\n        list.splice(index, 1);\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Used to load ng module factories.\\n *\\n * @publicApi\\n */\\nvar NgModuleFactoryLoader = /** @class */ (function () {\\n    function NgModuleFactoryLoader() {\\n    }\\n    return NgModuleFactoryLoader;\\n}());\\nvar moduleFactories = new Map();\\n/**\\n * Registers a loaded module. Should only be called from generated NgModuleFactory code.\\n * @publicApi\\n */\\nfunction registerModuleFactory(id, factory) {\\n    var existing = moduleFactories.get(id);\\n    if (existing) {\\n        throw new Error(\\\"Duplicate module registered for \\\" + id + \\\" - \\\" + existing.moduleType.name + \\\" vs \\\" + factory.moduleType.name);\\n    }\\n    moduleFactories.set(id, factory);\\n}\\n/**\\n * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\\n * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\\n * cannot be found.\\n * @publicApi\\n */\\nfunction getModuleFactory(id) {\\n    var factory = moduleFactories.get(id);\\n    if (!factory)\\n        throw new Error(\\\"No module with ID \\\" + id + \\\" loaded\\\");\\n    return factory;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * An unmodifiable list of items that Angular keeps up to date when the state\\n * of the application changes.\\n *\\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\\n * provide.\\n *\\n * Implements an iterable interface, therefore it can be used in both ES6\\n * javascript `for (var i of items)` loops as well as in Angular templates with\\n * `*ngFor=\\\"let i of myList\\\"`.\\n *\\n * Changes can be observed by subscribing to the changes `Observable`.\\n *\\n * NOTE: In the future this class will implement an `Observable` interface.\\n *\\n * @usageNotes\\n * ### Example\\n * ```typescript\\n * @Component({...})\\n * class Container {\\n *   @ViewChildren(Item) items:QueryList<Item>;\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar QueryList$1 = /** @class */ (function () {\\n    function QueryList() {\\n        this.dirty = true;\\n        this._results = [];\\n        this.changes = new EventEmitter();\\n        this.length = 0;\\n    }\\n    /**\\n     * See\\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\\n     */\\n    QueryList.prototype.map = function (fn) { return this._results.map(fn); };\\n    /**\\n     * See\\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\\n     */\\n    QueryList.prototype.filter = function (fn) {\\n        return this._results.filter(fn);\\n    };\\n    /**\\n     * See\\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\\n     */\\n    QueryList.prototype.find = function (fn) {\\n        return this._results.find(fn);\\n    };\\n    /**\\n     * See\\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\\n     */\\n    QueryList.prototype.reduce = function (fn, init) {\\n        return this._results.reduce(fn, init);\\n    };\\n    /**\\n     * See\\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\\n     */\\n    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };\\n    /**\\n     * See\\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\\n     */\\n    QueryList.prototype.some = function (fn) {\\n        return this._results.some(fn);\\n    };\\n    QueryList.prototype.toArray = function () { return this._results.slice(); };\\n    QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };\\n    QueryList.prototype.toString = function () { return this._results.toString(); };\\n    QueryList.prototype.reset = function (res) {\\n        this._results = flatten$2(res);\\n        this.dirty = false;\\n        this.length = this._results.length;\\n        this.last = this._results[this.length - 1];\\n        this.first = this._results[0];\\n    };\\n    QueryList.prototype.notifyOnChanges = function () { this.changes.emit(this); };\\n    /** internal */\\n    QueryList.prototype.setDirty = function () { this.dirty = true; };\\n    /** internal */\\n    QueryList.prototype.destroy = function () {\\n        this.changes.complete();\\n        this.changes.unsubscribe();\\n    };\\n    return QueryList;\\n}());\\nfunction flatten$2(list) {\\n    return list.reduce(function (flat, item) {\\n        var flatItem = Array.isArray(item) ? flatten$2(item) : item;\\n        return flat.concat(flatItem);\\n    }, []);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar _SEPARATOR = '#';\\nvar FACTORY_CLASS_SUFFIX = 'NgFactory';\\n/**\\n * Configuration for SystemJsNgModuleLoader.\\n * token.\\n *\\n * @publicApi\\n */\\nvar SystemJsNgModuleLoaderConfig = /** @class */ (function () {\\n    function SystemJsNgModuleLoaderConfig() {\\n    }\\n    return SystemJsNgModuleLoaderConfig;\\n}());\\nvar DEFAULT_CONFIG = {\\n    factoryPathPrefix: '',\\n    factoryPathSuffix: '.ngfactory',\\n};\\n/**\\n * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\\n * @publicApi\\n */\\nvar SystemJsNgModuleLoader = /** @class */ (function () {\\n    function SystemJsNgModuleLoader(_compiler, config) {\\n        this._compiler = _compiler;\\n        this._config = config || DEFAULT_CONFIG;\\n    }\\n    SystemJsNgModuleLoader.prototype.load = function (path) {\\n        var offlineMode = this._compiler instanceof Compiler;\\n        return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);\\n    };\\n    SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {\\n        var _this = this;\\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];\\n        if (exportName === undefined) {\\n            exportName = 'default';\\n        }\\n        return __webpack_require__(128)(module)\\n            .then(function (module) { return module[exportName]; })\\n            .then(function (type) { return checkNotEmpty(type, module, exportName); })\\n            .then(function (type) { return _this._compiler.compileModuleAsync(type); });\\n    };\\n    SystemJsNgModuleLoader.prototype.loadFactory = function (path) {\\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(path.split(_SEPARATOR), 2), module = _a[0], exportName = _a[1];\\n        var factoryClassSuffix = FACTORY_CLASS_SUFFIX;\\n        if (exportName === undefined) {\\n            exportName = 'default';\\n            factoryClassSuffix = '';\\n        }\\n        return __webpack_require__(128)(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)\\n            .then(function (module) { return module[exportName + factoryClassSuffix]; })\\n            .then(function (factory) { return checkNotEmpty(factory, module, exportName); });\\n    };\\n    SystemJsNgModuleLoader = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Injectable(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __param */ \\\"e\\\"])(1, Optional()),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [Compiler, SystemJsNgModuleLoaderConfig])\\n    ], SystemJsNgModuleLoader);\\n    return SystemJsNgModuleLoader;\\n}());\\nfunction checkNotEmpty(value, modulePath, exportName) {\\n    if (!value) {\\n        throw new Error(\\\"Cannot find '\\\" + exportName + \\\"' in '\\\" + modulePath + \\\"'\\\");\\n    }\\n    return value;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Represents a container where one or more views can be attached to a component.\\n *\\n * Can contain *host views* (created by instantiating a\\n * component with the `createComponent()` method), and *embedded views*\\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\\n *\\n * A view container instance can contain other view containers,\\n * creating a [view hierarchy](guide/glossary#view-tree).\\n *\\n * @see `ComponentRef`\\n * @see `EmbeddedViewRef`\\n *\\n * @publicApi\\n */\\nvar ViewContainerRef = /** @class */ (function () {\\n    function ViewContainerRef() {\\n    }\\n    /** @internal */\\n    ViewContainerRef.__NG_ELEMENT_ID__ = function () { return R3_VIEW_CONTAINER_REF_FACTORY$1(ViewContainerRef, ElementRef); };\\n    return ViewContainerRef;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Base class for Angular Views, provides change detection functionality.\\n * A change-detection tree collects all views that are to be checked for changes.\\n * Use the methods to add and remove views from the tree, initiate change-detection,\\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.\\n *\\n * @usageNotes\\n *\\n * The following examples demonstrate how to modify default change-detection behavior\\n * to perform explicit detection when needed.\\n *\\n * ### Use `markForCheck()` with `CheckOnce` strategy\\n *\\n * The following example sets the `OnPush` change-detection strategy for a component\\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\\n * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).\\n *\\n * <code-example path=\\\"core/ts/change_detect/change-detection.ts\\\"\\n * region=\\\"mark-for-check\\\"></code-example>\\n *\\n * ### Detach change detector to limit how often check occurs\\n *\\n * The following example defines a component with a large list of read-only data\\n * that is expected to change constantly, many times per second.\\n * To improve performance, we want to check and update the list\\n * less often than the changes actually occur. To do that, we detach\\n * the component's change detector and perform an explicit local check every five seconds.\\n *\\n * <code-example path=\\\"core/ts/change_detect/change-detection.ts\\\" region=\\\"detach\\\"></code-example>\\n *\\n *\\n * ### Reattaching a detached component\\n *\\n * The following example creates a component displaying live data.\\n * The component detaches its change detector from the main change detector tree\\n * when the `live` property is set to false, and reattaches it when the property\\n * becomes true.\\n *\\n * <code-example path=\\\"core/ts/change_detect/change-detection.ts\\\" region=\\\"reattach\\\"></code-example>\\n *\\n * @publicApi\\n */\\nvar ChangeDetectorRef = /** @class */ (function () {\\n    function ChangeDetectorRef() {\\n    }\\n    /** @internal */\\n    ChangeDetectorRef.__NG_ELEMENT_ID__ = function () { return R3_CHANGE_DETECTOR_REF_FACTORY$1(); };\\n    return ChangeDetectorRef;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Represents an Angular [view](guide/glossary#view),\\n * specifically the [host view](guide/glossary#view-tree) that is defined by a component.\\n * Also serves as the base class\\n * that adds destroy methods for [embedded views](guide/glossary#view-tree).\\n *\\n * @see `EmbeddedViewRef`\\n *\\n * @publicApi\\n */\\nvar ViewRef$1 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ViewRef, _super);\\n    function ViewRef() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return ViewRef;\\n}(ChangeDetectorRef));\\n/**\\n * Represents an Angular [view](guide/glossary#view) in a view container.\\n * An [embedded view](guide/glossary#view-tree) can be referenced from a component\\n * other than the hosting component whose template defines it, or it can be defined\\n * independently by a `TemplateRef`.\\n *\\n * Properties of elements in a view can change, but the structure (number and order) of elements in\\n * a view cannot. Change the structure of elements by inserting, moving, or\\n * removing nested views in a view container.\\n *\\n * @see `ViewContainerRef`\\n *\\n * @usageNotes\\n *\\n * The following template breaks down into two separate `TemplateRef` instances,\\n * an outer one and an inner one.\\n *\\n * ```\\n * Count: {{items.length}}\\n * <ul>\\n *   <li *ngFor=\\\"let  item of items\\\">{{item}}</li>\\n * </ul>\\n * ```\\n *\\n * This is the outer `TemplateRef`:\\n *\\n * ```\\n * Count: {{items.length}}\\n * <ul>\\n *   <ng-template ngFor let-item [ngForOf]=\\\"items\\\"></ng-template>\\n * </ul>\\n * ```\\n *\\n * This is the inner `TemplateRef`:\\n *\\n * ```\\n *   <li>{{item}}</li>\\n * ```\\n *\\n * The outer and inner `TemplateRef` instances are assembled into views as follows:\\n *\\n * ```\\n * \\x3c!-- ViewRef: outer-0 --\\x3e\\n * Count: 2\\n * <ul>\\n *   <ng-template view-container-ref></ng-template>\\n *   \\x3c!-- ViewRef: inner-1 --\\x3e<li>first</li>\\x3c!-- /ViewRef: inner-1 --\\x3e\\n *   \\x3c!-- ViewRef: inner-2 --\\x3e<li>second</li>\\x3c!-- /ViewRef: inner-2 --\\x3e\\n * </ul>\\n * \\x3c!-- /ViewRef: outer-0 --\\x3e\\n * ```\\n * @publicApi\\n */\\nvar EmbeddedViewRef = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(EmbeddedViewRef, _super);\\n    function EmbeddedViewRef() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return EmbeddedViewRef;\\n}(ViewRef$1));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar EventListener = /** @class */ (function () {\\n    function EventListener(name, callback) {\\n        this.name = name;\\n        this.callback = callback;\\n    }\\n    return EventListener;\\n}());\\n/**\\n * @publicApi\\n */\\nvar DebugNode = /** @class */ (function () {\\n    function DebugNode(nativeNode, parent, _debugContext) {\\n        this.nativeNode = nativeNode;\\n        this._debugContext = _debugContext;\\n        this.listeners = [];\\n        this.parent = null;\\n        if (parent && parent instanceof DebugElement) {\\n            parent.addChild(this);\\n        }\\n    }\\n    Object.defineProperty(DebugNode.prototype, \\\"injector\\\", {\\n        get: function () { return this._debugContext.injector; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugNode.prototype, \\\"componentInstance\\\", {\\n        get: function () { return this._debugContext.component; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugNode.prototype, \\\"context\\\", {\\n        get: function () { return this._debugContext.context; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugNode.prototype, \\\"references\\\", {\\n        get: function () { return this._debugContext.references; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugNode.prototype, \\\"providerTokens\\\", {\\n        get: function () { return this._debugContext.providerTokens; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return DebugNode;\\n}());\\n/**\\n * @publicApi\\n */\\nvar DebugElement = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(DebugElement, _super);\\n    function DebugElement(nativeNode, parent, _debugContext) {\\n        var _this = _super.call(this, nativeNode, parent, _debugContext) || this;\\n        _this.properties = {};\\n        _this.attributes = {};\\n        _this.classes = {};\\n        _this.styles = {};\\n        _this.childNodes = [];\\n        _this.nativeElement = nativeNode;\\n        return _this;\\n    }\\n    DebugElement.prototype.addChild = function (child) {\\n        if (child) {\\n            this.childNodes.push(child);\\n            child.parent = this;\\n        }\\n    };\\n    DebugElement.prototype.removeChild = function (child) {\\n        var childIndex = this.childNodes.indexOf(child);\\n        if (childIndex !== -1) {\\n            child.parent = null;\\n            this.childNodes.splice(childIndex, 1);\\n        }\\n    };\\n    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {\\n        var _this = this;\\n        var _a;\\n        var siblingIndex = this.childNodes.indexOf(child);\\n        if (siblingIndex !== -1) {\\n            (_a = this.childNodes).splice.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([siblingIndex + 1, 0], newChildren));\\n            newChildren.forEach(function (c) {\\n                if (c.parent) {\\n                    c.parent.removeChild(c);\\n                }\\n                c.parent = _this;\\n            });\\n        }\\n    };\\n    DebugElement.prototype.insertBefore = function (refChild, newChild) {\\n        var refIndex = this.childNodes.indexOf(refChild);\\n        if (refIndex === -1) {\\n            this.addChild(newChild);\\n        }\\n        else {\\n            if (newChild.parent) {\\n                newChild.parent.removeChild(newChild);\\n            }\\n            newChild.parent = this;\\n            this.childNodes.splice(refIndex, 0, newChild);\\n        }\\n    };\\n    DebugElement.prototype.query = function (predicate) {\\n        var results = this.queryAll(predicate);\\n        return results[0] || null;\\n    };\\n    DebugElement.prototype.queryAll = function (predicate) {\\n        var matches = [];\\n        _queryElementChildren(this, predicate, matches);\\n        return matches;\\n    };\\n    DebugElement.prototype.queryAllNodes = function (predicate) {\\n        var matches = [];\\n        _queryNodeChildren(this, predicate, matches);\\n        return matches;\\n    };\\n    Object.defineProperty(DebugElement.prototype, \\\"children\\\", {\\n        get: function () {\\n            return this.childNodes.filter(function (node) { return node instanceof DebugElement; });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {\\n        this.listeners.forEach(function (listener) {\\n            if (listener.name == eventName) {\\n                listener.callback(eventObj);\\n            }\\n        });\\n    };\\n    return DebugElement;\\n}(DebugNode));\\n/**\\n * @publicApi\\n */\\nfunction asNativeElements(debugEls) {\\n    return debugEls.map(function (el) { return el.nativeElement; });\\n}\\nfunction _queryElementChildren(element, predicate, matches) {\\n    element.childNodes.forEach(function (node) {\\n        if (node instanceof DebugElement) {\\n            if (predicate(node)) {\\n                matches.push(node);\\n            }\\n            _queryElementChildren(node, predicate, matches);\\n        }\\n    });\\n}\\nfunction _queryNodeChildren(parentNode, predicate, matches) {\\n    if (parentNode instanceof DebugElement) {\\n        parentNode.childNodes.forEach(function (node) {\\n            if (predicate(node)) {\\n                matches.push(node);\\n            }\\n            if (node instanceof DebugElement) {\\n                _queryNodeChildren(node, predicate, matches);\\n            }\\n        });\\n    }\\n}\\n// Need to keep the nodes in a global Map so that multiple angular apps are supported.\\nvar _nativeNodeToDebugNode = new Map();\\n/**\\n * @publicApi\\n */\\nfunction getDebugNode(nativeNode) {\\n    return _nativeNodeToDebugNode.get(nativeNode) || null;\\n}\\nfunction indexDebugNode(node) {\\n    _nativeNodeToDebugNode.set(node.nativeNode, node);\\n}\\nfunction removeDebugNodeFromIndex(node) {\\n    _nativeNodeToDebugNode.delete(node.nativeNode);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar DefaultIterableDifferFactory = /** @class */ (function () {\\n    function DefaultIterableDifferFactory() {\\n    }\\n    DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };\\n    DefaultIterableDifferFactory.prototype.create = function (trackByFn) {\\n        return new DefaultIterableDiffer(trackByFn);\\n    };\\n    return DefaultIterableDifferFactory;\\n}());\\nvar trackByIdentity = function (index, item) { return item; };\\n/**\\n * @deprecated v4.0.0 - Should not be part of public API.\\n * @publicApi\\n */\\nvar DefaultIterableDiffer = /** @class */ (function () {\\n    function DefaultIterableDiffer(trackByFn) {\\n        this.length = 0;\\n        // Keeps track of the used records at any point in time (during & across `_check()` calls)\\n        this._linkedRecords = null;\\n        // Keeps track of the removed records at any point in time during `_check()` calls.\\n        this._unlinkedRecords = null;\\n        this._previousItHead = null;\\n        this._itHead = null;\\n        this._itTail = null;\\n        this._additionsHead = null;\\n        this._additionsTail = null;\\n        this._movesHead = null;\\n        this._movesTail = null;\\n        this._removalsHead = null;\\n        this._removalsTail = null;\\n        // Keeps track of records where custom track by is the same, but item identity has changed\\n        this._identityChangesHead = null;\\n        this._identityChangesTail = null;\\n        this._trackByFn = trackByFn || trackByIdentity;\\n    }\\n    DefaultIterableDiffer.prototype.forEachItem = function (fn) {\\n        var record;\\n        for (record = this._itHead; record !== null; record = record._next) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachOperation = function (fn) {\\n        var nextIt = this._itHead;\\n        var nextRemove = this._removalsHead;\\n        var addRemoveOffset = 0;\\n        var moveOffsets = null;\\n        while (nextIt || nextRemove) {\\n            // Figure out which is the next record to process\\n            // Order: remove, add, move\\n            var record = !nextRemove ||\\n                nextIt &&\\n                    nextIt.currentIndex <\\n                        getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\\n                nextIt :\\n                nextRemove;\\n            var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\\n            var currentIndex = record.currentIndex;\\n            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\\n            if (record === nextRemove) {\\n                addRemoveOffset--;\\n                nextRemove = nextRemove._nextRemoved;\\n            }\\n            else {\\n                nextIt = nextIt._next;\\n                if (record.previousIndex == null) {\\n                    addRemoveOffset++;\\n                }\\n                else {\\n                    // INVARIANT:  currentIndex < previousIndex\\n                    if (!moveOffsets)\\n                        moveOffsets = [];\\n                    var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\\n                    var localCurrentIndex = currentIndex - addRemoveOffset;\\n                    if (localMovePreviousIndex != localCurrentIndex) {\\n                        for (var i = 0; i < localMovePreviousIndex; i++) {\\n                            var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\\n                            var index = offset + i;\\n                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {\\n                                moveOffsets[i] = offset + 1;\\n                            }\\n                        }\\n                        var previousIndex = record.previousIndex;\\n                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\\n                    }\\n                }\\n            }\\n            if (adjPreviousIndex !== currentIndex) {\\n                fn(record, adjPreviousIndex, currentIndex);\\n            }\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {\\n        var record;\\n        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {\\n        var record;\\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {\\n        var record;\\n        for (record = this._movesHead; record !== null; record = record._nextMoved) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {\\n        var record;\\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {\\n        var record;\\n        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\\n            fn(record);\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.diff = function (collection) {\\n        if (collection == null)\\n            collection = [];\\n        if (!isListLikeIterable(collection)) {\\n            throw new Error(\\\"Error trying to diff '\\\" + stringify(collection) + \\\"'. Only arrays and iterables are allowed\\\");\\n        }\\n        if (this.check(collection)) {\\n            return this;\\n        }\\n        else {\\n            return null;\\n        }\\n    };\\n    DefaultIterableDiffer.prototype.onDestroy = function () { };\\n    DefaultIterableDiffer.prototype.check = function (collection) {\\n        var _this = this;\\n        this._reset();\\n        var record = this._itHead;\\n        var mayBeDirty = false;\\n        var index;\\n        var item;\\n        var itemTrackBy;\\n        if (Array.isArray(collection)) {\\n            this.length = collection.length;\\n            for (var index_1 = 0; index_1 < this.length; index_1++) {\\n                item = collection[index_1];\\n                itemTrackBy = this._trackByFn(index_1, item);\\n                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\\n                    record = this._mismatch(record, item, itemTrackBy, index_1);\\n                    mayBeDirty = true;\\n                }\\n                else {\\n                    if (mayBeDirty) {\\n                        // TODO(misko): can we limit this to duplicates only?\\n                        record = this._verifyReinsertion(record, item, itemTrackBy, index_1);\\n                    }\\n                    if (!looseIdentical(record.item, item))\\n                        this._addIdentityChange(record, item);\\n                }\\n                record = record._next;\\n            }\\n        }\\n        else {\\n            index = 0;\\n            iterateListLike(collection, function (item) {\\n                itemTrackBy = _this._trackByFn(index, item);\\n                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {\\n                    record = _this._mismatch(record, item, itemTrackBy, index);\\n                    mayBeDirty = true;\\n                }\\n                else {\\n                    if (mayBeDirty) {\\n                        // TODO(misko): can we limit this to duplicates only?\\n                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);\\n                    }\\n                    if (!looseIdentical(record.item, item))\\n                        _this._addIdentityChange(record, item);\\n                }\\n                record = record._next;\\n                index++;\\n            });\\n            this.length = index;\\n        }\\n        this._truncate(record);\\n        this.collection = collection;\\n        return this.isDirty;\\n    };\\n    Object.defineProperty(DefaultIterableDiffer.prototype, \\\"isDirty\\\", {\\n        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\\n         * changes.\\n         */\\n        get: function () {\\n            return this._additionsHead !== null || this._movesHead !== null ||\\n                this._removalsHead !== null || this._identityChangesHead !== null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Reset the state of the change objects to show no changes. This means set previousKey to\\n     * currentKey, and clear all of the queues (additions, moves, removals).\\n     * Set the previousIndexes of moved and added items to their currentIndexes\\n     * Reset the list of additions, moves and removals\\n     *\\n     * @internal\\n     */\\n    DefaultIterableDiffer.prototype._reset = function () {\\n        if (this.isDirty) {\\n            var record = void 0;\\n            var nextRecord = void 0;\\n            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\\n                record._nextPrevious = record._next;\\n            }\\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\\n                record.previousIndex = record.currentIndex;\\n            }\\n            this._additionsHead = this._additionsTail = null;\\n            for (record = this._movesHead; record !== null; record = nextRecord) {\\n                record.previousIndex = record.currentIndex;\\n                nextRecord = record._nextMoved;\\n            }\\n            this._movesHead = this._movesTail = null;\\n            this._removalsHead = this._removalsTail = null;\\n            this._identityChangesHead = this._identityChangesTail = null;\\n            // TODO(vicb): when assert gets supported\\n            // assert(!this.isDirty);\\n        }\\n    };\\n    /**\\n     * This is the core function which handles differences between collections.\\n     *\\n     * - `record` is the record which we saw at this position last time. If null then it is a new\\n     *   item.\\n     * - `item` is the current item in the collection\\n     * - `index` is the position of the item in the collection\\n     *\\n     * @internal\\n     */\\n    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {\\n        // The previous record after which we will append the current one.\\n        var previousRecord;\\n        if (record === null) {\\n            previousRecord = this._itTail;\\n        }\\n        else {\\n            previousRecord = record._prev;\\n            // Remove the record from the collection since we know it does not match the item.\\n            this._remove(record);\\n        }\\n        // Attempt to see if we have seen the item before.\\n        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\\n        if (record !== null) {\\n            // We have seen this before, we need to move it forward in the collection.\\n            // But first we need to check if identity changed, so we can update in view if necessary\\n            if (!looseIdentical(record.item, item))\\n                this._addIdentityChange(record, item);\\n            this._moveAfter(record, previousRecord, index);\\n        }\\n        else {\\n            // Never seen it, check evicted list.\\n            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\\n            if (record !== null) {\\n                // It is an item which we have evicted earlier: reinsert it back into the list.\\n                // But first we need to check if identity changed, so we can update in view if necessary\\n                if (!looseIdentical(record.item, item))\\n                    this._addIdentityChange(record, item);\\n                this._reinsertAfter(record, previousRecord, index);\\n            }\\n            else {\\n                // It is a new item: add it.\\n                record =\\n                    this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);\\n            }\\n        }\\n        return record;\\n    };\\n    /**\\n     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\\n     *\\n     * Use case: `[a, a]` => `[b, a, a]`\\n     *\\n     * If we did not have this check then the insertion of `b` would:\\n     *   1) evict first `a`\\n     *   2) insert `b` at `0` index.\\n     *   3) leave `a` at index `1` as is. <-- this is wrong!\\n     *   3) reinsert `a` at index 2. <-- this is wrong!\\n     *\\n     * The correct behavior is:\\n     *   1) evict first `a`\\n     *   2) insert `b` at `0` index.\\n     *   3) reinsert `a` at index 1.\\n     *   3) move `a` at from `1` to `2`.\\n     *\\n     *\\n     * Double check that we have not evicted a duplicate item. We need to check if the item type may\\n     * have already been removed:\\n     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\\n     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\\n     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\\n     * at the end.\\n     *\\n     * @internal\\n     */\\n    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {\\n        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\\n        if (reinsertRecord !== null) {\\n            record = this._reinsertAfter(reinsertRecord, record._prev, index);\\n        }\\n        else if (record.currentIndex != index) {\\n            record.currentIndex = index;\\n            this._addToMoves(record, index);\\n        }\\n        return record;\\n    };\\n    /**\\n     * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\\n     *\\n     * - `record` The first excess {@link IterableChangeRecord_}.\\n     *\\n     * @internal\\n     */\\n    DefaultIterableDiffer.prototype._truncate = function (record) {\\n        // Anything after that needs to be removed;\\n        while (record !== null) {\\n            var nextRecord = record._next;\\n            this._addToRemovals(this._unlink(record));\\n            record = nextRecord;\\n        }\\n        if (this._unlinkedRecords !== null) {\\n            this._unlinkedRecords.clear();\\n        }\\n        if (this._additionsTail !== null) {\\n            this._additionsTail._nextAdded = null;\\n        }\\n        if (this._movesTail !== null) {\\n            this._movesTail._nextMoved = null;\\n        }\\n        if (this._itTail !== null) {\\n            this._itTail._next = null;\\n        }\\n        if (this._removalsTail !== null) {\\n            this._removalsTail._nextRemoved = null;\\n        }\\n        if (this._identityChangesTail !== null) {\\n            this._identityChangesTail._nextIdentityChange = null;\\n        }\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {\\n        if (this._unlinkedRecords !== null) {\\n            this._unlinkedRecords.remove(record);\\n        }\\n        var prev = record._prevRemoved;\\n        var next = record._nextRemoved;\\n        if (prev === null) {\\n            this._removalsHead = next;\\n        }\\n        else {\\n            prev._nextRemoved = next;\\n        }\\n        if (next === null) {\\n            this._removalsTail = prev;\\n        }\\n        else {\\n            next._prevRemoved = prev;\\n        }\\n        this._insertAfter(record, prevRecord, index);\\n        this._addToMoves(record, index);\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {\\n        this._unlink(record);\\n        this._insertAfter(record, prevRecord, index);\\n        this._addToMoves(record, index);\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {\\n        this._insertAfter(record, prevRecord, index);\\n        if (this._additionsTail === null) {\\n            // TODO(vicb):\\n            // assert(this._additionsHead === null);\\n            this._additionsTail = this._additionsHead = record;\\n        }\\n        else {\\n            // TODO(vicb):\\n            // assert(_additionsTail._nextAdded === null);\\n            // assert(record._nextAdded === null);\\n            this._additionsTail = this._additionsTail._nextAdded = record;\\n        }\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {\\n        // TODO(vicb):\\n        // assert(record != prevRecord);\\n        // assert(record._next === null);\\n        // assert(record._prev === null);\\n        var next = prevRecord === null ? this._itHead : prevRecord._next;\\n        // TODO(vicb):\\n        // assert(next != record);\\n        // assert(prevRecord != record);\\n        record._next = next;\\n        record._prev = prevRecord;\\n        if (next === null) {\\n            this._itTail = record;\\n        }\\n        else {\\n            next._prev = record;\\n        }\\n        if (prevRecord === null) {\\n            this._itHead = record;\\n        }\\n        else {\\n            prevRecord._next = record;\\n        }\\n        if (this._linkedRecords === null) {\\n            this._linkedRecords = new _DuplicateMap();\\n        }\\n        this._linkedRecords.put(record);\\n        record.currentIndex = index;\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._remove = function (record) {\\n        return this._addToRemovals(this._unlink(record));\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._unlink = function (record) {\\n        if (this._linkedRecords !== null) {\\n            this._linkedRecords.remove(record);\\n        }\\n        var prev = record._prev;\\n        var next = record._next;\\n        // TODO(vicb):\\n        // assert((record._prev = null) === null);\\n        // assert((record._next = null) === null);\\n        if (prev === null) {\\n            this._itHead = next;\\n        }\\n        else {\\n            prev._next = next;\\n        }\\n        if (next === null) {\\n            this._itTail = prev;\\n        }\\n        else {\\n            next._prev = prev;\\n        }\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {\\n        // TODO(vicb):\\n        // assert(record._nextMoved === null);\\n        if (record.previousIndex === toIndex) {\\n            return record;\\n        }\\n        if (this._movesTail === null) {\\n            // TODO(vicb):\\n            // assert(_movesHead === null);\\n            this._movesTail = this._movesHead = record;\\n        }\\n        else {\\n            // TODO(vicb):\\n            // assert(_movesTail._nextMoved === null);\\n            this._movesTail = this._movesTail._nextMoved = record;\\n        }\\n        return record;\\n    };\\n    DefaultIterableDiffer.prototype._addToRemovals = function (record) {\\n        if (this._unlinkedRecords === null) {\\n            this._unlinkedRecords = new _DuplicateMap();\\n        }\\n        this._unlinkedRecords.put(record);\\n        record.currentIndex = null;\\n        record._nextRemoved = null;\\n        if (this._removalsTail === null) {\\n            // TODO(vicb):\\n            // assert(_removalsHead === null);\\n            this._removalsTail = this._removalsHead = record;\\n            record._prevRemoved = null;\\n        }\\n        else {\\n            // TODO(vicb):\\n            // assert(_removalsTail._nextRemoved === null);\\n            // assert(record._nextRemoved === null);\\n            record._prevRemoved = this._removalsTail;\\n            this._removalsTail = this._removalsTail._nextRemoved = record;\\n        }\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {\\n        record.item = item;\\n        if (this._identityChangesTail === null) {\\n            this._identityChangesTail = this._identityChangesHead = record;\\n        }\\n        else {\\n            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\\n        }\\n        return record;\\n    };\\n    return DefaultIterableDiffer;\\n}());\\nvar IterableChangeRecord_ = /** @class */ (function () {\\n    function IterableChangeRecord_(item, trackById) {\\n        this.item = item;\\n        this.trackById = trackById;\\n        this.currentIndex = null;\\n        this.previousIndex = null;\\n        /** @internal */\\n        this._nextPrevious = null;\\n        /** @internal */\\n        this._prev = null;\\n        /** @internal */\\n        this._next = null;\\n        /** @internal */\\n        this._prevDup = null;\\n        /** @internal */\\n        this._nextDup = null;\\n        /** @internal */\\n        this._prevRemoved = null;\\n        /** @internal */\\n        this._nextRemoved = null;\\n        /** @internal */\\n        this._nextAdded = null;\\n        /** @internal */\\n        this._nextMoved = null;\\n        /** @internal */\\n        this._nextIdentityChange = null;\\n    }\\n    return IterableChangeRecord_;\\n}());\\n// A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item\\nvar _DuplicateItemRecordList = /** @class */ (function () {\\n    function _DuplicateItemRecordList() {\\n        /** @internal */\\n        this._head = null;\\n        /** @internal */\\n        this._tail = null;\\n    }\\n    /**\\n     * Append the record to the list of duplicates.\\n     *\\n     * Note: by design all records in the list of duplicates hold the same value in record.item.\\n     */\\n    _DuplicateItemRecordList.prototype.add = function (record) {\\n        if (this._head === null) {\\n            this._head = this._tail = record;\\n            record._nextDup = null;\\n            record._prevDup = null;\\n        }\\n        else {\\n            // TODO(vicb):\\n            // assert(record.item ==  _head.item ||\\n            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\\n            this._tail._nextDup = record;\\n            record._prevDup = this._tail;\\n            record._nextDup = null;\\n            this._tail = record;\\n        }\\n    };\\n    // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\\n    // IterableChangeRecord_.currentIndex >= atOrAfterIndex\\n    _DuplicateItemRecordList.prototype.get = function (trackById, atOrAfterIndex) {\\n        var record;\\n        for (record = this._head; record !== null; record = record._nextDup) {\\n            if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&\\n                looseIdentical(record.trackById, trackById)) {\\n                return record;\\n            }\\n        }\\n        return null;\\n    };\\n    /**\\n     * Remove one {@link IterableChangeRecord_} from the list of duplicates.\\n     *\\n     * Returns whether the list of duplicates is empty.\\n     */\\n    _DuplicateItemRecordList.prototype.remove = function (record) {\\n        // TODO(vicb):\\n        // assert(() {\\n        //  // verify that the record being removed is in the list.\\n        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\\n        //    if (identical(cursor, record)) return true;\\n        //  }\\n        //  return false;\\n        //});\\n        var prev = record._prevDup;\\n        var next = record._nextDup;\\n        if (prev === null) {\\n            this._head = next;\\n        }\\n        else {\\n            prev._nextDup = next;\\n        }\\n        if (next === null) {\\n            this._tail = prev;\\n        }\\n        else {\\n            next._prevDup = prev;\\n        }\\n        return this._head === null;\\n    };\\n    return _DuplicateItemRecordList;\\n}());\\nvar _DuplicateMap = /** @class */ (function () {\\n    function _DuplicateMap() {\\n        this.map = new Map();\\n    }\\n    _DuplicateMap.prototype.put = function (record) {\\n        var key = record.trackById;\\n        var duplicates = this.map.get(key);\\n        if (!duplicates) {\\n            duplicates = new _DuplicateItemRecordList();\\n            this.map.set(key, duplicates);\\n        }\\n        duplicates.add(record);\\n    };\\n    /**\\n     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\\n     * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\\n     *\\n     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\\n     * have any more `a`s needs to return the second `a`.\\n     */\\n    _DuplicateMap.prototype.get = function (trackById, atOrAfterIndex) {\\n        var key = trackById;\\n        var recordList = this.map.get(key);\\n        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\\n    };\\n    /**\\n     * Removes a {@link IterableChangeRecord_} from the list of duplicates.\\n     *\\n     * The list of duplicates also is removed from the map if it gets empty.\\n     */\\n    _DuplicateMap.prototype.remove = function (record) {\\n        var key = record.trackById;\\n        var recordList = this.map.get(key);\\n        // Remove the list of duplicates when it gets empty\\n        if (recordList.remove(record)) {\\n            this.map.delete(key);\\n        }\\n        return record;\\n    };\\n    Object.defineProperty(_DuplicateMap.prototype, \\\"isEmpty\\\", {\\n        get: function () { return this.map.size === 0; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    _DuplicateMap.prototype.clear = function () { this.map.clear(); };\\n    return _DuplicateMap;\\n}());\\nfunction getPreviousIndex(item, addRemoveOffset, moveOffsets) {\\n    var previousIndex = item.previousIndex;\\n    if (previousIndex === null)\\n        return previousIndex;\\n    var moveOffset = 0;\\n    if (moveOffsets && previousIndex < moveOffsets.length) {\\n        moveOffset = moveOffsets[previousIndex];\\n    }\\n    return previousIndex + addRemoveOffset + moveOffset;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar DefaultKeyValueDifferFactory = /** @class */ (function () {\\n    function DefaultKeyValueDifferFactory() {\\n    }\\n    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };\\n    DefaultKeyValueDifferFactory.prototype.create = function () { return new DefaultKeyValueDiffer(); };\\n    return DefaultKeyValueDifferFactory;\\n}());\\nvar DefaultKeyValueDiffer = /** @class */ (function () {\\n    function DefaultKeyValueDiffer() {\\n        this._records = new Map();\\n        this._mapHead = null;\\n        // _appendAfter is used in the check loop\\n        this._appendAfter = null;\\n        this._previousMapHead = null;\\n        this._changesHead = null;\\n        this._changesTail = null;\\n        this._additionsHead = null;\\n        this._additionsTail = null;\\n        this._removalsHead = null;\\n        this._removalsTail = null;\\n    }\\n    Object.defineProperty(DefaultKeyValueDiffer.prototype, \\\"isDirty\\\", {\\n        get: function () {\\n            return this._additionsHead !== null || this._changesHead !== null ||\\n                this._removalsHead !== null;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {\\n        var record;\\n        for (record = this._mapHead; record !== null; record = record._next) {\\n            fn(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {\\n        var record;\\n        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\\n            fn(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {\\n        var record;\\n        for (record = this._changesHead; record !== null; record = record._nextChanged) {\\n            fn(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {\\n        var record;\\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\\n            fn(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {\\n        var record;\\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\\n            fn(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype.diff = function (map) {\\n        if (!map) {\\n            map = new Map();\\n        }\\n        else if (!(map instanceof Map || isJsObject(map))) {\\n            throw new Error(\\\"Error trying to diff '\\\" + stringify(map) + \\\"'. Only maps and objects are allowed\\\");\\n        }\\n        return this.check(map) ? this : null;\\n    };\\n    DefaultKeyValueDiffer.prototype.onDestroy = function () { };\\n    /**\\n     * Check the current state of the map vs the previous.\\n     * The algorithm is optimised for when the keys do no change.\\n     */\\n    DefaultKeyValueDiffer.prototype.check = function (map) {\\n        var _this = this;\\n        this._reset();\\n        var insertBefore = this._mapHead;\\n        this._appendAfter = null;\\n        this._forEach(map, function (value, key) {\\n            if (insertBefore && insertBefore.key === key) {\\n                _this._maybeAddToChanges(insertBefore, value);\\n                _this._appendAfter = insertBefore;\\n                insertBefore = insertBefore._next;\\n            }\\n            else {\\n                var record = _this._getOrCreateRecordForKey(key, value);\\n                insertBefore = _this._insertBeforeOrAppend(insertBefore, record);\\n            }\\n        });\\n        // Items remaining at the end of the list have been deleted\\n        if (insertBefore) {\\n            if (insertBefore._prev) {\\n                insertBefore._prev._next = null;\\n            }\\n            this._removalsHead = insertBefore;\\n            for (var record = insertBefore; record !== null; record = record._nextRemoved) {\\n                if (record === this._mapHead) {\\n                    this._mapHead = null;\\n                }\\n                this._records.delete(record.key);\\n                record._nextRemoved = record._next;\\n                record.previousValue = record.currentValue;\\n                record.currentValue = null;\\n                record._prev = null;\\n                record._next = null;\\n            }\\n        }\\n        // Make sure tails have no next records from previous runs\\n        if (this._changesTail)\\n            this._changesTail._nextChanged = null;\\n        if (this._additionsTail)\\n            this._additionsTail._nextAdded = null;\\n        return this.isDirty;\\n    };\\n    /**\\n     * Inserts a record before `before` or append at the end of the list when `before` is null.\\n     *\\n     * Notes:\\n     * - This method appends at `this._appendAfter`,\\n     * - This method updates `this._appendAfter`,\\n     * - The return value is the new value for the insertion pointer.\\n     */\\n    DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function (before, record) {\\n        if (before) {\\n            var prev = before._prev;\\n            record._next = before;\\n            record._prev = prev;\\n            before._prev = record;\\n            if (prev) {\\n                prev._next = record;\\n            }\\n            if (before === this._mapHead) {\\n                this._mapHead = record;\\n            }\\n            this._appendAfter = before;\\n            return before;\\n        }\\n        if (this._appendAfter) {\\n            this._appendAfter._next = record;\\n            record._prev = this._appendAfter;\\n        }\\n        else {\\n            this._mapHead = record;\\n        }\\n        this._appendAfter = record;\\n        return null;\\n    };\\n    DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function (key, value) {\\n        if (this._records.has(key)) {\\n            var record_1 = this._records.get(key);\\n            this._maybeAddToChanges(record_1, value);\\n            var prev = record_1._prev;\\n            var next = record_1._next;\\n            if (prev) {\\n                prev._next = next;\\n            }\\n            if (next) {\\n                next._prev = prev;\\n            }\\n            record_1._next = null;\\n            record_1._prev = null;\\n            return record_1;\\n        }\\n        var record = new KeyValueChangeRecord_(key);\\n        this._records.set(key, record);\\n        record.currentValue = value;\\n        this._addToAdditions(record);\\n        return record;\\n    };\\n    /** @internal */\\n    DefaultKeyValueDiffer.prototype._reset = function () {\\n        if (this.isDirty) {\\n            var record = void 0;\\n            // let `_previousMapHead` contain the state of the map before the changes\\n            this._previousMapHead = this._mapHead;\\n            for (record = this._previousMapHead; record !== null; record = record._next) {\\n                record._nextPrevious = record._next;\\n            }\\n            // Update `record.previousValue` with the value of the item before the changes\\n            // We need to update all changed items (that's those which have been added and changed)\\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\\n                record.previousValue = record.currentValue;\\n            }\\n            for (record = this._additionsHead; record != null; record = record._nextAdded) {\\n                record.previousValue = record.currentValue;\\n            }\\n            this._changesHead = this._changesTail = null;\\n            this._additionsHead = this._additionsTail = null;\\n            this._removalsHead = null;\\n        }\\n    };\\n    // Add the record or a given key to the list of changes only when the value has actually changed\\n    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {\\n        if (!looseIdentical(newValue, record.currentValue)) {\\n            record.previousValue = record.currentValue;\\n            record.currentValue = newValue;\\n            this._addToChanges(record);\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {\\n        if (this._additionsHead === null) {\\n            this._additionsHead = this._additionsTail = record;\\n        }\\n        else {\\n            this._additionsTail._nextAdded = record;\\n            this._additionsTail = record;\\n        }\\n    };\\n    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {\\n        if (this._changesHead === null) {\\n            this._changesHead = this._changesTail = record;\\n        }\\n        else {\\n            this._changesTail._nextChanged = record;\\n            this._changesTail = record;\\n        }\\n    };\\n    /** @internal */\\n    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {\\n        if (obj instanceof Map) {\\n            obj.forEach(fn);\\n        }\\n        else {\\n            Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });\\n        }\\n    };\\n    return DefaultKeyValueDiffer;\\n}());\\nvar KeyValueChangeRecord_ = /** @class */ (function () {\\n    function KeyValueChangeRecord_(key) {\\n        this.key = key;\\n        this.previousValue = null;\\n        this.currentValue = null;\\n        /** @internal */\\n        this._nextPrevious = null;\\n        /** @internal */\\n        this._next = null;\\n        /** @internal */\\n        this._prev = null;\\n        /** @internal */\\n        this._nextAdded = null;\\n        /** @internal */\\n        this._nextRemoved = null;\\n        /** @internal */\\n        this._nextChanged = null;\\n    }\\n    return KeyValueChangeRecord_;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\\n *\\n * @publicApi\\n */\\nvar IterableDiffers = /** @class */ (function () {\\n    function IterableDiffers(factories) {\\n        this.factories = factories;\\n    }\\n    IterableDiffers.create = function (factories, parent) {\\n        if (parent != null) {\\n            var copied = parent.factories.slice();\\n            factories = factories.concat(copied);\\n        }\\n        return new IterableDiffers(factories);\\n    };\\n    /**\\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\\n     * {@link IterableDiffers} instance.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * The following example shows how to extend an existing list of factories,\\n     * which will only be applied to the injector for this component and its children.\\n     * This step is all that's required to make a new {@link IterableDiffer} available.\\n     *\\n     * ```\\n     * @Component({\\n     *   viewProviders: [\\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\\n     *   ]\\n     * })\\n     * ```\\n     */\\n    IterableDiffers.extend = function (factories) {\\n        return {\\n            provide: IterableDiffers,\\n            useFactory: function (parent) {\\n                if (!parent) {\\n                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed\\n                    // to\\n                    // bootstrap(), which would override default pipes instead of extending them.\\n                    throw new Error('Cannot extend IterableDiffers without a parent injector');\\n                }\\n                return IterableDiffers.create(factories, parent);\\n            },\\n            // Dependency technically isn't optional, but we can provide a better error message this way.\\n            deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\\n        };\\n    };\\n    IterableDiffers.prototype.find = function (iterable) {\\n        var factory = this.factories.find(function (f) { return f.supports(iterable); });\\n        if (factory != null) {\\n            return factory;\\n        }\\n        else {\\n            throw new Error(\\\"Cannot find a differ supporting object '\\\" + iterable + \\\"' of type '\\\" + getTypeNameForDebugging(iterable) + \\\"'\\\");\\n        }\\n    };\\n    IterableDiffers.ngInjectableDef = defineInjectable({\\n        providedIn: 'root',\\n        factory: function () { return new IterableDiffers([new DefaultIterableDifferFactory()]); }\\n    });\\n    return IterableDiffers;\\n}());\\nfunction getTypeNameForDebugging(type) {\\n    return type['name'] || typeof type;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\\n *\\n * @publicApi\\n */\\nvar KeyValueDiffers = /** @class */ (function () {\\n    function KeyValueDiffers(factories) {\\n        this.factories = factories;\\n    }\\n    KeyValueDiffers.create = function (factories, parent) {\\n        if (parent) {\\n            var copied = parent.factories.slice();\\n            factories = factories.concat(copied);\\n        }\\n        return new KeyValueDiffers(factories);\\n    };\\n    /**\\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\\n     * {@link KeyValueDiffers} instance.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * The following example shows how to extend an existing list of factories,\\n     * which will only be applied to the injector for this component and its children.\\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\\n     *\\n     * ```\\n     * @Component({\\n     *   viewProviders: [\\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\\n     *   ]\\n     * })\\n     * ```\\n     */\\n    KeyValueDiffers.extend = function (factories) {\\n        return {\\n            provide: KeyValueDiffers,\\n            useFactory: function (parent) {\\n                if (!parent) {\\n                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\\n                    // to bootstrap(), which would override default pipes instead of extending them.\\n                    throw new Error('Cannot extend KeyValueDiffers without a parent injector');\\n                }\\n                return KeyValueDiffers.create(factories, parent);\\n            },\\n            // Dependency technically isn't optional, but we can provide a better error message this way.\\n            deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\\n        };\\n    };\\n    KeyValueDiffers.prototype.find = function (kv) {\\n        var factory = this.factories.find(function (f) { return f.supports(kv); });\\n        if (factory) {\\n            return factory;\\n        }\\n        throw new Error(\\\"Cannot find a differ supporting object '\\\" + kv + \\\"'\\\");\\n    };\\n    return KeyValueDiffers;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Structural diffing for `Object`s and `Map`s.\\n */\\nvar keyValDiff = [new DefaultKeyValueDifferFactory()];\\n/**\\n * Structural diffing for `Iterable` types such as `Array`s.\\n */\\nvar iterableDiff = [new DefaultIterableDifferFactory()];\\nvar defaultIterableDiffers = new IterableDiffers(iterableDiff);\\nvar defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar _CORE_PLATFORM_PROVIDERS = [\\n    // Set a default platform name for platforms that don't set it explicitly.\\n    { provide: PLATFORM_ID, useValue: 'unknown' },\\n    { provide: PlatformRef, deps: [Injector] },\\n    { provide: TestabilityRegistry, deps: [] },\\n    { provide: Console, deps: [] },\\n];\\n/**\\n * This platform has to be included in any other platform\\n *\\n * @publicApi\\n */\\nvar platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Provide this token to set the locale of your application.\\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\\n * DecimalPipe and PercentPipe) and by ICU expressions.\\n *\\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import { LOCALE_ID } from '@angular/core';\\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\\n * import { AppModule } from './app/app.module';\\n *\\n * platformBrowserDynamic().bootstrapModule(AppModule, {\\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\\n * });\\n * ```\\n *\\n * @publicApi\\n */\\nvar LOCALE_ID = new InjectionToken('LocaleId');\\n/**\\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\\n * `xlf` or `xlf2`) when you want to translate your application in another language.\\n *\\n * See the [i18n guide](guide/i18n#merge) for more information.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import { TRANSLATIONS } from '@angular/core';\\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\\n * import { AppModule } from './app/app.module';\\n *\\n * // content of your translation file\\n * const translations = '....';\\n *\\n * platformBrowserDynamic().bootstrapModule(AppModule, {\\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\\n * });\\n * ```\\n *\\n * @publicApi\\n */\\nvar TRANSLATIONS = new InjectionToken('Translations');\\n/**\\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\\n * `xlf` or `xlf2`.\\n *\\n * See the [i18n guide](guide/i18n#merge) for more information.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\\n * import { AppModule } from './app/app.module';\\n *\\n * platformBrowserDynamic().bootstrapModule(AppModule, {\\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\\n * });\\n * ```\\n *\\n * @publicApi\\n */\\nvar TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');\\n/**\\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\\n * that the compiler should use in case of missing translations:\\n * - Error: throw if you have missing translations.\\n * - Warning (default): show a warning in the console and/or shell.\\n * - Ignore: do nothing.\\n *\\n * See the [i18n guide](guide/i18n#missing-translation) for more information.\\n *\\n * @usageNotes\\n * ### Example\\n * ```typescript\\n * import { MissingTranslationStrategy } from '@angular/core';\\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\\n * import { AppModule } from './app/app.module';\\n *\\n * platformBrowserDynamic().bootstrapModule(AppModule, {\\n *   missingTranslation: MissingTranslationStrategy.Error\\n * });\\n * ```\\n *\\n * @publicApi\\n */\\nvar MissingTranslationStrategy;\\n(function (MissingTranslationStrategy) {\\n    MissingTranslationStrategy[MissingTranslationStrategy[\\\"Error\\\"] = 0] = \\\"Error\\\";\\n    MissingTranslationStrategy[MissingTranslationStrategy[\\\"Warning\\\"] = 1] = \\\"Warning\\\";\\n    MissingTranslationStrategy[MissingTranslationStrategy[\\\"Ignore\\\"] = 2] = \\\"Ignore\\\";\\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction _iterableDiffersFactory() {\\n    return defaultIterableDiffers;\\n}\\nfunction _keyValueDiffersFactory() {\\n    return defaultKeyValueDiffers;\\n}\\nfunction _localeFactory(locale) {\\n    return locale || 'en-US';\\n}\\n/**\\n * A built-in [dependency injection token](guide/glossary#di-token)\\n * that is used to configure the root injector for bootstrapping.\\n */\\nvar APPLICATION_MODULE_PROVIDERS = [\\n    {\\n        provide: ApplicationRef,\\n        useClass: ApplicationRef,\\n        deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]\\n    },\\n    {\\n        provide: ApplicationInitStatus,\\n        useClass: ApplicationInitStatus,\\n        deps: [[new Optional(), APP_INITIALIZER]]\\n    },\\n    { provide: Compiler, useClass: Compiler, deps: [] },\\n    APP_ID_RANDOM_PROVIDER,\\n    { provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: [] },\\n    { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: [] },\\n    {\\n        provide: LOCALE_ID,\\n        useFactory: _localeFactory,\\n        deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]\\n    },\\n];\\n/**\\n * Configures the root injector for an app with\\n * providers of `@angular/core` dependencies that `ApplicationRef` needs\\n * to bootstrap components.\\n *\\n * Re-exported by `BrowserModule`, which is included automatically in the root\\n * `AppModule` when you create a new app with the CLI `new` command.\\n *\\n * @publicApi\\n */\\nvar ApplicationModule = /** @class */ (function () {\\n    // Inject ApplicationRef to make it eager...\\n    function ApplicationModule(appRef) {\\n    }\\n    ApplicationModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        NgModule({ providers: APPLICATION_MODULE_PROVIDERS }),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [ApplicationRef])\\n    ], ApplicationModule);\\n    return ApplicationModule;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// Called before each cycle of a view's check to detect whether this is in the\\n// initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit\\n// lifecycle methods. Returns true if this check cycle should call lifecycle\\n// methods.\\nfunction shiftInitState(view, priorInitState, newInitState) {\\n    // Only update the InitState if we are currently in the prior state.\\n    // For example, only move into CallingInit if we are in BeforeInit. Only\\n    // move into CallingContentInit if we are in CallingInit. Normally this will\\n    // always be true because of how checkCycle is called in checkAndUpdateView.\\n    // However, if checkAndUpdateView is called recursively or if an exception is\\n    // thrown while checkAndUpdateView is running, checkAndUpdateView starts over\\n    // from the beginning. This ensures the state is monotonically increasing,\\n    // terminating in the AfterInit state, which ensures the Init methods are called\\n    // at least once and only once.\\n    var state = view.state;\\n    var initState = state & 1792 /* InitState_Mask */;\\n    if (initState === priorInitState) {\\n        view.state = (state & ~1792 /* InitState_Mask */) | newInitState;\\n        view.initIndex = -1;\\n        return true;\\n    }\\n    return initState === newInitState;\\n}\\n// Returns true if the lifecycle init method should be called for the node with\\n// the given init index.\\nfunction shouldCallLifecycleInitHook(view, initState, index) {\\n    if ((view.state & 1792 /* InitState_Mask */) === initState && view.initIndex <= index) {\\n        view.initIndex = index + 1;\\n        return true;\\n    }\\n    return false;\\n}\\n/**\\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\\n */\\nfunction asTextData(view, index) {\\n    return view.nodes[index];\\n}\\n/**\\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\\n */\\nfunction asElementData(view, index) {\\n    return view.nodes[index];\\n}\\n/**\\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\\n */\\nfunction asProviderData(view, index) {\\n    return view.nodes[index];\\n}\\n/**\\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\\n */\\nfunction asPureExpressionData(view, index) {\\n    return view.nodes[index];\\n}\\n/**\\n * Accessor for view.nodes, enforcing that every usage site stays monomorphic.\\n */\\nfunction asQueryList(view, index) {\\n    return view.nodes[index];\\n}\\nvar DebugContext = /** @class */ (function () {\\n    function DebugContext() {\\n    }\\n    return DebugContext;\\n}());\\n/**\\n * This object is used to prevent cycles in the source files and to have a place where\\n * debug mode can hook it. It is lazily filled when `isDevMode` is known.\\n */\\nvar Services = {\\n    setCurrentNode: undefined,\\n    createRootView: undefined,\\n    createEmbeddedView: undefined,\\n    createComponentView: undefined,\\n    createNgModuleRef: undefined,\\n    overrideProvider: undefined,\\n    overrideComponentView: undefined,\\n    clearOverrides: undefined,\\n    checkAndUpdateView: undefined,\\n    checkNoChangesView: undefined,\\n    destroyView: undefined,\\n    resolveDep: undefined,\\n    createDebugContext: undefined,\\n    handleEvent: undefined,\\n    updateDirectives: undefined,\\n    updateRenderer: undefined,\\n    dirtyParentQueries: undefined,\\n};\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {\\n    var msg = \\\"ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '\\\" + oldValue + \\\"'. Current value: '\\\" + currValue + \\\"'.\\\";\\n    if (isFirstCheck) {\\n        msg +=\\n            \\\" It seems like the view has been created after its parent and its children have been dirty checked.\\\" +\\n                \\\" Has it been created in a change detection hook ?\\\";\\n    }\\n    return viewDebugError(msg, context);\\n}\\nfunction viewWrappedDebugError(err, context) {\\n    if (!(err instanceof Error)) {\\n        // errors that are not Error instances don't have a stack,\\n        // so it is ok to wrap them into a new Error object...\\n        err = new Error(err.toString());\\n    }\\n    _addDebugContext(err, context);\\n    return err;\\n}\\nfunction viewDebugError(msg, context) {\\n    var err = new Error(msg);\\n    _addDebugContext(err, context);\\n    return err;\\n}\\nfunction _addDebugContext(err, context) {\\n    err[ERROR_DEBUG_CONTEXT] = context;\\n    err[ERROR_LOGGER] = context.logError.bind(context);\\n}\\nfunction isViewDebugError(err) {\\n    return !!getDebugContext(err);\\n}\\nfunction viewDestroyedError(action) {\\n    return new Error(\\\"ViewDestroyedError: Attempt to use a destroyed view: \\\" + action);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar NOOP = function () { };\\nvar _tokenKeyCache = new Map();\\nfunction tokenKey(token) {\\n    var key = _tokenKeyCache.get(token);\\n    if (!key) {\\n        key = stringify(token) + '_' + _tokenKeyCache.size;\\n        _tokenKeyCache.set(token, key);\\n    }\\n    return key;\\n}\\nfunction unwrapValue(view, nodeIdx, bindingIdx, value) {\\n    if (WrappedValue.isWrapped(value)) {\\n        value = WrappedValue.unwrap(value);\\n        var globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;\\n        var oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);\\n        view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);\\n    }\\n    return value;\\n}\\nvar UNDEFINED_RENDERER_TYPE_ID = '$$undefined';\\nvar EMPTY_RENDERER_TYPE_ID = '$$empty';\\n// Attention: this function is called as top level function.\\n// Putting any logic in here will destroy closure tree shaking!\\nfunction createRendererType2(values) {\\n    return {\\n        id: UNDEFINED_RENDERER_TYPE_ID,\\n        styles: values.styles,\\n        encapsulation: values.encapsulation,\\n        data: values.data\\n    };\\n}\\nvar _renderCompCount$1 = 0;\\nfunction resolveRendererType2(type) {\\n    if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {\\n        // first time we see this RendererType2. Initialize it...\\n        var isFilled = ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None) ||\\n            type.styles.length || Object.keys(type.data).length);\\n        if (isFilled) {\\n            type.id = \\\"c\\\" + _renderCompCount$1++;\\n        }\\n        else {\\n            type.id = EMPTY_RENDERER_TYPE_ID;\\n        }\\n    }\\n    if (type && type.id === EMPTY_RENDERER_TYPE_ID) {\\n        type = null;\\n    }\\n    return type || null;\\n}\\nfunction checkBinding(view, def, bindingIdx, value) {\\n    var oldValues = view.oldValues;\\n    if ((view.state & 2 /* FirstCheck */) ||\\n        !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {\\n        return true;\\n    }\\n    return false;\\n}\\nfunction checkAndUpdateBinding(view, def, bindingIdx, value) {\\n    if (checkBinding(view, def, bindingIdx, value)) {\\n        view.oldValues[def.bindingIndex + bindingIdx] = value;\\n        return true;\\n    }\\n    return false;\\n}\\nfunction checkBindingNoChanges(view, def, bindingIdx, value) {\\n    var oldValue = view.oldValues[def.bindingIndex + bindingIdx];\\n    if ((view.state & 1 /* BeforeFirstCheck */) || !devModeEqual(oldValue, value)) {\\n        var bindingName = def.bindings[bindingIdx].name;\\n        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.nodeIndex), bindingName + \\\": \\\" + oldValue, bindingName + \\\": \\\" + value, (view.state & 1 /* BeforeFirstCheck */) !== 0);\\n    }\\n}\\nfunction markParentViewsForCheck(view) {\\n    var currView = view;\\n    while (currView) {\\n        if (currView.def.flags & 2 /* OnPush */) {\\n            currView.state |= 8 /* ChecksEnabled */;\\n        }\\n        currView = currView.viewContainerParent || currView.parent;\\n    }\\n}\\nfunction markParentViewsForCheckProjectedViews(view, endView) {\\n    var currView = view;\\n    while (currView && currView !== endView) {\\n        currView.state |= 64 /* CheckProjectedViews */;\\n        currView = currView.viewContainerParent || currView.parent;\\n    }\\n}\\nfunction dispatchEvent(view, nodeIndex, eventName, event) {\\n    try {\\n        var nodeDef = view.def.nodes[nodeIndex];\\n        var startView = nodeDef.flags & 33554432 /* ComponentView */ ?\\n            asElementData(view, nodeIndex).componentView :\\n            view;\\n        markParentViewsForCheck(startView);\\n        return Services.handleEvent(view, nodeIndex, eventName, event);\\n    }\\n    catch (e) {\\n        // Attention: Don't rethrow, as it would cancel Observable subscriptions!\\n        view.root.errorHandler.handleError(e);\\n    }\\n}\\nfunction declaredViewContainer(view) {\\n    if (view.parent) {\\n        var parentView = view.parent;\\n        return asElementData(parentView, view.parentNodeDef.nodeIndex);\\n    }\\n    return null;\\n}\\n/**\\n * for component views, this is the host element.\\n * for embedded views, this is the index of the parent node\\n * that contains the view container.\\n */\\nfunction viewParentEl(view) {\\n    var parentView = view.parent;\\n    if (parentView) {\\n        return view.parentNodeDef.parent;\\n    }\\n    else {\\n        return null;\\n    }\\n}\\nfunction renderNode(view, def) {\\n    switch (def.flags & 201347067 /* Types */) {\\n        case 1 /* TypeElement */:\\n            return asElementData(view, def.nodeIndex).renderElement;\\n        case 2 /* TypeText */:\\n            return asTextData(view, def.nodeIndex).renderText;\\n    }\\n}\\nfunction elementEventFullName(target, name) {\\n    return target ? target + \\\":\\\" + name : name;\\n}\\nfunction isComponentView(view) {\\n    return !!view.parent && !!(view.parentNodeDef.flags & 32768 /* Component */);\\n}\\nfunction isEmbeddedView(view) {\\n    return !!view.parent && !(view.parentNodeDef.flags & 32768 /* Component */);\\n}\\nfunction filterQueryId(queryId) {\\n    return 1 << (queryId % 32);\\n}\\nfunction splitMatchedQueriesDsl(matchedQueriesDsl) {\\n    var matchedQueries = {};\\n    var matchedQueryIds = 0;\\n    var references = {};\\n    if (matchedQueriesDsl) {\\n        matchedQueriesDsl.forEach(function (_a) {\\n            var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(_a, 2), queryId = _b[0], valueType = _b[1];\\n            if (typeof queryId === 'number') {\\n                matchedQueries[queryId] = valueType;\\n                matchedQueryIds |= filterQueryId(queryId);\\n            }\\n            else {\\n                references[queryId] = valueType;\\n            }\\n        });\\n    }\\n    return { matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds };\\n}\\nfunction splitDepsDsl(deps, sourceName) {\\n    return deps.map(function (value) {\\n        var _a;\\n        var token;\\n        var flags;\\n        if (Array.isArray(value)) {\\n            _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(value, 2), flags = _a[0], token = _a[1];\\n        }\\n        else {\\n            flags = 0 /* None */;\\n            token = value;\\n        }\\n        if (token && (typeof token === 'function' || typeof token === 'object') && sourceName) {\\n            Object.defineProperty(token, SOURCE, { value: sourceName, configurable: true });\\n        }\\n        return { flags: flags, token: token, tokenKey: tokenKey(token) };\\n    });\\n}\\nfunction getParentRenderElement(view, renderHost, def) {\\n    var renderParent = def.renderParent;\\n    if (renderParent) {\\n        if ((renderParent.flags & 1 /* TypeElement */) === 0 ||\\n            (renderParent.flags & 33554432 /* ComponentView */) === 0 ||\\n            (renderParent.element.componentRendererType &&\\n                renderParent.element.componentRendererType.encapsulation ===\\n                    ViewEncapsulation.Native)) {\\n            // only children of non components, or children of components with native encapsulation should\\n            // be attached.\\n            return asElementData(view, def.renderParent.nodeIndex).renderElement;\\n        }\\n    }\\n    else {\\n        return renderHost;\\n    }\\n}\\nvar DEFINITION_CACHE = new WeakMap();\\nfunction resolveDefinition(factory) {\\n    var value = DEFINITION_CACHE.get(factory);\\n    if (!value) {\\n        value = factory(function () { return NOOP; });\\n        value.factory = factory;\\n        DEFINITION_CACHE.set(factory, value);\\n    }\\n    return value;\\n}\\nfunction rootRenderNodes(view) {\\n    var renderNodes = [];\\n    visitRootRenderNodes(view, 0 /* Collect */, undefined, undefined, renderNodes);\\n    return renderNodes;\\n}\\nfunction visitRootRenderNodes(view, action, parentNode, nextSibling, target) {\\n    // We need to re-compute the parent node in case the nodes have been moved around manually\\n    if (action === 3 /* RemoveChild */) {\\n        parentNode = view.renderer.parentNode(renderNode(view, view.def.lastRenderRootNode));\\n    }\\n    visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);\\n}\\nfunction visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {\\n    for (var i = startIndex; i <= endIndex; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        if (nodeDef.flags & (1 /* TypeElement */ | 2 /* TypeText */ | 8 /* TypeNgContent */)) {\\n            visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);\\n        }\\n        // jump to next sibling\\n        i += nodeDef.childCount;\\n    }\\n}\\nfunction visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {\\n    var compView = view;\\n    while (compView && !isComponentView(compView)) {\\n        compView = compView.parent;\\n    }\\n    var hostView = compView.parent;\\n    var hostElDef = viewParentEl(compView);\\n    var startIndex = hostElDef.nodeIndex + 1;\\n    var endIndex = hostElDef.nodeIndex + hostElDef.childCount;\\n    for (var i = startIndex; i <= endIndex; i++) {\\n        var nodeDef = hostView.def.nodes[i];\\n        if (nodeDef.ngContentIndex === ngContentIndex) {\\n            visitRenderNode(hostView, nodeDef, action, parentNode, nextSibling, target);\\n        }\\n        // jump to next sibling\\n        i += nodeDef.childCount;\\n    }\\n    if (!hostView.parent) {\\n        // a root view\\n        var projectedNodes = view.root.projectableNodes[ngContentIndex];\\n        if (projectedNodes) {\\n            for (var i = 0; i < projectedNodes.length; i++) {\\n                execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);\\n            }\\n        }\\n    }\\n}\\nfunction visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {\\n    if (nodeDef.flags & 8 /* TypeNgContent */) {\\n        visitProjectedRenderNodes(view, nodeDef.ngContent.index, action, parentNode, nextSibling, target);\\n    }\\n    else {\\n        var rn = renderNode(view, nodeDef);\\n        if (action === 3 /* RemoveChild */ && (nodeDef.flags & 33554432 /* ComponentView */) &&\\n            (nodeDef.bindingFlags & 48 /* CatSyntheticProperty */)) {\\n            // Note: we might need to do both actions.\\n            if (nodeDef.bindingFlags & (16 /* SyntheticProperty */)) {\\n                execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\\n            }\\n            if (nodeDef.bindingFlags & (32 /* SyntheticHostProperty */)) {\\n                var compView = asElementData(view, nodeDef.nodeIndex).componentView;\\n                execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);\\n            }\\n        }\\n        else {\\n            execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);\\n        }\\n        if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\\n            var embeddedViews = asElementData(view, nodeDef.nodeIndex).viewContainer._embeddedViews;\\n            for (var k = 0; k < embeddedViews.length; k++) {\\n                visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);\\n            }\\n        }\\n        if (nodeDef.flags & 1 /* TypeElement */ && !nodeDef.element.name) {\\n            visitSiblingRenderNodes(view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode, nextSibling, target);\\n        }\\n    }\\n}\\nfunction execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {\\n    var renderer = view.renderer;\\n    switch (action) {\\n        case 1 /* AppendChild */:\\n            renderer.appendChild(parentNode, renderNode);\\n            break;\\n        case 2 /* InsertBefore */:\\n            renderer.insertBefore(parentNode, renderNode, nextSibling);\\n            break;\\n        case 3 /* RemoveChild */:\\n            renderer.removeChild(parentNode, renderNode);\\n            break;\\n        case 0 /* Collect */:\\n            target.push(renderNode);\\n            break;\\n    }\\n}\\nvar NS_PREFIX_RE = /^:([^:]+):(.+)$/;\\nfunction splitNamespace(name) {\\n    if (name[0] === ':') {\\n        var match = name.match(NS_PREFIX_RE);\\n        return [match[1], match[2]];\\n    }\\n    return ['', name];\\n}\\nfunction calcBindingFlags(bindings) {\\n    var flags = 0;\\n    for (var i = 0; i < bindings.length; i++) {\\n        flags |= bindings[i].flags;\\n    }\\n    return flags;\\n}\\nfunction interpolate(valueCount, constAndInterp) {\\n    var result = '';\\n    for (var i = 0; i < valueCount * 2; i = i + 2) {\\n        result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);\\n    }\\n    return result + constAndInterp[valueCount * 2];\\n}\\nfunction inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {\\n    switch (valueCount) {\\n        case 1:\\n            return c0 + _toStringWithNull(a1) + c1;\\n        case 2:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;\\n        case 3:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3;\\n        case 4:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4;\\n        case 5:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;\\n        case 6:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;\\n        case 7:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\\n                c6 + _toStringWithNull(a7) + c7;\\n        case 8:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\\n                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;\\n        case 9:\\n            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +\\n                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +\\n                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;\\n        default:\\n            throw new Error(\\\"Does not support more than 9 expressions\\\");\\n    }\\n}\\nfunction _toStringWithNull(v) {\\n    return v != null ? v.toString() : '';\\n}\\nvar EMPTY_ARRAY$4 = [];\\nvar EMPTY_MAP = {};\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {\\n    flags |= 1 /* TypeElement */;\\n    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;\\n    var template = templateFactory ? resolveDefinition(templateFactory) : null;\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        flags: flags,\\n        checkIndex: -1,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,\\n        bindings: [],\\n        bindingFlags: 0,\\n        outputs: [],\\n        element: {\\n            ns: null,\\n            name: null,\\n            attrs: null, template: template,\\n            componentProvider: null,\\n            componentView: null,\\n            componentRendererType: null,\\n            publicProviders: null,\\n            allProviders: null,\\n            handleEvent: handleEvent || NOOP\\n        },\\n        provider: null,\\n        text: null,\\n        query: null,\\n        ngContent: null\\n    };\\n}\\nfunction elementDef(checkIndex, flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs, bindings, outputs, handleEvent, componentView, componentRendererType) {\\n    if (fixedAttrs === void 0) { fixedAttrs = []; }\\n    var _a;\\n    if (!handleEvent) {\\n        handleEvent = NOOP;\\n    }\\n    var _b = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _b.matchedQueries, references = _b.references, matchedQueryIds = _b.matchedQueryIds;\\n    var ns = null;\\n    var name = null;\\n    if (namespaceAndName) {\\n        _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\\n    }\\n    bindings = bindings || [];\\n    var bindingDefs = new Array(bindings.length);\\n    for (var i = 0; i < bindings.length; i++) {\\n        var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(bindings[i], 3), bindingFlags = _c[0], namespaceAndName_1 = _c[1], suffixOrSecurityContext = _c[2];\\n        var _d = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(splitNamespace(namespaceAndName_1), 2), ns_1 = _d[0], name_1 = _d[1];\\n        var securityContext = undefined;\\n        var suffix = undefined;\\n        switch (bindingFlags & 15 /* Types */) {\\n            case 4 /* TypeElementStyle */:\\n                suffix = suffixOrSecurityContext;\\n                break;\\n            case 1 /* TypeElementAttribute */:\\n            case 8 /* TypeProperty */:\\n                securityContext = suffixOrSecurityContext;\\n                break;\\n        }\\n        bindingDefs[i] =\\n            { flags: bindingFlags, ns: ns_1, name: name_1, nonMinifiedName: name_1, securityContext: securityContext, suffix: suffix };\\n    }\\n    outputs = outputs || [];\\n    var outputDefs = new Array(outputs.length);\\n    for (var i = 0; i < outputs.length; i++) {\\n        var _e = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(outputs[i], 2), target = _e[0], eventName = _e[1];\\n        outputDefs[i] = {\\n            type: 0 /* ElementOutput */,\\n            target: target, eventName: eventName,\\n            propName: null\\n        };\\n    }\\n    fixedAttrs = fixedAttrs || [];\\n    var attrs = fixedAttrs.map(function (_a) {\\n        var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(_a, 2), namespaceAndName = _b[0], value = _b[1];\\n        var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(splitNamespace(namespaceAndName), 2), ns = _c[0], name = _c[1];\\n        return [ns, name, value];\\n    });\\n    componentRendererType = resolveRendererType2(componentRendererType);\\n    if (componentView) {\\n        flags |= 33554432 /* ComponentView */;\\n    }\\n    flags |= 1 /* TypeElement */;\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        checkIndex: checkIndex,\\n        flags: flags,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,\\n        bindings: bindingDefs,\\n        bindingFlags: calcBindingFlags(bindingDefs),\\n        outputs: outputDefs,\\n        element: {\\n            ns: ns,\\n            name: name,\\n            attrs: attrs,\\n            template: null,\\n            // will bet set by the view definition\\n            componentProvider: null,\\n            componentView: componentView || null,\\n            componentRendererType: componentRendererType,\\n            publicProviders: null,\\n            allProviders: null,\\n            handleEvent: handleEvent || NOOP,\\n        },\\n        provider: null,\\n        text: null,\\n        query: null,\\n        ngContent: null\\n    };\\n}\\nfunction createElement(view, renderHost, def) {\\n    var elDef = def.element;\\n    var rootSelectorOrNode = view.root.selectorOrNode;\\n    var renderer = view.renderer;\\n    var el;\\n    if (view.parent || !rootSelectorOrNode) {\\n        if (elDef.name) {\\n            el = renderer.createElement(elDef.name, elDef.ns);\\n        }\\n        else {\\n            el = renderer.createComment('');\\n        }\\n        var parentEl = getParentRenderElement(view, renderHost, def);\\n        if (parentEl) {\\n            renderer.appendChild(parentEl, el);\\n        }\\n    }\\n    else {\\n        // when using native Shadow DOM, do not clear the root element contents to allow slot projection\\n        var preserveContent = (!!elDef.componentRendererType &&\\n            elDef.componentRendererType.encapsulation === ViewEncapsulation.ShadowDom);\\n        el = renderer.selectRootElement(rootSelectorOrNode, preserveContent);\\n    }\\n    if (elDef.attrs) {\\n        for (var i = 0; i < elDef.attrs.length; i++) {\\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(elDef.attrs[i], 3), ns = _a[0], name_2 = _a[1], value = _a[2];\\n            renderer.setAttribute(el, name_2, value, ns);\\n        }\\n    }\\n    return el;\\n}\\nfunction listenToElementOutputs(view, compView, def, el) {\\n    for (var i = 0; i < def.outputs.length; i++) {\\n        var output = def.outputs[i];\\n        var handleEventClosure = renderEventHandlerClosure(view, def.nodeIndex, elementEventFullName(output.target, output.eventName));\\n        var listenTarget = output.target;\\n        var listenerView = view;\\n        if (output.target === 'component') {\\n            listenTarget = null;\\n            listenerView = compView;\\n        }\\n        var disposable = listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure);\\n        view.disposables[def.outputIndex + i] = disposable;\\n    }\\n}\\nfunction renderEventHandlerClosure(view, index, eventName) {\\n    return function (event) { return dispatchEvent(view, index, eventName, event); };\\n}\\nfunction checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var bindLen = def.bindings.length;\\n    var changed = false;\\n    if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))\\n        changed = true;\\n    if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))\\n        changed = true;\\n    if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))\\n        changed = true;\\n    if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))\\n        changed = true;\\n    if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))\\n        changed = true;\\n    if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))\\n        changed = true;\\n    if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))\\n        changed = true;\\n    if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))\\n        changed = true;\\n    if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))\\n        changed = true;\\n    if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))\\n        changed = true;\\n    return changed;\\n}\\nfunction checkAndUpdateElementDynamic(view, def, values) {\\n    var changed = false;\\n    for (var i = 0; i < values.length; i++) {\\n        if (checkAndUpdateElementValue(view, def, i, values[i]))\\n            changed = true;\\n    }\\n    return changed;\\n}\\nfunction checkAndUpdateElementValue(view, def, bindingIdx, value) {\\n    if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {\\n        return false;\\n    }\\n    var binding = def.bindings[bindingIdx];\\n    var elData = asElementData(view, def.nodeIndex);\\n    var renderNode$$1 = elData.renderElement;\\n    var name = binding.name;\\n    switch (binding.flags & 15 /* Types */) {\\n        case 1 /* TypeElementAttribute */:\\n            setElementAttribute(view, binding, renderNode$$1, binding.ns, name, value);\\n            break;\\n        case 2 /* TypeElementClass */:\\n            setElementClass(view, renderNode$$1, name, value);\\n            break;\\n        case 4 /* TypeElementStyle */:\\n            setElementStyle(view, binding, renderNode$$1, name, value);\\n            break;\\n        case 8 /* TypeProperty */:\\n            var bindView = (def.flags & 33554432 /* ComponentView */ &&\\n                binding.flags & 32 /* SyntheticHostProperty */) ?\\n                elData.componentView :\\n                view;\\n            setElementProperty(bindView, binding, renderNode$$1, name, value);\\n            break;\\n    }\\n    return true;\\n}\\nfunction setElementAttribute(view, binding, renderNode$$1, ns, name, value) {\\n    var securityContext = binding.securityContext;\\n    var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\\n    renderValue = renderValue != null ? renderValue.toString() : null;\\n    var renderer = view.renderer;\\n    if (value != null) {\\n        renderer.setAttribute(renderNode$$1, name, renderValue, ns);\\n    }\\n    else {\\n        renderer.removeAttribute(renderNode$$1, name, ns);\\n    }\\n}\\nfunction setElementClass(view, renderNode$$1, name, value) {\\n    var renderer = view.renderer;\\n    if (value) {\\n        renderer.addClass(renderNode$$1, name);\\n    }\\n    else {\\n        renderer.removeClass(renderNode$$1, name);\\n    }\\n}\\nfunction setElementStyle(view, binding, renderNode$$1, name, value) {\\n    var renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE, value);\\n    if (renderValue != null) {\\n        renderValue = renderValue.toString();\\n        var unit = binding.suffix;\\n        if (unit != null) {\\n            renderValue = renderValue + unit;\\n        }\\n    }\\n    else {\\n        renderValue = null;\\n    }\\n    var renderer = view.renderer;\\n    if (renderValue != null) {\\n        renderer.setStyle(renderNode$$1, name, renderValue);\\n    }\\n    else {\\n        renderer.removeStyle(renderNode$$1, name);\\n    }\\n}\\nfunction setElementProperty(view, binding, renderNode$$1, name, value) {\\n    var securityContext = binding.securityContext;\\n    var renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;\\n    view.renderer.setProperty(renderNode$$1, name, renderValue);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar UNDEFINED_VALUE = new Object();\\nvar InjectorRefTokenKey = tokenKey(Injector);\\nvar INJECTORRefTokenKey = tokenKey(INJECTOR);\\nvar NgModuleRefTokenKey = tokenKey(NgModuleRef);\\nfunction moduleProvideDef(flags, token, value, deps) {\\n    // Need to resolve forwardRefs as e.g. for `useValue` we\\n    // lowered the expression and then stopped evaluating it,\\n    // i.e. also didn't unwrap it.\\n    value = resolveForwardRef(value);\\n    var depDefs = splitDepsDsl(deps, stringify(token));\\n    return {\\n        // will bet set by the module definition\\n        index: -1,\\n        deps: depDefs, flags: flags, token: token, value: value\\n    };\\n}\\nfunction moduleDef(providers) {\\n    var providersByKey = {};\\n    var modules = [];\\n    var isRoot = false;\\n    for (var i = 0; i < providers.length; i++) {\\n        var provider = providers[i];\\n        if (provider.token === APP_ROOT && provider.value === true) {\\n            isRoot = true;\\n        }\\n        if (provider.flags & 1073741824 /* TypeNgModule */) {\\n            modules.push(provider.token);\\n        }\\n        provider.index = i;\\n        providersByKey[tokenKey(provider.token)] = provider;\\n    }\\n    return {\\n        // Will be filled later...\\n        factory: null,\\n        providersByKey: providersByKey,\\n        providers: providers,\\n        modules: modules,\\n        isRoot: isRoot,\\n    };\\n}\\nfunction initNgModule(data) {\\n    var def = data._def;\\n    var providers = data._providers = new Array(def.providers.length);\\n    for (var i = 0; i < def.providers.length; i++) {\\n        var provDef = def.providers[i];\\n        if (!(provDef.flags & 4096 /* LazyProvider */)) {\\n            // Make sure the provider has not been already initialized outside this loop.\\n            if (providers[i] === undefined) {\\n                providers[i] = _createProviderInstance(data, provDef);\\n            }\\n        }\\n    }\\n}\\nfunction resolveNgModuleDep(data, depDef, notFoundValue) {\\n    if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\\n    var former = setCurrentInjector(data);\\n    try {\\n        if (depDef.flags & 8 /* Value */) {\\n            return depDef.token;\\n        }\\n        if (depDef.flags & 2 /* Optional */) {\\n            notFoundValue = null;\\n        }\\n        if (depDef.flags & 1 /* SkipSelf */) {\\n            return data._parent.get(depDef.token, notFoundValue);\\n        }\\n        var tokenKey_1 = depDef.tokenKey;\\n        switch (tokenKey_1) {\\n            case InjectorRefTokenKey:\\n            case INJECTORRefTokenKey:\\n            case NgModuleRefTokenKey:\\n                return data;\\n        }\\n        var providerDef = data._def.providersByKey[tokenKey_1];\\n        var injectableDef = void 0;\\n        if (providerDef) {\\n            var providerInstance = data._providers[providerDef.index];\\n            if (providerInstance === undefined) {\\n                providerInstance = data._providers[providerDef.index] =\\n                    _createProviderInstance(data, providerDef);\\n            }\\n            return providerInstance === UNDEFINED_VALUE ? undefined : providerInstance;\\n        }\\n        else if ((injectableDef = getInjectableDef(depDef.token)) && targetsModule(data, injectableDef)) {\\n            var index = data._providers.length;\\n            data._def.providersByKey[depDef.tokenKey] = {\\n                flags: 1024 /* TypeFactoryProvider */ | 4096 /* LazyProvider */,\\n                value: injectableDef.factory,\\n                deps: [], index: index,\\n                token: depDef.token,\\n            };\\n            data._providers[index] = UNDEFINED_VALUE;\\n            return (data._providers[index] =\\n                _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]));\\n        }\\n        else if (depDef.flags & 4 /* Self */) {\\n            return notFoundValue;\\n        }\\n        return data._parent.get(depDef.token, notFoundValue);\\n    }\\n    finally {\\n        setCurrentInjector(former);\\n    }\\n}\\nfunction moduleTransitivelyPresent(ngModule, scope) {\\n    return ngModule._def.modules.indexOf(scope) > -1;\\n}\\nfunction targetsModule(ngModule, def) {\\n    return def.providedIn != null && (moduleTransitivelyPresent(ngModule, def.providedIn) ||\\n        def.providedIn === 'root' && ngModule._def.isRoot);\\n}\\nfunction _createProviderInstance(ngModule, providerDef) {\\n    var injectable;\\n    switch (providerDef.flags & 201347067 /* Types */) {\\n        case 512 /* TypeClassProvider */:\\n            injectable = _createClass(ngModule, providerDef.value, providerDef.deps);\\n            break;\\n        case 1024 /* TypeFactoryProvider */:\\n            injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);\\n            break;\\n        case 2048 /* TypeUseExistingProvider */:\\n            injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);\\n            break;\\n        case 256 /* TypeValueProvider */:\\n            injectable = providerDef.value;\\n            break;\\n    }\\n    // The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be\\n    // avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be\\n    // checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already\\n    // set (ngOnDestroy was detected statically).\\n    if (injectable !== UNDEFINED_VALUE && injectable != null && typeof injectable === 'object' &&\\n        !(providerDef.flags & 131072 /* OnDestroy */) && typeof injectable.ngOnDestroy === 'function') {\\n        providerDef.flags |= 131072 /* OnDestroy */;\\n    }\\n    return injectable === undefined ? UNDEFINED_VALUE : injectable;\\n}\\nfunction _createClass(ngModule, ctor, deps) {\\n    var len = deps.length;\\n    switch (len) {\\n        case 0:\\n            return new ctor();\\n        case 1:\\n            return new ctor(resolveNgModuleDep(ngModule, deps[0]));\\n        case 2:\\n            return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\\n        case 3:\\n            return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));\\n        default:\\n            var depValues = new Array(len);\\n            for (var i = 0; i < len; i++) {\\n                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\\n            }\\n            return new (ctor.bind.apply(ctor, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], depValues)))();\\n    }\\n}\\nfunction _callFactory(ngModule, factory, deps) {\\n    var len = deps.length;\\n    switch (len) {\\n        case 0:\\n            return factory();\\n        case 1:\\n            return factory(resolveNgModuleDep(ngModule, deps[0]));\\n        case 2:\\n            return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));\\n        case 3:\\n            return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));\\n        default:\\n            var depValues = Array(len);\\n            for (var i = 0; i < len; i++) {\\n                depValues[i] = resolveNgModuleDep(ngModule, deps[i]);\\n            }\\n            return factory.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(depValues));\\n    }\\n}\\nfunction callNgModuleLifecycle(ngModule, lifecycles) {\\n    var def = ngModule._def;\\n    var destroyed = new Set();\\n    for (var i = 0; i < def.providers.length; i++) {\\n        var provDef = def.providers[i];\\n        if (provDef.flags & 131072 /* OnDestroy */) {\\n            var instance = ngModule._providers[i];\\n            if (instance && instance !== UNDEFINED_VALUE) {\\n                var onDestroy = instance.ngOnDestroy;\\n                if (typeof onDestroy === 'function' && !destroyed.has(instance)) {\\n                    onDestroy.apply(instance);\\n                    destroyed.add(instance);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction attachEmbeddedView(parentView, elementData, viewIndex, view) {\\n    var embeddedViews = elementData.viewContainer._embeddedViews;\\n    if (viewIndex === null || viewIndex === undefined) {\\n        viewIndex = embeddedViews.length;\\n    }\\n    view.viewContainerParent = parentView;\\n    addToArray(embeddedViews, viewIndex, view);\\n    attachProjectedView(elementData, view);\\n    Services.dirtyParentQueries(view);\\n    var prevView = viewIndex > 0 ? embeddedViews[viewIndex - 1] : null;\\n    renderAttachEmbeddedView(elementData, prevView, view);\\n}\\nfunction attachProjectedView(vcElementData, view) {\\n    var dvcElementData = declaredViewContainer(view);\\n    if (!dvcElementData || dvcElementData === vcElementData ||\\n        view.state & 16 /* IsProjectedView */) {\\n        return;\\n    }\\n    // Note: For performance reasons, we\\n    // - add a view to template._projectedViews only 1x throughout its lifetime,\\n    //   and remove it not until the view is destroyed.\\n    //   (hard, as when a parent view is attached/detached we would need to attach/detach all\\n    //    nested projected views as well, even across component boundaries).\\n    // - don't track the insertion order of views in the projected views array\\n    //   (hard, as when the views of the same template are inserted different view containers)\\n    view.state |= 16 /* IsProjectedView */;\\n    var projectedViews = dvcElementData.template._projectedViews;\\n    if (!projectedViews) {\\n        projectedViews = dvcElementData.template._projectedViews = [];\\n    }\\n    projectedViews.push(view);\\n    // Note: we are changing the NodeDef here as we cannot calculate\\n    // the fact whether a template is used for projection during compilation.\\n    markNodeAsProjectedTemplate(view.parent.def, view.parentNodeDef);\\n}\\nfunction markNodeAsProjectedTemplate(viewDef, nodeDef) {\\n    if (nodeDef.flags & 4 /* ProjectedTemplate */) {\\n        return;\\n    }\\n    viewDef.nodeFlags |= 4 /* ProjectedTemplate */;\\n    nodeDef.flags |= 4 /* ProjectedTemplate */;\\n    var parentNodeDef = nodeDef.parent;\\n    while (parentNodeDef) {\\n        parentNodeDef.childFlags |= 4 /* ProjectedTemplate */;\\n        parentNodeDef = parentNodeDef.parent;\\n    }\\n}\\nfunction detachEmbeddedView(elementData, viewIndex) {\\n    var embeddedViews = elementData.viewContainer._embeddedViews;\\n    if (viewIndex == null || viewIndex >= embeddedViews.length) {\\n        viewIndex = embeddedViews.length - 1;\\n    }\\n    if (viewIndex < 0) {\\n        return null;\\n    }\\n    var view = embeddedViews[viewIndex];\\n    view.viewContainerParent = null;\\n    removeFromArray(embeddedViews, viewIndex);\\n    // See attachProjectedView for why we don't update projectedViews here.\\n    Services.dirtyParentQueries(view);\\n    renderDetachView(view);\\n    return view;\\n}\\nfunction detachProjectedView(view) {\\n    if (!(view.state & 16 /* IsProjectedView */)) {\\n        return;\\n    }\\n    var dvcElementData = declaredViewContainer(view);\\n    if (dvcElementData) {\\n        var projectedViews = dvcElementData.template._projectedViews;\\n        if (projectedViews) {\\n            removeFromArray(projectedViews, projectedViews.indexOf(view));\\n            Services.dirtyParentQueries(view);\\n        }\\n    }\\n}\\nfunction moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {\\n    var embeddedViews = elementData.viewContainer._embeddedViews;\\n    var view = embeddedViews[oldViewIndex];\\n    removeFromArray(embeddedViews, oldViewIndex);\\n    if (newViewIndex == null) {\\n        newViewIndex = embeddedViews.length;\\n    }\\n    addToArray(embeddedViews, newViewIndex, view);\\n    // Note: Don't need to change projectedViews as the order in there\\n    // as always invalid...\\n    Services.dirtyParentQueries(view);\\n    renderDetachView(view);\\n    var prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;\\n    renderAttachEmbeddedView(elementData, prevView, view);\\n    return view;\\n}\\nfunction renderAttachEmbeddedView(elementData, prevView, view) {\\n    var prevRenderNode = prevView ? renderNode(prevView, prevView.def.lastRenderRootNode) :\\n        elementData.renderElement;\\n    var parentNode = view.renderer.parentNode(prevRenderNode);\\n    var nextSibling = view.renderer.nextSibling(prevRenderNode);\\n    // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!\\n    // However, browsers automatically do `appendChild` when there is no `nextSibling`.\\n    visitRootRenderNodes(view, 2 /* InsertBefore */, parentNode, nextSibling, undefined);\\n}\\nfunction renderDetachView(view) {\\n    visitRootRenderNodes(view, 3 /* RemoveChild */, null, null, undefined);\\n}\\nfunction addToArray(arr, index, value) {\\n    // perf: array.push is faster than array.splice!\\n    if (index >= arr.length) {\\n        arr.push(value);\\n    }\\n    else {\\n        arr.splice(index, 0, value);\\n    }\\n}\\nfunction removeFromArray(arr, index) {\\n    // perf: array.pop is faster than array.splice!\\n    if (index >= arr.length - 1) {\\n        arr.pop();\\n    }\\n    else {\\n        arr.splice(index, 1);\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar EMPTY_CONTEXT = new Object();\\n// Attention: this function is called as top level function.\\n// Putting any logic in here will destroy closure tree shaking!\\nfunction createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {\\n    return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);\\n}\\nfunction getComponentViewDefinitionFactory(componentFactory) {\\n    return componentFactory.viewDefFactory;\\n}\\nvar ComponentFactory_ = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentFactory_, _super);\\n    function ComponentFactory_(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {\\n        var _this = \\n        // Attention: this ctor is called as top level function.\\n        // Putting any logic in here will destroy closure tree shaking!\\n        _super.call(this) || this;\\n        _this.selector = selector;\\n        _this.componentType = componentType;\\n        _this._inputs = _inputs;\\n        _this._outputs = _outputs;\\n        _this.ngContentSelectors = ngContentSelectors;\\n        _this.viewDefFactory = viewDefFactory;\\n        return _this;\\n    }\\n    Object.defineProperty(ComponentFactory_.prototype, \\\"inputs\\\", {\\n        get: function () {\\n            var inputsArr = [];\\n            var inputs = this._inputs;\\n            for (var propName in inputs) {\\n                var templateName = inputs[propName];\\n                inputsArr.push({ propName: propName, templateName: templateName });\\n            }\\n            return inputsArr;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ComponentFactory_.prototype, \\\"outputs\\\", {\\n        get: function () {\\n            var outputsArr = [];\\n            for (var propName in this._outputs) {\\n                var templateName = this._outputs[propName];\\n                outputsArr.push({ propName: propName, templateName: templateName });\\n            }\\n            return outputsArr;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Creates a new component.\\n     */\\n    ComponentFactory_.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {\\n        if (!ngModule) {\\n            throw new Error('ngModule should be provided');\\n        }\\n        var viewDef = resolveDefinition(this.viewDefFactory);\\n        var componentNodeIndex = viewDef.nodes[0].element.componentProvider.nodeIndex;\\n        var view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);\\n        var component = asProviderData(view, componentNodeIndex).instance;\\n        if (rootSelectorOrNode) {\\n            view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);\\n        }\\n        return new ComponentRef_(view, new ViewRef_(view), component);\\n    };\\n    return ComponentFactory_;\\n}(ComponentFactory));\\nvar ComponentRef_ = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(ComponentRef_, _super);\\n    function ComponentRef_(_view, _viewRef, _component) {\\n        var _this = _super.call(this) || this;\\n        _this._view = _view;\\n        _this._viewRef = _viewRef;\\n        _this._component = _component;\\n        _this._elDef = _this._view.def.nodes[0];\\n        _this.hostView = _viewRef;\\n        _this.changeDetectorRef = _viewRef;\\n        _this.instance = _component;\\n        return _this;\\n    }\\n    Object.defineProperty(ComponentRef_.prototype, \\\"location\\\", {\\n        get: function () {\\n            return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ComponentRef_.prototype, \\\"injector\\\", {\\n        get: function () { return new Injector_(this._view, this._elDef); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ComponentRef_.prototype, \\\"componentType\\\", {\\n        get: function () { return this._component.constructor; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ComponentRef_.prototype.destroy = function () { this._viewRef.destroy(); };\\n    ComponentRef_.prototype.onDestroy = function (callback) { this._viewRef.onDestroy(callback); };\\n    return ComponentRef_;\\n}(ComponentRef));\\nfunction createViewContainerData(view, elDef, elData) {\\n    return new ViewContainerRef_(view, elDef, elData);\\n}\\nvar ViewContainerRef_ = /** @class */ (function () {\\n    function ViewContainerRef_(_view, _elDef, _data) {\\n        this._view = _view;\\n        this._elDef = _elDef;\\n        this._data = _data;\\n        /**\\n         * @internal\\n         */\\n        this._embeddedViews = [];\\n    }\\n    Object.defineProperty(ViewContainerRef_.prototype, \\\"element\\\", {\\n        get: function () { return new ElementRef(this._data.renderElement); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ViewContainerRef_.prototype, \\\"injector\\\", {\\n        get: function () { return new Injector_(this._view, this._elDef); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ViewContainerRef_.prototype, \\\"parentInjector\\\", {\\n        /** @deprecated No replacement */\\n        get: function () {\\n            var view = this._view;\\n            var elDef = this._elDef.parent;\\n            while (!elDef && view) {\\n                elDef = viewParentEl(view);\\n                view = view.parent;\\n            }\\n            return view ? new Injector_(view, elDef) : new Injector_(this._view, null);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ViewContainerRef_.prototype.clear = function () {\\n        var len = this._embeddedViews.length;\\n        for (var i = len - 1; i >= 0; i--) {\\n            var view = detachEmbeddedView(this._data, i);\\n            Services.destroyView(view);\\n        }\\n    };\\n    ViewContainerRef_.prototype.get = function (index) {\\n        var view = this._embeddedViews[index];\\n        if (view) {\\n            var ref = new ViewRef_(view);\\n            ref.attachToViewContainerRef(this);\\n            return ref;\\n        }\\n        return null;\\n    };\\n    Object.defineProperty(ViewContainerRef_.prototype, \\\"length\\\", {\\n        get: function () { return this._embeddedViews.length; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {\\n        var viewRef = templateRef.createEmbeddedView(context || {});\\n        this.insert(viewRef, index);\\n        return viewRef;\\n    };\\n    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {\\n        var contextInjector = injector || this.parentInjector;\\n        if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {\\n            ngModuleRef = contextInjector.get(NgModuleRef);\\n        }\\n        var componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\\n        this.insert(componentRef.hostView, index);\\n        return componentRef;\\n    };\\n    ViewContainerRef_.prototype.insert = function (viewRef, index) {\\n        if (viewRef.destroyed) {\\n            throw new Error('Cannot insert a destroyed View in a ViewContainer!');\\n        }\\n        var viewRef_ = viewRef;\\n        var viewData = viewRef_._view;\\n        attachEmbeddedView(this._view, this._data, index, viewData);\\n        viewRef_.attachToViewContainerRef(this);\\n        return viewRef;\\n    };\\n    ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {\\n        if (viewRef.destroyed) {\\n            throw new Error('Cannot move a destroyed View in a ViewContainer!');\\n        }\\n        var previousIndex = this._embeddedViews.indexOf(viewRef._view);\\n        moveEmbeddedView(this._data, previousIndex, currentIndex);\\n        return viewRef;\\n    };\\n    ViewContainerRef_.prototype.indexOf = function (viewRef) {\\n        return this._embeddedViews.indexOf(viewRef._view);\\n    };\\n    ViewContainerRef_.prototype.remove = function (index) {\\n        var viewData = detachEmbeddedView(this._data, index);\\n        if (viewData) {\\n            Services.destroyView(viewData);\\n        }\\n    };\\n    ViewContainerRef_.prototype.detach = function (index) {\\n        var view = detachEmbeddedView(this._data, index);\\n        return view ? new ViewRef_(view) : null;\\n    };\\n    return ViewContainerRef_;\\n}());\\nfunction createChangeDetectorRef(view) {\\n    return new ViewRef_(view);\\n}\\nvar ViewRef_ = /** @class */ (function () {\\n    function ViewRef_(_view) {\\n        this._view = _view;\\n        this._viewContainerRef = null;\\n        this._appRef = null;\\n    }\\n    Object.defineProperty(ViewRef_.prototype, \\\"rootNodes\\\", {\\n        get: function () { return rootRenderNodes(this._view); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ViewRef_.prototype, \\\"context\\\", {\\n        get: function () { return this._view.context; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ViewRef_.prototype, \\\"destroyed\\\", {\\n        get: function () { return (this._view.state & 128 /* Destroyed */) !== 0; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ViewRef_.prototype.markForCheck = function () { markParentViewsForCheck(this._view); };\\n    ViewRef_.prototype.detach = function () { this._view.state &= ~4 /* Attached */; };\\n    ViewRef_.prototype.detectChanges = function () {\\n        var fs = this._view.root.rendererFactory;\\n        if (fs.begin) {\\n            fs.begin();\\n        }\\n        try {\\n            Services.checkAndUpdateView(this._view);\\n        }\\n        finally {\\n            if (fs.end) {\\n                fs.end();\\n            }\\n        }\\n    };\\n    ViewRef_.prototype.checkNoChanges = function () { Services.checkNoChangesView(this._view); };\\n    ViewRef_.prototype.reattach = function () { this._view.state |= 4 /* Attached */; };\\n    ViewRef_.prototype.onDestroy = function (callback) {\\n        if (!this._view.disposables) {\\n            this._view.disposables = [];\\n        }\\n        this._view.disposables.push(callback);\\n    };\\n    ViewRef_.prototype.destroy = function () {\\n        if (this._appRef) {\\n            this._appRef.detachView(this);\\n        }\\n        else if (this._viewContainerRef) {\\n            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\\n        }\\n        Services.destroyView(this._view);\\n    };\\n    ViewRef_.prototype.detachFromAppRef = function () {\\n        this._appRef = null;\\n        renderDetachView(this._view);\\n        Services.dirtyParentQueries(this._view);\\n    };\\n    ViewRef_.prototype.attachToAppRef = function (appRef) {\\n        if (this._viewContainerRef) {\\n            throw new Error('This view is already attached to a ViewContainer!');\\n        }\\n        this._appRef = appRef;\\n    };\\n    ViewRef_.prototype.attachToViewContainerRef = function (vcRef) {\\n        if (this._appRef) {\\n            throw new Error('This view is already attached directly to the ApplicationRef!');\\n        }\\n        this._viewContainerRef = vcRef;\\n    };\\n    return ViewRef_;\\n}());\\nfunction createTemplateData(view, def) {\\n    return new TemplateRef_(view, def);\\n}\\nvar TemplateRef_ = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(TemplateRef_, _super);\\n    function TemplateRef_(_parentView, _def) {\\n        var _this = _super.call(this) || this;\\n        _this._parentView = _parentView;\\n        _this._def = _def;\\n        return _this;\\n    }\\n    TemplateRef_.prototype.createEmbeddedView = function (context) {\\n        return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, this._def.element.template, context));\\n    };\\n    Object.defineProperty(TemplateRef_.prototype, \\\"elementRef\\\", {\\n        get: function () {\\n            return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return TemplateRef_;\\n}(TemplateRef));\\nfunction createInjector$1(view, elDef) {\\n    return new Injector_(view, elDef);\\n}\\nvar Injector_ = /** @class */ (function () {\\n    function Injector_(view, elDef) {\\n        this.view = view;\\n        this.elDef = elDef;\\n    }\\n    Injector_.prototype.get = function (token, notFoundValue) {\\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\\n        var allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432 /* ComponentView */) !== 0 : false;\\n        return Services.resolveDep(this.view, this.elDef, allowPrivateServices, { flags: 0 /* None */, token: token, tokenKey: tokenKey(token) }, notFoundValue);\\n    };\\n    return Injector_;\\n}());\\nfunction nodeValue(view, index) {\\n    var def = view.def.nodes[index];\\n    if (def.flags & 1 /* TypeElement */) {\\n        var elData = asElementData(view, def.nodeIndex);\\n        return def.element.template ? elData.template : elData.renderElement;\\n    }\\n    else if (def.flags & 2 /* TypeText */) {\\n        return asTextData(view, def.nodeIndex).renderText;\\n    }\\n    else if (def.flags & (20224 /* CatProvider */ | 16 /* TypePipe */)) {\\n        return asProviderData(view, def.nodeIndex).instance;\\n    }\\n    throw new Error(\\\"Illegal state: read nodeValue for node index \\\" + index);\\n}\\nfunction createRendererV1(view) {\\n    return new RendererAdapter(view.renderer);\\n}\\nvar RendererAdapter = /** @class */ (function () {\\n    function RendererAdapter(delegate) {\\n        this.delegate = delegate;\\n    }\\n    RendererAdapter.prototype.selectRootElement = function (selectorOrNode) {\\n        return this.delegate.selectRootElement(selectorOrNode);\\n    };\\n    RendererAdapter.prototype.createElement = function (parent, namespaceAndName) {\\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\\n        var el = this.delegate.createElement(name, ns);\\n        if (parent) {\\n            this.delegate.appendChild(parent, el);\\n        }\\n        return el;\\n    };\\n    RendererAdapter.prototype.createViewRoot = function (hostElement) { return hostElement; };\\n    RendererAdapter.prototype.createTemplateAnchor = function (parentElement) {\\n        var comment = this.delegate.createComment('');\\n        if (parentElement) {\\n            this.delegate.appendChild(parentElement, comment);\\n        }\\n        return comment;\\n    };\\n    RendererAdapter.prototype.createText = function (parentElement, value) {\\n        var node = this.delegate.createText(value);\\n        if (parentElement) {\\n            this.delegate.appendChild(parentElement, node);\\n        }\\n        return node;\\n    };\\n    RendererAdapter.prototype.projectNodes = function (parentElement, nodes) {\\n        for (var i = 0; i < nodes.length; i++) {\\n            this.delegate.appendChild(parentElement, nodes[i]);\\n        }\\n    };\\n    RendererAdapter.prototype.attachViewAfter = function (node, viewRootNodes) {\\n        var parentElement = this.delegate.parentNode(node);\\n        var nextSibling = this.delegate.nextSibling(node);\\n        for (var i = 0; i < viewRootNodes.length; i++) {\\n            this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);\\n        }\\n    };\\n    RendererAdapter.prototype.detachView = function (viewRootNodes) {\\n        for (var i = 0; i < viewRootNodes.length; i++) {\\n            var node = viewRootNodes[i];\\n            var parentElement = this.delegate.parentNode(node);\\n            this.delegate.removeChild(parentElement, node);\\n        }\\n    };\\n    RendererAdapter.prototype.destroyView = function (hostElement, viewAllNodes) {\\n        for (var i = 0; i < viewAllNodes.length; i++) {\\n            this.delegate.destroyNode(viewAllNodes[i]);\\n        }\\n    };\\n    RendererAdapter.prototype.listen = function (renderElement, name, callback) {\\n        return this.delegate.listen(renderElement, name, callback);\\n    };\\n    RendererAdapter.prototype.listenGlobal = function (target, name, callback) {\\n        return this.delegate.listen(target, name, callback);\\n    };\\n    RendererAdapter.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {\\n        this.delegate.setProperty(renderElement, propertyName, propertyValue);\\n    };\\n    RendererAdapter.prototype.setElementAttribute = function (renderElement, namespaceAndName, attributeValue) {\\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(splitNamespace(namespaceAndName), 2), ns = _a[0], name = _a[1];\\n        if (attributeValue != null) {\\n            this.delegate.setAttribute(renderElement, name, attributeValue, ns);\\n        }\\n        else {\\n            this.delegate.removeAttribute(renderElement, name, ns);\\n        }\\n    };\\n    RendererAdapter.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };\\n    RendererAdapter.prototype.setElementClass = function (renderElement, className, isAdd) {\\n        if (isAdd) {\\n            this.delegate.addClass(renderElement, className);\\n        }\\n        else {\\n            this.delegate.removeClass(renderElement, className);\\n        }\\n    };\\n    RendererAdapter.prototype.setElementStyle = function (renderElement, styleName, styleValue) {\\n        if (styleValue != null) {\\n            this.delegate.setStyle(renderElement, styleName, styleValue);\\n        }\\n        else {\\n            this.delegate.removeStyle(renderElement, styleName);\\n        }\\n    };\\n    RendererAdapter.prototype.invokeElementMethod = function (renderElement, methodName, args) {\\n        renderElement[methodName].apply(renderElement, args);\\n    };\\n    RendererAdapter.prototype.setText = function (renderNode$$1, text) { this.delegate.setValue(renderNode$$1, text); };\\n    RendererAdapter.prototype.animate = function () { throw new Error('Renderer.animate is no longer supported!'); };\\n    return RendererAdapter;\\n}());\\nfunction createNgModuleRef(moduleType, parent, bootstrapComponents, def) {\\n    return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);\\n}\\nvar NgModuleRef_ = /** @class */ (function () {\\n    function NgModuleRef_(_moduleType, _parent, _bootstrapComponents, _def) {\\n        this._moduleType = _moduleType;\\n        this._parent = _parent;\\n        this._bootstrapComponents = _bootstrapComponents;\\n        this._def = _def;\\n        this._destroyListeners = [];\\n        this._destroyed = false;\\n        this.injector = this;\\n        initNgModule(this);\\n    }\\n    NgModuleRef_.prototype.get = function (token, notFoundValue, injectFlags) {\\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\\n        if (injectFlags === void 0) { injectFlags = 0 /* Default */; }\\n        var flags = 0 /* None */;\\n        if (injectFlags & 4 /* SkipSelf */) {\\n            flags |= 1 /* SkipSelf */;\\n        }\\n        else if (injectFlags & 2 /* Self */) {\\n            flags |= 4 /* Self */;\\n        }\\n        return resolveNgModuleDep(this, { token: token, tokenKey: tokenKey(token), flags: flags }, notFoundValue);\\n    };\\n    Object.defineProperty(NgModuleRef_.prototype, \\\"instance\\\", {\\n        get: function () { return this.get(this._moduleType); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(NgModuleRef_.prototype, \\\"componentFactoryResolver\\\", {\\n        get: function () { return this.get(ComponentFactoryResolver); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    NgModuleRef_.prototype.destroy = function () {\\n        if (this._destroyed) {\\n            throw new Error(\\\"The ng module \\\" + stringify(this.instance.constructor) + \\\" has already been destroyed.\\\");\\n        }\\n        this._destroyed = true;\\n        callNgModuleLifecycle(this, 131072 /* OnDestroy */);\\n        this._destroyListeners.forEach(function (listener) { return listener(); });\\n    };\\n    NgModuleRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };\\n    return NgModuleRef_;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar RendererV1TokenKey = tokenKey(Renderer);\\nvar Renderer2TokenKey = tokenKey(Renderer2);\\nvar ElementRefTokenKey = tokenKey(ElementRef);\\nvar ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\\nvar TemplateRefTokenKey = tokenKey(TemplateRef);\\nvar ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\\nvar InjectorRefTokenKey$1 = tokenKey(Injector);\\nvar INJECTORRefTokenKey$1 = tokenKey(INJECTOR);\\nfunction directiveDef(checkIndex, flags, matchedQueries, childCount, ctor, deps, props, outputs) {\\n    var bindings = [];\\n    if (props) {\\n        for (var prop in props) {\\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(props[prop], 2), bindingIndex = _a[0], nonMinifiedName = _a[1];\\n            bindings[bindingIndex] = {\\n                flags: 8 /* TypeProperty */,\\n                name: prop, nonMinifiedName: nonMinifiedName,\\n                ns: null,\\n                securityContext: null,\\n                suffix: null\\n            };\\n        }\\n    }\\n    var outputDefs = [];\\n    if (outputs) {\\n        for (var propName in outputs) {\\n            outputDefs.push({ type: 1 /* DirectiveOutput */, propName: propName, target: null, eventName: outputs[propName] });\\n        }\\n    }\\n    flags |= 16384 /* TypeDirective */;\\n    return _def(checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);\\n}\\nfunction pipeDef(flags, ctor, deps) {\\n    flags |= 16 /* TypePipe */;\\n    return _def(-1, flags, null, 0, ctor, ctor, deps);\\n}\\nfunction providerDef(flags, matchedQueries, token, value, deps) {\\n    return _def(-1, flags, matchedQueries, 0, token, value, deps);\\n}\\nfunction _def(checkIndex, flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {\\n    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;\\n    if (!outputs) {\\n        outputs = [];\\n    }\\n    if (!bindings) {\\n        bindings = [];\\n    }\\n    // Need to resolve forwardRefs as e.g. for `useValue` we\\n    // lowered the expression and then stopped evaluating it,\\n    // i.e. also didn't unwrap it.\\n    value = resolveForwardRef(value);\\n    var depDefs = splitDepsDsl(deps, stringify(token));\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        checkIndex: checkIndex,\\n        flags: flags,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references,\\n        ngContentIndex: -1, childCount: childCount, bindings: bindings,\\n        bindingFlags: calcBindingFlags(bindings), outputs: outputs,\\n        element: null,\\n        provider: { token: token, value: value, deps: depDefs },\\n        text: null,\\n        query: null,\\n        ngContent: null\\n    };\\n}\\nfunction createProviderInstance(view, def) {\\n    return _createProviderInstance$1(view, def);\\n}\\nfunction createPipeInstance(view, def) {\\n    // deps are looked up from component.\\n    var compView = view;\\n    while (compView.parent && !isComponentView(compView)) {\\n        compView = compView.parent;\\n    }\\n    // pipes can see the private services of the component\\n    var allowPrivateServices = true;\\n    // pipes are always eager and classes!\\n    return createClass(compView.parent, viewParentEl(compView), allowPrivateServices, def.provider.value, def.provider.deps);\\n}\\nfunction createDirectiveInstance(view, def) {\\n    // components can see other private services, other directives can't.\\n    var allowPrivateServices = (def.flags & 32768 /* Component */) > 0;\\n    // directives are always eager and classes!\\n    var instance = createClass(view, def.parent, allowPrivateServices, def.provider.value, def.provider.deps);\\n    if (def.outputs.length) {\\n        for (var i = 0; i < def.outputs.length; i++) {\\n            var output = def.outputs[i];\\n            var outputObservable = instance[output.propName];\\n            if (isObservable(outputObservable)) {\\n                var subscription = outputObservable.subscribe(eventHandlerClosure(view, def.parent.nodeIndex, output.eventName));\\n                view.disposables[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);\\n            }\\n            else {\\n                throw new Error(\\\"@Output \\\" + output.propName + \\\" not initialized in '\\\" + instance.constructor.name + \\\"'.\\\");\\n            }\\n        }\\n    }\\n    return instance;\\n}\\nfunction eventHandlerClosure(view, index, eventName) {\\n    return function (event) { return dispatchEvent(view, index, eventName, event); };\\n}\\nfunction checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var providerData = asProviderData(view, def.nodeIndex);\\n    var directive = providerData.instance;\\n    var changed = false;\\n    var changes = undefined;\\n    var bindLen = def.bindings.length;\\n    if (bindLen > 0 && checkBinding(view, def, 0, v0)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 0, v0, changes);\\n    }\\n    if (bindLen > 1 && checkBinding(view, def, 1, v1)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 1, v1, changes);\\n    }\\n    if (bindLen > 2 && checkBinding(view, def, 2, v2)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 2, v2, changes);\\n    }\\n    if (bindLen > 3 && checkBinding(view, def, 3, v3)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 3, v3, changes);\\n    }\\n    if (bindLen > 4 && checkBinding(view, def, 4, v4)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 4, v4, changes);\\n    }\\n    if (bindLen > 5 && checkBinding(view, def, 5, v5)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 5, v5, changes);\\n    }\\n    if (bindLen > 6 && checkBinding(view, def, 6, v6)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 6, v6, changes);\\n    }\\n    if (bindLen > 7 && checkBinding(view, def, 7, v7)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 7, v7, changes);\\n    }\\n    if (bindLen > 8 && checkBinding(view, def, 8, v8)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 8, v8, changes);\\n    }\\n    if (bindLen > 9 && checkBinding(view, def, 9, v9)) {\\n        changed = true;\\n        changes = updateProp(view, providerData, def, 9, v9, changes);\\n    }\\n    if (changes) {\\n        directive.ngOnChanges(changes);\\n    }\\n    if ((def.flags & 65536 /* OnInit */) &&\\n        shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {\\n        directive.ngOnInit();\\n    }\\n    if (def.flags & 262144 /* DoCheck */) {\\n        directive.ngDoCheck();\\n    }\\n    return changed;\\n}\\nfunction checkAndUpdateDirectiveDynamic(view, def, values) {\\n    var providerData = asProviderData(view, def.nodeIndex);\\n    var directive = providerData.instance;\\n    var changed = false;\\n    var changes = undefined;\\n    for (var i = 0; i < values.length; i++) {\\n        if (checkBinding(view, def, i, values[i])) {\\n            changed = true;\\n            changes = updateProp(view, providerData, def, i, values[i], changes);\\n        }\\n    }\\n    if (changes) {\\n        directive.ngOnChanges(changes);\\n    }\\n    if ((def.flags & 65536 /* OnInit */) &&\\n        shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {\\n        directive.ngOnInit();\\n    }\\n    if (def.flags & 262144 /* DoCheck */) {\\n        directive.ngDoCheck();\\n    }\\n    return changed;\\n}\\nfunction _createProviderInstance$1(view, def) {\\n    // private services can see other private services\\n    var allowPrivateServices = (def.flags & 8192 /* PrivateProvider */) > 0;\\n    var providerDef = def.provider;\\n    switch (def.flags & 201347067 /* Types */) {\\n        case 512 /* TypeClassProvider */:\\n            return createClass(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);\\n        case 1024 /* TypeFactoryProvider */:\\n            return callFactory(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);\\n        case 2048 /* TypeUseExistingProvider */:\\n            return resolveDep(view, def.parent, allowPrivateServices, providerDef.deps[0]);\\n        case 256 /* TypeValueProvider */:\\n            return providerDef.value;\\n    }\\n}\\nfunction createClass(view, elDef, allowPrivateServices, ctor, deps) {\\n    var len = deps.length;\\n    switch (len) {\\n        case 0:\\n            return new ctor();\\n        case 1:\\n            return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));\\n        case 2:\\n            return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));\\n        case 3:\\n            return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));\\n        default:\\n            var depValues = new Array(len);\\n            for (var i = 0; i < len; i++) {\\n                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\\n            }\\n            return new (ctor.bind.apply(ctor, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([void 0], depValues)))();\\n    }\\n}\\nfunction callFactory(view, elDef, allowPrivateServices, factory, deps) {\\n    var len = deps.length;\\n    switch (len) {\\n        case 0:\\n            return factory();\\n        case 1:\\n            return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));\\n        case 2:\\n            return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));\\n        case 3:\\n            return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));\\n        default:\\n            var depValues = Array(len);\\n            for (var i = 0; i < len; i++) {\\n                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);\\n            }\\n            return factory.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(depValues));\\n    }\\n}\\n// This default value is when checking the hierarchy for a token.\\n//\\n// It means both:\\n// - the token is not provided by the current injector,\\n// - only the element injectors should be checked (ie do not check module injectors\\n//\\n//          mod1\\n//         /\\n//       el1   mod2\\n//         \\\\  /\\n//         el2\\n//\\n// When requesting el2.injector.get(token), we should check in the following order and return the\\n// first found value:\\n// - el2.injector.get(token, default)\\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\\n// - mod2.injector.get(token, default)\\nvar NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\\nfunction resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue) {\\n    if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\\n    if (depDef.flags & 8 /* Value */) {\\n        return depDef.token;\\n    }\\n    var startView = view;\\n    if (depDef.flags & 2 /* Optional */) {\\n        notFoundValue = null;\\n    }\\n    var tokenKey$$1 = depDef.tokenKey;\\n    if (tokenKey$$1 === ChangeDetectorRefTokenKey) {\\n        // directives on the same element as a component should be able to control the change detector\\n        // of that component as well.\\n        allowPrivateServices = !!(elDef && elDef.element.componentView);\\n    }\\n    if (elDef && (depDef.flags & 1 /* SkipSelf */)) {\\n        allowPrivateServices = false;\\n        elDef = elDef.parent;\\n    }\\n    var searchView = view;\\n    while (searchView) {\\n        if (elDef) {\\n            switch (tokenKey$$1) {\\n                case RendererV1TokenKey: {\\n                    var compView = findCompView(searchView, elDef, allowPrivateServices);\\n                    return createRendererV1(compView);\\n                }\\n                case Renderer2TokenKey: {\\n                    var compView = findCompView(searchView, elDef, allowPrivateServices);\\n                    return compView.renderer;\\n                }\\n                case ElementRefTokenKey:\\n                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);\\n                case ViewContainerRefTokenKey:\\n                    return asElementData(searchView, elDef.nodeIndex).viewContainer;\\n                case TemplateRefTokenKey: {\\n                    if (elDef.element.template) {\\n                        return asElementData(searchView, elDef.nodeIndex).template;\\n                    }\\n                    break;\\n                }\\n                case ChangeDetectorRefTokenKey: {\\n                    var cdView = findCompView(searchView, elDef, allowPrivateServices);\\n                    return createChangeDetectorRef(cdView);\\n                }\\n                case InjectorRefTokenKey$1:\\n                case INJECTORRefTokenKey$1:\\n                    return createInjector$1(searchView, elDef);\\n                default:\\n                    var providerDef_1 = (allowPrivateServices ? elDef.element.allProviders :\\n                        elDef.element.publicProviders)[tokenKey$$1];\\n                    if (providerDef_1) {\\n                        var providerData = asProviderData(searchView, providerDef_1.nodeIndex);\\n                        if (!providerData) {\\n                            providerData = { instance: _createProviderInstance$1(searchView, providerDef_1) };\\n                            searchView.nodes[providerDef_1.nodeIndex] = providerData;\\n                        }\\n                        return providerData.instance;\\n                    }\\n            }\\n        }\\n        allowPrivateServices = isComponentView(searchView);\\n        elDef = viewParentEl(searchView);\\n        searchView = searchView.parent;\\n        if (depDef.flags & 4 /* Self */) {\\n            searchView = null;\\n        }\\n    }\\n    var value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);\\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\\n        notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\\n        // Return the value from the root element injector when\\n        // - it provides it\\n        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\\n        // - the module injector should not be checked\\n        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\\n        return value;\\n    }\\n    return startView.root.ngModule.injector.get(depDef.token, notFoundValue);\\n}\\nfunction findCompView(view, elDef, allowPrivateServices) {\\n    var compView;\\n    if (allowPrivateServices) {\\n        compView = asElementData(view, elDef.nodeIndex).componentView;\\n    }\\n    else {\\n        compView = view;\\n        while (compView.parent && !isComponentView(compView)) {\\n            compView = compView.parent;\\n        }\\n    }\\n    return compView;\\n}\\nfunction updateProp(view, providerData, def, bindingIdx, value, changes) {\\n    if (def.flags & 32768 /* Component */) {\\n        var compView = asElementData(view, def.parent.nodeIndex).componentView;\\n        if (compView.def.flags & 2 /* OnPush */) {\\n            compView.state |= 8 /* ChecksEnabled */;\\n        }\\n    }\\n    var binding = def.bindings[bindingIdx];\\n    var propName = binding.name;\\n    // Note: This is still safe with Closure Compiler as\\n    // the user passed in the property name as an object has to `providerDef`,\\n    // so Closure Compiler will have renamed the property correctly already.\\n    providerData.instance[propName] = value;\\n    if (def.flags & 524288 /* OnChanges */) {\\n        changes = changes || {};\\n        var oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);\\n        var binding_1 = def.bindings[bindingIdx];\\n        changes[binding_1.nonMinifiedName] =\\n            new SimpleChange(oldValue, value, (view.state & 2 /* FirstCheck */) !== 0);\\n    }\\n    view.oldValues[def.bindingIndex + bindingIdx] = value;\\n    return changes;\\n}\\n// This function calls the ngAfterContentCheck, ngAfterContentInit,\\n// ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node\\n// flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are\\n// called during a pre-order traversal of the view tree (that is calling the\\n// parent hooks before the child hooks) these events are sent in using a\\n// post-order traversal of the tree (children before parents). This changes the\\n// meaning of initIndex in the view state. For ngOnInit, initIndex tracks the\\n// expected nodeIndex which a ngOnInit should be called. When sending\\n// ngAfterContentInit and ngAfterViewInit it is the expected count of\\n// ngAfterContentInit or ngAfterViewInit methods that have been called. This\\n// ensure that despite being called recursively or after picking up after an\\n// exception, the ngAfterContentInit or ngAfterViewInit will be called on the\\n// correct nodes. Consider for example, the following (where E is an element\\n// and D is a directive)\\n//  Tree:       pre-order index  post-order index\\n//    E1        0                6\\n//      E2      1                1\\n//       D3     2                0\\n//      E4      3                5\\n//       E5     4                4\\n//        E6    5                2\\n//        E7    6                3\\n// As can be seen, the post-order index has an unclear relationship to the\\n// pre-order index (postOrderIndex === preOrderIndex - parentCount +\\n// childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit\\n// are stable (will be the same for the same view regardless of exceptions or\\n// recursion) we just need to count them which will roughly correspond to the\\n// post-order index (it skips elements and directives that do not have\\n// lifecycle hooks).\\n//\\n// For example, if an exception is raised in the E6.onAfterViewInit() the\\n// initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to\\n// initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will\\n// not have their ngAfterViewInit() called but, starting with E7, the rest of\\n// the view will begin getting ngAfterViewInit() called until a check and\\n// pass is complete.\\n//\\n// This algorthim also handles recursion. Consider if E4's ngAfterViewInit()\\n// indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected\\n// initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.\\n// D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.\\n// When the recursion returns the initIndex will be 7 so E1 is skipped as it\\n// has already been called in the recursively called checkAnUpdateView().\\nfunction callLifecycleHooksChildrenFirst(view, lifecycles) {\\n    if (!(view.def.nodeFlags & lifecycles)) {\\n        return;\\n    }\\n    var nodes = view.def.nodes;\\n    var initIndex = 0;\\n    for (var i = 0; i < nodes.length; i++) {\\n        var nodeDef = nodes[i];\\n        var parent_1 = nodeDef.parent;\\n        if (!parent_1 && nodeDef.flags & lifecycles) {\\n            // matching root node (e.g. a pipe)\\n            callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\\n        }\\n        if ((nodeDef.childFlags & lifecycles) === 0) {\\n            // no child matches one of the lifecycles\\n            i += nodeDef.childCount;\\n        }\\n        while (parent_1 && (parent_1.flags & 1 /* TypeElement */) &&\\n            i === parent_1.nodeIndex + parent_1.childCount) {\\n            // last child of an element\\n            if (parent_1.directChildFlags & lifecycles) {\\n                initIndex = callElementProvidersLifecycles(view, parent_1, lifecycles, initIndex);\\n            }\\n            parent_1 = parent_1.parent;\\n        }\\n    }\\n}\\nfunction callElementProvidersLifecycles(view, elDef, lifecycles, initIndex) {\\n    for (var i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        if (nodeDef.flags & lifecycles) {\\n            callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\\n        }\\n        // only visit direct children\\n        i += nodeDef.childCount;\\n    }\\n    return initIndex;\\n}\\nfunction callProviderLifecycles(view, index, lifecycles, initIndex) {\\n    var providerData = asProviderData(view, index);\\n    if (!providerData) {\\n        return;\\n    }\\n    var provider = providerData.instance;\\n    if (!provider) {\\n        return;\\n    }\\n    Services.setCurrentNode(view, index);\\n    if (lifecycles & 1048576 /* AfterContentInit */ &&\\n        shouldCallLifecycleInitHook(view, 512 /* InitState_CallingAfterContentInit */, initIndex)) {\\n        provider.ngAfterContentInit();\\n    }\\n    if (lifecycles & 2097152 /* AfterContentChecked */) {\\n        provider.ngAfterContentChecked();\\n    }\\n    if (lifecycles & 4194304 /* AfterViewInit */ &&\\n        shouldCallLifecycleInitHook(view, 768 /* InitState_CallingAfterViewInit */, initIndex)) {\\n        provider.ngAfterViewInit();\\n    }\\n    if (lifecycles & 8388608 /* AfterViewChecked */) {\\n        provider.ngAfterViewChecked();\\n    }\\n    if (lifecycles & 131072 /* OnDestroy */) {\\n        provider.ngOnDestroy();\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction queryDef(flags, id, bindings) {\\n    var bindingDefs = [];\\n    for (var propName in bindings) {\\n        var bindingType = bindings[propName];\\n        bindingDefs.push({ propName: propName, bindingType: bindingType });\\n    }\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        // TODO(vicb): check\\n        checkIndex: -1, flags: flags,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0,\\n        ngContentIndex: -1,\\n        matchedQueries: {},\\n        matchedQueryIds: 0,\\n        references: {},\\n        childCount: 0,\\n        bindings: [],\\n        bindingFlags: 0,\\n        outputs: [],\\n        element: null,\\n        provider: null,\\n        text: null,\\n        query: { id: id, filterId: filterQueryId(id), bindings: bindingDefs },\\n        ngContent: null\\n    };\\n}\\nfunction createQuery$1() {\\n    return new QueryList$1();\\n}\\nfunction dirtyParentQueries(view) {\\n    var queryIds = view.def.nodeMatchedQueries;\\n    while (view.parent && isEmbeddedView(view)) {\\n        var tplDef = view.parentNodeDef;\\n        view = view.parent;\\n        // content queries\\n        var end = tplDef.nodeIndex + tplDef.childCount;\\n        for (var i = 0; i <= end; i++) {\\n            var nodeDef = view.def.nodes[i];\\n            if ((nodeDef.flags & 67108864 /* TypeContentQuery */) &&\\n                (nodeDef.flags & 536870912 /* DynamicQuery */) &&\\n                (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId) {\\n                asQueryList(view, i).setDirty();\\n            }\\n            if ((nodeDef.flags & 1 /* TypeElement */ && i + nodeDef.childCount < tplDef.nodeIndex) ||\\n                !(nodeDef.childFlags & 67108864 /* TypeContentQuery */) ||\\n                !(nodeDef.childFlags & 536870912 /* DynamicQuery */)) {\\n                // skip elements that don't contain the template element or no query.\\n                i += nodeDef.childCount;\\n            }\\n        }\\n    }\\n    // view queries\\n    if (view.def.nodeFlags & 134217728 /* TypeViewQuery */) {\\n        for (var i = 0; i < view.def.nodes.length; i++) {\\n            var nodeDef = view.def.nodes[i];\\n            if ((nodeDef.flags & 134217728 /* TypeViewQuery */) && (nodeDef.flags & 536870912 /* DynamicQuery */)) {\\n                asQueryList(view, i).setDirty();\\n            }\\n            // only visit the root nodes\\n            i += nodeDef.childCount;\\n        }\\n    }\\n}\\nfunction checkAndUpdateQuery(view, nodeDef) {\\n    var queryList = asQueryList(view, nodeDef.nodeIndex);\\n    if (!queryList.dirty) {\\n        return;\\n    }\\n    var directiveInstance;\\n    var newValues = undefined;\\n    if (nodeDef.flags & 67108864 /* TypeContentQuery */) {\\n        var elementDef = nodeDef.parent.parent;\\n        newValues = calcQueryValues(view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount, nodeDef.query, []);\\n        directiveInstance = asProviderData(view, nodeDef.parent.nodeIndex).instance;\\n    }\\n    else if (nodeDef.flags & 134217728 /* TypeViewQuery */) {\\n        newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, nodeDef.query, []);\\n        directiveInstance = view.component;\\n    }\\n    queryList.reset(newValues);\\n    var bindings = nodeDef.query.bindings;\\n    var notify = false;\\n    for (var i = 0; i < bindings.length; i++) {\\n        var binding = bindings[i];\\n        var boundValue = void 0;\\n        switch (binding.bindingType) {\\n            case 0 /* First */:\\n                boundValue = queryList.first;\\n                break;\\n            case 1 /* All */:\\n                boundValue = queryList;\\n                notify = true;\\n                break;\\n        }\\n        directiveInstance[binding.propName] = boundValue;\\n    }\\n    if (notify) {\\n        queryList.notifyOnChanges();\\n    }\\n}\\nfunction calcQueryValues(view, startIndex, endIndex, queryDef, values) {\\n    for (var i = startIndex; i <= endIndex; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        var valueType = nodeDef.matchedQueries[queryDef.id];\\n        if (valueType != null) {\\n            values.push(getQueryValue(view, nodeDef, valueType));\\n        }\\n        if (nodeDef.flags & 1 /* TypeElement */ && nodeDef.element.template &&\\n            (nodeDef.element.template.nodeMatchedQueries & queryDef.filterId) ===\\n                queryDef.filterId) {\\n            var elementData = asElementData(view, i);\\n            // check embedded views that were attached at the place of their template,\\n            // but process child nodes first if some match the query (see issue #16568)\\n            if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId) {\\n                calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values);\\n                i += nodeDef.childCount;\\n            }\\n            if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\\n                var embeddedViews = elementData.viewContainer._embeddedViews;\\n                for (var k = 0; k < embeddedViews.length; k++) {\\n                    var embeddedView = embeddedViews[k];\\n                    var dvc = declaredViewContainer(embeddedView);\\n                    if (dvc && dvc === elementData) {\\n                        calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);\\n                    }\\n                }\\n            }\\n            var projectedViews = elementData.template._projectedViews;\\n            if (projectedViews) {\\n                for (var k = 0; k < projectedViews.length; k++) {\\n                    var projectedView = projectedViews[k];\\n                    calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);\\n                }\\n            }\\n        }\\n        if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {\\n            // if no child matches the query, skip the children.\\n            i += nodeDef.childCount;\\n        }\\n    }\\n    return values;\\n}\\nfunction getQueryValue(view, nodeDef, queryValueType) {\\n    if (queryValueType != null) {\\n        // a match\\n        switch (queryValueType) {\\n            case 1 /* RenderElement */:\\n                return asElementData(view, nodeDef.nodeIndex).renderElement;\\n            case 0 /* ElementRef */:\\n                return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);\\n            case 2 /* TemplateRef */:\\n                return asElementData(view, nodeDef.nodeIndex).template;\\n            case 3 /* ViewContainerRef */:\\n                return asElementData(view, nodeDef.nodeIndex).viewContainer;\\n            case 4 /* Provider */:\\n                return asProviderData(view, nodeDef.nodeIndex).instance;\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction ngContentDef(ngContentIndex, index) {\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        checkIndex: -1,\\n        flags: 8 /* TypeNgContent */,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0,\\n        matchedQueries: {},\\n        matchedQueryIds: 0,\\n        references: {}, ngContentIndex: ngContentIndex,\\n        childCount: 0,\\n        bindings: [],\\n        bindingFlags: 0,\\n        outputs: [],\\n        element: null,\\n        provider: null,\\n        text: null,\\n        query: null,\\n        ngContent: { index: index }\\n    };\\n}\\nfunction appendNgContent(view, renderHost, def) {\\n    var parentEl = getParentRenderElement(view, renderHost, def);\\n    if (!parentEl) {\\n        // Nothing to do if there is no parent element.\\n        return;\\n    }\\n    var ngContentIndex = def.ngContent.index;\\n    visitProjectedRenderNodes(view, ngContentIndex, 1 /* AppendChild */, parentEl, null, undefined);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction purePipeDef(checkIndex, argCount) {\\n    // argCount + 1 to include the pipe as first arg\\n    return _pureExpressionDef(128 /* TypePurePipe */, checkIndex, new Array(argCount + 1));\\n}\\nfunction pureArrayDef(checkIndex, argCount) {\\n    return _pureExpressionDef(32 /* TypePureArray */, checkIndex, new Array(argCount));\\n}\\nfunction pureObjectDef(checkIndex, propToIndex) {\\n    var keys = Object.keys(propToIndex);\\n    var nbKeys = keys.length;\\n    var propertyNames = new Array(nbKeys);\\n    for (var i = 0; i < nbKeys; i++) {\\n        var key = keys[i];\\n        var index = propToIndex[key];\\n        propertyNames[index] = key;\\n    }\\n    return _pureExpressionDef(64 /* TypePureObject */, checkIndex, propertyNames);\\n}\\nfunction _pureExpressionDef(flags, checkIndex, propertyNames) {\\n    var bindings = new Array(propertyNames.length);\\n    for (var i = 0; i < propertyNames.length; i++) {\\n        var prop = propertyNames[i];\\n        bindings[i] = {\\n            flags: 8 /* TypeProperty */,\\n            name: prop,\\n            ns: null,\\n            nonMinifiedName: prop,\\n            securityContext: null,\\n            suffix: null\\n        };\\n    }\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        checkIndex: checkIndex,\\n        flags: flags,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0,\\n        matchedQueries: {},\\n        matchedQueryIds: 0,\\n        references: {},\\n        ngContentIndex: -1,\\n        childCount: 0, bindings: bindings,\\n        bindingFlags: calcBindingFlags(bindings),\\n        outputs: [],\\n        element: null,\\n        provider: null,\\n        text: null,\\n        query: null,\\n        ngContent: null\\n    };\\n}\\nfunction createPureExpression(view, def) {\\n    return { value: undefined };\\n}\\nfunction checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var bindings = def.bindings;\\n    var changed = false;\\n    var bindLen = bindings.length;\\n    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))\\n        changed = true;\\n    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))\\n        changed = true;\\n    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))\\n        changed = true;\\n    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))\\n        changed = true;\\n    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))\\n        changed = true;\\n    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))\\n        changed = true;\\n    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))\\n        changed = true;\\n    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))\\n        changed = true;\\n    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))\\n        changed = true;\\n    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))\\n        changed = true;\\n    if (changed) {\\n        var data = asPureExpressionData(view, def.nodeIndex);\\n        var value = void 0;\\n        switch (def.flags & 201347067 /* Types */) {\\n            case 32 /* TypePureArray */:\\n                value = new Array(bindings.length);\\n                if (bindLen > 0)\\n                    value[0] = v0;\\n                if (bindLen > 1)\\n                    value[1] = v1;\\n                if (bindLen > 2)\\n                    value[2] = v2;\\n                if (bindLen > 3)\\n                    value[3] = v3;\\n                if (bindLen > 4)\\n                    value[4] = v4;\\n                if (bindLen > 5)\\n                    value[5] = v5;\\n                if (bindLen > 6)\\n                    value[6] = v6;\\n                if (bindLen > 7)\\n                    value[7] = v7;\\n                if (bindLen > 8)\\n                    value[8] = v8;\\n                if (bindLen > 9)\\n                    value[9] = v9;\\n                break;\\n            case 64 /* TypePureObject */:\\n                value = {};\\n                if (bindLen > 0)\\n                    value[bindings[0].name] = v0;\\n                if (bindLen > 1)\\n                    value[bindings[1].name] = v1;\\n                if (bindLen > 2)\\n                    value[bindings[2].name] = v2;\\n                if (bindLen > 3)\\n                    value[bindings[3].name] = v3;\\n                if (bindLen > 4)\\n                    value[bindings[4].name] = v4;\\n                if (bindLen > 5)\\n                    value[bindings[5].name] = v5;\\n                if (bindLen > 6)\\n                    value[bindings[6].name] = v6;\\n                if (bindLen > 7)\\n                    value[bindings[7].name] = v7;\\n                if (bindLen > 8)\\n                    value[bindings[8].name] = v8;\\n                if (bindLen > 9)\\n                    value[bindings[9].name] = v9;\\n                break;\\n            case 128 /* TypePurePipe */:\\n                var pipe = v0;\\n                switch (bindLen) {\\n                    case 1:\\n                        value = pipe.transform(v0);\\n                        break;\\n                    case 2:\\n                        value = pipe.transform(v1);\\n                        break;\\n                    case 3:\\n                        value = pipe.transform(v1, v2);\\n                        break;\\n                    case 4:\\n                        value = pipe.transform(v1, v2, v3);\\n                        break;\\n                    case 5:\\n                        value = pipe.transform(v1, v2, v3, v4);\\n                        break;\\n                    case 6:\\n                        value = pipe.transform(v1, v2, v3, v4, v5);\\n                        break;\\n                    case 7:\\n                        value = pipe.transform(v1, v2, v3, v4, v5, v6);\\n                        break;\\n                    case 8:\\n                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);\\n                        break;\\n                    case 9:\\n                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);\\n                        break;\\n                    case 10:\\n                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n                        break;\\n                }\\n                break;\\n        }\\n        data.value = value;\\n    }\\n    return changed;\\n}\\nfunction checkAndUpdatePureExpressionDynamic(view, def, values) {\\n    var bindings = def.bindings;\\n    var changed = false;\\n    for (var i = 0; i < values.length; i++) {\\n        // Note: We need to loop over all values, so that\\n        // the old values are updates as well!\\n        if (checkAndUpdateBinding(view, def, i, values[i])) {\\n            changed = true;\\n        }\\n    }\\n    if (changed) {\\n        var data = asPureExpressionData(view, def.nodeIndex);\\n        var value = void 0;\\n        switch (def.flags & 201347067 /* Types */) {\\n            case 32 /* TypePureArray */:\\n                value = values;\\n                break;\\n            case 64 /* TypePureObject */:\\n                value = {};\\n                for (var i = 0; i < values.length; i++) {\\n                    value[bindings[i].name] = values[i];\\n                }\\n                break;\\n            case 128 /* TypePurePipe */:\\n                var pipe = values[0];\\n                var params = values.slice(1);\\n                value = pipe.transform.apply(pipe, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(params));\\n                break;\\n        }\\n        data.value = value;\\n    }\\n    return changed;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction textDef(checkIndex, ngContentIndex, staticText) {\\n    var bindings = new Array(staticText.length - 1);\\n    for (var i = 1; i < staticText.length; i++) {\\n        bindings[i - 1] = {\\n            flags: 8 /* TypeProperty */,\\n            name: null,\\n            ns: null,\\n            nonMinifiedName: null,\\n            securityContext: null,\\n            suffix: staticText[i],\\n        };\\n    }\\n    return {\\n        // will bet set by the view definition\\n        nodeIndex: -1,\\n        parent: null,\\n        renderParent: null,\\n        bindingIndex: -1,\\n        outputIndex: -1,\\n        // regular values\\n        checkIndex: checkIndex,\\n        flags: 2 /* TypeText */,\\n        childFlags: 0,\\n        directChildFlags: 0,\\n        childMatchedQueries: 0,\\n        matchedQueries: {},\\n        matchedQueryIds: 0,\\n        references: {}, ngContentIndex: ngContentIndex,\\n        childCount: 0, bindings: bindings,\\n        bindingFlags: 8 /* TypeProperty */,\\n        outputs: [],\\n        element: null,\\n        provider: null,\\n        text: { prefix: staticText[0] },\\n        query: null,\\n        ngContent: null,\\n    };\\n}\\nfunction createText(view, renderHost, def) {\\n    var renderNode$$1;\\n    var renderer = view.renderer;\\n    renderNode$$1 = renderer.createText(def.text.prefix);\\n    var parentEl = getParentRenderElement(view, renderHost, def);\\n    if (parentEl) {\\n        renderer.appendChild(parentEl, renderNode$$1);\\n    }\\n    return { renderText: renderNode$$1 };\\n}\\nfunction checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var changed = false;\\n    var bindings = def.bindings;\\n    var bindLen = bindings.length;\\n    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))\\n        changed = true;\\n    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))\\n        changed = true;\\n    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))\\n        changed = true;\\n    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))\\n        changed = true;\\n    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))\\n        changed = true;\\n    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))\\n        changed = true;\\n    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))\\n        changed = true;\\n    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))\\n        changed = true;\\n    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))\\n        changed = true;\\n    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))\\n        changed = true;\\n    if (changed) {\\n        var value = def.text.prefix;\\n        if (bindLen > 0)\\n            value += _addInterpolationPart(v0, bindings[0]);\\n        if (bindLen > 1)\\n            value += _addInterpolationPart(v1, bindings[1]);\\n        if (bindLen > 2)\\n            value += _addInterpolationPart(v2, bindings[2]);\\n        if (bindLen > 3)\\n            value += _addInterpolationPart(v3, bindings[3]);\\n        if (bindLen > 4)\\n            value += _addInterpolationPart(v4, bindings[4]);\\n        if (bindLen > 5)\\n            value += _addInterpolationPart(v5, bindings[5]);\\n        if (bindLen > 6)\\n            value += _addInterpolationPart(v6, bindings[6]);\\n        if (bindLen > 7)\\n            value += _addInterpolationPart(v7, bindings[7]);\\n        if (bindLen > 8)\\n            value += _addInterpolationPart(v8, bindings[8]);\\n        if (bindLen > 9)\\n            value += _addInterpolationPart(v9, bindings[9]);\\n        var renderNode$$1 = asTextData(view, def.nodeIndex).renderText;\\n        view.renderer.setValue(renderNode$$1, value);\\n    }\\n    return changed;\\n}\\nfunction checkAndUpdateTextDynamic(view, def, values) {\\n    var bindings = def.bindings;\\n    var changed = false;\\n    for (var i = 0; i < values.length; i++) {\\n        // Note: We need to loop over all values, so that\\n        // the old values are updates as well!\\n        if (checkAndUpdateBinding(view, def, i, values[i])) {\\n            changed = true;\\n        }\\n    }\\n    if (changed) {\\n        var value = '';\\n        for (var i = 0; i < values.length; i++) {\\n            value = value + _addInterpolationPart(values[i], bindings[i]);\\n        }\\n        value = def.text.prefix + value;\\n        var renderNode$$1 = asTextData(view, def.nodeIndex).renderText;\\n        view.renderer.setValue(renderNode$$1, value);\\n    }\\n    return changed;\\n}\\nfunction _addInterpolationPart(value, binding) {\\n    var valueStr = value != null ? value.toString() : '';\\n    return valueStr + binding.suffix;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction viewDef(flags, nodes, updateDirectives, updateRenderer) {\\n    // clone nodes and set auto calculated values\\n    var viewBindingCount = 0;\\n    var viewDisposableCount = 0;\\n    var viewNodeFlags = 0;\\n    var viewRootNodeFlags = 0;\\n    var viewMatchedQueries = 0;\\n    var currentParent = null;\\n    var currentRenderParent = null;\\n    var currentElementHasPublicProviders = false;\\n    var currentElementHasPrivateProviders = false;\\n    var lastRenderRootNode = null;\\n    for (var i = 0; i < nodes.length; i++) {\\n        var node = nodes[i];\\n        node.nodeIndex = i;\\n        node.parent = currentParent;\\n        node.bindingIndex = viewBindingCount;\\n        node.outputIndex = viewDisposableCount;\\n        node.renderParent = currentRenderParent;\\n        viewNodeFlags |= node.flags;\\n        viewMatchedQueries |= node.matchedQueryIds;\\n        if (node.element) {\\n            var elDef = node.element;\\n            elDef.publicProviders =\\n                currentParent ? currentParent.element.publicProviders : Object.create(null);\\n            elDef.allProviders = elDef.publicProviders;\\n            // Note: We assume that all providers of an element are before any child element!\\n            currentElementHasPublicProviders = false;\\n            currentElementHasPrivateProviders = false;\\n            if (node.element.template) {\\n                viewMatchedQueries |= node.element.template.nodeMatchedQueries;\\n            }\\n        }\\n        validateNode(currentParent, node, nodes.length);\\n        viewBindingCount += node.bindings.length;\\n        viewDisposableCount += node.outputs.length;\\n        if (!currentRenderParent && (node.flags & 3 /* CatRenderNode */)) {\\n            lastRenderRootNode = node;\\n        }\\n        if (node.flags & 20224 /* CatProvider */) {\\n            if (!currentElementHasPublicProviders) {\\n                currentElementHasPublicProviders = true;\\n                // Use prototypical inheritance to not get O(n^2) complexity...\\n                currentParent.element.publicProviders =\\n                    Object.create(currentParent.element.publicProviders);\\n                currentParent.element.allProviders = currentParent.element.publicProviders;\\n            }\\n            var isPrivateService = (node.flags & 8192 /* PrivateProvider */) !== 0;\\n            var isComponent = (node.flags & 32768 /* Component */) !== 0;\\n            if (!isPrivateService || isComponent) {\\n                currentParent.element.publicProviders[tokenKey(node.provider.token)] = node;\\n            }\\n            else {\\n                if (!currentElementHasPrivateProviders) {\\n                    currentElementHasPrivateProviders = true;\\n                    // Use prototypical inheritance to not get O(n^2) complexity...\\n                    currentParent.element.allProviders =\\n                        Object.create(currentParent.element.publicProviders);\\n                }\\n                currentParent.element.allProviders[tokenKey(node.provider.token)] = node;\\n            }\\n            if (isComponent) {\\n                currentParent.element.componentProvider = node;\\n            }\\n        }\\n        if (currentParent) {\\n            currentParent.childFlags |= node.flags;\\n            currentParent.directChildFlags |= node.flags;\\n            currentParent.childMatchedQueries |= node.matchedQueryIds;\\n            if (node.element && node.element.template) {\\n                currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;\\n            }\\n        }\\n        else {\\n            viewRootNodeFlags |= node.flags;\\n        }\\n        if (node.childCount > 0) {\\n            currentParent = node;\\n            if (!isNgContainer(node)) {\\n                currentRenderParent = node;\\n            }\\n        }\\n        else {\\n            // When the current node has no children, check if it is the last children of its parent.\\n            // When it is, propagate the flags up.\\n            // The loop is required because an element could be the last transitive children of several\\n            // elements. We loop to either the root or the highest opened element (= with remaining\\n            // children)\\n            while (currentParent && i === currentParent.nodeIndex + currentParent.childCount) {\\n                var newParent = currentParent.parent;\\n                if (newParent) {\\n                    newParent.childFlags |= currentParent.childFlags;\\n                    newParent.childMatchedQueries |= currentParent.childMatchedQueries;\\n                }\\n                currentParent = newParent;\\n                // We also need to update the render parent & account for ng-container\\n                if (currentParent && isNgContainer(currentParent)) {\\n                    currentRenderParent = currentParent.renderParent;\\n                }\\n                else {\\n                    currentRenderParent = currentParent;\\n                }\\n            }\\n        }\\n    }\\n    var handleEvent = function (view, nodeIndex, eventName, event) {\\n        return nodes[nodeIndex].element.handleEvent(view, eventName, event);\\n    };\\n    return {\\n        // Will be filled later...\\n        factory: null,\\n        nodeFlags: viewNodeFlags,\\n        rootNodeFlags: viewRootNodeFlags,\\n        nodeMatchedQueries: viewMatchedQueries, flags: flags,\\n        nodes: nodes,\\n        updateDirectives: updateDirectives || NOOP,\\n        updateRenderer: updateRenderer || NOOP, handleEvent: handleEvent,\\n        bindingCount: viewBindingCount,\\n        outputCount: viewDisposableCount, lastRenderRootNode: lastRenderRootNode\\n    };\\n}\\nfunction isNgContainer(node) {\\n    return (node.flags & 1 /* TypeElement */) !== 0 && node.element.name === null;\\n}\\nfunction validateNode(parent, node, nodeCount) {\\n    var template = node.element && node.element.template;\\n    if (template) {\\n        if (!template.lastRenderRootNode) {\\n            throw new Error(\\\"Illegal State: Embedded templates without nodes are not allowed!\\\");\\n        }\\n        if (template.lastRenderRootNode &&\\n            template.lastRenderRootNode.flags & 16777216 /* EmbeddedViews */) {\\n            throw new Error(\\\"Illegal State: Last root node of a template can't have embedded views, at index \\\" + node.nodeIndex + \\\"!\\\");\\n        }\\n    }\\n    if (node.flags & 20224 /* CatProvider */) {\\n        var parentFlags = parent ? parent.flags : 0;\\n        if ((parentFlags & 1 /* TypeElement */) === 0) {\\n            throw new Error(\\\"Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index \\\" + node.nodeIndex + \\\"!\\\");\\n        }\\n    }\\n    if (node.query) {\\n        if (node.flags & 67108864 /* TypeContentQuery */ &&\\n            (!parent || (parent.flags & 16384 /* TypeDirective */) === 0)) {\\n            throw new Error(\\\"Illegal State: Content Query nodes need to be children of directives, at index \\\" + node.nodeIndex + \\\"!\\\");\\n        }\\n        if (node.flags & 134217728 /* TypeViewQuery */ && parent) {\\n            throw new Error(\\\"Illegal State: View Query nodes have to be top level nodes, at index \\\" + node.nodeIndex + \\\"!\\\");\\n        }\\n    }\\n    if (node.childCount) {\\n        var parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;\\n        if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) {\\n            throw new Error(\\\"Illegal State: childCount of node leads outside of parent, at index \\\" + node.nodeIndex + \\\"!\\\");\\n        }\\n    }\\n}\\nfunction createEmbeddedView(parent, anchorDef$$1, viewDef, context) {\\n    // embedded views are seen as siblings to the anchor, so we need\\n    // to get the parent of the anchor and use it as parentIndex.\\n    var view = createView(parent.root, parent.renderer, parent, anchorDef$$1, viewDef);\\n    initView(view, parent.component, context);\\n    createViewNodes(view);\\n    return view;\\n}\\nfunction createRootView(root, def, context) {\\n    var view = createView(root, root.renderer, null, null, def);\\n    initView(view, context, context);\\n    createViewNodes(view);\\n    return view;\\n}\\nfunction createComponentView(parentView, nodeDef, viewDef, hostElement) {\\n    var rendererType = nodeDef.element.componentRendererType;\\n    var compRenderer;\\n    if (!rendererType) {\\n        compRenderer = parentView.root.renderer;\\n    }\\n    else {\\n        compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);\\n    }\\n    return createView(parentView.root, compRenderer, parentView, nodeDef.element.componentProvider, viewDef);\\n}\\nfunction createView(root, renderer, parent, parentNodeDef, def) {\\n    var nodes = new Array(def.nodes.length);\\n    var disposables = def.outputCount ? new Array(def.outputCount) : null;\\n    var view = {\\n        def: def,\\n        parent: parent,\\n        viewContainerParent: null, parentNodeDef: parentNodeDef,\\n        context: null,\\n        component: null, nodes: nodes,\\n        state: 13 /* CatInit */, root: root, renderer: renderer,\\n        oldValues: new Array(def.bindingCount), disposables: disposables,\\n        initIndex: -1\\n    };\\n    return view;\\n}\\nfunction initView(view, component, context) {\\n    view.component = component;\\n    view.context = context;\\n}\\nfunction createViewNodes(view) {\\n    var renderHost;\\n    if (isComponentView(view)) {\\n        var hostDef = view.parentNodeDef;\\n        renderHost = asElementData(view.parent, hostDef.parent.nodeIndex).renderElement;\\n    }\\n    var def = view.def;\\n    var nodes = view.nodes;\\n    for (var i = 0; i < def.nodes.length; i++) {\\n        var nodeDef = def.nodes[i];\\n        Services.setCurrentNode(view, i);\\n        var nodeData = void 0;\\n        switch (nodeDef.flags & 201347067 /* Types */) {\\n            case 1 /* TypeElement */:\\n                var el = createElement(view, renderHost, nodeDef);\\n                var componentView = undefined;\\n                if (nodeDef.flags & 33554432 /* ComponentView */) {\\n                    var compViewDef = resolveDefinition(nodeDef.element.componentView);\\n                    componentView = Services.createComponentView(view, nodeDef, compViewDef, el);\\n                }\\n                listenToElementOutputs(view, componentView, nodeDef, el);\\n                nodeData = {\\n                    renderElement: el,\\n                    componentView: componentView,\\n                    viewContainer: null,\\n                    template: nodeDef.element.template ? createTemplateData(view, nodeDef) : undefined\\n                };\\n                if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\\n                    nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);\\n                }\\n                break;\\n            case 2 /* TypeText */:\\n                nodeData = createText(view, renderHost, nodeDef);\\n                break;\\n            case 512 /* TypeClassProvider */:\\n            case 1024 /* TypeFactoryProvider */:\\n            case 2048 /* TypeUseExistingProvider */:\\n            case 256 /* TypeValueProvider */: {\\n                nodeData = nodes[i];\\n                if (!nodeData && !(nodeDef.flags & 4096 /* LazyProvider */)) {\\n                    var instance = createProviderInstance(view, nodeDef);\\n                    nodeData = { instance: instance };\\n                }\\n                break;\\n            }\\n            case 16 /* TypePipe */: {\\n                var instance = createPipeInstance(view, nodeDef);\\n                nodeData = { instance: instance };\\n                break;\\n            }\\n            case 16384 /* TypeDirective */: {\\n                nodeData = nodes[i];\\n                if (!nodeData) {\\n                    var instance = createDirectiveInstance(view, nodeDef);\\n                    nodeData = { instance: instance };\\n                }\\n                if (nodeDef.flags & 32768 /* Component */) {\\n                    var compView = asElementData(view, nodeDef.parent.nodeIndex).componentView;\\n                    initView(compView, nodeData.instance, nodeData.instance);\\n                }\\n                break;\\n            }\\n            case 32 /* TypePureArray */:\\n            case 64 /* TypePureObject */:\\n            case 128 /* TypePurePipe */:\\n                nodeData = createPureExpression(view, nodeDef);\\n                break;\\n            case 67108864 /* TypeContentQuery */:\\n            case 134217728 /* TypeViewQuery */:\\n                nodeData = createQuery$1();\\n                break;\\n            case 8 /* TypeNgContent */:\\n                appendNgContent(view, renderHost, nodeDef);\\n                // no runtime data needed for NgContent...\\n                nodeData = undefined;\\n                break;\\n        }\\n        nodes[i] = nodeData;\\n    }\\n    // Create the ViewData.nodes of component views after we created everything else,\\n    // so that e.g. ng-content works\\n    execComponentViewsAction(view, ViewAction.CreateViewNodes);\\n    // fill static content and view queries\\n    execQueriesAction(view, 67108864 /* TypeContentQuery */ | 134217728 /* TypeViewQuery */, 268435456 /* StaticQuery */, 0 /* CheckAndUpdate */);\\n}\\nfunction checkNoChangesView(view) {\\n    markProjectedViewsForCheck(view);\\n    Services.updateDirectives(view, 1 /* CheckNoChanges */);\\n    execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);\\n    Services.updateRenderer(view, 1 /* CheckNoChanges */);\\n    execComponentViewsAction(view, ViewAction.CheckNoChanges);\\n    // Note: We don't check queries for changes as we didn't do this in v2.x.\\n    // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.\\n    view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);\\n}\\nfunction checkAndUpdateView(view) {\\n    if (view.state & 1 /* BeforeFirstCheck */) {\\n        view.state &= ~1 /* BeforeFirstCheck */;\\n        view.state |= 2 /* FirstCheck */;\\n    }\\n    else {\\n        view.state &= ~2 /* FirstCheck */;\\n    }\\n    shiftInitState(view, 0 /* InitState_BeforeInit */, 256 /* InitState_CallingOnInit */);\\n    markProjectedViewsForCheck(view);\\n    Services.updateDirectives(view, 0 /* CheckAndUpdate */);\\n    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);\\n    execQueriesAction(view, 67108864 /* TypeContentQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);\\n    var callInit = shiftInitState(view, 256 /* InitState_CallingOnInit */, 512 /* InitState_CallingAfterContentInit */);\\n    callLifecycleHooksChildrenFirst(view, 2097152 /* AfterContentChecked */ | (callInit ? 1048576 /* AfterContentInit */ : 0));\\n    Services.updateRenderer(view, 0 /* CheckAndUpdate */);\\n    execComponentViewsAction(view, ViewAction.CheckAndUpdate);\\n    execQueriesAction(view, 134217728 /* TypeViewQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);\\n    callInit = shiftInitState(view, 512 /* InitState_CallingAfterContentInit */, 768 /* InitState_CallingAfterViewInit */);\\n    callLifecycleHooksChildrenFirst(view, 8388608 /* AfterViewChecked */ | (callInit ? 4194304 /* AfterViewInit */ : 0));\\n    if (view.def.flags & 2 /* OnPush */) {\\n        view.state &= ~8 /* ChecksEnabled */;\\n    }\\n    view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);\\n    shiftInitState(view, 768 /* InitState_CallingAfterViewInit */, 1024 /* InitState_AfterInit */);\\n}\\nfunction checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    if (argStyle === 0 /* Inline */) {\\n        return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n    }\\n    else {\\n        return checkAndUpdateNodeDynamic(view, nodeDef, v0);\\n    }\\n}\\nfunction markProjectedViewsForCheck(view) {\\n    var def = view.def;\\n    if (!(def.nodeFlags & 4 /* ProjectedTemplate */)) {\\n        return;\\n    }\\n    for (var i = 0; i < def.nodes.length; i++) {\\n        var nodeDef = def.nodes[i];\\n        if (nodeDef.flags & 4 /* ProjectedTemplate */) {\\n            var projectedViews = asElementData(view, i).template._projectedViews;\\n            if (projectedViews) {\\n                for (var i_1 = 0; i_1 < projectedViews.length; i_1++) {\\n                    var projectedView = projectedViews[i_1];\\n                    projectedView.state |= 32 /* CheckProjectedView */;\\n                    markParentViewsForCheckProjectedViews(projectedView, view);\\n                }\\n            }\\n        }\\n        else if ((nodeDef.childFlags & 4 /* ProjectedTemplate */) === 0) {\\n            // a parent with leafs\\n            // no child is a component,\\n            // then skip the children\\n            i += nodeDef.childCount;\\n        }\\n    }\\n}\\nfunction checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    switch (nodeDef.flags & 201347067 /* Types */) {\\n        case 1 /* TypeElement */:\\n            return checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n        case 2 /* TypeText */:\\n            return checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n        case 16384 /* TypeDirective */:\\n            return checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n        case 32 /* TypePureArray */:\\n        case 64 /* TypePureObject */:\\n        case 128 /* TypePurePipe */:\\n            return checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n        default:\\n            throw 'unreachable';\\n    }\\n}\\nfunction checkAndUpdateNodeDynamic(view, nodeDef, values) {\\n    switch (nodeDef.flags & 201347067 /* Types */) {\\n        case 1 /* TypeElement */:\\n            return checkAndUpdateElementDynamic(view, nodeDef, values);\\n        case 2 /* TypeText */:\\n            return checkAndUpdateTextDynamic(view, nodeDef, values);\\n        case 16384 /* TypeDirective */:\\n            return checkAndUpdateDirectiveDynamic(view, nodeDef, values);\\n        case 32 /* TypePureArray */:\\n        case 64 /* TypePureObject */:\\n        case 128 /* TypePurePipe */:\\n            return checkAndUpdatePureExpressionDynamic(view, nodeDef, values);\\n        default:\\n            throw 'unreachable';\\n    }\\n}\\nfunction checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    if (argStyle === 0 /* Inline */) {\\n        checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n    }\\n    else {\\n        checkNoChangesNodeDynamic(view, nodeDef, v0);\\n    }\\n    // Returning false is ok here as we would have thrown in case of a change.\\n    return false;\\n}\\nfunction checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var bindLen = nodeDef.bindings.length;\\n    if (bindLen > 0)\\n        checkBindingNoChanges(view, nodeDef, 0, v0);\\n    if (bindLen > 1)\\n        checkBindingNoChanges(view, nodeDef, 1, v1);\\n    if (bindLen > 2)\\n        checkBindingNoChanges(view, nodeDef, 2, v2);\\n    if (bindLen > 3)\\n        checkBindingNoChanges(view, nodeDef, 3, v3);\\n    if (bindLen > 4)\\n        checkBindingNoChanges(view, nodeDef, 4, v4);\\n    if (bindLen > 5)\\n        checkBindingNoChanges(view, nodeDef, 5, v5);\\n    if (bindLen > 6)\\n        checkBindingNoChanges(view, nodeDef, 6, v6);\\n    if (bindLen > 7)\\n        checkBindingNoChanges(view, nodeDef, 7, v7);\\n    if (bindLen > 8)\\n        checkBindingNoChanges(view, nodeDef, 8, v8);\\n    if (bindLen > 9)\\n        checkBindingNoChanges(view, nodeDef, 9, v9);\\n}\\nfunction checkNoChangesNodeDynamic(view, nodeDef, values) {\\n    for (var i = 0; i < values.length; i++) {\\n        checkBindingNoChanges(view, nodeDef, i, values[i]);\\n    }\\n}\\n/**\\n * Workaround https://github.com/angular/tsickle/issues/497\\n * @suppress {misplacedTypeAnnotation}\\n */\\nfunction checkNoChangesQuery(view, nodeDef) {\\n    var queryList = asQueryList(view, nodeDef.nodeIndex);\\n    if (queryList.dirty) {\\n        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.nodeIndex), \\\"Query \\\" + nodeDef.query.id + \\\" not dirty\\\", \\\"Query \\\" + nodeDef.query.id + \\\" dirty\\\", (view.state & 1 /* BeforeFirstCheck */) !== 0);\\n    }\\n}\\nfunction destroyView(view) {\\n    if (view.state & 128 /* Destroyed */) {\\n        return;\\n    }\\n    execEmbeddedViewsAction(view, ViewAction.Destroy);\\n    execComponentViewsAction(view, ViewAction.Destroy);\\n    callLifecycleHooksChildrenFirst(view, 131072 /* OnDestroy */);\\n    if (view.disposables) {\\n        for (var i = 0; i < view.disposables.length; i++) {\\n            view.disposables[i]();\\n        }\\n    }\\n    detachProjectedView(view);\\n    if (view.renderer.destroyNode) {\\n        destroyViewNodes(view);\\n    }\\n    if (isComponentView(view)) {\\n        view.renderer.destroy();\\n    }\\n    view.state |= 128 /* Destroyed */;\\n}\\nfunction destroyViewNodes(view) {\\n    var len = view.def.nodes.length;\\n    for (var i = 0; i < len; i++) {\\n        var def = view.def.nodes[i];\\n        if (def.flags & 1 /* TypeElement */) {\\n            view.renderer.destroyNode(asElementData(view, i).renderElement);\\n        }\\n        else if (def.flags & 2 /* TypeText */) {\\n            view.renderer.destroyNode(asTextData(view, i).renderText);\\n        }\\n        else if (def.flags & 67108864 /* TypeContentQuery */ || def.flags & 134217728 /* TypeViewQuery */) {\\n            asQueryList(view, i).destroy();\\n        }\\n    }\\n}\\nvar ViewAction;\\n(function (ViewAction) {\\n    ViewAction[ViewAction[\\\"CreateViewNodes\\\"] = 0] = \\\"CreateViewNodes\\\";\\n    ViewAction[ViewAction[\\\"CheckNoChanges\\\"] = 1] = \\\"CheckNoChanges\\\";\\n    ViewAction[ViewAction[\\\"CheckNoChangesProjectedViews\\\"] = 2] = \\\"CheckNoChangesProjectedViews\\\";\\n    ViewAction[ViewAction[\\\"CheckAndUpdate\\\"] = 3] = \\\"CheckAndUpdate\\\";\\n    ViewAction[ViewAction[\\\"CheckAndUpdateProjectedViews\\\"] = 4] = \\\"CheckAndUpdateProjectedViews\\\";\\n    ViewAction[ViewAction[\\\"Destroy\\\"] = 5] = \\\"Destroy\\\";\\n})(ViewAction || (ViewAction = {}));\\nfunction execComponentViewsAction(view, action) {\\n    var def = view.def;\\n    if (!(def.nodeFlags & 33554432 /* ComponentView */)) {\\n        return;\\n    }\\n    for (var i = 0; i < def.nodes.length; i++) {\\n        var nodeDef = def.nodes[i];\\n        if (nodeDef.flags & 33554432 /* ComponentView */) {\\n            // a leaf\\n            callViewAction(asElementData(view, i).componentView, action);\\n        }\\n        else if ((nodeDef.childFlags & 33554432 /* ComponentView */) === 0) {\\n            // a parent with leafs\\n            // no child is a component,\\n            // then skip the children\\n            i += nodeDef.childCount;\\n        }\\n    }\\n}\\nfunction execEmbeddedViewsAction(view, action) {\\n    var def = view.def;\\n    if (!(def.nodeFlags & 16777216 /* EmbeddedViews */)) {\\n        return;\\n    }\\n    for (var i = 0; i < def.nodes.length; i++) {\\n        var nodeDef = def.nodes[i];\\n        if (nodeDef.flags & 16777216 /* EmbeddedViews */) {\\n            // a leaf\\n            var embeddedViews = asElementData(view, i).viewContainer._embeddedViews;\\n            for (var k = 0; k < embeddedViews.length; k++) {\\n                callViewAction(embeddedViews[k], action);\\n            }\\n        }\\n        else if ((nodeDef.childFlags & 16777216 /* EmbeddedViews */) === 0) {\\n            // a parent with leafs\\n            // no child is a component,\\n            // then skip the children\\n            i += nodeDef.childCount;\\n        }\\n    }\\n}\\nfunction callViewAction(view, action) {\\n    var viewState = view.state;\\n    switch (action) {\\n        case ViewAction.CheckNoChanges:\\n            if ((viewState & 128 /* Destroyed */) === 0) {\\n                if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {\\n                    checkNoChangesView(view);\\n                }\\n                else if (viewState & 64 /* CheckProjectedViews */) {\\n                    execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);\\n                }\\n            }\\n            break;\\n        case ViewAction.CheckNoChangesProjectedViews:\\n            if ((viewState & 128 /* Destroyed */) === 0) {\\n                if (viewState & 32 /* CheckProjectedView */) {\\n                    checkNoChangesView(view);\\n                }\\n                else if (viewState & 64 /* CheckProjectedViews */) {\\n                    execProjectedViewsAction(view, action);\\n                }\\n            }\\n            break;\\n        case ViewAction.CheckAndUpdate:\\n            if ((viewState & 128 /* Destroyed */) === 0) {\\n                if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {\\n                    checkAndUpdateView(view);\\n                }\\n                else if (viewState & 64 /* CheckProjectedViews */) {\\n                    execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);\\n                }\\n            }\\n            break;\\n        case ViewAction.CheckAndUpdateProjectedViews:\\n            if ((viewState & 128 /* Destroyed */) === 0) {\\n                if (viewState & 32 /* CheckProjectedView */) {\\n                    checkAndUpdateView(view);\\n                }\\n                else if (viewState & 64 /* CheckProjectedViews */) {\\n                    execProjectedViewsAction(view, action);\\n                }\\n            }\\n            break;\\n        case ViewAction.Destroy:\\n            // Note: destroyView recurses over all views,\\n            // so we don't need to special case projected views here.\\n            destroyView(view);\\n            break;\\n        case ViewAction.CreateViewNodes:\\n            createViewNodes(view);\\n            break;\\n    }\\n}\\nfunction execProjectedViewsAction(view, action) {\\n    execEmbeddedViewsAction(view, action);\\n    execComponentViewsAction(view, action);\\n}\\nfunction execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {\\n    if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {\\n        return;\\n    }\\n    var nodeCount = view.def.nodes.length;\\n    for (var i = 0; i < nodeCount; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {\\n            Services.setCurrentNode(view, nodeDef.nodeIndex);\\n            switch (checkType) {\\n                case 0 /* CheckAndUpdate */:\\n                    checkAndUpdateQuery(view, nodeDef);\\n                    break;\\n                case 1 /* CheckNoChanges */:\\n                    checkNoChangesQuery(view, nodeDef);\\n                    break;\\n            }\\n        }\\n        if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {\\n            // no child has a matching query\\n            // then skip the children\\n            i += nodeDef.childCount;\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar initialized = false;\\nfunction initServicesIfNeeded() {\\n    if (initialized) {\\n        return;\\n    }\\n    initialized = true;\\n    var services = isDevMode() ? createDebugServices() : createProdServices();\\n    Services.setCurrentNode = services.setCurrentNode;\\n    Services.createRootView = services.createRootView;\\n    Services.createEmbeddedView = services.createEmbeddedView;\\n    Services.createComponentView = services.createComponentView;\\n    Services.createNgModuleRef = services.createNgModuleRef;\\n    Services.overrideProvider = services.overrideProvider;\\n    Services.overrideComponentView = services.overrideComponentView;\\n    Services.clearOverrides = services.clearOverrides;\\n    Services.checkAndUpdateView = services.checkAndUpdateView;\\n    Services.checkNoChangesView = services.checkNoChangesView;\\n    Services.destroyView = services.destroyView;\\n    Services.resolveDep = resolveDep;\\n    Services.createDebugContext = services.createDebugContext;\\n    Services.handleEvent = services.handleEvent;\\n    Services.updateDirectives = services.updateDirectives;\\n    Services.updateRenderer = services.updateRenderer;\\n    Services.dirtyParentQueries = dirtyParentQueries;\\n}\\nfunction createProdServices() {\\n    return {\\n        setCurrentNode: function () { },\\n        createRootView: createProdRootView,\\n        createEmbeddedView: createEmbeddedView,\\n        createComponentView: createComponentView,\\n        createNgModuleRef: createNgModuleRef,\\n        overrideProvider: NOOP,\\n        overrideComponentView: NOOP,\\n        clearOverrides: NOOP,\\n        checkAndUpdateView: checkAndUpdateView,\\n        checkNoChangesView: checkNoChangesView,\\n        destroyView: destroyView,\\n        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },\\n        handleEvent: function (view, nodeIndex, eventName, event) {\\n            return view.def.handleEvent(view, nodeIndex, eventName, event);\\n        },\\n        updateDirectives: function (view, checkType) { return view.def.updateDirectives(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :\\n            prodCheckNoChangesNode, view); },\\n        updateRenderer: function (view, checkType) { return view.def.updateRenderer(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :\\n            prodCheckNoChangesNode, view); },\\n    };\\n}\\nfunction createDebugServices() {\\n    return {\\n        setCurrentNode: debugSetCurrentNode,\\n        createRootView: debugCreateRootView,\\n        createEmbeddedView: debugCreateEmbeddedView,\\n        createComponentView: debugCreateComponentView,\\n        createNgModuleRef: debugCreateNgModuleRef,\\n        overrideProvider: debugOverrideProvider,\\n        overrideComponentView: debugOverrideComponentView,\\n        clearOverrides: debugClearOverrides,\\n        checkAndUpdateView: debugCheckAndUpdateView,\\n        checkNoChangesView: debugCheckNoChangesView,\\n        destroyView: debugDestroyView,\\n        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },\\n        handleEvent: debugHandleEvent,\\n        updateDirectives: debugUpdateDirectives,\\n        updateRenderer: debugUpdateRenderer,\\n    };\\n}\\nfunction createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {\\n    var rendererFactory = ngModule.injector.get(RendererFactory2);\\n    return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);\\n}\\nfunction debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {\\n    var rendererFactory = ngModule.injector.get(RendererFactory2);\\n    var root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);\\n    var defWithOverride = applyProviderOverridesToView(def);\\n    return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);\\n}\\nfunction createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {\\n    var sanitizer = ngModule.injector.get(Sanitizer);\\n    var errorHandler = ngModule.injector.get(ErrorHandler);\\n    var renderer = rendererFactory.createRenderer(null, null);\\n    return {\\n        ngModule: ngModule,\\n        injector: elInjector, projectableNodes: projectableNodes,\\n        selectorOrNode: rootSelectorOrNode, sanitizer: sanitizer, rendererFactory: rendererFactory, renderer: renderer, errorHandler: errorHandler\\n    };\\n}\\nfunction debugCreateEmbeddedView(parentView, anchorDef, viewDef$$1, context) {\\n    var defWithOverride = applyProviderOverridesToView(viewDef$$1);\\n    return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);\\n}\\nfunction debugCreateComponentView(parentView, nodeDef, viewDef$$1, hostElement) {\\n    var overrideComponentView = viewDefOverrides.get(nodeDef.element.componentProvider.provider.token);\\n    if (overrideComponentView) {\\n        viewDef$$1 = overrideComponentView;\\n    }\\n    else {\\n        viewDef$$1 = applyProviderOverridesToView(viewDef$$1);\\n    }\\n    return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, viewDef$$1, hostElement]);\\n}\\nfunction debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {\\n    var defWithOverride = applyProviderOverridesToNgModule(def);\\n    return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);\\n}\\nvar providerOverrides = new Map();\\nvar providerOverridesWithScope = new Map();\\nvar viewDefOverrides = new Map();\\nfunction debugOverrideProvider(override) {\\n    providerOverrides.set(override.token, override);\\n    var injectableDef;\\n    if (typeof override.token === 'function' && (injectableDef = getInjectableDef(override.token)) &&\\n        typeof injectableDef.providedIn === 'function') {\\n        providerOverridesWithScope.set(override.token, override);\\n    }\\n}\\nfunction debugOverrideComponentView(comp, compFactory) {\\n    var hostViewDef = resolveDefinition(getComponentViewDefinitionFactory(compFactory));\\n    var compViewDef = resolveDefinition(hostViewDef.nodes[0].element.componentView);\\n    viewDefOverrides.set(comp, compViewDef);\\n}\\nfunction debugClearOverrides() {\\n    providerOverrides.clear();\\n    providerOverridesWithScope.clear();\\n    viewDefOverrides.clear();\\n}\\n// Notes about the algorithm:\\n// 1) Locate the providers of an element and check if one of them was overwritten\\n// 2) Change the providers of that element\\n//\\n// We only create new datastructures if we need to, to keep perf impact\\n// reasonable.\\nfunction applyProviderOverridesToView(def) {\\n    if (providerOverrides.size === 0) {\\n        return def;\\n    }\\n    var elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);\\n    if (elementIndicesWithOverwrittenProviders.length === 0) {\\n        return def;\\n    }\\n    // clone the whole view definition,\\n    // as it maintains references between the nodes that are hard to update.\\n    def = def.factory(function () { return NOOP; });\\n    for (var i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {\\n        applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);\\n    }\\n    return def;\\n    function findElementIndicesWithOverwrittenProviders(def) {\\n        var elIndicesWithOverwrittenProviders = [];\\n        var lastElementDef = null;\\n        for (var i = 0; i < def.nodes.length; i++) {\\n            var nodeDef = def.nodes[i];\\n            if (nodeDef.flags & 1 /* TypeElement */) {\\n                lastElementDef = nodeDef;\\n            }\\n            if (lastElementDef && nodeDef.flags & 3840 /* CatProviderNoDirective */ &&\\n                providerOverrides.has(nodeDef.provider.token)) {\\n                elIndicesWithOverwrittenProviders.push(lastElementDef.nodeIndex);\\n                lastElementDef = null;\\n            }\\n        }\\n        return elIndicesWithOverwrittenProviders;\\n    }\\n    function applyProviderOverridesToElement(viewDef$$1, elIndex) {\\n        for (var i = elIndex + 1; i < viewDef$$1.nodes.length; i++) {\\n            var nodeDef = viewDef$$1.nodes[i];\\n            if (nodeDef.flags & 1 /* TypeElement */) {\\n                // stop at the next element\\n                return;\\n            }\\n            if (nodeDef.flags & 3840 /* CatProviderNoDirective */) {\\n                var provider = nodeDef.provider;\\n                var override = providerOverrides.get(provider.token);\\n                if (override) {\\n                    nodeDef.flags = (nodeDef.flags & ~3840 /* CatProviderNoDirective */) | override.flags;\\n                    provider.deps = splitDepsDsl(override.deps);\\n                    provider.value = override.value;\\n                }\\n            }\\n        }\\n    }\\n}\\n// Notes about the algorithm:\\n// We only create new datastructures if we need to, to keep perf impact\\n// reasonable.\\nfunction applyProviderOverridesToNgModule(def) {\\n    var _a = calcHasOverrides(def), hasOverrides = _a.hasOverrides, hasDeprecatedOverrides = _a.hasDeprecatedOverrides;\\n    if (!hasOverrides) {\\n        return def;\\n    }\\n    // clone the whole view definition,\\n    // as it maintains references between the nodes that are hard to update.\\n    def = def.factory(function () { return NOOP; });\\n    applyProviderOverrides(def);\\n    return def;\\n    function calcHasOverrides(def) {\\n        var hasOverrides = false;\\n        var hasDeprecatedOverrides = false;\\n        if (providerOverrides.size === 0) {\\n            return { hasOverrides: hasOverrides, hasDeprecatedOverrides: hasDeprecatedOverrides };\\n        }\\n        def.providers.forEach(function (node) {\\n            var override = providerOverrides.get(node.token);\\n            if ((node.flags & 3840 /* CatProviderNoDirective */) && override) {\\n                hasOverrides = true;\\n                hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\\n            }\\n        });\\n        def.modules.forEach(function (module) {\\n            providerOverridesWithScope.forEach(function (override, token) {\\n                if (getInjectableDef(token).providedIn === module) {\\n                    hasOverrides = true;\\n                    hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;\\n                }\\n            });\\n        });\\n        return { hasOverrides: hasOverrides, hasDeprecatedOverrides: hasDeprecatedOverrides };\\n    }\\n    function applyProviderOverrides(def) {\\n        for (var i = 0; i < def.providers.length; i++) {\\n            var provider = def.providers[i];\\n            if (hasDeprecatedOverrides) {\\n                // We had a bug where me made\\n                // all providers lazy. Keep this logic behind a flag\\n                // for migrating existing users.\\n                provider.flags |= 4096 /* LazyProvider */;\\n            }\\n            var override = providerOverrides.get(provider.token);\\n            if (override) {\\n                provider.flags = (provider.flags & ~3840 /* CatProviderNoDirective */) | override.flags;\\n                provider.deps = splitDepsDsl(override.deps);\\n                provider.value = override.value;\\n            }\\n        }\\n        if (providerOverridesWithScope.size > 0) {\\n            var moduleSet_1 = new Set(def.modules);\\n            providerOverridesWithScope.forEach(function (override, token) {\\n                if (moduleSet_1.has(getInjectableDef(token).providedIn)) {\\n                    var provider = {\\n                        token: token,\\n                        flags: override.flags | (hasDeprecatedOverrides ? 4096 /* LazyProvider */ : 0 /* None */),\\n                        deps: splitDepsDsl(override.deps),\\n                        value: override.value,\\n                        index: def.providers.length,\\n                    };\\n                    def.providers.push(provider);\\n                    def.providersByKey[tokenKey(token)] = provider;\\n                }\\n            });\\n        }\\n    }\\n}\\nfunction prodCheckAndUpdateNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var nodeDef = view.def.nodes[checkIndex];\\n    checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n    return (nodeDef.flags & 224 /* CatPureExpression */) ?\\n        asPureExpressionData(view, checkIndex).value :\\n        undefined;\\n}\\nfunction prodCheckNoChangesNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {\\n    var nodeDef = view.def.nodes[checkIndex];\\n    checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);\\n    return (nodeDef.flags & 224 /* CatPureExpression */) ?\\n        asPureExpressionData(view, checkIndex).value :\\n        undefined;\\n}\\nfunction debugCheckAndUpdateView(view) {\\n    return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);\\n}\\nfunction debugCheckNoChangesView(view) {\\n    return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);\\n}\\nfunction debugDestroyView(view) {\\n    return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);\\n}\\nvar DebugAction;\\n(function (DebugAction) {\\n    DebugAction[DebugAction[\\\"create\\\"] = 0] = \\\"create\\\";\\n    DebugAction[DebugAction[\\\"detectChanges\\\"] = 1] = \\\"detectChanges\\\";\\n    DebugAction[DebugAction[\\\"checkNoChanges\\\"] = 2] = \\\"checkNoChanges\\\";\\n    DebugAction[DebugAction[\\\"destroy\\\"] = 3] = \\\"destroy\\\";\\n    DebugAction[DebugAction[\\\"handleEvent\\\"] = 4] = \\\"handleEvent\\\";\\n})(DebugAction || (DebugAction = {}));\\nvar _currentAction;\\nvar _currentView;\\nvar _currentNodeIndex;\\nfunction debugSetCurrentNode(view, nodeIndex) {\\n    _currentView = view;\\n    _currentNodeIndex = nodeIndex;\\n}\\nfunction debugHandleEvent(view, nodeIndex, eventName, event) {\\n    debugSetCurrentNode(view, nodeIndex);\\n    return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);\\n}\\nfunction debugUpdateDirectives(view, checkType) {\\n    if (view.state & 128 /* Destroyed */) {\\n        throw viewDestroyedError(DebugAction[_currentAction]);\\n    }\\n    debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));\\n    return view.def.updateDirectives(debugCheckDirectivesFn, view);\\n    function debugCheckDirectivesFn(view, nodeIndex, argStyle) {\\n        var values = [];\\n        for (var _i = 3; _i < arguments.length; _i++) {\\n            values[_i - 3] = arguments[_i];\\n        }\\n        var nodeDef = view.def.nodes[nodeIndex];\\n        if (checkType === 0 /* CheckAndUpdate */) {\\n            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\\n        }\\n        else {\\n            debugCheckNoChangesNode(view, nodeDef, argStyle, values);\\n        }\\n        if (nodeDef.flags & 16384 /* TypeDirective */) {\\n            debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));\\n        }\\n        return (nodeDef.flags & 224 /* CatPureExpression */) ?\\n            asPureExpressionData(view, nodeDef.nodeIndex).value :\\n            undefined;\\n    }\\n}\\nfunction debugUpdateRenderer(view, checkType) {\\n    if (view.state & 128 /* Destroyed */) {\\n        throw viewDestroyedError(DebugAction[_currentAction]);\\n    }\\n    debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));\\n    return view.def.updateRenderer(debugCheckRenderNodeFn, view);\\n    function debugCheckRenderNodeFn(view, nodeIndex, argStyle) {\\n        var values = [];\\n        for (var _i = 3; _i < arguments.length; _i++) {\\n            values[_i - 3] = arguments[_i];\\n        }\\n        var nodeDef = view.def.nodes[nodeIndex];\\n        if (checkType === 0 /* CheckAndUpdate */) {\\n            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);\\n        }\\n        else {\\n            debugCheckNoChangesNode(view, nodeDef, argStyle, values);\\n        }\\n        if (nodeDef.flags & 3 /* CatRenderNode */) {\\n            debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));\\n        }\\n        return (nodeDef.flags & 224 /* CatPureExpression */) ?\\n            asPureExpressionData(view, nodeDef.nodeIndex).value :\\n            undefined;\\n    }\\n}\\nfunction debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {\\n    var changed = checkAndUpdateNode.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([view, nodeDef, argStyle], givenValues));\\n    if (changed) {\\n        var values = argStyle === 1 /* Dynamic */ ? givenValues[0] : givenValues;\\n        if (nodeDef.flags & 16384 /* TypeDirective */) {\\n            var bindingValues = {};\\n            for (var i = 0; i < nodeDef.bindings.length; i++) {\\n                var binding = nodeDef.bindings[i];\\n                var value = values[i];\\n                if (binding.flags & 8 /* TypeProperty */) {\\n                    bindingValues[normalizeDebugBindingName(binding.nonMinifiedName)] =\\n                        normalizeDebugBindingValue(value);\\n                }\\n            }\\n            var elDef = nodeDef.parent;\\n            var el = asElementData(view, elDef.nodeIndex).renderElement;\\n            if (!elDef.element.name) {\\n                // a comment.\\n                view.renderer.setValue(el, \\\"bindings=\\\" + JSON.stringify(bindingValues, null, 2));\\n            }\\n            else {\\n                // a regular element.\\n                for (var attr in bindingValues) {\\n                    var value = bindingValues[attr];\\n                    if (value != null) {\\n                        view.renderer.setAttribute(el, attr, value);\\n                    }\\n                    else {\\n                        view.renderer.removeAttribute(el, attr);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\nfunction debugCheckNoChangesNode(view, nodeDef, argStyle, values) {\\n    checkNoChangesNode.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([view, nodeDef, argStyle], values));\\n}\\nfunction normalizeDebugBindingName(name) {\\n    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\\n    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\\n    return \\\"ng-reflect-\\\" + name;\\n}\\nvar CAMEL_CASE_REGEXP = /([A-Z])/g;\\nfunction camelCaseToDashCase(input) {\\n    return input.replace(CAMEL_CASE_REGEXP, function () {\\n        var m = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            m[_i] = arguments[_i];\\n        }\\n        return '-' + m[1].toLowerCase();\\n    });\\n}\\nfunction normalizeDebugBindingValue(value) {\\n    try {\\n        // Limit the size of the value as otherwise the DOM just gets polluted.\\n        return value != null ? value.toString().slice(0, 30) : value;\\n    }\\n    catch (e) {\\n        return '[ERROR] Exception while trying to serialize the value';\\n    }\\n}\\nfunction nextDirectiveWithBinding(view, nodeIndex) {\\n    for (var i = nodeIndex; i < view.def.nodes.length; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        if (nodeDef.flags & 16384 /* TypeDirective */ && nodeDef.bindings && nodeDef.bindings.length) {\\n            return i;\\n        }\\n    }\\n    return null;\\n}\\nfunction nextRenderNodeWithBinding(view, nodeIndex) {\\n    for (var i = nodeIndex; i < view.def.nodes.length; i++) {\\n        var nodeDef = view.def.nodes[i];\\n        if ((nodeDef.flags & 3 /* CatRenderNode */) && nodeDef.bindings && nodeDef.bindings.length) {\\n            return i;\\n        }\\n    }\\n    return null;\\n}\\nvar DebugContext_ = /** @class */ (function () {\\n    function DebugContext_(view, nodeIndex) {\\n        this.view = view;\\n        this.nodeIndex = nodeIndex;\\n        if (nodeIndex == null) {\\n            this.nodeIndex = nodeIndex = 0;\\n        }\\n        this.nodeDef = view.def.nodes[nodeIndex];\\n        var elDef = this.nodeDef;\\n        var elView = view;\\n        while (elDef && (elDef.flags & 1 /* TypeElement */) === 0) {\\n            elDef = elDef.parent;\\n        }\\n        if (!elDef) {\\n            while (!elDef && elView) {\\n                elDef = viewParentEl(elView);\\n                elView = elView.parent;\\n            }\\n        }\\n        this.elDef = elDef;\\n        this.elView = elView;\\n    }\\n    Object.defineProperty(DebugContext_.prototype, \\\"elOrCompView\\\", {\\n        get: function () {\\n            // Has to be done lazily as we use the DebugContext also during creation of elements...\\n            return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"injector\\\", {\\n        get: function () { return createInjector$1(this.elView, this.elDef); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"component\\\", {\\n        get: function () { return this.elOrCompView.component; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"context\\\", {\\n        get: function () { return this.elOrCompView.context; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"providerTokens\\\", {\\n        get: function () {\\n            var tokens = [];\\n            if (this.elDef) {\\n                for (var i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {\\n                    var childDef = this.elView.def.nodes[i];\\n                    if (childDef.flags & 20224 /* CatProvider */) {\\n                        tokens.push(childDef.provider.token);\\n                    }\\n                    i += childDef.childCount;\\n                }\\n            }\\n            return tokens;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"references\\\", {\\n        get: function () {\\n            var references = {};\\n            if (this.elDef) {\\n                collectReferences(this.elView, this.elDef, references);\\n                for (var i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {\\n                    var childDef = this.elView.def.nodes[i];\\n                    if (childDef.flags & 20224 /* CatProvider */) {\\n                        collectReferences(this.elView, childDef, references);\\n                    }\\n                    i += childDef.childCount;\\n                }\\n            }\\n            return references;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"componentRenderElement\\\", {\\n        get: function () {\\n            var elData = findHostElement(this.elOrCompView);\\n            return elData ? elData.renderElement : undefined;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(DebugContext_.prototype, \\\"renderNode\\\", {\\n        get: function () {\\n            return this.nodeDef.flags & 2 /* TypeText */ ? renderNode(this.view, this.nodeDef) :\\n                renderNode(this.elView, this.elDef);\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    DebugContext_.prototype.logError = function (console) {\\n        var values = [];\\n        for (var _i = 1; _i < arguments.length; _i++) {\\n            values[_i - 1] = arguments[_i];\\n        }\\n        var logViewDef;\\n        var logNodeIndex;\\n        if (this.nodeDef.flags & 2 /* TypeText */) {\\n            logViewDef = this.view.def;\\n            logNodeIndex = this.nodeDef.nodeIndex;\\n        }\\n        else {\\n            logViewDef = this.elView.def;\\n            logNodeIndex = this.elDef.nodeIndex;\\n        }\\n        // Note: we only generate a log function for text and element nodes\\n        // to make the generated code as small as possible.\\n        var renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);\\n        var currRenderNodeIndex = -1;\\n        var nodeLogger = function () {\\n            var _a;\\n            currRenderNodeIndex++;\\n            if (currRenderNodeIndex === renderNodeIndex) {\\n                return (_a = console.error).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])([console], values));\\n            }\\n            else {\\n                return NOOP;\\n            }\\n        };\\n        logViewDef.factory(nodeLogger);\\n        if (currRenderNodeIndex < renderNodeIndex) {\\n            console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');\\n            console.error.apply(console, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(values));\\n        }\\n    };\\n    return DebugContext_;\\n}());\\nfunction getRenderNodeIndex(viewDef$$1, nodeIndex) {\\n    var renderNodeIndex = -1;\\n    for (var i = 0; i <= nodeIndex; i++) {\\n        var nodeDef = viewDef$$1.nodes[i];\\n        if (nodeDef.flags & 3 /* CatRenderNode */) {\\n            renderNodeIndex++;\\n        }\\n    }\\n    return renderNodeIndex;\\n}\\nfunction findHostElement(view) {\\n    while (view && !isComponentView(view)) {\\n        view = view.parent;\\n    }\\n    if (view.parent) {\\n        return asElementData(view.parent, viewParentEl(view).nodeIndex);\\n    }\\n    return null;\\n}\\nfunction collectReferences(view, nodeDef, references) {\\n    for (var refName in nodeDef.references) {\\n        references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);\\n    }\\n}\\nfunction callWithDebugContext(action, fn, self, args) {\\n    var oldAction = _currentAction;\\n    var oldView = _currentView;\\n    var oldNodeIndex = _currentNodeIndex;\\n    try {\\n        _currentAction = action;\\n        var result = fn.apply(self, args);\\n        _currentView = oldView;\\n        _currentNodeIndex = oldNodeIndex;\\n        _currentAction = oldAction;\\n        return result;\\n    }\\n    catch (e) {\\n        if (isViewDebugError(e) || !_currentView) {\\n            throw e;\\n        }\\n        throw viewWrappedDebugError(e, getCurrentDebugContext());\\n    }\\n}\\nfunction getCurrentDebugContext() {\\n    return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;\\n}\\nvar DebugRendererFactory2 = /** @class */ (function () {\\n    function DebugRendererFactory2(delegate) {\\n        this.delegate = delegate;\\n    }\\n    DebugRendererFactory2.prototype.createRenderer = function (element, renderData) {\\n        return new DebugRenderer2(this.delegate.createRenderer(element, renderData));\\n    };\\n    DebugRendererFactory2.prototype.begin = function () {\\n        if (this.delegate.begin) {\\n            this.delegate.begin();\\n        }\\n    };\\n    DebugRendererFactory2.prototype.end = function () {\\n        if (this.delegate.end) {\\n            this.delegate.end();\\n        }\\n    };\\n    DebugRendererFactory2.prototype.whenRenderingDone = function () {\\n        if (this.delegate.whenRenderingDone) {\\n            return this.delegate.whenRenderingDone();\\n        }\\n        return Promise.resolve(null);\\n    };\\n    return DebugRendererFactory2;\\n}());\\nvar DebugRenderer2 = /** @class */ (function () {\\n    function DebugRenderer2(delegate) {\\n        this.delegate = delegate;\\n        /**\\n         * Factory function used to create a `DebugContext` when a node is created.\\n         *\\n         * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.\\n         *\\n         * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine\\n         * or a Render context.\\n         */\\n        this.debugContextFactory = getCurrentDebugContext;\\n        this.data = this.delegate.data;\\n    }\\n    DebugRenderer2.prototype.createDebugContext = function (nativeElement) { return this.debugContextFactory(nativeElement); };\\n    DebugRenderer2.prototype.destroyNode = function (node) {\\n        removeDebugNodeFromIndex(getDebugNode(node));\\n        if (this.delegate.destroyNode) {\\n            this.delegate.destroyNode(node);\\n        }\\n    };\\n    DebugRenderer2.prototype.destroy = function () { this.delegate.destroy(); };\\n    DebugRenderer2.prototype.createElement = function (name, namespace) {\\n        var el = this.delegate.createElement(name, namespace);\\n        var debugCtx = this.createDebugContext(el);\\n        if (debugCtx) {\\n            var debugEl = new DebugElement(el, null, debugCtx);\\n            debugEl.name = name;\\n            indexDebugNode(debugEl);\\n        }\\n        return el;\\n    };\\n    DebugRenderer2.prototype.createComment = function (value) {\\n        var comment = this.delegate.createComment(value);\\n        var debugCtx = this.createDebugContext(comment);\\n        if (debugCtx) {\\n            indexDebugNode(new DebugNode(comment, null, debugCtx));\\n        }\\n        return comment;\\n    };\\n    DebugRenderer2.prototype.createText = function (value) {\\n        var text = this.delegate.createText(value);\\n        var debugCtx = this.createDebugContext(text);\\n        if (debugCtx) {\\n            indexDebugNode(new DebugNode(text, null, debugCtx));\\n        }\\n        return text;\\n    };\\n    DebugRenderer2.prototype.appendChild = function (parent, newChild) {\\n        var debugEl = getDebugNode(parent);\\n        var debugChildEl = getDebugNode(newChild);\\n        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {\\n            debugEl.addChild(debugChildEl);\\n        }\\n        this.delegate.appendChild(parent, newChild);\\n    };\\n    DebugRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {\\n        var debugEl = getDebugNode(parent);\\n        var debugChildEl = getDebugNode(newChild);\\n        var debugRefEl = getDebugNode(refChild);\\n        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {\\n            debugEl.insertBefore(debugRefEl, debugChildEl);\\n        }\\n        this.delegate.insertBefore(parent, newChild, refChild);\\n    };\\n    DebugRenderer2.prototype.removeChild = function (parent, oldChild) {\\n        var debugEl = getDebugNode(parent);\\n        var debugChildEl = getDebugNode(oldChild);\\n        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {\\n            debugEl.removeChild(debugChildEl);\\n        }\\n        this.delegate.removeChild(parent, oldChild);\\n    };\\n    DebugRenderer2.prototype.selectRootElement = function (selectorOrNode, preserveContent) {\\n        var el = this.delegate.selectRootElement(selectorOrNode, preserveContent);\\n        var debugCtx = getCurrentDebugContext() || (ivyEnabled$1 ? this.createDebugContext(el) : null);\\n        if (debugCtx) {\\n            indexDebugNode(new DebugElement(el, null, debugCtx));\\n        }\\n        return el;\\n    };\\n    DebugRenderer2.prototype.setAttribute = function (el, name, value, namespace) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            var fullName = namespace ? namespace + ':' + name : name;\\n            debugEl.attributes[fullName] = value;\\n        }\\n        this.delegate.setAttribute(el, name, value, namespace);\\n    };\\n    DebugRenderer2.prototype.removeAttribute = function (el, name, namespace) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            var fullName = namespace ? namespace + ':' + name : name;\\n            debugEl.attributes[fullName] = null;\\n        }\\n        this.delegate.removeAttribute(el, name, namespace);\\n    };\\n    DebugRenderer2.prototype.addClass = function (el, name) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            debugEl.classes[name] = true;\\n        }\\n        this.delegate.addClass(el, name);\\n    };\\n    DebugRenderer2.prototype.removeClass = function (el, name) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            debugEl.classes[name] = false;\\n        }\\n        this.delegate.removeClass(el, name);\\n    };\\n    DebugRenderer2.prototype.setStyle = function (el, style, value, flags) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            debugEl.styles[style] = value;\\n        }\\n        this.delegate.setStyle(el, style, value, flags);\\n    };\\n    DebugRenderer2.prototype.removeStyle = function (el, style, flags) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            debugEl.styles[style] = null;\\n        }\\n        this.delegate.removeStyle(el, style, flags);\\n    };\\n    DebugRenderer2.prototype.setProperty = function (el, name, value) {\\n        var debugEl = getDebugNode(el);\\n        if (debugEl && debugEl instanceof DebugElement) {\\n            debugEl.properties[name] = value;\\n        }\\n        this.delegate.setProperty(el, name, value);\\n    };\\n    DebugRenderer2.prototype.listen = function (target, eventName, callback) {\\n        if (typeof target !== 'string') {\\n            var debugEl = getDebugNode(target);\\n            if (debugEl) {\\n                debugEl.listeners.push(new EventListener(eventName, callback));\\n            }\\n        }\\n        return this.delegate.listen(target, eventName, callback);\\n    };\\n    DebugRenderer2.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };\\n    DebugRenderer2.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };\\n    DebugRenderer2.prototype.setValue = function (node, value) { return this.delegate.setValue(node, value); };\\n    return DebugRenderer2;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction overrideProvider(override) {\\n    initServicesIfNeeded();\\n    return Services.overrideProvider(override);\\n}\\nfunction overrideComponentView(comp, componentFactory) {\\n    initServicesIfNeeded();\\n    return Services.overrideComponentView(comp, componentFactory);\\n}\\nfunction clearOverrides() {\\n    initServicesIfNeeded();\\n    return Services.clearOverrides();\\n}\\n// Attention: this function is called as top level function.\\n// Putting any logic in here will destroy closure tree shaking!\\nfunction createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {\\n    return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);\\n}\\nfunction cloneNgModuleDefinition(def) {\\n    var providers = Array.from(def.providers);\\n    var modules = Array.from(def.modules);\\n    var providersByKey = {};\\n    for (var key in def.providersByKey) {\\n        providersByKey[key] = def.providersByKey[key];\\n    }\\n    return {\\n        factory: def.factory,\\n        isRoot: def.isRoot, providers: providers, modules: modules, providersByKey: providersByKey,\\n    };\\n}\\nvar NgModuleFactory_ = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(NgModuleFactory_, _super);\\n    function NgModuleFactory_(moduleType, _bootstrapComponents, _ngModuleDefFactory) {\\n        var _this = \\n        // Attention: this ctor is called as top level function.\\n        // Putting any logic in here will destroy closure tree shaking!\\n        _super.call(this) || this;\\n        _this.moduleType = moduleType;\\n        _this._bootstrapComponents = _bootstrapComponents;\\n        _this._ngModuleDefFactory = _ngModuleDefFactory;\\n        return _this;\\n    }\\n    NgModuleFactory_.prototype.create = function (parentInjector) {\\n        initServicesIfNeeded();\\n        // Clone the NgModuleDefinition so that any tree shakeable provider definition\\n        // added to this instance of the NgModuleRef doesn't affect the cached copy.\\n        // See https://github.com/angular/angular/issues/25018.\\n        var def = cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));\\n        return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);\\n    };\\n    return NgModuleFactory_;\\n}(NgModuleFactory));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * Returns the host component instance associated with the target.\\n *\\n * This will only return a component instance of the DOM node\\n * contains an instance of a component on it.\\n */\\nfunction getHostComponent(target) {\\n    var context = loadContext(target);\\n    var tNode = context.lViewData[TVIEW].data[context.nodeIndex];\\n    if (tNode.flags & 4096 /* isComponent */) {\\n        var componentView = getComponentViewByIndex(context.nodeIndex, context.lViewData);\\n        return componentView[CONTEXT];\\n    }\\n    return null;\\n}\\n/**\\n * Returns the `RootContext` instance that is associated with\\n * the application where the target is situated.\\n */\\nfunction getRootContext$2(target) {\\n    var lViewData = Array.isArray(target) ? target : loadContext(target).lViewData;\\n    var rootLViewData = getRootView$1(lViewData);\\n    return rootLViewData[CONTEXT];\\n}\\n/**\\n * Returns the injector instance that is associated with\\n * the element, component or directive.\\n */\\nfunction getInjector(target) {\\n    var context = loadContext(target);\\n    var tNode = context.lViewData[TVIEW].data[context.nodeIndex];\\n    return new NodeInjector(tNode, context.lViewData);\\n}\\n/**\\n * Returns LContext associated with a target passed as an argument.\\n * Throws if a given target doesn't have associated LContext.\\n */\\nfunction loadContext(target) {\\n    var context = getContext(target);\\n    if (!context) {\\n        throw new Error(ngDevMode ? 'Unable to find the given context data for the given target' :\\n            'Invalid ng target');\\n    }\\n    return context;\\n}\\n/**\\n * Retrieve the root view from any component by walking the parent `LViewData` until\\n * reaching the root `LViewData`.\\n *\\n * @param componentOrView any component or view\\n */\\nfunction getRootView$1(componentOrView) {\\n    var lViewData;\\n    if (Array.isArray(componentOrView)) {\\n        ngDevMode && assertDefined(componentOrView, 'lViewData');\\n        lViewData = componentOrView;\\n    }\\n    else {\\n        ngDevMode && assertDefined(componentOrView, 'component');\\n        lViewData = readPatchedLViewData(componentOrView);\\n    }\\n    while (lViewData && !(lViewData[FLAGS] & 64 /* IsRoot */)) {\\n        lViewData = lViewData[PARENT];\\n    }\\n    return lViewData;\\n}\\n/**\\n *  Retrieve map of local references (local reference name => element or directive instance).\\n */\\nfunction getLocalRefs(target) {\\n    var context = loadContext(target);\\n    if (context.localRefs === undefined) {\\n        context.localRefs = discoverLocalRefs(context.lViewData, context.nodeIndex);\\n    }\\n    return context.localRefs || {};\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Adapts the DebugRendererFactory2 to create a DebugRenderer2 specific for IVY.\\n *\\n * The created DebugRenderer know how to create a Debug Context specific to IVY.\\n */\\nvar Render3DebugRendererFactory2 = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(Render3DebugRendererFactory2, _super);\\n    function Render3DebugRendererFactory2() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    Render3DebugRendererFactory2.prototype.createRenderer = function (element, renderData) {\\n        var renderer = _super.prototype.createRenderer.call(this, element, renderData);\\n        renderer.debugContextFactory = function (nativeElement) { return new Render3DebugContext(nativeElement); };\\n        return renderer;\\n    };\\n    return Render3DebugRendererFactory2;\\n}(DebugRendererFactory2));\\n/**\\n * Stores context information about view nodes.\\n *\\n * Used in tests to retrieve information those nodes.\\n */\\nvar Render3DebugContext = /** @class */ (function () {\\n    function Render3DebugContext(_nativeNode) {\\n        this._nativeNode = _nativeNode;\\n    }\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"nodeIndex\\\", {\\n        get: function () { return loadContext(this._nativeNode).nodeIndex; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"view\\\", {\\n        get: function () { return loadContext(this._nativeNode).lViewData; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"injector\\\", {\\n        get: function () { return getInjector(this._nativeNode); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"component\\\", {\\n        get: function () { return getHostComponent(this._nativeNode); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"providerTokens\\\", {\\n        get: function () {\\n            var lDebugCtx = loadContext(this._nativeNode);\\n            var lViewData = lDebugCtx.lViewData;\\n            var tNode = lViewData[TVIEW].data[lDebugCtx.nodeIndex];\\n            var directivesCount = tNode.flags & 4095 /* DirectiveCountMask */;\\n            if (directivesCount > 0) {\\n                var directiveIdxStart = tNode.flags >> 15 /* DirectiveStartingIndexShift */;\\n                var directiveIdxEnd = directiveIdxStart + directivesCount;\\n                var viewDirectiveDefs = this.view[TVIEW].data;\\n                var directiveDefs = viewDirectiveDefs.slice(directiveIdxStart, directiveIdxEnd);\\n                return directiveDefs.map(function (directiveDef) { return directiveDef.type; });\\n            }\\n            return [];\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"references\\\", {\\n        get: function () { return getLocalRefs(this._nativeNode); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"context\\\", {\\n        // TODO(pk): check previous implementation and re-implement\\n        get: function () { throw new Error('Not implemented in ivy'); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"componentRenderElement\\\", {\\n        // TODO(pk): check previous implementation and re-implement\\n        get: function () { throw new Error('Not implemented in ivy'); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(Render3DebugContext.prototype, \\\"renderNode\\\", {\\n        // TODO(pk): check previous implementation and re-implement\\n        get: function () { throw new Error('Not implemented in ivy'); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    // TODO(pk): check previous implementation and re-implement\\n    Render3DebugContext.prototype.logError = function (console) {\\n        var values = [];\\n        for (var _i = 1; _i < arguments.length; _i++) {\\n            values[_i - 1] = arguments[_i];\\n        }\\n        console.error.apply(console, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(values));\\n    };\\n    return Render3DebugContext;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Adds a player to an element, directive or component instance that will later be\\n * animated once change detection has passed.\\n *\\n * When a player is added to a reference it will stay active until `player.destroy()`\\n * is called. Once called then the player will be removed from the active players\\n * present on the associated ref instance.\\n *\\n * To get a list of all the active players on an element see [getPlayers].\\n *\\n * @param ref The element, directive or component that the player will be placed on.\\n * @param player The player that will be triggered to play once change detection has run.\\n */\\nfunction addPlayer(ref, player) {\\n    var context = getContext(ref);\\n    if (!context) {\\n        ngDevMode && throwInvalidRefError();\\n        return;\\n    }\\n    var element$$1 = context.native;\\n    var lViewData = context.lViewData;\\n    var playerContext = getOrCreatePlayerContext(element$$1, context);\\n    var rootContext = getRootContext$2(lViewData);\\n    addPlayerInternal(playerContext, rootContext, element$$1, player, 0, ref);\\n    scheduleTick(rootContext, 2 /* FlushPlayers */);\\n}\\n/**\\n * Returns a list of all the active players present on the provided ref instance (which can\\n * be an instance of a directive, component or element).\\n *\\n * This function will only return players that have been added to the ref instance using\\n * `addPlayer` or any players that are active through any template styling bindings\\n * (`[style]`, `[style.prop]`, `[class]` and `[class.name]`).\\n */\\nfunction getPlayers(ref) {\\n    var context = getContext(ref);\\n    if (!context) {\\n        ngDevMode && throwInvalidRefError();\\n        return [];\\n    }\\n    var stylingContext = getStylingContext(context.nodeIndex - HEADER_OFFSET, context.lViewData);\\n    var playerContext = stylingContext ? getPlayerContext(stylingContext) : null;\\n    return playerContext ? getPlayersInternal(playerContext) : [];\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// clang-format on\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// This file only reexports content of the `src` folder. Keep it that way.\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n\\n//# sourceMappingURL=core.js.map\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(75)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2Zlc201L2NvcmUuanM/MDljOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjcuMC40XG4gKiAoYykgMjAxMC0yMDE4IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3NwcmVhZCwgX19leHRlbmRzLCBfX3BhcmFtLCBfX3JlYWQsIF9fYXNzaWduLCBfX3ZhbHVlcyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHNoYXJlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5KG9ialdpdGhQcm9wZXJ0eVRvRXh0cmFjdCkge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmpXaXRoUHJvcGVydHlUb0V4dHJhY3QpIHtcbiAgICAgICAgaWYgKG9ialdpdGhQcm9wZXJ0eVRvRXh0cmFjdFtrZXldID09PSBnZXRDbG9zdXJlU2FmZVByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZmluZCByZW5hbWVkIHByb3BlcnR5IG9uIHRhcmdldCBvYmplY3QuJyk7XG59XG4vKipcbiAqIFNldHMgcHJvcGVydGllcyBvbiBhIHRhcmdldCBvYmplY3QgZnJvbSBhIHNvdXJjZSBvYmplY3QsIGJ1dCBvbmx5IGlmXG4gKiB0aGUgcHJvcGVydHkgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHRvIHNldCBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugb2YgdGhlIHByb3BlcnR5IGtleXMgYW5kIHZhbHVlcyB0byBzZXRcbiAqL1xuZnVuY3Rpb24gZmlsbFByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBOR19DT01QT05FTlRfREVGID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IG5nQ29tcG9uZW50RGVmOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xudmFyIE5HX0RJUkVDVElWRV9ERUYgPSBnZXRDbG9zdXJlU2FmZVByb3BlcnR5KHsgbmdEaXJlY3RpdmVEZWY6IGdldENsb3N1cmVTYWZlUHJvcGVydHkgfSk7XG52YXIgTkdfSU5KRUNUQUJMRV9ERUYgPSBnZXRDbG9zdXJlU2FmZVByb3BlcnR5KHsgbmdJbmplY3RhYmxlRGVmOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xudmFyIE5HX0lOSkVDVE9SX0RFRiA9IGdldENsb3N1cmVTYWZlUHJvcGVydHkoeyBuZ0luamVjdG9yRGVmOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xudmFyIE5HX1BJUEVfREVGID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IG5nUGlwZURlZjogZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSB9KTtcbnZhciBOR19NT0RVTEVfREVGID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IG5nTW9kdWxlRGVmOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xudmFyIE5HX0JBU0VfREVGID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IG5nQmFzZURlZjogZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSB9KTtcbi8qKlxuICogSWYgYSBkaXJlY3RpdmUgaXMgZGlQdWJsaWMsIGJsb29tQWRkIHNldHMgYSBwcm9wZXJ0eSBvbiB0aGUgdHlwZSB3aXRoIHRoaXMgY29uc3RhbnQgYXNcbiAqIHRoZSBrZXkgYW5kIHRoZSBkaXJlY3RpdmUncyB1bmlxdWUgSUQgYXMgdGhlIHZhbHVlLiBUaGlzIGFsbG93cyB1cyB0byBtYXAgZGlyZWN0aXZlcyB0byB0aGVpclxuICogYmxvb20gZmlsdGVyIGJpdCBmb3IgREkuXG4gKi9cbnZhciBOR19FTEVNRU5UX0lEID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IF9fTkdfRUxFTUVOVF9JRF9fOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENvbnN0cnVjdCBhbiBgSW5qZWN0YWJsZURlZmAgd2hpY2ggZGVmaW5lcyBob3cgYSB0b2tlbiB3aWxsIGJlIGNvbnN0cnVjdGVkIGJ5IHRoZSBESSBzeXN0ZW0sIGFuZFxuICogaW4gd2hpY2ggaW5qZWN0b3JzIChpZiBhbnkpIGl0IHdpbGwgYmUgYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIGEgc3RhdGljIGBuZ0luamVjdGFibGVEZWZgIGZpZWxkIG9uIGEgdHlwZSwgd2hpY2ggd2lsbCB0aGVuIGJlIGFuXG4gKiBgSW5qZWN0YWJsZVR5cGVgLlxuICpcbiAqIE9wdGlvbnM6XG4gKiAqIGBwcm92aWRlZEluYCBkZXRlcm1pbmVzIHdoaWNoIGluamVjdG9ycyB3aWxsIGluY2x1ZGUgdGhlIGluamVjdGFibGUsIGJ5IGVpdGhlciBhc3NvY2lhdGluZyBpdFxuICogICB3aXRoIGFuIGBATmdNb2R1bGVgIG9yIG90aGVyIGBJbmplY3RvclR5cGVgLCBvciBieSBzcGVjaWZ5aW5nIHRoYXQgdGhpcyBpbmplY3RhYmxlIHNob3VsZCBiZVxuICogICBwcm92aWRlZCBpbiB0aGUgYCdyb290J2AgaW5qZWN0b3IsIHdoaWNoIHdpbGwgYmUgdGhlIGFwcGxpY2F0aW9uLWxldmVsIGluamVjdG9yIGluIG1vc3QgYXBwcy5cbiAqICogYGZhY3RvcnlgIGdpdmVzIHRoZSB6ZXJvIGFyZ3VtZW50IGZ1bmN0aW9uIHdoaWNoIHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBpbmplY3RhYmxlLlxuICogICBUaGUgZmFjdG9yeSBjYW4gY2FsbCBgaW5qZWN0YCB0byBhY2Nlc3MgdGhlIGBJbmplY3RvcmAgYW5kIHJlcXVlc3QgaW5qZWN0aW9uIG9mIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUluamVjdGFibGUob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3ZpZGVkSW46IG9wdHMucHJvdmlkZWRJbiB8fCBudWxsLCBmYWN0b3J5OiBvcHRzLmZhY3RvcnksIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ29uc3RydWN0IGFuIGBJbmplY3RvckRlZmAgd2hpY2ggY29uZmlndXJlcyBhbiBpbmplY3Rvci5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBhc3NpZ25lZCB0byBhIHN0YXRpYyBgbmdJbmplY3RvckRlZmAgZmllbGQgb24gYSB0eXBlLCB3aGljaCB3aWxsIHRoZW4gYmUgYW5cbiAqIGBJbmplY3RvclR5cGVgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogKiBgZmFjdG9yeWA6IGFuIGBJbmplY3RvclR5cGVgIGlzIGFuIGluc3RhbnRpYWJsZSB0eXBlLCBzbyBhIHplcm8gYXJndW1lbnQgYGZhY3RvcnlgIGZ1bmN0aW9uIHRvXG4gKiAgIGNyZWF0ZSB0aGUgdHlwZSBtdXN0IGJlIHByb3ZpZGVkLiBJZiB0aGF0IGZhY3RvcnkgZnVuY3Rpb24gbmVlZHMgdG8gaW5qZWN0IGFyZ3VtZW50cywgaXQgY2FuXG4gKiAgIHVzZSB0aGUgYGluamVjdGAgZnVuY3Rpb24uXG4gKiAqIGBwcm92aWRlcnNgOiBhbiBvcHRpb25hbCBhcnJheSBvZiBwcm92aWRlcnMgdG8gYWRkIHRvIHRoZSBpbmplY3Rvci4gRWFjaCBwcm92aWRlciBtdXN0XG4gKiAgIGVpdGhlciBoYXZlIGEgZmFjdG9yeSBvciBwb2ludCB0byBhIHR5cGUgd2hpY2ggaGFzIGFuIGBuZ0luamVjdGFibGVEZWZgIHN0YXRpYyBwcm9wZXJ0eSAodGhlXG4gKiAgIHR5cGUgbXVzdCBiZSBhbiBgSW5qZWN0YWJsZVR5cGVgKS5cbiAqICogYGltcG9ydHNgOiBhbiBvcHRpb25hbCBhcnJheSBvZiBpbXBvcnRzIG9mIG90aGVyIGBJbmplY3RvclR5cGVgcyBvciBgSW5qZWN0b3JUeXBlV2l0aE1vZHVsZWBzXG4gKiAgIHdob3NlIHByb3ZpZGVycyB3aWxsIGFsc28gYmUgYWRkZWQgdG8gdGhlIGluamVjdG9yLiBMb2NhbGx5IHByb3ZpZGVkIHR5cGVzIHdpbGwgb3ZlcnJpZGVcbiAqICAgcHJvdmlkZXJzIGZyb20gaW1wb3J0cy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUluamVjdG9yKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmYWN0b3J5OiBvcHRpb25zLmZhY3RvcnksIHByb3ZpZGVyczogb3B0aW9ucy5wcm92aWRlcnMgfHwgW10sIGltcG9ydHM6IG9wdGlvbnMuaW1wb3J0cyB8fCBbXSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZWFkIHRoZSBgbmdJbmplY3RhYmxlRGVmYCB0eXBlIGluIGEgd2F5IHdoaWNoIGlzIGltbXVuZSB0byBhY2NpZGVudGFsbHkgcmVhZGluZyBpbmhlcml0ZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHR5cGUgdHlwZSB3aGljaCBtYXkgaGF2ZSBgbmdJbmplY3RhYmxlRGVmYFxuICovXG5mdW5jdGlvbiBnZXRJbmplY3RhYmxlRGVmKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5oYXNPd25Qcm9wZXJ0eShOR19JTkpFQ1RBQkxFX0RFRikgPyB0eXBlW05HX0lOSkVDVEFCTEVfREVGXSA6IG51bGw7XG59XG4vKipcbiAqIFJlYWQgdGhlIGBuZ0luamVjdG9yRGVmYCB0eXBlIGluIGEgd2F5IHdoaWNoIGlzIGltbXVuZSB0byBhY2NpZGVudGFsbHkgcmVhZGluZyBpbmhlcml0ZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHR5cGUgdHlwZSB3aGljaCBtYXkgaGF2ZSBgbmdJbmplY3RvckRlZmBcbiAqL1xuZnVuY3Rpb24gZ2V0SW5qZWN0b3JEZWYodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmhhc093blByb3BlcnR5KE5HX0lOSkVDVE9SX0RFRikgPyB0eXBlW05HX0lOSkVDVE9SX0RFRl0gOiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZXMgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgREkgUHJvdmlkZXIuXG4gKlxuICogVXNlIGFuIGBJbmplY3Rpb25Ub2tlbmAgd2hlbmV2ZXIgdGhlIHR5cGUgeW91IGFyZSBpbmplY3RpbmcgaXMgbm90IHJlaWZpZWQgKGRvZXMgbm90IGhhdmUgYVxuICogcnVudGltZSByZXByZXNlbnRhdGlvbikgc3VjaCBhcyB3aGVuIGluamVjdGluZyBhbiBpbnRlcmZhY2UsIGNhbGxhYmxlIHR5cGUsIGFycmF5IG9yXG4gKiBwYXJhbWV0cml6ZWQgdHlwZS5cbiAqXG4gKiBgSW5qZWN0aW9uVG9rZW5gIGlzIHBhcmFtZXRlcml6ZWQgb24gYFRgIHdoaWNoIGlzIHRoZSB0eXBlIG9mIG9iamVjdCB3aGljaCB3aWxsIGJlIHJldHVybmVkIGJ5XG4gKiB0aGUgYEluamVjdG9yYC4gVGhpcyBwcm92aWRlcyBhZGRpdGlvbmFsIGxldmVsIG9mIHR5cGUgc2FmZXR5LlxuICpcbiAqIGBgYFxuICogaW50ZXJmYWNlIE15SW50ZXJmYWNlIHsuLi59XG4gKiB2YXIgbXlJbnRlcmZhY2UgPSBpbmplY3Rvci5nZXQobmV3IEluamVjdGlvblRva2VuPE15SW50ZXJmYWNlPignU29tZVRva2VuJykpO1xuICogLy8gbXlJbnRlcmZhY2UgaXMgaW5mZXJyZWQgdG8gYmUgTXlJbnRlcmZhY2UuXG4gKiBgYGBcbiAqXG4gKiBXaGVuIGNyZWF0aW5nIGFuIGBJbmplY3Rpb25Ub2tlbmAsIHlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IGEgZmFjdG9yeSBmdW5jdGlvbiB3aGljaCByZXR1cm5zXG4gKiAocG9zc2libHkgYnkgY3JlYXRpbmcpIGEgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyaXplZCB0eXBlIGBUYC4gVGhpcyBzZXRzIHVwIHRoZVxuICogYEluamVjdGlvblRva2VuYCB1c2luZyB0aGlzIGZhY3RvcnkgYXMgYSBwcm92aWRlciBhcyBpZiBpdCB3YXMgZGVmaW5lZCBleHBsaWNpdGx5IGluIHRoZVxuICogYXBwbGljYXRpb24ncyByb290IGluamVjdG9yLiBJZiB0aGUgZmFjdG9yeSBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgemVybyBhcmd1bWVudHMsIG5lZWRzIHRvIGluamVjdFxuICogZGVwZW5kZW5jaWVzLCBpdCBjYW4gZG8gc28gdXNpbmcgdGhlIGBpbmplY3RgIGZ1bmN0aW9uLiBTZWUgYmVsb3cgZm9yIGFuIGV4YW1wbGUuXG4gKlxuICogQWRkaXRpb25hbGx5LCBpZiBhIGBmYWN0b3J5YCBpcyBzcGVjaWZpZWQgeW91IGNhbiBhbHNvIHNwZWNpZnkgdGhlIGBwcm92aWRlZEluYCBvcHRpb24sIHdoaWNoXG4gKiBvdmVycmlkZXMgdGhlIGFib3ZlIGJlaGF2aW9yIGFuZCBtYXJrcyB0aGUgdG9rZW4gYXMgYmVsb25naW5nIHRvIGEgcGFydGljdWxhciBgQE5nTW9kdWxlYC4gQXNcbiAqIG1lbnRpb25lZCBhYm92ZSwgYCdyb290J2AgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGBwcm92aWRlZEluYC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEJhc2ljIEV4YW1wbGVcbiAqXG4gKiAjIyMgUGxhaW4gSW5qZWN0aW9uVG9rZW5cbiAqXG4gKiB7QGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0nSW5qZWN0aW9uVG9rZW4nfVxuICpcbiAqICMjIyBUcmVlLXNoYWthYmxlIEluamVjdGlvblRva2VuXG4gKlxuICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J1NoYWthYmxlSW5qZWN0aW9uVG9rZW4nfVxuICpcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBJbmplY3Rpb25Ub2tlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3Rpb25Ub2tlbihfZGVzYywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9kZXNjID0gX2Rlc2M7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5uZ01ldGFkYXRhTmFtZSA9ICdJbmplY3Rpb25Ub2tlbic7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbjogb3B0aW9ucy5wcm92aWRlZEluIHx8ICdyb290JyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5OiBvcHRpb25zLmZhY3RvcnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmdJbmplY3RhYmxlRGVmID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIEluamVjdGlvblRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiSW5qZWN0aW9uVG9rZW4gXCIgKyB0aGlzLl9kZXNjOyB9O1xuICAgIHJldHVybiBJbmplY3Rpb25Ub2tlbjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBTk5PVEFUSU9OUyA9ICdfX2Fubm90YXRpb25zX18nO1xudmFyIFBBUkFNRVRFUlMgPSAnX19wYXJhbWV0ZXJzX18nO1xudmFyIFBST1BfTUVUQURBVEEgPSAnX19wcm9wX19tZXRhZGF0YV9fJztcbi8qKlxuICogQHN1cHByZXNzIHtnbG9iYWxUaGlzfVxuICovXG5mdW5jdGlvbiBtYWtlRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcywgYWRkaXRpb25hbFByb2Nlc3NpbmcsIHR5cGVGbikge1xuICAgIHZhciBtZXRhQ3RvciA9IG1ha2VNZXRhZGF0YUN0b3IocHJvcHMpO1xuICAgIGZ1bmN0aW9uIERlY29yYXRvckZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgIG1ldGFDdG9yLmNhbGwuYXBwbHkobWV0YUN0b3IsIF9fc3ByZWFkKFt0aGlzXSwgYXJncykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb25JbnN0YW5jZSA9IG5ldyAoKF9hID0gRGVjb3JhdG9yRmFjdG9yeSkuYmluZC5hcHBseShfYSwgX19zcHJlYWQoW3ZvaWQgMF0sIGFyZ3MpKSkoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIFR5cGVEZWNvcmF0b3IoY2xzKSB7XG4gICAgICAgICAgICBpZiAodHlwZUZuKVxuICAgICAgICAgICAgICAgIHR5cGVGbi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFtjbHNdLCBhcmdzKSk7XG4gICAgICAgICAgICAvLyBVc2Ugb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIGltcG9ydGFudCBzaW5jZSBpdCBjcmVhdGVzIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHdoaWNoXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyB0aGUgcHJvcGVydHkgaXMgY29waWVkIGR1cmluZyBzdWJjbGFzc2luZy5cbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGNscy5oYXNPd25Qcm9wZXJ0eShBTk5PVEFUSU9OUykgP1xuICAgICAgICAgICAgICAgIGNsc1tBTk5PVEFUSU9OU10gOlxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbHMsIEFOTk9UQVRJT05TLCB7IHZhbHVlOiBbXSB9KVtBTk5PVEFUSU9OU107XG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb2Nlc3NpbmcpXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb2Nlc3NpbmcoY2xzKTtcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUubmdNZXRhZGF0YU5hbWUgPSBuYW1lO1xuICAgIERlY29yYXRvckZhY3RvcnkuYW5ub3RhdGlvbkNscyA9IERlY29yYXRvckZhY3Rvcnk7XG4gICAgcmV0dXJuIERlY29yYXRvckZhY3Rvcnk7XG59XG5mdW5jdGlvbiBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGN0b3IoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gcHJvcHMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IHZhbHVlc1twcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbWFrZVBhcmFtRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgIHZhciBtZXRhQ3RvciA9IG1ha2VNZXRhZGF0YUN0b3IocHJvcHMpO1xuICAgIGZ1bmN0aW9uIFBhcmFtRGVjb3JhdG9yRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSB7XG4gICAgICAgICAgICBtZXRhQ3Rvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uSW5zdGFuY2UgPSBuZXcgKChfYSA9IFBhcmFtRGVjb3JhdG9yRmFjdG9yeSkuYmluZC5hcHBseShfYSwgX19zcHJlYWQoW3ZvaWQgMF0sIGFyZ3MpKSkoKTtcbiAgICAgICAgUGFyYW1EZWNvcmF0b3IuYW5ub3RhdGlvbiA9IGFubm90YXRpb25JbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xuICAgICAgICBmdW5jdGlvbiBQYXJhbURlY29yYXRvcihjbHMsIHVudXNlZEtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFVzZSBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgaW1wb3J0YW50IHNpbmNlIGl0IGNyZWF0ZXMgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgd2hpY2hcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIHRoZSBwcm9wZXJ0eSBpcyBjb3BpZWQgZHVyaW5nIHN1YmNsYXNzaW5nLlxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBjbHMuaGFzT3duUHJvcGVydHkoUEFSQU1FVEVSUykgP1xuICAgICAgICAgICAgICAgIGNsc1tQQVJBTUVURVJTXSA6XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNscywgUEFSQU1FVEVSUywgeyB2YWx1ZTogW10gfSlbUEFSQU1FVEVSU107XG4gICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBnYXBzIGlmIHNvbWUgaW4gYmV0d2VlbiBwYXJhbWV0ZXJzIGRvIG5vdCBoYXZlIGFubm90YXRpb25zLlxuICAgICAgICAgICAgLy8gd2UgcGFkIHdpdGggbnVsbHMuXG4gICAgICAgICAgICB3aGlsZSAocGFyYW1ldGVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAocGFyYW1ldGVyc1tpbmRleF0gPSBwYXJhbWV0ZXJzW2luZGV4XSB8fCBbXSkucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50Q2xhc3MpIHtcbiAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS5uZ01ldGFkYXRhTmFtZSA9IG5hbWU7XG4gICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG4gICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIG1ha2VQcm9wRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcywgYWRkaXRpb25hbFByb2Nlc3NpbmcpIHtcbiAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUHJvcERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgIG1ldGFDdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY29yYXRvckluc3RhbmNlID0gbmV3ICgoX2EgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeSkuYmluZC5hcHBseShfYSwgX19zcHJlYWQoW3ZvaWQgMF0sIGFyZ3MpKSkoKTtcbiAgICAgICAgZnVuY3Rpb24gUHJvcERlY29yYXRvcih0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgaXMgaW1wb3J0YW50IHNpbmNlIGl0IGNyZWF0ZXMgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgd2hpY2hcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIHRoZSBwcm9wZXJ0eSBpcyBjb3BpZWQgZHVyaW5nIHN1YmNsYXNzaW5nLlxuICAgICAgICAgICAgdmFyIG1ldGEgPSBjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShQUk9QX01FVEFEQVRBKSA/XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3JbUFJPUF9NRVRBREFUQV0gOlxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgUFJPUF9NRVRBREFUQSwgeyB2YWx1ZToge30gfSlbUFJPUF9NRVRBREFUQV07XG4gICAgICAgICAgICBtZXRhW25hbWVdID0gbWV0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBtZXRhW25hbWVdIHx8IFtdO1xuICAgICAgICAgICAgbWV0YVtuYW1lXS51bnNoaWZ0KGRlY29yYXRvckluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsUHJvY2Vzc2luZylcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJvY2Vzc2luZy5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFt0YXJnZXQsIG5hbWVdLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb3BEZWNvcmF0b3I7XG4gICAgfVxuICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudENsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS5uZ01ldGFkYXRhTmFtZSA9IG5hbWU7XG4gICAgUHJvcERlY29yYXRvckZhY3RvcnkuYW5ub3RhdGlvbkNscyA9IFByb3BEZWNvcmF0b3JGYWN0b3J5O1xuICAgIHJldHVybiBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIHRva2VuIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHZpcnR1YWwgcHJvdmlkZXIgdGhhdCB3aWxsIHBvcHVsYXRlIHRoZVxuICogYGVudHJ5Q29tcG9uZW50c2AgZmllbGRzIG9mIGNvbXBvbmVudHMgYW5kIG5nIG1vZHVsZXMgYmFzZWQgb24gaXRzIGB1c2VWYWx1ZWAuXG4gKiBBbGwgY29tcG9uZW50cyB0aGF0IGFyZSByZWZlcmVuY2VkIGluIHRoZSBgdXNlVmFsdWVgIHZhbHVlIChlaXRoZXIgZGlyZWN0bHlcbiAqIG9yIGluIGEgbmVzdGVkIGFycmF5IG9yIG1hcCkgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRoZSByb3V0ZXIgY2FuIHBvcHVsYXRlIHRoZSBgZW50cnlDb21wb25lbnRzYFxuICogZmllbGQgb2YgYW4gTmdNb2R1bGUgYmFzZWQgb24gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uIHdoaWNoIHJlZmVyc1xuICogdG8gY29tcG9uZW50cy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBoZWxwZXIgZnVuY3Rpb24gaW5zaWRlIHRoZSByb3V0ZXJcbiAqIGZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXMocm91dGVzKSB7XG4gKiAgIHJldHVybiBbXG4gKiAgICAge3Byb3ZpZGU6IFJPVVRFUywgdXNlVmFsdWU6IHJvdXRlc30sXG4gKiAgICAge3Byb3ZpZGU6IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIHVzZVZhbHVlOiByb3V0ZXMsIG11bHRpOiB0cnVlfVxuICogICBdO1xuICogfVxuICpcbiAqIC8vIHVzZXIgY29kZVxuICogbGV0IHJvdXRlcyA9IFtcbiAqICAge3BhdGg6ICcvcm9vdCcsIGNvbXBvbmVudDogUm9vdENvbXB9LFxuICogICB7cGF0aDogJy90ZWFtcycsIGNvbXBvbmVudDogVGVhbXNDb21wfVxuICogXTtcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBwcm92aWRlcnM6IFtwcm92aWRlUm91dGVzKHJvdXRlcyldXG4gKiB9KVxuICogY2xhc3MgTW9kdWxlV2l0aFJvdXRlcyB7fVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignQW5hbHl6ZUZvckVudHJ5Q29tcG9uZW50cycpO1xuLyoqXG4gKiBBdHRyaWJ1dGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQXR0cmlidXRlID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdBdHRyaWJ1dGUnLCBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkgeyByZXR1cm4gKHsgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlTmFtZSB9KTsgfSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHF1ZXJ5IG1ldGFkYXRhLlxuICpcbiAqIEBzZWUgYENvbnRlbnRDaGlsZHJlbmAuXG4gKiBAc2VlIGBDb250ZW50Q2hpbGRgLlxuICogQHNlZSBgVmlld0NoaWxkcmVuYC5cbiAqIEBzZWUgYFZpZXdDaGlsZGAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUXVlcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBRdWVyeTtcbn0oKSk7XG4vKipcbiAqIENvbnRlbnRDaGlsZHJlbiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICpcbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQ29udGVudENoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ0NvbnRlbnRDaGlsZHJlbicsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgcmV0dXJuIChfX2Fzc2lnbih7IHNlbGVjdG9yOiBzZWxlY3RvciwgZmlyc3Q6IGZhbHNlLCBpc1ZpZXdRdWVyeTogZmFsc2UsIGRlc2NlbmRhbnRzOiBmYWxzZSB9LCBkYXRhKSk7XG59LCBRdWVyeSk7XG4vKipcbiAqIENvbnRlbnRDaGlsZCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICpcbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQ29udGVudENoaWxkID0gbWFrZVByb3BEZWNvcmF0b3IoJ0NvbnRlbnRDaGlsZCcsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgcmV0dXJuIChfX2Fzc2lnbih7IHNlbGVjdG9yOiBzZWxlY3RvciwgZmlyc3Q6IHRydWUsIGlzVmlld1F1ZXJ5OiBmYWxzZSwgZGVzY2VuZGFudHM6IHRydWUgfSwgZGF0YSkpO1xufSwgUXVlcnkpO1xuLyoqXG4gKiBWaWV3Q2hpbGRyZW4gZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmlld0NoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZHJlbicsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgcmV0dXJuIChfX2Fzc2lnbih7IHNlbGVjdG9yOiBzZWxlY3RvciwgZmlyc3Q6IGZhbHNlLCBpc1ZpZXdRdWVyeTogdHJ1ZSwgZGVzY2VuZGFudHM6IHRydWUgfSwgZGF0YSkpO1xufSwgUXVlcnkpO1xuLyoqXG4gKiBWaWV3Q2hpbGQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmlld0NoaWxkID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZCcsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIHJldHVybiAoX19hc3NpZ24oeyBzZWxlY3Rvcjogc2VsZWN0b3IsIGZpcnN0OiB0cnVlLCBpc1ZpZXdRdWVyeTogdHJ1ZSwgZGVzY2VuZGFudHM6IHRydWUgfSwgZGF0YSkpO1xufSwgUXVlcnkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoZSBzdHJhdGVneSB0aGF0IHRoZSBkZWZhdWx0IGNoYW5nZSBkZXRlY3RvciB1c2VzIHRvIGRldGVjdCBjaGFuZ2VzLlxuICogV2hlbiBzZXQsIHRha2VzIGVmZmVjdCB0aGUgbmV4dCB0aW1lIGNoYW5nZSBkZXRlY3Rpb24gaXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgYENoZWNrT25jZWAgc3RyYXRlZ3ksIG1lYW5pbmcgdGhhdCBhdXRvbWF0aWMgY2hhbmdlIGRldGVjdGlvbiBpcyBkZWFjdGl2YXRlZFxuICAgICAqIHVudGlsIHJlYWN0aXZhdGVkIGJ5IHNldHRpbmcgdGhlIHN0cmF0ZWd5IHRvIGBEZWZhdWx0YCAoYENoZWNrQWx3YXlzYCkuXG4gICAgICogQ2hhbmdlIGRldGVjdGlvbiBjYW4gc3RpbGwgYmUgZXhwbGljdGx5IGludm9rZWQuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJPblB1c2hcIl0gPSAwXSA9IFwiT25QdXNoXCI7XG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBkZWZhdWx0IGBDaGVja0Fsd2F5c2Agc3RyYXRlZ3ksIGluIHdoaWNoIGNoYW5nZSBkZXRlY3Rpb24gaXMgYXV0b21hdGljIHVudGlsXG4gICAgICogZXhwbGljaXRseSBkZWFjdGl2YXRlZC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRlZmF1bHRcIl0gPSAxXSA9IFwiRGVmYXVsdFwiO1xufSkoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfHwgKENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB0aGUgcG9zc2libGUgc3RhdGVzIG9mIHRoZSBkZWZhdWx0IGNoYW5nZSBkZXRlY3Rvci5cbiAqIEBzZWUgYENoYW5nZURldGVjdG9yUmVmYFxuICovXG52YXIgQ2hhbmdlRGV0ZWN0b3JTdGF0dXM7XG4oZnVuY3Rpb24gKENoYW5nZURldGVjdG9yU3RhdHVzKSB7XG4gICAgLyoqXG4gICAgICogQSBzdGF0ZSBpbiB3aGljaCwgYWZ0ZXIgY2FsbGluZyBgZGV0ZWN0Q2hhbmdlcygpYCwgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAqIHN0YXRlIGJlY29tZXMgYENoZWNrZWRgLCBhbmQgbXVzdCBiZSBleHBsaWNpdGx5IGludm9rZWQgb3IgcmVhY3RpdmF0ZWQuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJDaGVja09uY2VcIl0gPSAwXSA9IFwiQ2hlY2tPbmNlXCI7XG4gICAgLyoqXG4gICAgICogQSBzdGF0ZSBpbiB3aGljaCBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHNraXBwZWQgdW50aWwgdGhlIGNoYW5nZSBkZXRlY3RvciBtb2RlXG4gICAgICogYmVjb21lcyBgQ2hlY2tPbmNlYC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGUgaW4gd2hpY2ggY2hhbmdlIGRldGVjdGlvbiBjb250aW51ZXMgYXV0b21hdGljYWxseSB1bnRpbCBleHBsaWN0bHlcbiAgICAgKiBkZWFjdGl2YXRlZC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrQWx3YXlzXCJdID0gMl0gPSBcIkNoZWNrQWx3YXlzXCI7XG4gICAgLyoqXG4gICAgICogQSBzdGF0ZSBpbiB3aGljaCBhIGNoYW5nZSBkZXRlY3RvciBzdWIgdHJlZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBtYWluIHRyZWUgYW5kXG4gICAgICogc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJEZXRhY2hlZFwiXSA9IDNdID0gXCJEZXRhY2hlZFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IgZW5jb3VudGVyZWQgYW4gZXJyb3IgY2hlY2tpbmcgYSBiaW5kaW5nXG4gICAgICogb3IgY2FsbGluZyBhIGRpcmVjdGl2ZSBsaWZlY3ljbGUgbWV0aG9kIGFuZCBpcyBub3cgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBDaGFuZ2VcbiAgICAgKiBkZXRlY3RvcnMgaW4gdGhpcyBzdGF0ZSBkbyBub3QgZGV0ZWN0IGNoYW5nZXMuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJFcnJvcmVkXCJdID0gNF0gPSBcIkVycm9yZWRcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkRlc3Ryb3llZFwiXSA9IDVdID0gXCJEZXN0cm95ZWRcIjtcbn0pKENoYW5nZURldGVjdG9yU3RhdHVzIHx8IChDaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBhIGdpdmVuIHN0cmF0ZWd5IGlzIGN1cnJlbnRseSB0aGUgZGVmYXVsdCBmb3IgY2hhbmdlIGRldGVjdGlvbi5cbiAqIEBwYXJhbSBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSBUaGUgc3RyYXRlZ3kgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBnaXZlbiBzdHJhdGVneSBpcyB0aGUgY3VycmVudCBkZWZhdWx0LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAc2VlIGBDaGFuZ2VEZXRlY3RvclN0YXR1c2BcbiAqIEBzZWUgYENoYW5nZURldGVjdG9yUmVmYFxuICovXG5mdW5jdGlvbiBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneShjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIHJldHVybiBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9PSBudWxsIHx8XG4gICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID09PSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX193aW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG52YXIgX19zZWxmID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiYgc2VsZjtcbnZhciBfX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbDtcbi8vIENoZWNrIF9fZ2xvYmFsIGZpcnN0LCBiZWNhdXNlIGluIE5vZGUgdGVzdHMgYm90aCBfX2dsb2JhbCBhbmQgX193aW5kb3cgbWF5IGJlIGRlZmluZWQgYW5kIF9nbG9iYWxcbi8vIHNob3VsZCBiZSBfX2dsb2JhbCBpbiB0aGF0IGNhc2UuXG52YXIgX2dsb2JhbCA9IF9fZ2xvYmFsIHx8IF9fd2luZG93IHx8IF9fc2VsZjtcbnZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDApO1xudmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICBpZiAoIV9zeW1ib2xJdGVyYXRvcikge1xuICAgICAgICB2YXIgU3ltYm9sXzEgPSBfZ2xvYmFsWydTeW1ib2wnXTtcbiAgICAgICAgaWYgKFN5bWJvbF8xICYmIFN5bWJvbF8xLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2xfMS5pdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzNi1zaGltIHNwZWNpZmljIGxvZ2ljXG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmXG4gICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBab25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyB1c2UgcHJvbWlzZSB0byBzY2hlZHVsZSBtaWNyb1Rhc2sgaW5zdGVhZCBvZiB1c2UgWm9uZVxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyBmbiAmJiBmbi5hcHBseShudWxsLCBudWxsKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBab25lLmN1cnJlbnQuc2NoZWR1bGVNaWNyb1Rhc2soJ3NjaGVkdWxlTWljcm90YXNrJywgZm4pO1xuICAgIH1cbn1cbi8vIEpTIGhhcyBOYU4gIT09IE5hTlxuZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0b2tlbi5tYXAoc3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgfVxuICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdG9rZW4ubmFtZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHJlcztcbiAgICB9XG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbn1cbi8qKlxuICogQ29udmluY2UgY2xvc3VyZSBjb21waWxlciB0aGF0IHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGhhcyBubyBzaWRlLWVmZmVjdHMuXG4gKlxuICogQ2xvc3VyZSBjb21waWxlciBhbHdheXMgYXNzdW1lcyB0aGF0IGB0b1N0cmluZ2AgaGFzIG5vIHNpZGUtZWZmZWN0cy4gV2UgdXNlIHRoaXMgcXVpcmsgdG9cbiAqIGFsbG93IHVzIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBidXQgaGF2ZSBjbG9zdXJlIGNvbXBpbGVyIG1hcmsgdGhlIGNhbGwgYXMgbm8tc2lkZS1lZmZlY3RzLlxuICogSXQgaXMgaW1wb3J0YW50IHRoYXQgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIGBub1NpZGVFZmZlY3RzYCBmdW5jdGlvbiBiZSBhc3NpZ25lZFxuICogdG8gc29tZXRoaW5nIHdoaWNoIGlzIHJldGFpbmVkIG90aGVyd2lzZSB0aGUgY2FsbCB0byBgbm9TaWRlRWZmZWN0c2Agd2lsbCBiZSByZW1vdmVkIGJ5IGNsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICovXG5mdW5jdGlvbiBub1NpZGVFZmZlY3RzKGZuKSB7XG4gICAgcmV0dXJuICcnICsgeyB0b1N0cmluZzogZm4gfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbGxvd3MgdG8gcmVmZXIgdG8gcmVmZXJlbmNlcyB3aGljaCBhcmUgbm90IHlldCBkZWZpbmVkLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgYGZvcndhcmRSZWZgIGlzIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSBuZWVkIHRvIHJlZmVyIHRvIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAqIERJIGlzIGRlY2xhcmVkLCBidXQgbm90IHlldCBkZWZpbmVkLiBJdCBpcyBhbHNvIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSB1c2Ugd2hlbiBjcmVhdGluZ1xuICogYSBxdWVyeSBpcyBub3QgeWV0IGRlZmluZWQuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKiB7QGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZl9zcGVjLnRzIHJlZ2lvbj0nZm9yd2FyZF9yZWYnfVxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBmb3J3YXJkUmVmKGZvcndhcmRSZWZGbikge1xuICAgIGZvcndhcmRSZWZGbi5fX2ZvcndhcmRfcmVmX18gPSBmb3J3YXJkUmVmO1xuICAgIGZvcndhcmRSZWZGbi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeSh0aGlzKCkpOyB9O1xuICAgIHJldHVybiBmb3J3YXJkUmVmRm47XG59XG4vKipcbiAqIExhemlseSByZXRyaWV2ZXMgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGEgZm9yd2FyZFJlZi5cbiAqXG4gKiBBY3RzIGFzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiB3aGVuIGdpdmVuIGEgbm9uLWZvcndhcmQtcmVmIHZhbHVlLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2ZvcndhcmRfcmVmL2ZvcndhcmRfcmVmX3NwZWMudHMgcmVnaW9uPSdyZXNvbHZlX2ZvcndhcmRfcmVmJ31cbiAqXG4gKiBAc2VlIGBmb3J3YXJkUmVmYFxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGUuaGFzT3duUHJvcGVydHkoJ19fZm9yd2FyZF9yZWZfXycpICYmXG4gICAgICAgIHR5cGUuX19mb3J3YXJkX3JlZl9fID09PSBmb3J3YXJkUmVmKSB7XG4gICAgICAgIHJldHVybiB0eXBlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogSW5qZWN0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gKlxuICogQEFubm90YXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEluamVjdCA9IG1ha2VQYXJhbURlY29yYXRvcignSW5qZWN0JywgZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiAoeyB0b2tlbjogdG9rZW4gfSk7IH0pO1xuLyoqXG4gKiBPcHRpb25hbCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICpcbiAqIEBBbm5vdGF0aW9uXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBPcHRpb25hbCA9IG1ha2VQYXJhbURlY29yYXRvcignT3B0aW9uYWwnKTtcbi8qKlxuICogU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICpcbiAqIEBBbm5vdGF0aW9uXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBTZWxmID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdTZWxmJyk7XG4vKipcbiAqIFNraXBTZWxmIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gKlxuICogQEFubm90YXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFNraXBTZWxmID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdTa2lwU2VsZicpO1xuLyoqXG4gKiBIb3N0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gKlxuICogQEFubm90YXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEhvc3QgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0hvc3QnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFNPVVJDRSA9ICdfX3NvdXJjZSc7XG52YXIgX1RIUk9XX0lGX05PVF9GT1VORCA9IG5ldyBPYmplY3QoKTtcbnZhciBUSFJPV19JRl9OT1RfRk9VTkQgPSBfVEhST1dfSUZfTk9UX0ZPVU5EO1xuLyoqXG4gKiBBbiBJbmplY3Rpb25Ub2tlbiB0aGF0IGdldHMgdGhlIGN1cnJlbnQgYEluamVjdG9yYCBmb3IgYGNyZWF0ZUluamVjdG9yKClgLXN0eWxlIGluamVjdG9ycy5cbiAqXG4gKiBSZXF1ZXN0aW5nIHRoaXMgdG9rZW4gaW5zdGVhZCBvZiBgSW5qZWN0b3JgIGFsbG93cyBgU3RhdGljSW5qZWN0b3JgIHRvIGJlIHRyZWUtc2hha2VuIGZyb20gYVxuICogcHJvamVjdC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBJTkpFQ1RPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignSU5KRUNUT1InKTtcbnZhciBOdWxsSW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVsbEluamVjdG9yKCkge1xuICAgIH1cbiAgICBOdWxsSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBfVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSBfVEhST1dfSUZfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGxlZnQgYmVoaW5kOiBXaXRoIGRldiB0b29scyBvcGVuIHRoZSBkZWJ1Z2dlciB3aWxsIHN0b3AgaGVyZS4gVGhlcmUgaXMgbm9cbiAgICAgICAgICAgIC8vIHJlYXNvbiB3aHkgY29ycmVjdGx5IHdyaXR0ZW4gYXBwbGljYXRpb24gc2hvdWxkIGNhdXNlIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETyhtaXNrbyk6IHVuY29tbWVudCB0aGUgbmV4dCBsaW5lIG9uY2UgYG5nRGV2TW9kZWAgd29ya3Mgd2l0aCBjbG9zdXJlLlxuICAgICAgICAgICAgLy8gaWYobmdEZXZNb2RlKSBkZWJ1Z2dlcjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bGxJbmplY3RvckVycm9yOiBObyBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pICsgXCIhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RGb3VuZFZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxJbmplY3Rvcjtcbn0oKSk7XG4vKipcbiAqIENvbmNyZXRlIGluamVjdG9ycyBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBbXCJEZXBlbmRlbmN5IEluamVjdGlvbiBHdWlkZVwiXShndWlkZS9kZXBlbmRlbmN5LWluamVjdGlvbikuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J0luamVjdG9yJ31cbiAqXG4gKiBgSW5qZWN0b3JgIHJldHVybnMgaXRzZWxmIHdoZW4gZ2l2ZW4gYEluamVjdG9yYCBhcyBhIHRva2VuOlxuICpcbiAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2luamVjdG9yX3NwZWMudHMgcmVnaW9uPSdpbmplY3RJbmplY3Rvcid9XG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbmplY3RvciB3aGljaCBpcyBjb25maWd1cmUgdXNpbmcgYFN0YXRpY1Byb3ZpZGVyYHMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9wcm92aWRlcl9zcGVjLnRzIHJlZ2lvbj0nQ29uc3RydWN0b3JQcm92aWRlcid9XG4gICAgICovXG4gICAgSW5qZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0aWNJbmplY3RvcihvcHRpb25zLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0aWNJbmplY3RvcihvcHRpb25zLnByb3ZpZGVycywgb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EID0gX1RIUk9XX0lGX05PVF9GT1VORDtcbiAgICBJbmplY3Rvci5OVUxMID0gbmV3IE51bGxJbmplY3RvcigpO1xuICAgIEluamVjdG9yLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoe1xuICAgICAgICBwcm92aWRlZEluOiAnYW55JyxcbiAgICAgICAgZmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5qZWN0KElOSkVDVE9SKTsgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gSW5qZWN0b3I7XG59KCkpO1xudmFyIElERU5UID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBFTVBUWSA9IFtdO1xudmFyIENJUkNVTEFSID0gSURFTlQ7XG52YXIgTVVMVElfUFJPVklERVJfRk4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG59O1xudmFyIFVTRV9WQUxVRSA9IGdldENsb3N1cmVTYWZlUHJvcGVydHkoeyBwcm92aWRlOiBTdHJpbmcsIHVzZVZhbHVlOiBnZXRDbG9zdXJlU2FmZVByb3BlcnR5IH0pO1xudmFyIE5HX1RPS0VOX1BBVEggPSAnbmdUb2tlblBhdGgnO1xudmFyIE5HX1RFTVBfVE9LRU5fUEFUSCA9ICduZ1RlbXBUb2tlblBhdGgnO1xudmFyIE5VTExfSU5KRUNUT1IgPSBJbmplY3Rvci5OVUxMO1xudmFyIE5FV19MSU5FID0gL1xcbi9nbTtcbnZhciBOT19ORVdfTElORSA9ICfJtSc7XG52YXIgU3RhdGljSW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljSW5qZWN0b3IocHJvdmlkZXJzLCBwYXJlbnQsIHNvdXJjZSkge1xuICAgICAgICBpZiAocGFyZW50ID09PSB2b2lkIDApIHsgcGFyZW50ID0gTlVMTF9JTkpFQ1RPUjsgfVxuICAgICAgICBpZiAoc291cmNlID09PSB2b2lkIDApIHsgc291cmNlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHZhciByZWNvcmRzID0gdGhpcy5fcmVjb3JkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmVjb3Jkcy5zZXQoSW5qZWN0b3IsIHsgdG9rZW46IEluamVjdG9yLCBmbjogSURFTlQsIGRlcHM6IEVNUFRZLCB2YWx1ZTogdGhpcywgdXNlTmV3OiBmYWxzZSB9KTtcbiAgICAgICAgcmVjb3Jkcy5zZXQoSU5KRUNUT1IsIHsgdG9rZW46IElOSkVDVE9SLCBmbjogSURFTlQsIGRlcHM6IEVNUFRZLCB2YWx1ZTogdGhpcywgdXNlTmV3OiBmYWxzZSB9KTtcbiAgICAgICAgcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVycyk7XG4gICAgfVxuICAgIFN0YXRpY0luamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFncyA9PT0gdm9pZCAwKSB7IGZsYWdzID0gMCAvKiBEZWZhdWx0ICovOyB9XG4gICAgICAgIHZhciByZWNvcmQgPSB0aGlzLl9yZWNvcmRzLmdldCh0b2tlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ5UmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHRoaXMuX3JlY29yZHMsIHRoaXMucGFyZW50LCBub3RGb3VuZFZhbHVlLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciB0b2tlblBhdGggPSBlW05HX1RFTVBfVE9LRU5fUEFUSF07XG4gICAgICAgICAgICBpZiAodG9rZW5bU09VUkNFXSkge1xuICAgICAgICAgICAgICAgIHRva2VuUGF0aC51bnNoaWZ0KHRva2VuW1NPVVJDRV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5tZXNzYWdlID0gZm9ybWF0RXJyb3IoJ1xcbicgKyBlLm1lc3NhZ2UsIHRva2VuUGF0aCwgdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgZVtOR19UT0tFTl9QQVRIXSA9IHRva2VuUGF0aDtcbiAgICAgICAgICAgIGVbTkdfVEVNUF9UT0tFTl9QQVRIXSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNJbmplY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXSwgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAodiwgdG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHN0cmluZ2lmeSh0b2tlbikpOyB9KTtcbiAgICAgICAgcmV0dXJuIFwiU3RhdGljSW5qZWN0b3JbXCIgKyB0b2tlbnMuam9pbignLCAnKSArIFwiXVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0luamVjdG9yO1xufSgpKTtcbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBkZXBzID0gY29tcHV0ZURlcHMocHJvdmlkZXIpO1xuICAgIHZhciBmbiA9IElERU5UO1xuICAgIHZhciB2YWx1ZSA9IEVNUFRZO1xuICAgIHZhciB1c2VOZXcgPSBmYWxzZTtcbiAgICB2YXIgcHJvdmlkZSA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnByb3ZpZGUpO1xuICAgIGlmIChVU0VfVkFMVUUgaW4gcHJvdmlkZXIpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1c2UgVVNFX1ZBTFVFIGluIHByb3ZpZGVyIHNpbmNlIHByb3ZpZGVyLnVzZVZhbHVlIGNvdWxkIGJlIGRlZmluZWQgYXMgdW5kZWZpbmVkLlxuICAgICAgICB2YWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgIGZuID0gcHJvdmlkZXIudXNlRmFjdG9yeTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIDtcbiAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICB1c2VOZXcgPSB0cnVlO1xuICAgICAgICBmbiA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHByb3ZpZGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1c2VOZXcgPSB0cnVlO1xuICAgICAgICBmbiA9IHByb3ZpZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignU3RhdGljUHJvdmlkZXIgZG9lcyBub3QgaGF2ZSBbdXNlVmFsdWV8dXNlRmFjdG9yeXx1c2VFeGlzdGluZ3x1c2VDbGFzc10gb3IgW3Byb3ZpZGVdIGlzIG5vdCBuZXdhYmxlJywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICByZXR1cm4geyBkZXBzOiBkZXBzLCBmbjogZm4sIHVzZU5ldzogdXNlTmV3LCB2YWx1ZTogdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbikge1xuICAgIHJldHVybiBzdGF0aWNFcnJvcignQ2Fubm90IG1peCBtdWx0aSBwcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzJywgdG9rZW4pO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyKSB7XG4gICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBhcnJheSByZWN1cnNlIGludG8gdGhlIGFycmF5XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlQcm9jZXNzUHJvdmlkZXJzKHJlY29yZHMsIHByb3ZpZGVyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9ucyB3ZXJlIHN1cHBvcnRlZCBpbiBSZWZsZWN0aXZlSW5qZWN0b3IsIGJ1dCBhcmUgbm90IGhlcmUuIEZvciBzYWZldHkgZ2l2ZSB1c2VmdWxcbiAgICAgICAgICAgIC8vIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignRnVuY3Rpb24vQ2xhc3Mgbm90IHN1cHBvcnRlZCcsIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciAmJiB0eXBlb2YgcHJvdmlkZXIgPT09ICdvYmplY3QnICYmIHByb3ZpZGVyLnByb3ZpZGUpIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSB3aGF0IGxvb2tzIGxpa2UgYSBwcm92aWRlcjoge3Byb3ZpZGU6ID8sIC4uLi59XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci5wcm92aWRlKTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gcmVzb2x2ZVByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtdWx0aSBwcm92aWRlci5cbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlQcm92aWRlciA9IHJlY29yZHMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlQcm92aWRlci5mbiAhPT0gTVVMVElfUFJPVklERVJfRk4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIGZhY3Rvcnkgd2hpY2ggd2lsbCBsb29rIHVwIHRoZSBjb25zdGl0dWVudHMgb2YgdGhlIG11bHRpIHByb3ZpZGVyLlxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldCh0b2tlbiwgbXVsdGlQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBwcm92aWRlci5wcm92aWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VOZXc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm46IE1VTFRJX1BST1ZJREVSX0ZOLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEVNUFRZXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcmVhdCB0aGUgcHJvdmlkZXIgYXMgdGhlIHRva2VuLlxuICAgICAgICAgICAgICAgIHRva2VuID0gcHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgbXVsdGlQcm92aWRlci5kZXBzLnB1c2goeyB0b2tlbjogdG9rZW4sIG9wdGlvbnM6IDYgLyogRGVmYXVsdCAqLyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWNvcmQgPSByZWNvcmRzLmdldCh0b2tlbik7XG4gICAgICAgICAgICBpZiAocmVjb3JkICYmIHJlY29yZC5mbiA9PSBNVUxUSV9QUk9WSURFUl9GTikge1xuICAgICAgICAgICAgICAgIHRocm93IG11bHRpUHJvdmlkZXJNaXhFcnJvcih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmRzLnNldCh0b2tlbiwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignVW5leHBlY3RlZCBwcm92aWRlcicsIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeVJlc29sdmVUb2tlbih0b2tlbiwgcmVjb3JkLCByZWNvcmRzLCBwYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUb2tlbih0b2tlbiwgcmVjb3JkLCByZWNvcmRzLCBwYXJlbnQsIG5vdEZvdW5kVmFsdWUsIGZsYWdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgJ2UnIGlzIG9mIHR5cGUgRXJyb3IuXG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIGUgPSBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBlW05HX1RFTVBfVE9LRU5fUEFUSF0gPSBlW05HX1RFTVBfVE9LRU5fUEFUSF0gfHwgW107XG4gICAgICAgIHBhdGgudW5zaGlmdCh0b2tlbik7XG4gICAgICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnZhbHVlID09IENJUkNVTEFSKSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgQ2lyY3VsYXIgZmxhZy5cbiAgICAgICAgICAgIHJlY29yZC52YWx1ZSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVRva2VuKHRva2VuLCByZWNvcmQsIHJlY29yZHMsIHBhcmVudCwgbm90Rm91bmRWYWx1ZSwgZmxhZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChyZWNvcmQgJiYgIShmbGFncyAmIDQgLyogU2tpcFNlbGYgKi8pKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZWNvcmQsIHRoaXMgaW1wbGllcyB0aGF0IHdlIGRvbid0IG93biB0aGUgcHJvdmlkZXIgaGVuY2UgZG9uJ3Qga25vdyBob3dcbiAgICAgICAgLy8gdG8gcmVzb2x2ZSBpdC5cbiAgICAgICAgdmFsdWUgPSByZWNvcmQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBDSVJDVUxBUikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoTk9fTkVXX0xJTkUgKyAnQ2lyY3VsYXIgZGVwZW5kZW5jeScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBFTVBUWSkge1xuICAgICAgICAgICAgcmVjb3JkLnZhbHVlID0gQ0lSQ1VMQVI7XG4gICAgICAgICAgICB2YXIgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHVzZU5ldyA9IHJlY29yZC51c2VOZXc7XG4gICAgICAgICAgICB2YXIgZm4gPSByZWNvcmQuZm47XG4gICAgICAgICAgICB2YXIgZGVwUmVjb3JkcyA9IHJlY29yZC5kZXBzO1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBFTVBUWTtcbiAgICAgICAgICAgIGlmIChkZXBSZWNvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcFJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcFJlY29yZCA9IGRlcFJlY29yZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZGVwUmVjb3JkLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY29yZCA9IG9wdGlvbnMgJiAyIC8qIENoZWNrU2VsZiAqLyA/IHJlY29yZHMuZ2V0KGRlcFJlY29yZC50b2tlbikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaCh0cnlSZXNvbHZlVG9rZW4oXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgVG9rZW4gdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICBkZXBSZWNvcmQudG9rZW4sIFxuICAgICAgICAgICAgICAgICAgICAvLyBBIHJlY29yZCB3aGljaCBkZXNjcmliZXMgaG93IHRvIHJlc29sdmUgdGhlIHRva2VuLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1bmRlZmluZWQsIHRoaXMgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBzdWNoIGEgcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUmVjb3JkLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgcmVjb3JkcyB3ZSBrbm93IGFib3V0LlxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qga25vdyBob3cgdG8gcmVzb2x2ZSBkZXBlbmRlbmN5IGFuZCB3ZSBzaG91bGQgbm90IGNoZWNrIHBhcmVudCBmb3IgaXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYW4gcGFzcyBpbiBOdWxsIGluamVjdG9yLlxuICAgICAgICAgICAgICAgICAgICAhY2hpbGRSZWNvcmQgJiYgIShvcHRpb25zICYgNCAvKiBDaGVja1BhcmVudCAqLykgPyBOVUxMX0lOSkVDVE9SIDogcGFyZW50LCBvcHRpb25zICYgMSAvKiBPcHRpb25hbCAqLyA/IG51bGwgOiBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQsIDAgLyogRGVmYXVsdCAqLykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY29yZC52YWx1ZSA9IHZhbHVlID0gdXNlTmV3ID8gbmV3ICgoX2EgPSBmbikuYmluZC5hcHBseShfYSwgX19zcHJlYWQoW3ZvaWQgMF0sIGRlcHMpKSkoKSA6IGZuLmFwcGx5KG9iaiwgZGVwcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIShmbGFncyAmIDIgLyogU2VsZiAqLykpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJlbnQuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlLCAwIC8qIERlZmF1bHQgKi8pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wdXRlRGVwcyhwcm92aWRlcikge1xuICAgIHZhciBkZXBzID0gRU1QVFk7XG4gICAgdmFyIHByb3ZpZGVyRGVwcyA9IHByb3ZpZGVyLmRlcHM7XG4gICAgaWYgKHByb3ZpZGVyRGVwcyAmJiBwcm92aWRlckRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGRlcHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlckRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gNiAvKiBEZWZhdWx0ICovO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXJEZXBzW2ldKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGFubm90YXRpb25zID0gdG9rZW47IGogPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIE9wdGlvbmFsIHx8IGFubm90YXRpb24gPT0gT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHwgMSAvKiBPcHRpb25hbCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgU2tpcFNlbGYgfHwgYW5ub3RhdGlvbiA9PSBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgJiB+MiAvKiBDaGVja1NlbGYgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIFNlbGYgfHwgYW5ub3RhdGlvbiA9PSBTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAmIH40IC8qIENoZWNrUGFyZW50ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFubm90YXRpb24gaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gYW5ub3RhdGlvbi50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXBzLnB1c2goeyB0b2tlbjogdG9rZW4sIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIudXNlRXhpc3RpbmcpO1xuICAgICAgICBkZXBzID0gW3sgdG9rZW46IHRva2VuLCBvcHRpb25zOiA2IC8qIERlZmF1bHQgKi8gfV07XG4gICAgfVxuICAgIGVsc2UgaWYgKCFwcm92aWRlckRlcHMgJiYgIShVU0VfVkFMVUUgaW4gcHJvdmlkZXIpKSB7XG4gICAgICAgIC8vIHVzZVZhbHVlICYgdXNlRXhpc3RpbmcgYXJlIHRoZSBvbmx5IG9uZXMgd2hpY2ggYXJlIGV4ZW1wdCBmcm9tIGRlcHMgYWxsIG90aGVycyBuZWVkIGl0LlxuICAgICAgICB0aHJvdyBzdGF0aWNFcnJvcignXFwnZGVwc1xcJyByZXF1aXJlZCcsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcHM7XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcih0ZXh0LCBvYmosIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IHZvaWQgMCkgeyBzb3VyY2UgPSBudWxsOyB9XG4gICAgdGV4dCA9IHRleHQgJiYgdGV4dC5jaGFyQXQoMCkgPT09ICdcXG4nICYmIHRleHQuY2hhckF0KDEpID09IE5PX05FV19MSU5FID8gdGV4dC5zdWJzdHIoMikgOiB0ZXh0O1xuICAgIHZhciBjb250ZXh0ID0gc3RyaW5naWZ5KG9iaik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnRleHQgPSBvYmoubWFwKHN0cmluZ2lmeSkuam9pbignIC0+ICcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChrZXkgKyAnOicgKyAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHN0cmluZ2lmeSh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0ID0gXCJ7XCIgKyBwYXJ0cy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgfVxuICAgIHJldHVybiBcIlN0YXRpY0luamVjdG9yRXJyb3JcIiArIChzb3VyY2UgPyAnKCcgKyBzb3VyY2UgKyAnKScgOiAnJykgKyBcIltcIiArIGNvbnRleHQgKyBcIl06IFwiICsgdGV4dC5yZXBsYWNlKE5FV19MSU5FLCAnXFxuICAnKTtcbn1cbmZ1bmN0aW9uIHN0YXRpY0Vycm9yKHRleHQsIG9iaikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoZm9ybWF0RXJyb3IodGV4dCwgb2JqKSk7XG59XG4vKipcbiAqIEN1cnJlbnQgaW5qZWN0b3IgdmFsdWUgdXNlZCBieSBgaW5qZWN0YC5cbiAqIC0gYHVuZGVmaW5lZGA6IGl0IGlzIGFuIGVycm9yIHRvIGNhbGwgYGluamVjdGBcbiAqIC0gYG51bGxgOiBgaW5qZWN0YCBjYW4gYmUgY2FsbGVkIGJ1dCB0aGVyZSBpcyBubyBpbmplY3RvciAobGltcC1tb2RlKS5cbiAqIC0gSW5qZWN0b3IgaW5zdGFuY2U6IFVzZSB0aGUgaW5qZWN0b3IgZm9yIHJlc29sdXRpb24uXG4gKi9cbnZhciBfY3VycmVudEluamVjdG9yID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gc2V0Q3VycmVudEluamVjdG9yKGluamVjdG9yKSB7XG4gICAgdmFyIGZvcm1lciA9IF9jdXJyZW50SW5qZWN0b3I7XG4gICAgX2N1cnJlbnRJbmplY3RvciA9IGluamVjdG9yO1xuICAgIHJldHVybiBmb3JtZXI7XG59XG5mdW5jdGlvbiBpbmplY3QodG9rZW4sIGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAwIC8qIERlZmF1bHQgKi87IH1cbiAgICBpZiAoX2N1cnJlbnRJbmplY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdCgpIG11c3QgYmUgY2FsbGVkIGZyb20gYW4gaW5qZWN0aW9uIGNvbnRleHRcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9jdXJyZW50SW5qZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluamVjdGFibGVEZWYgPSBnZXRJbmplY3RhYmxlRGVmKHRva2VuKTtcbiAgICAgICAgaWYgKGluamVjdGFibGVEZWYgJiYgaW5qZWN0YWJsZURlZi5wcm92aWRlZEluID09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIGluamVjdGFibGVEZWYudmFsdWUgPT09IHVuZGVmaW5lZCA/IGluamVjdGFibGVEZWYudmFsdWUgPSBpbmplY3RhYmxlRGVmLmZhY3RvcnkoKSA6XG4gICAgICAgICAgICAgICAgaW5qZWN0YWJsZURlZi52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiA4IC8qIE9wdGlvbmFsICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluamVjdG9yOiBOT1RfRk9VTkQgW1wiICsgc3RyaW5naWZ5KHRva2VuKSArIFwiXVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY3VycmVudEluamVjdG9yLmdldCh0b2tlbiwgZmxhZ3MgJiA4IC8qIE9wdGlvbmFsICovID8gbnVsbCA6IHVuZGVmaW5lZCwgZmxhZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluamVjdEFyZ3ModHlwZXMpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnRzIGFycmF5IG11c3QgaGF2ZSBhcmd1bWVudHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IDAgLyogRGVmYXVsdCAqLztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJnLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBhcmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEgaW5zdGFuY2VvZiBPcHRpb25hbCB8fCBtZXRhLm5nTWV0YWRhdGFOYW1lID09PSAnT3B0aW9uYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IDggLyogT3B0aW9uYWwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGEgaW5zdGFuY2VvZiBTa2lwU2VsZiB8fCBtZXRhLm5nTWV0YWRhdGFOYW1lID09PSAnU2tpcFNlbGYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IDQgLyogU2tpcFNlbGYgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGEgaW5zdGFuY2VvZiBTZWxmIHx8IG1ldGEubmdNZXRhZGF0YU5hbWUgPT09ICdTZWxmJykge1xuICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSAyIC8qIFNlbGYgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGEgaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG1ldGEudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gbWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2goaW5qZWN0KHR5cGUsIGZsYWdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goaW5qZWN0KGFyZykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgYSB0eXBlIHRoYXQgYSBDb21wb25lbnQgb3Igb3RoZXIgb2JqZWN0IGlzIGluc3RhbmNlcyBvZi5cbiAqXG4gKiBBbiBleGFtcGxlIG9mIGEgYFR5cGVgIGlzIGBNeUN1c3RvbUNvbXBvbmVudGAgY2xhc3MsIHdoaWNoIGluIEphdmFTY3JpcHQgaXMgYmUgcmVwcmVzZW50ZWQgYnlcbiAqIHRoZSBgTXlDdXN0b21Db21wb25lbnRgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFR5cGUgPSBGdW5jdGlvbjtcbmZ1bmN0aW9uIGlzVHlwZSh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEF0dGVudGlvbjogVGhlc2UgcmVnZXggaGFzIHRvIGhvbGQgZXZlbiBpZiB0aGUgY29kZSBpcyBtaW5pZmllZCFcbiAqL1xudmFyIERFTEVHQVRFX0NUT1IgPSAvXmZ1bmN0aW9uXFxzK1xcUytcXChcXClcXHMqe1tcXHNcXFNdK1xcLmFwcGx5XFwodGhpcyxcXHMqYXJndW1lbnRzXFwpLztcbnZhciBJTkhFUklURURfQ0xBU1MgPSAvXmNsYXNzXFxzK1tBLVphLXpcXGQkX10qXFxzKmV4dGVuZHNcXHMrW157XSt7LztcbnZhciBJTkhFUklURURfQ0xBU1NfV0lUSF9DVE9SID0gL15jbGFzc1xccytbQS1aYS16XFxkJF9dKlxccypleHRlbmRzXFxzK1tee10re1tcXHNcXFNdKmNvbnN0cnVjdG9yXFxzKlxcKC87XG52YXIgUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHJlZmxlY3QpIHtcbiAgICAgICAgdGhpcy5fcmVmbGVjdCA9IHJlZmxlY3QgfHwgX2dsb2JhbFsnUmVmbGVjdCddO1xuICAgIH1cbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pc1JlZmxlY3Rpb25FbmFibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICh0LmJpbmQuYXBwbHkodCwgX19zcHJlYWQoW3ZvaWQgMF0sIGFyZ3MpKSkoKTtcbiAgICB9OyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShwYXJhbUFubm90YXRpb25zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkocGFyYW1UeXBlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBUUyBvdXRwdXRzIE9iamVjdCBmb3IgcGFyYW1ldGVycyB3aXRob3V0IHR5cGVzLCB3aGlsZSBUcmFjZXVyIG9taXRzXG4gICAgICAgICAgICAvLyB0aGUgYW5ub3RhdGlvbnMuIEZvciBub3cgd2UgcHJlc2VydmUgdGhlIFRyYWNldXIgYmVoYXZpb3IgdG8gYWlkXG4gICAgICAgICAgICAvLyBtaWdyYXRpb24sIGJ1dCB0aGlzIGNhbiBiZSByZXZpc2l0ZWQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbVR5cGVzW2ldICE9IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtwYXJhbVR5cGVzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtQW5ub3RhdGlvbnMgJiYgcGFyYW1Bbm5vdGF0aW9uc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldLmNvbmNhdChwYXJhbUFubm90YXRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuX293blBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSwgcGFyZW50Q3Rvcikge1xuICAgICAgICB2YXIgdHlwZVN0ciA9IHR5cGUudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBkZWNvcmF0b3JzLCB3ZSBvbmx5IGhhdmUgZnVuY3Rpb24ubGVuZ3RoIGFzIG1ldGFkYXRhLlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRvIGRldGVjdCB3aGV0aGVyIGEgY2hpbGQgY2xhc3MgZGVjbGFyZWQgYW4gb3duIGNvbnN0cnVjdG9yIG9yIG5vdCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBsb29rIGluc2lkZSBvZiB0aGF0IGNvbnN0cnVjdG9yIHRvIGNoZWNrIHdoZXRoZXIgaXQgaXNcbiAgICAgICAgLy8ganVzdCBjYWxsaW5nIHRoZSBwYXJlbnQuXG4gICAgICAgIC8vIFRoaXMgYWxzbyBoZWxwcyB0byB3b3JrIGFyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjQzOVxuICAgICAgICAvLyB0aGF0IHNldHMgJ2Rlc2lnbjpwYXJhbXR5cGVzJyB0byBbXVxuICAgICAgICAvLyBpZiBhIGNsYXNzIGluaGVyaXRzIGZyb20gYW5vdGhlciBjbGFzcyBidXQgaGFzIG5vIGN0b3IgZGVjbGFyZWQgaXRzZWxmLlxuICAgICAgICBpZiAoREVMRUdBVEVfQ1RPUi5leGVjKHR5cGVTdHIpIHx8XG4gICAgICAgICAgICAoSU5IRVJJVEVEX0NMQVNTLmV4ZWModHlwZVN0cikgJiYgIUlOSEVSSVRFRF9DTEFTU19XSVRIX0NUT1IuZXhlYyh0eXBlU3RyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVycyAmJiB0eXBlLnBhcmFtZXRlcnMgIT09IHBhcmVudEN0b3IucGFyYW1ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUucGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgdmFyIHRzaWNrbGVDdG9yUGFyYW1zID0gdHlwZS5jdG9yUGFyYW1ldGVycztcbiAgICAgICAgaWYgKHRzaWNrbGVDdG9yUGFyYW1zICYmIHRzaWNrbGVDdG9yUGFyYW1zICE9PSBwYXJlbnRDdG9yLmN0b3JQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAvLyBOZXdlciB0c2lja2xlIHVzZXMgYSBmdW5jdGlvbiBjbG9zdXJlXG4gICAgICAgICAgICAvLyBSZXRhaW4gdGhlIG5vbi1mdW5jdGlvbiBjYXNlIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdHNpY2tsZVxuICAgICAgICAgICAgdmFyIGN0b3JQYXJhbWV0ZXJzID0gdHlwZW9mIHRzaWNrbGVDdG9yUGFyYW1zID09PSAnZnVuY3Rpb24nID8gdHNpY2tsZUN0b3JQYXJhbXMoKSA6IHRzaWNrbGVDdG9yUGFyYW1zO1xuICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXNfMSA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7IHJldHVybiBjdG9yUGFyYW0gJiYgY3RvclBhcmFtLnR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHBhcmFtQW5ub3RhdGlvbnNfMSA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0b3JQYXJhbSAmJiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YShjdG9yUGFyYW0uZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXNfMSwgcGFyYW1Bbm5vdGF0aW9uc18xKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gdHlwZS5oYXNPd25Qcm9wZXJ0eShQQVJBTUVURVJTKSAmJiB0eXBlW1BBUkFNRVRFUlNdO1xuICAgICAgICB2YXIgcGFyYW1UeXBlcyA9IHRoaXMuX3JlZmxlY3QgJiYgdGhpcy5fcmVmbGVjdC5nZXRPd25NZXRhZGF0YSAmJlxuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdC5nZXRPd25NZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCB0eXBlKTtcbiAgICAgICAgaWYgKHBhcmFtVHlwZXMgfHwgcGFyYW1Bbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ppcFR5cGVzQW5kQW5ub3RhdGlvbnMocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBjbGFzcyBoYXMgbm8gZGVjb3JhdG9ycywgYXQgbGVhc3QgY3JlYXRlIG1ldGFkYXRhXG4gICAgICAgIC8vIGJhc2VkIG9uIGZ1bmN0aW9uLmxlbmd0aC5cbiAgICAgICAgLy8gTm90ZTogV2Uga25vdyB0aGF0IHRoaXMgaXMgYSByZWFsIGNvbnN0cnVjdG9yIGFzIHdlIGNoZWNrZWRcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGNvbnN0cnVjdG9yIGFib3ZlLlxuICAgICAgICByZXR1cm4gbmV3IEFycmF5KHR5cGUubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gTm90ZTogb25seSByZXBvcnQgbWV0YWRhdGEgaWYgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgY2xhc3MgZGVjb3JhdG9yXG4gICAgICAgIC8vIHRvIHN0YXkgaW4gc3luYyB3aXRoIHRoZSBzdGF0aWMgcmVmbGVjdG9yLlxuICAgICAgICBpZiAoIWlzVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRDdG9yID0gZ2V0UGFyZW50Q3Rvcih0eXBlKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLl9vd25QYXJhbWV0ZXJzKHR5cGUsIHBhcmVudEN0b3IpO1xuICAgICAgICBpZiAoIXBhcmFtZXRlcnMgJiYgcGFyZW50Q3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzKHBhcmVudEN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzIHx8IFtdO1xuICAgIH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuX293bkFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIHBhcmVudEN0b3IpIHtcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICBpZiAodHlwZU9yRnVuYy5hbm5vdGF0aW9ucyAmJiB0eXBlT3JGdW5jLmFubm90YXRpb25zICE9PSBwYXJlbnRDdG9yLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0eXBlT3JGdW5jLmFubm90YXRpb25zO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9ucyA9PT0gJ2Z1bmN0aW9uJyAmJiBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgIGlmICh0eXBlT3JGdW5jLmRlY29yYXRvcnMgJiYgdHlwZU9yRnVuYy5kZWNvcmF0b3JzICE9PSBwYXJlbnRDdG9yLmRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YSh0eXBlT3JGdW5jLmRlY29yYXRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFQSSBmb3IgbWV0YWRhdGEgY3JlYXRlZCBieSBpbnZva2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgICAgaWYgKHR5cGVPckZ1bmMuaGFzT3duUHJvcGVydHkoQU5OT1RBVElPTlMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZU9yRnVuY1tBTk5PVEFUSU9OU107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIGlmICghaXNUeXBlKHR5cGVPckZ1bmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudEN0b3IgPSBnZXRQYXJlbnRDdG9yKHR5cGVPckZ1bmMpO1xuICAgICAgICB2YXIgb3duQW5ub3RhdGlvbnMgPSB0aGlzLl9vd25Bbm5vdGF0aW9ucyh0eXBlT3JGdW5jLCBwYXJlbnRDdG9yKSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcmVudEFubm90YXRpb25zID0gcGFyZW50Q3RvciAhPT0gT2JqZWN0ID8gdGhpcy5hbm5vdGF0aW9ucyhwYXJlbnRDdG9yKSA6IFtdO1xuICAgICAgICByZXR1cm4gcGFyZW50QW5ub3RhdGlvbnMuY29uY2F0KG93bkFubm90YXRpb25zKTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl9vd25Qcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgcGFyZW50Q3Rvcikge1xuICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgIGlmICh0eXBlT3JGdW5jLnByb3BNZXRhZGF0YSAmJlxuICAgICAgICAgICAgdHlwZU9yRnVuYy5wcm9wTWV0YWRhdGEgIT09IHBhcmVudEN0b3IucHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdHlwZU9yRnVuYy5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BNZXRhZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wTWV0YWRhdGEucHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0gcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgIGlmICh0eXBlT3JGdW5jLnByb3BEZWNvcmF0b3JzICYmXG4gICAgICAgICAgICB0eXBlT3JGdW5jLnByb3BEZWNvcmF0b3JzICE9PSBwYXJlbnRDdG9yLnByb3BEZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICB2YXIgcHJvcERlY29yYXRvcnNfMSA9IHR5cGVPckZ1bmMucHJvcERlY29yYXRvcnM7XG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhXzEgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BEZWNvcmF0b3JzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGFfMVtwcm9wXSA9IGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKHByb3BEZWNvcmF0b3JzXzFbcHJvcF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICBpZiAodHlwZU9yRnVuYy5oYXNPd25Qcm9wZXJ0eShQUk9QX01FVEFEQVRBKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVPckZ1bmNbUFJPUF9NRVRBREFUQV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICBpZiAoIWlzVHlwZSh0eXBlT3JGdW5jKSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRDdG9yID0gZ2V0UGFyZW50Q3Rvcih0eXBlT3JGdW5jKTtcbiAgICAgICAgdmFyIHByb3BNZXRhZGF0YSA9IHt9O1xuICAgICAgICBpZiAocGFyZW50Q3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50UHJvcE1ldGFkYXRhXzEgPSB0aGlzLnByb3BNZXRhZGF0YShwYXJlbnRDdG9yKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudFByb3BNZXRhZGF0YV8xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YVtwcm9wTmFtZV0gPSBwYXJlbnRQcm9wTWV0YWRhdGFfMVtwcm9wTmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3duUHJvcE1ldGFkYXRhID0gdGhpcy5fb3duUHJvcE1ldGFkYXRhKHR5cGVPckZ1bmMsIHBhcmVudEN0b3IpO1xuICAgICAgICBpZiAob3duUHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvd25Qcm9wTWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE1ldGFkYXRhLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JzLnB1c2guYXBwbHkoZGVjb3JhdG9ycywgX19zcHJlYWQocHJvcE1ldGFkYXRhW3Byb3BOYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvcmF0b3JzLnB1c2guYXBwbHkoZGVjb3JhdG9ycywgX19zcHJlYWQob3duUHJvcE1ldGFkYXRhW3Byb3BOYW1lXSkpO1xuICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YVtwcm9wTmFtZV0gPSBkZWNvcmF0b3JzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGUgJiYgbGNQcm9wZXJ0eSBpbiB0eXBlLnByb3RvdHlwZTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmd1YXJkcyA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB7fTsgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ3JldHVybiBvLicgKyBuYW1lICsgJzsnKTsgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ3YnLCAncmV0dXJuIG8uJyArIG5hbWUgKyAnID0gdjsnKTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBmdW5jdGlvbkJvZHkgPSBcImlmICghby5cIiArIG5hbWUgKyBcIikgdGhyb3cgbmV3IEVycm9yKCdcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIHVuZGVmaW5lZCcpO1xcbiAgICAgICAgcmV0dXJuIG8uXCIgKyBuYW1lICsgXCIuYXBwbHkobywgYXJncyk7XCI7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAnYXJncycsIGZ1bmN0aW9uQm9keSk7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBpcyBub3QgYSBjb25jZXB0IG9mIGltcG9ydCB1cmkgaW4gSnMsIGJ1dCB0aGlzIGlzIHVzZWZ1bCBpbiBkZXZlbG9waW5nIERhcnQgYXBwbGljYXRpb25zLlxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIFN0YXRpY1N5bWJvbFxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVbJ2ZpbGVQYXRoJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlWydmaWxlUGF0aCddO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJ1bnRpbWUgdHlwZVxuICAgICAgICByZXR1cm4gXCIuL1wiICsgc3RyaW5naWZ5KHR5cGUpO1xuICAgIH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb3VyY2VVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gXCIuL1wiICsgc3RyaW5naWZ5KHR5cGUpOyB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgbWVtYmVycywgcnVudGltZSkge1xuICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGVudW1JZGVudGlmaWVyLCBuYW1lKSB7IHJldHVybiBlbnVtSWRlbnRpZmllcltuYW1lXTsgfTtcbiAgICByZXR1cm4gUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbn0oKSk7XG5mdW5jdGlvbiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YShkZWNvcmF0b3JJbnZvY2F0aW9ucykge1xuICAgIGlmICghZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdG9ySW52b2NhdGlvbnMubWFwKGZ1bmN0aW9uIChkZWNvcmF0b3JJbnZvY2F0aW9uKSB7XG4gICAgICAgIHZhciBkZWNvcmF0b3JUeXBlID0gZGVjb3JhdG9ySW52b2NhdGlvbi50eXBlO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbkNscyA9IGRlY29yYXRvclR5cGUuYW5ub3RhdGlvbkNscztcbiAgICAgICAgdmFyIGFubm90YXRpb25BcmdzID0gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzID8gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzIDogW107XG4gICAgICAgIHJldHVybiBuZXcgKGFubm90YXRpb25DbHMuYmluZC5hcHBseShhbm5vdGF0aW9uQ2xzLCBfX3NwcmVhZChbdm9pZCAwXSwgYW5ub3RhdGlvbkFyZ3MpKSkoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudEN0b3IoY3Rvcikge1xuICAgIHZhciBwYXJlbnRQcm90byA9IGN0b3IucHJvdG90eXBlID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKSA6IG51bGw7XG4gICAgdmFyIHBhcmVudEN0b3IgPSBwYXJlbnRQcm90byA/IHBhcmVudFByb3RvLmNvbnN0cnVjdG9yIDogbnVsbDtcbiAgICAvLyBOb3RlOiBXZSBhbHdheXMgdXNlIGBPYmplY3RgIGFzIHRoZSBudWxsIHZhbHVlXG4gICAgLy8gdG8gc2ltcGxpZnkgY2hlY2tpbmcgbGF0ZXIgb24uXG4gICAgcmV0dXJuIHBhcmVudEN0b3IgfHwgT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSByZXNvdXJjZSBVUkxzIG9uIGBAQ29tcG9uZW50YCB3aGVuIHVzZWQgd2l0aCBKSVQgY29tcGlsYXRpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcCcsXG4gKiAgIHRlbXBsYXRlVXJsOiAnbXktY29tcC5odG1sJywgLy8gVGhpcyByZXF1aXJlcyBhc3luY2hyb25vdXMgcmVzb2x1dGlvblxuICogfSlcbiAqIGNsYXNzIE15Q29tcG9ubmVudHtcbiAqIH1cbiAqXG4gKiAvLyBDYWxsaW5nIGByZW5kZXJDb21wb25lbnRgIHdpbGwgZmFpbCBiZWNhdXNlIGBNeUNvbXBvbmVudGAncyBgQENvbXBlbmVudC50ZW1wbGF0ZVVybGBcbiAqIC8vIG5lZWRzIHRvIGJlIHJlc29sdmVkIGJlY2F1c2UgYHJlbmRlckNvbXBvbmVudGAgaXMgc3luY2hyb25vdXMgcHJvY2Vzcy5cbiAqIC8vIHJlbmRlckNvbXBvbmVudChNeUNvbXBvbmVudCk7XG4gKlxuICogLy8gQ2FsbGluZyBgcmVzb2x2ZUNvbXBvbmVudFJlc291cmNlc2Agd2lsbCByZXNvbHZlIGBAQ29tcGVuZW50LnRlbXBsYXRlVXJsYCBpbnRvXG4gKiAvLyBgQENvbXBlbmVudC50ZW1wbGF0ZWAsIHdoaWNoIHdvdWxkIGFsbG93IGByZW5kZXJDb21wb25lbnRgIHRvIHByb2NlZWQgaW4gc3luY2hyb25vdXMgbWFubmVyLlxuICogLy8gVXNlIGJyb3dzZXIncyBgZmV0Y2hgIGZ1bmN0aW9uIGFzIHRoZSBkZWZhdWx0IHJlc291cmNlIHJlc29sdXRpb24gc3RyYXRlZ3kuXG4gKiByZXNvbHZlQ29tcG9uZW50UmVzb3VyY2VzKGZldGNoKS50aGVuKCgpID0+IHtcbiAqICAgLy8gQWZ0ZXIgcmVzb2x1dGlvbiBhbGwgVVJMcyBoYXZlIGJlZW4gY29udmVydGVkIGludG8gc3RyaW5ncy5cbiAqICAgcmVuZGVyQ29tcG9uZW50KE15Q29tcG9uZW50KTtcbiAqIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIE5PVEU6IEluIEFPVCB0aGUgcmVzb2x1dGlvbiBoYXBwZW5zIGR1cmluZyBjb21waWxhdGlvbiwgYW5kIHNvIHRoZXJlIHNob3VsZCBiZSBubyBuZWVkXG4gKiB0byBjYWxsIHRoaXMgbWV0aG9kIG91dHNpZGUgSklUIG1vZGUuXG4gKlxuICogQHBhcmFtIHJlc291cmNlUmVzb2x2ZXIgYSBmdW5jdGlvbiB3aGljaCBpcyByZXNwb25zaWJsZSB0byByZXR1cm5pbmcgYSBgUHJvbWlzZWAgb2YgdGhlIHJlc29sdmVkXG4gKiBVUkwuIEJyb3dzZXIncyBgZmV0Y2hgIG1ldGhvZCBpcyBhIGdvb2QgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudFJlc291cmNlcyhyZXNvdXJjZVJlc29sdmVyKSB7XG4gICAgLy8gU3RvcmUgYWxsIHByb21pc2VzIHdoaWNoIGFyZSBmZXRjaGluZyB0aGUgcmVzb3VyY2VzLlxuICAgIHZhciB1cmxGZXRjaGVzID0gW107XG4gICAgLy8gQ2FjaGUgc28gdGhhdCB3ZSBkb24ndCBmZXRjaCB0aGUgc2FtZSByZXNvdXJjZSBtb3JlIHRoYW4gb25jZS5cbiAgICB2YXIgdXJsTWFwID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGNhY2hlZFJlc291cmNlUmVzb2x2ZSh1cmwpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB1cmxNYXAuZ2V0KHVybCk7XG4gICAgICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHJlc3AgPSByZXNvdXJjZVJlc29sdmVyKHVybCk7XG4gICAgICAgICAgICB1cmxNYXAuc2V0KHVybCwgcHJvbWlzZSA9IHJlc3AudGhlbih1bndyYXBSZXNwb25zZSkpO1xuICAgICAgICAgICAgdXJsRmV0Y2hlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBjb21wb25lbnRSZXNvdXJjZVJlc29sdXRpb25RdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgY2FjaGVkUmVzb3VyY2VSZXNvbHZlKGNvbXBvbmVudC50ZW1wbGF0ZVVybCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGVVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVVcmxzID0gY29tcG9uZW50LnN0eWxlVXJscztcbiAgICAgICAgdmFyIHN0eWxlcyA9IGNvbXBvbmVudC5zdHlsZXMgfHwgKGNvbXBvbmVudC5zdHlsZXMgPSBbXSk7XG4gICAgICAgIHZhciBzdHlsZU9mZnNldCA9IGNvbXBvbmVudC5zdHlsZXMubGVuZ3RoO1xuICAgICAgICBzdHlsZVVybHMgJiYgc3R5bGVVcmxzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlVXJsLCBpbmRleCkge1xuICAgICAgICAgICAgc3R5bGVzLnB1c2goJycpOyAvLyBwcmUtYWxsb2NhdGUgYXJyYXkuXG4gICAgICAgICAgICBjYWNoZWRSZXNvdXJjZVJlc29sdmUoc3R5bGVVcmwpLnRoZW4oZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzW3N0eWxlT2Zmc2V0ICsgaW5kZXhdID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzLnNwbGljZShzdHlsZVVybHMuaW5kZXhPZihzdHlsZVVybCksIDEpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVVybHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlVXJscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tcG9uZW50UmVzb3VyY2VSZXNvbHV0aW9uUXVldWUuY2xlYXIoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodXJsRmV0Y2hlcykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcbn1cbnZhciBjb21wb25lbnRSZXNvdXJjZVJlc29sdXRpb25RdWV1ZSA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIG1heWJlUXVldWVSZXNvbHV0aW9uT2ZDb21wb25lbnRSZXNvdXJjZXMobWV0YWRhdGEpIHtcbiAgICBpZiAoY29tcG9uZW50TmVlZHNSZXNvbHV0aW9uKG1ldGFkYXRhKSkge1xuICAgICAgICBjb21wb25lbnRSZXNvdXJjZVJlc29sdXRpb25RdWV1ZS5hZGQobWV0YWRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvbmVudE5lZWRzUmVzb2x1dGlvbihjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnRlbXBsYXRlVXJsIHx8IGNvbXBvbmVudC5zdHlsZVVybHMgJiYgY29tcG9uZW50LnN0eWxlVXJscy5sZW5ndGg7XG59XG5mdW5jdGlvbiB1bndyYXBSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiB0eXBlb2YgcmVzcG9uc2UgPT0gJ3N0cmluZycgPyByZXNwb25zZSA6IHJlc3BvbnNlLnRleHQoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBEZWZpbmVzIHRlbXBsYXRlIGFuZCBzdHlsZSBlbmNhcHN1bGF0aW9uIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBDb21wb25lbnQncyB7QGxpbmsgQ29tcG9uZW50fS5cbiAqXG4gKiBTZWUge0BsaW5rIENvbXBvbmVudCNlbmNhcHN1bGF0aW9uIGVuY2Fwc3VsYXRpb259LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2VuY2Fwc3VsYXRpb24udHMgcmVnaW9uPSdsb25nZm9ybSd9XG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmlld0VuY2Fwc3VsYXRpb247XG4oZnVuY3Rpb24gKFZpZXdFbmNhcHN1bGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogRW11bGF0ZSBgTmF0aXZlYCBzY29waW5nIG9mIHN0eWxlcyBieSBhZGRpbmcgYW4gYXR0cmlidXRlIGNvbnRhaW5pbmcgc3Vycm9nYXRlIGlkIHRvIHRoZSBIb3N0XG4gICAgICogRWxlbWVudCBhbmQgcHJlLXByb2Nlc3NpbmcgdGhlIHN0eWxlIHJ1bGVzIHByb3ZpZGVkIHZpYSB7QGxpbmsgQ29tcG9uZW50I3N0eWxlcyBzdHlsZXN9IG9yXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNzdHlsZVVybHMgc3R5bGVVcmxzfSwgYW5kIGFkZGluZyB0aGUgbmV3IEhvc3QgRWxlbWVudCBhdHRyaWJ1dGUgdG8gYWxsXG4gICAgICogc2VsZWN0b3JzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBvcHRpb24uXG4gICAgICovXG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJFbXVsYXRlZFwiXSA9IDBdID0gXCJFbXVsYXRlZFwiO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHY2LjEuMCAtIHVzZSB7Vmlld0VuY2Fwc3VsYXRpb24uU2hhZG93RG9tfSBpbnN0ZWFkLlxuICAgICAqIFVzZSB0aGUgbmF0aXZlIGVuY2Fwc3VsYXRpb24gbWVjaGFuaXNtIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEZvciB0aGUgRE9NIHRoaXMgbWVhbnMgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgW1NoYWRvdyBET01cbiAgICAgKiB2MF0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvKSBhbmRcbiAgICAgKiBjcmVhdGluZyBhIFNoYWRvd1Jvb3QgZm9yIENvbXBvbmVudCdzIEhvc3QgRWxlbWVudC5cbiAgICAgKi9cbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5hdGl2ZVwiXSA9IDFdID0gXCJOYXRpdmVcIjtcbiAgICAvKipcbiAgICAgKiBEb24ndCBwcm92aWRlIGFueSB0ZW1wbGF0ZSBvciBzdHlsZSBlbmNhcHN1bGF0aW9uLlxuICAgICAqL1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogVXNlIFNoYWRvdyBET00gdG8gZW5jYXBzdWxhdGUgc3R5bGVzLlxuICAgICAqXG4gICAgICogRm9yIHRoZSBET00gdGhpcyBtZWFucyB1c2luZyBtb2Rlcm4gW1NoYWRvd1xuICAgICAqIERPTV0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvKSBhbmRcbiAgICAgKiBjcmVhdGluZyBhIFNoYWRvd1Jvb3QgZm9yIENvbXBvbmVudCdzIEhvc3QgRWxlbWVudC5cbiAgICAgKi9cbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIlNoYWRvd0RvbVwiXSA9IDNdID0gXCJTaGFkb3dEb21cIjtcbn0pKFZpZXdFbmNhcHN1bGF0aW9uIHx8IChWaWV3RW5jYXBzdWxhdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG5nRGV2TW9kZVJlc2V0UGVyZkNvdW50ZXJzKCkge1xuICAgIHZhciBuZXdDb3VudGVycyA9IHtcbiAgICAgICAgZmlyc3RUZW1wbGF0ZVBhc3M6IDAsXG4gICAgICAgIHROb2RlOiAwLFxuICAgICAgICB0VmlldzogMCxcbiAgICAgICAgcmVuZGVyZXJDcmVhdGVUZXh0Tm9kZTogMCxcbiAgICAgICAgcmVuZGVyZXJTZXRUZXh0OiAwLFxuICAgICAgICByZW5kZXJlckNyZWF0ZUVsZW1lbnQ6IDAsXG4gICAgICAgIHJlbmRlcmVyQWRkRXZlbnRMaXN0ZW5lcjogMCxcbiAgICAgICAgcmVuZGVyZXJTZXRBdHRyaWJ1dGU6IDAsXG4gICAgICAgIHJlbmRlcmVyUmVtb3ZlQXR0cmlidXRlOiAwLFxuICAgICAgICByZW5kZXJlclNldFByb3BlcnR5OiAwLFxuICAgICAgICByZW5kZXJlclNldENsYXNzTmFtZTogMCxcbiAgICAgICAgcmVuZGVyZXJBZGRDbGFzczogMCxcbiAgICAgICAgcmVuZGVyZXJSZW1vdmVDbGFzczogMCxcbiAgICAgICAgcmVuZGVyZXJTZXRTdHlsZTogMCxcbiAgICAgICAgcmVuZGVyZXJSZW1vdmVTdHlsZTogMCxcbiAgICAgICAgcmVuZGVyZXJEZXN0cm95OiAwLFxuICAgICAgICByZW5kZXJlckRlc3Ryb3lOb2RlOiAwLFxuICAgICAgICByZW5kZXJlck1vdmVOb2RlOiAwLFxuICAgICAgICByZW5kZXJlclJlbW92ZU5vZGU6IDAsXG4gICAgICAgIHJlbmRlcmVyQ3JlYXRlQ29tbWVudDogMCxcbiAgICB9O1xuICAgIC8vIE5PVEU6IFVuZGVyIEl2eSB3ZSBtYXkgaGF2ZSBib3RoIHdpbmRvdyAmIGdsb2JhbCBkZWZpbmVkIGluIHRoZSBOb2RlXG4gICAgLy8gICAgZW52aXJvbm1lbnQgc2luY2UgZW5zdXJlRG9jdW1lbnQoKSBpbiByZW5kZXIzLnRzIHNldHMgZ2xvYmFsLndpbmRvdy5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVmZXIgdG8gbmdEZXZNb2RlIGFzIFsnbmdEZXZNb2RlJ10gZm9yIGNsb3N1cmUuXG4gICAgICAgIHdpbmRvd1snbmdEZXZNb2RlJ10gPSBuZXdDb3VudGVycztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlZmVyIHRvIG5nRGV2TW9kZSBhcyBbJ25nRGV2TW9kZSddIGZvciBjbG9zdXJlLlxuICAgICAgICBnbG9iYWxbJ25nRGV2TW9kZSddID0gbmV3Q291bnRlcnM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gcmVmZXIgdG8gbmdEZXZNb2RlIGFzIFsnbmdEZXZNb2RlJ10gZm9yIGNsb3N1cmUuXG4gICAgICAgIHNlbGZbJ25nRGV2TW9kZSddID0gbmV3Q291bnRlcnM7XG4gICAgfVxuICAgIHJldHVybiBuZXdDb3VudGVycztcbn1cbi8qKlxuICogVGhpcyBjaGVja3MgdG8gc2VlIGlmIHRoZSBgbmdEZXZNb2RlYCBoYXMgYmVlbiBzZXQuIElmIHllcyxcbiAqIHRoYW4gd2UgaG9ub3IgaXQsIG90aGVyd2lzZSB3ZSBkZWZhdWx0IHRvIGRldiBtb2RlIHdpdGggYWRkaXRpb25hbCBjaGVja3MuXG4gKlxuICogVGhlIGlkZWEgaXMgdGhhdCB1bmxlc3Mgd2UgYXJlIGRvaW5nIHByb2R1Y3Rpb24gYnVpbGQgd2hlcmUgd2UgZXhwbGljaXRseVxuICogc2V0IGBuZ0Rldk1vZGUgPT0gZmFsc2VgIHdlIHNob3VsZCBiZSBoZWxwaW5nIHRoZSBkZXZlbG9wZXIgYnkgcHJvdmlkaW5nXG4gKiBhcyBtdWNoIGVhcmx5IHdhcm5pbmcgYW5kIGVycm9ycyBhcyBwb3NzaWJsZS5cbiAqL1xuaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgIG5nRGV2TW9kZVJlc2V0UGVyZkNvdW50ZXJzKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFTVBUWSQxID0ge307XG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcbmlmICh0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGUpIHtcbiAgICBPYmplY3QuZnJlZXplKEVNUFRZJDEpO1xuICAgIE9iamVjdC5mcmVlemUoRU1QVFlfQVJSQVkpO1xufVxudmFyIF9yZW5kZXJDb21wQ291bnQgPSAwO1xuLyoqXG4gKiBDcmVhdGUgYSBjb21wb25lbnQgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICpcbiAqICMgRXhhbXBsZVxuICogYGBgXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XG4gKiAgIC8vIEdlbmVyYXRlZCBieSBBbmd1bGFyIFRlbXBsYXRlIENvbXBpbGVyXG4gKiAgIC8vIFtTeW1ib2xdIHN5bnRheCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgYnkgVHlwZVNjcmlwdCB1bnRpbCB2Mi43XG4gKiAgIHN0YXRpYyBuZ0NvbXBvbmVudERlZiA9IGRlZmluZUNvbXBvbmVudCh7XG4gKiAgICAgLi4uXG4gKiAgIH0pO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChjb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgdmFyIHR5cGUgPSBjb21wb25lbnREZWZpbml0aW9uLnR5cGU7XG4gICAgdmFyIHR5cGVQcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICB2YXIgZGVjbGFyZWRJbnB1dHMgPSB7fTtcbiAgICB2YXIgZGVmID0ge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBkaVB1YmxpYzogbnVsbCxcbiAgICAgICAgY29uc3RzOiBjb21wb25lbnREZWZpbml0aW9uLmNvbnN0cyxcbiAgICAgICAgdmFyczogY29tcG9uZW50RGVmaW5pdGlvbi52YXJzLFxuICAgICAgICBob3N0VmFyczogY29tcG9uZW50RGVmaW5pdGlvbi5ob3N0VmFycyB8fCAwLFxuICAgICAgICBmYWN0b3J5OiBjb21wb25lbnREZWZpbml0aW9uLmZhY3RvcnksXG4gICAgICAgIHRlbXBsYXRlOiBjb21wb25lbnREZWZpbml0aW9uLnRlbXBsYXRlIHx8IG51bGwsXG4gICAgICAgIGhvc3RCaW5kaW5nczogY29tcG9uZW50RGVmaW5pdGlvbi5ob3N0QmluZGluZ3MgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFF1ZXJpZXM6IGNvbXBvbmVudERlZmluaXRpb24uY29udGVudFF1ZXJpZXMgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFF1ZXJpZXNSZWZyZXNoOiBjb21wb25lbnREZWZpbml0aW9uLmNvbnRlbnRRdWVyaWVzUmVmcmVzaCB8fCBudWxsLFxuICAgICAgICBhdHRyaWJ1dGVzOiBjb21wb25lbnREZWZpbml0aW9uLmF0dHJpYnV0ZXMgfHwgbnVsbCxcbiAgICAgICAgZGVjbGFyZWRJbnB1dHM6IGRlY2xhcmVkSW5wdXRzLFxuICAgICAgICBpbnB1dHM6IG51bGwsXG4gICAgICAgIG91dHB1dHM6IG51bGwsXG4gICAgICAgIGV4cG9ydEFzOiBjb21wb25lbnREZWZpbml0aW9uLmV4cG9ydEFzIHx8IG51bGwsXG4gICAgICAgIG9uSW5pdDogdHlwZVByb3RvdHlwZS5uZ09uSW5pdCB8fCBudWxsLFxuICAgICAgICBkb0NoZWNrOiB0eXBlUHJvdG90eXBlLm5nRG9DaGVjayB8fCBudWxsLFxuICAgICAgICBhZnRlckNvbnRlbnRJbml0OiB0eXBlUHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCB8fCBudWxsLFxuICAgICAgICBhZnRlckNvbnRlbnRDaGVja2VkOiB0eXBlUHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCB8fCBudWxsLFxuICAgICAgICBhZnRlclZpZXdJbml0OiB0eXBlUHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCB8fCBudWxsLFxuICAgICAgICBhZnRlclZpZXdDaGVja2VkOiB0eXBlUHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCB8fCBudWxsLFxuICAgICAgICBvbkRlc3Ryb3k6IHR5cGVQcm90b3R5cGUubmdPbkRlc3Ryb3kgfHwgbnVsbCxcbiAgICAgICAgb25QdXNoOiBjb21wb25lbnREZWZpbml0aW9uLmNoYW5nZURldGVjdGlvbiA9PT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBkaXJlY3RpdmVEZWZzOiBudWxsLFxuICAgICAgICBwaXBlRGVmczogbnVsbCxcbiAgICAgICAgc2VsZWN0b3JzOiBjb21wb25lbnREZWZpbml0aW9uLnNlbGVjdG9ycyxcbiAgICAgICAgdmlld1F1ZXJ5OiBjb21wb25lbnREZWZpbml0aW9uLnZpZXdRdWVyeSB8fCBudWxsLFxuICAgICAgICBmZWF0dXJlczogY29tcG9uZW50RGVmaW5pdGlvbi5mZWF0dXJlcyB8fCBudWxsLFxuICAgICAgICBkYXRhOiBjb21wb25lbnREZWZpbml0aW9uLmRhdGEgfHwge30sXG4gICAgICAgIC8vIFRPRE8obWlza28pOiBjb252ZXJ0IFZpZXdFbmNhcHN1bGF0aW9uIGludG8gY29uc3QgZW51bSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGRpcmVjdGx5IGluIHRoZVxuICAgICAgICAvLyBuZXh0IGxpbmUuIEFsc28gYE5vbmVgIHNob3VsZCBiZSAwIG5vdCAyLlxuICAgICAgICBlbmNhcHN1bGF0aW9uOiBjb21wb25lbnREZWZpbml0aW9uLmVuY2Fwc3VsYXRpb24gfHwgVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsXG4gICAgICAgIHByb3ZpZGVyczogRU1QVFlfQVJSQVksXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IEVNUFRZX0FSUkFZLFxuICAgICAgICBpZDogJ2MnLFxuICAgICAgICBzdHlsZXM6IGNvbXBvbmVudERlZmluaXRpb24uc3R5bGVzIHx8IEVNUFRZX0FSUkFZLFxuICAgICAgICBfOiBudWxsLFxuICAgIH07XG4gICAgZGVmLl8gPSBub1NpZGVFZmZlY3RzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZVR5cGVzID0gY29tcG9uZW50RGVmaW5pdGlvbi5kaXJlY3RpdmVzO1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGNvbXBvbmVudERlZmluaXRpb24uZmVhdHVyZXM7XG4gICAgICAgIHZhciBwaXBlVHlwZXMgPSBjb21wb25lbnREZWZpbml0aW9uLnBpcGVzO1xuICAgICAgICBkZWYuaWQgKz0gX3JlbmRlckNvbXBDb3VudCsrO1xuICAgICAgICBkZWYuaW5wdXRzID0gaW52ZXJ0T2JqZWN0KGNvbXBvbmVudERlZmluaXRpb24uaW5wdXRzLCBkZWNsYXJlZElucHV0cyksXG4gICAgICAgICAgICBkZWYub3V0cHV0cyA9IGludmVydE9iamVjdChjb21wb25lbnREZWZpbml0aW9uLm91dHB1dHMpLFxuICAgICAgICAgICAgZmVhdHVyZSAmJiBmZWF0dXJlLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbihkZWYpOyB9KTtcbiAgICAgICAgZGVmLmRpcmVjdGl2ZURlZnMgPSBkaXJlY3RpdmVUeXBlcyA/XG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiAodHlwZW9mIGRpcmVjdGl2ZVR5cGVzID09PSAnZnVuY3Rpb24nID8gZGlyZWN0aXZlVHlwZXMoKSA6IGRpcmVjdGl2ZVR5cGVzKVxuICAgICAgICAgICAgICAgIC5tYXAoZXh0cmFjdERpcmVjdGl2ZURlZik7IH0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgZGVmLnBpcGVEZWZzID0gcGlwZVR5cGVzID9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0eXBlb2YgcGlwZVR5cGVzID09PSAnZnVuY3Rpb24nID8gcGlwZVR5cGVzKCkgOiBwaXBlVHlwZXMpLm1hcChleHRyYWN0UGlwZURlZik7IH0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gZXh0cmFjdERpcmVjdGl2ZURlZih0eXBlKSB7XG4gICAgdmFyIGRlZiA9IGdldENvbXBvbmVudERlZih0eXBlKSB8fCBnZXREaXJlY3RpdmVEZWYodHlwZSk7XG4gICAgaWYgKG5nRGV2TW9kZSAmJiAhZGVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIHR5cGUubmFtZSArIFwiJyBpcyBuZWl0aGVyICdDb21wb25lbnRUeXBlJyBvciAnRGlyZWN0aXZlVHlwZScuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gZXh0cmFjdFBpcGVEZWYodHlwZSkge1xuICAgIHZhciBkZWYgPSBnZXRQaXBlRGVmKHR5cGUpO1xuICAgIGlmIChuZ0Rldk1vZGUgJiYgIWRlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyB0eXBlLm5hbWUgKyBcIicgaXMgbm90IGEgJ1BpcGVUeXBlJy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBkZWZpbmVOZ01vZHVsZShkZWYpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBkZWYudHlwZSxcbiAgICAgICAgYm9vdHN0cmFwOiBkZWYuYm9vdHN0cmFwIHx8IEVNUFRZX0FSUkFZLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IGRlZi5kZWNsYXJhdGlvbnMgfHwgRU1QVFlfQVJSQVksXG4gICAgICAgIGltcG9ydHM6IGRlZi5pbXBvcnRzIHx8IEVNUFRZX0FSUkFZLFxuICAgICAgICBleHBvcnRzOiBkZWYuZXhwb3J0cyB8fCBFTVBUWV9BUlJBWSxcbiAgICAgICAgdHJhbnNpdGl2ZUNvbXBpbGVTY29wZXM6IG51bGwsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnRzIGFuIGlucHV0cyBvciBvdXRwdXRzIGxvb2t1cCBzdWNoIHRoYXQgdGhlIGtleXMsIHdoaWNoIHdlcmUgdGhlXG4gKiBtaW5pZmllZCBrZXlzLCBhcmUgcGFydCBvZiB0aGUgdmFsdWVzLCBhbmQgdGhlIHZhbHVlcyBhcmUgcGFyc2VkIHNvIHRoYXRcbiAqIHRoZSBwdWJsaWNOYW1lIG9mIHRoZSBwcm9wZXJ0eSBpcyB0aGUgbmV3IGtleVxuICpcbiAqIGUuZy4gZm9yXG4gKlxuICogYGBgXG4gKiBjbGFzcyBDb21wIHtcbiAqICAgQElucHV0KClcbiAqICAgcHJvcE5hbWUxOiBzdHJpbmc7XG4gKlxuICogICBASW5wdXQoJ3B1YmxpY05hbWUnKVxuICogICBwcm9wTmFtZTI6IG51bWJlcjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgc2VyaWFsaXplZCBhc1xuICpcbiAqIGBgYFxuICoge1xuICogICBhMDogJ3Byb3BOYW1lMScsXG4gKiAgIGIxOiBbJ3B1YmxpY05hbWUnLCAncHJvcE5hbWUyJ10sXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBiZWNvbWVzXG4gKlxuICogYGBgXG4gKiB7XG4gKiAgJ3Byb3BOYW1lMSc6ICdhMCcsXG4gKiAgJ3B1YmxpY05hbWUnOiAnYjEnXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBPcHRpb25hbGx5IHRoZSBmdW5jdGlvbiBjYW4gdGFrZSBgc2Vjb25kYXJ5YCB3aGljaCB3aWxsIHJlc3VsdCBpbjpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAncHJvcE5hbWUxJzogJ2EwJyxcbiAqICAncHJvcE5hbWUyJzogJ2IxJ1xuICogfVxuICogYGBgXG4gKlxuXG4gKi9cbmZ1bmN0aW9uIGludmVydE9iamVjdChvYmosIHNlY29uZGFyeSkge1xuICAgIGlmIChvYmogPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEVNUFRZJDE7XG4gICAgdmFyIG5ld0xvb2t1cCA9IHt9O1xuICAgIGZvciAodmFyIG1pbmlmaWVkS2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG1pbmlmaWVkS2V5KSkge1xuICAgICAgICAgICAgdmFyIHB1YmxpY05hbWUgPSBvYmpbbWluaWZpZWRLZXldO1xuICAgICAgICAgICAgdmFyIGRlY2xhcmVkTmFtZSA9IHB1YmxpY05hbWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwdWJsaWNOYW1lKSkge1xuICAgICAgICAgICAgICAgIGRlY2xhcmVkTmFtZSA9IHB1YmxpY05hbWVbMV07XG4gICAgICAgICAgICAgICAgcHVibGljTmFtZSA9IHB1YmxpY05hbWVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdMb29rdXBbcHVibGljTmFtZV0gPSBtaW5pZmllZEtleTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRhcnkpIHtcbiAgICAgICAgICAgICAgICAoc2Vjb25kYXJ5W2RlY2xhcmVkTmFtZV0gPSBtaW5pZmllZEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0xvb2t1cDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYmFzZSBkZWZpbml0aW9uXG4gKlxuICogIyBFeGFtcGxlXG4gKiBgYGBcbiAqIGNsYXNzIFNob3VsZEJlSW5oZXJpdGVkIHtcbiAqICAgc3RhdGljIG5nQmFzZURlZiA9IGRlZmluZUJhc2Uoe1xuICogICAgICAuLi5cbiAqICAgfSlcbiAqIH1cbiAqIEBwYXJhbSBiYXNlRGVmaW5pdGlvbiBUaGUgYmFzZSBkZWZpbml0aW9uIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQmFzZShiYXNlRGVmaW5pdGlvbikge1xuICAgIHZhciBkZWNsYXJlZElucHV0cyA9IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogaW52ZXJ0T2JqZWN0KGJhc2VEZWZpbml0aW9uLmlucHV0cywgZGVjbGFyZWRJbnB1dHMpLFxuICAgICAgICBkZWNsYXJlZElucHV0czogZGVjbGFyZWRJbnB1dHMsXG4gICAgICAgIG91dHB1dHM6IGludmVydE9iamVjdChiYXNlRGVmaW5pdGlvbi5vdXRwdXRzKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICogIyBFeGFtcGxlXG4gKiBgYGBcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgLy8gR2VuZXJhdGVkIGJ5IEFuZ3VsYXIgVGVtcGxhdGUgQ29tcGlsZXJcbiAqICAgLy8gW1N5bWJvbF0gc3ludGF4IHdpbGwgbm90IGJlIHN1cHBvcnRlZCBieSBUeXBlU2NyaXB0IHVudGlsIHYyLjdcbiAqICAgc3RhdGljIG5nRGlyZWN0aXZlRGVmID0gZGVmaW5lRGlyZWN0aXZlKHtcbiAqICAgICAuLi5cbiAqICAgfSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIGRlZmluZURpcmVjdGl2ZSA9IGRlZmluZUNvbXBvbmVudDtcbi8qKlxuICogQ3JlYXRlIGEgcGlwZSBkZWZpbml0aW9uIG9iamVjdC5cbiAqXG4gKiAjIEV4YW1wbGVcbiAqIGBgYFxuICogY2xhc3MgTXlQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gKiAgIC8vIEdlbmVyYXRlZCBieSBBbmd1bGFyIFRlbXBsYXRlIENvbXBpbGVyXG4gKiAgIHN0YXRpYyBuZ1BpcGVEZWYgPSBkZWZpbmVQaXBlKHtcbiAqICAgICAuLi5cbiAqICAgfSk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBwaXBlRGVmIFBpcGUgZGVmaW5pdGlvbiBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVBpcGUocGlwZURlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHBpcGVEZWYubmFtZSxcbiAgICAgICAgZmFjdG9yeTogcGlwZURlZi5mYWN0b3J5LFxuICAgICAgICBwdXJlOiBwaXBlRGVmLnB1cmUgIT09IGZhbHNlLFxuICAgICAgICBvbkRlc3Ryb3k6IHBpcGVEZWYudHlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgfHwgbnVsbFxuICAgIH07XG59XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZ2V0dGVyIG1ldGhvZHMgcmV0cmlldmUgdGhlIGRlZmluaXRpb24gZm9ybSB0aGUgdHlwZS4gQ3VycmVudGx5IHRoZSByZXRyaWV2YWxcbiAqIGhvbm9ycyBpbmhlcml0YW5jZSwgYnV0IGluIHRoZSBmdXR1cmUgd2UgbWF5IGNoYW5nZSB0aGUgcnVsZSB0byByZXF1aXJlIHRoYXQgZGVmaW5pdGlvbnMgYXJlXG4gKiBleHBsaWNpdC4gVGhpcyB3b3VsZCByZXF1aXJlIHNvbWUgc29ydCBvZiBtaWdyYXRpb24gc3RyYXRlZ3kuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudERlZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVbTkdfQ09NUE9ORU5UX0RFRl0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZURlZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVbTkdfRElSRUNUSVZFX0RFRl0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBpcGVEZWYodHlwZSkge1xuICAgIHJldHVybiB0eXBlW05HX1BJUEVfREVGXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TmdNb2R1bGVEZWYodHlwZSkge1xuICAgIHJldHVybiB0eXBlW05HX01PRFVMRV9ERUZdIHx8IG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGU7XG4oZnVuY3Rpb24gKFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZSkge1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJUb2tlblwiXSA9IDBdID0gXCJUb2tlblwiO1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJBdHRyaWJ1dGVcIl0gPSAxXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlW1IzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtcIkluamVjdG9yXCJdID0gMl0gPSBcIkluamVjdG9yXCI7XG59KShSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUgfHwgKFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZSA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBpbGVyRmFjYWRlKCkge1xuICAgIHZhciBnbG9iYWxOZyA9IF9nbG9iYWwubmc7XG4gICAgaWYgKCFnbG9iYWxOZyB8fCAhZ2xvYmFsTmcuybVjb21waWxlckZhY2FkZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbmd1bGFyIEpJVCBjb21waWxhdGlvbiBmYWlsZWQ6ICdAYW5ndWxhci9jb21waWxlcicgbm90IGxvYWRlZCFcXG5cIiArXG4gICAgICAgICAgICBcIiAgLSBKSVQgY29tcGlsYXRpb24gaXMgZGlzY291cmFnZWQgZm9yIHByb2R1Y3Rpb24gdXNlLWNhc2VzISBDb25zaWRlciBBT1QgbW9kZSBpbnN0ZWFkLlxcblwiICtcbiAgICAgICAgICAgIFwiICAtIERpZCB5b3UgYm9vdHN0cmFwIHVzaW5nICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnIG9yICdAYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXInP1xcblwiICtcbiAgICAgICAgICAgIFwiICAtIEFsdGVybmF0aXZlbHkgcHJvdmlkZSB0aGUgY29tcGlsZXIgd2l0aCAnaW1wb3J0IFxcXCJAYW5ndWxhci9jb21waWxlclxcXCI7JyBiZWZvcmUgYm9vdHN0cmFwcGluZy5cIik7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxOZy7JtWNvbXBpbGVyRmFjYWRlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBhc3NlcnRFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnROb3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRMZXNzVGhhbihhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoYWN0dWFsID49IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRHcmVhdGVyVGhhbihhY3R1YWwsIGV4cGVjdGVkLCBtc2cpIHtcbiAgICBpZiAoYWN0dWFsIDw9IGV4cGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnREZWZpbmVkKGFjdHVhbCwgbXNnKSB7XG4gICAgaWYgKGFjdHVhbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93RXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRDb21wb25lbnRUeXBlKGFjdHVhbCwgbXNnKSB7XG4gICAgaWYgKG1zZyA9PT0gdm9pZCAwKSB7IG1zZyA9ICdUeXBlIHBhc3NlZCBpbiBpcyBub3QgQ29tcG9uZW50VHlwZSwgaXQgZG9lcyBub3QgaGF2ZSBcXCduZ0NvbXBvbmVudERlZlxcJyBwcm9wZXJ0eS4nOyB9XG4gICAgaWYgKCFnZXRDb21wb25lbnREZWYoYWN0dWFsKSkge1xuICAgICAgICB0aHJvd0Vycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0TmdNb2R1bGVUeXBlKGFjdHVhbCwgbXNnKSB7XG4gICAgaWYgKG1zZyA9PT0gdm9pZCAwKSB7IG1zZyA9ICdUeXBlIHBhc3NlZCBpbiBpcyBub3QgTmdNb2R1bGVUeXBlLCBpdCBkb2VzIG5vdCBoYXZlIFxcJ25nTW9kdWxlRGVmXFwnIHByb3BlcnR5Lic7IH1cbiAgICBpZiAoIWdldE5nTW9kdWxlRGVmKGFjdHVhbCkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRocm93RXJyb3IobXNnKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgZGVidWdnZXI7IC8vIExlZnQgaW50ZW50aW9uYWxseSBmb3IgYmV0dGVyIGRlYnVnZ2VyIGV4cGVyaWVuY2UuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQVNTRVJUSU9OIEVSUk9SOiBcIiArIG1zZyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIG1vbmtleS1wYXRjaGVkIG9uIGVsZW1lbnRzLCBjb21wb25lbnRzIGFuZCBkaXJlY3RpdmVzXG4gKi9cbnZhciBNT05LRVlfUEFUQ0hfS0VZX05BTUUgPSAnX19uZ0NvbnRleHRfXyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBTaXplIG9mIExWaWV3RGF0YSdzIGhlYWRlci4gTmVjZXNzYXJ5IHRvIGFkanVzdCBmb3IgaXQgd2hlbiBzZXR0aW5nIHNsb3RzLiAgKi9cbnZhciBIRUFERVJfT0ZGU0VUID0gMTc7XG4vLyBCZWxvdyBhcmUgY29uc3RhbnRzIGZvciBMVmlld0RhdGEgaW5kaWNlcyB0byBoZWxwIHVzIGxvb2sgdXAgTFZpZXdEYXRhIG1lbWJlcnNcbi8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlbWVtYmVyIHRoZSBzcGVjaWZpYyBpbmRpY2VzLlxuLy8gVWdsaWZ5IHdpbGwgaW5saW5lIHRoZXNlIHdoZW4gbWluaWZ5aW5nIHNvIHRoZXJlIHNob3VsZG4ndCBiZSBhIGNvc3QuXG52YXIgVFZJRVcgPSAwO1xudmFyIEZMQUdTID0gMTtcbnZhciBQQVJFTlQgPSAyO1xudmFyIE5FWFQgPSAzO1xudmFyIFFVRVJJRVMgPSA0O1xudmFyIEhPU1QgPSA1O1xudmFyIEhPU1RfTk9ERSA9IDY7XG52YXIgQklORElOR19JTkRFWCA9IDc7XG52YXIgQ0xFQU5VUCA9IDg7XG52YXIgQ09OVEVYVCA9IDk7XG52YXIgSU5KRUNUT1IkMSA9IDEwO1xudmFyIFJFTkRFUkVSID0gMTE7XG52YXIgU0FOSVRJWkVSID0gMTI7XG52YXIgVEFJTCA9IDEzO1xudmFyIENPTlRBSU5FUl9JTkRFWCA9IDE0O1xudmFyIENPTlRFTlRfUVVFUklFUyA9IDE1O1xudmFyIERFQ0xBUkFUSU9OX1ZJRVcgPSAxNjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZGV2TW9kZUVxdWFsKGEsIGIpIHtcbiAgICB2YXIgaXNMaXN0TGlrZUl0ZXJhYmxlQSA9IGlzTGlzdExpa2VJdGVyYWJsZShhKTtcbiAgICB2YXIgaXNMaXN0TGlrZUl0ZXJhYmxlQiA9IGlzTGlzdExpa2VJdGVyYWJsZShiKTtcbiAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlQSAmJiBpc0xpc3RMaWtlSXRlcmFibGVCKSB7XG4gICAgICAgIHJldHVybiBhcmVJdGVyYWJsZXNFcXVhbChhLCBiLCBkZXZNb2RlRXF1YWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlzQU9iamVjdCA9IGEgJiYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIHZhciBpc0JPYmplY3QgPSBiICYmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgPT09ICdmdW5jdGlvbicpO1xuICAgICAgICBpZiAoIWlzTGlzdExpa2VJdGVyYWJsZUEgJiYgaXNBT2JqZWN0ICYmICFpc0xpc3RMaWtlSXRlcmFibGVCICYmIGlzQk9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vc2VJZGVudGljYWwoYSwgYik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXG4gKiByZWZlcmVuY2UgaGFzIG5vdCBjaGFuZ2VkLlxuICpcbiAqIFdyYXBwZWQgdmFsdWVzIGFyZSB1bndyYXBwZWQgYXV0b21hdGljYWxseSBkdXJpbmcgdGhlIGNoYW5nZSBkZXRlY3Rpb24sIGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlXG4gKiBpcyBzdG9yZWQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGlmICh0aGlzLl9sYXRlc3RWYWx1ZSA9PT0gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkge1xuICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gKiAgfSBlbHNlIHtcbiAqICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcbiAqICB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBXcmFwcGVkVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV3JhcHBlZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIHdyYXBwZWQgdmFsdWUuICovXG4gICAgV3JhcHBlZFZhbHVlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBXcmFwcGVkVmFsdWUodmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgdmFsdWUgb2YgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIFJldHVybnMgdGhlIGdpdmVuIGB2YWx1ZWAgd2hlbiBpdCBpcyBub3Qgd3JhcHBlZC5cbiAgICAgKiovXG4gICAgV3JhcHBlZFZhbHVlLnVud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gV3JhcHBlZFZhbHVlLmlzV3JhcHBlZCh2YWx1ZSkgPyB2YWx1ZS53cmFwcGVkIDogdmFsdWU7IH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgd3JhcHBlZCB2YWx1ZS4gKi9cbiAgICBXcmFwcGVkVmFsdWUuaXNXcmFwcGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZTsgfTtcbiAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xufSgpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGJhc2ljIGNoYW5nZSBmcm9tIGEgcHJldmlvdXMgdG8gYSBuZXcgdmFsdWUuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgU2ltcGxlQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0Q2hhbmdlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB0aGlzLmZpcnN0Q2hhbmdlID0gZmlyc3RDaGFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIG5ldyB2YWx1ZSBpcyB0aGUgZmlyc3QgdmFsdWUgYXNzaWduZWQuXG4gICAgICovXG4gICAgU2ltcGxlQ2hhbmdlLnByb3RvdHlwZS5pc0ZpcnN0Q2hhbmdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5maXJzdENoYW5nZTsgfTtcbiAgICByZXR1cm4gU2ltcGxlQ2hhbmdlO1xufSgpKTtcbmZ1bmN0aW9uIGlzTGlzdExpa2VJdGVyYWJsZShvYmopIHtcbiAgICBpZiAoIWlzSnNPYmplY3Qob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAgICAgKCEob2JqIGluc3RhbmNlb2YgTWFwKSAmJiAvLyBKUyBNYXAgYXJlIGl0ZXJhYmxlcyBidXQgcmV0dXJuIGVudHJpZXMgYXMgW2ssIHZdXG4gICAgICAgICAgICBnZXRTeW1ib2xJdGVyYXRvcigpIGluIG9iaik7IC8vIEpTIEl0ZXJhYmxlIGhhdmUgYSBTeW1ib2wuaXRlcmF0b3IgcHJvcFxufVxuZnVuY3Rpb24gYXJlSXRlcmFibGVzRXF1YWwoYSwgYiwgY29tcGFyYXRvcikge1xuICAgIHZhciBpdGVyYXRvcjEgPSBhW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgdmFyIGl0ZXJhdG9yMiA9IGJbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbTEgPSBpdGVyYXRvcjEubmV4dCgpO1xuICAgICAgICB2YXIgaXRlbTIgPSBpdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlbTEuZG9uZSAmJiBpdGVtMi5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpdGVtMS5kb25lIHx8IGl0ZW0yLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY29tcGFyYXRvcihpdGVtMS52YWx1ZSwgaXRlbTIudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVMaXN0TGlrZShvYmosIGZuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm4ob2JqW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gb2JqW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoISgoaXRlbSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgIGZuKGl0ZW0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQmVsb3cgYXJlIGNvbnN0YW50cyBmb3IgTENvbnRhaW5lciBpbmRpY2VzIHRvIGhlbHAgdXMgbG9vayB1cCBMQ29udGFpbmVyIG1lbWJlcnNcbiAqIHdpdGhvdXQgaGF2aW5nIHRvIHJlbWVtYmVyIHRoZSBzcGVjaWZpYyBpbmRpY2VzLlxuICogVWdsaWZ5IHdpbGwgaW5saW5lIHRoZXNlIHdoZW4gbWluaWZ5aW5nIHNvIHRoZXJlIHNob3VsZG4ndCBiZSBhIGNvc3QuXG4gKi9cbnZhciBBQ1RJVkVfSU5ERVggPSAwO1xudmFyIFZJRVdTID0gMTtcbi8vIFBBUkVOVCwgTkVYVCwgUVVFUklFUywgYW5kIEhPU1QgYXJlIGluZGljZXMgMiwgMywgNCwgYW5kIDUuXG4vLyBBcyB3ZSBhbHJlYWR5IGhhdmUgdGhlc2UgY29uc3RhbnRzIGluIExWaWV3RGF0YSwgd2UgZG9uJ3QgbmVlZCB0byByZS1jcmVhdGUgdGhlbS5cbnZhciBOQVRJVkUgPSA2O1xudmFyIFJFTkRFUl9QQVJFTlQgPSA3O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdmFsdWVzIGFyZSBkaWZmZXJlbnQgZnJvbSBhIGNoYW5nZSBkZXRlY3Rpb24gc3RhbmQgcG9pbnQuXG4gKlxuICogQ29uc3RyYWludHMgYXJlIHJlbGF4ZWQgaW4gY2hlY2tOb0NoYW5nZXMgbW9kZS4gU2VlIGBkZXZNb2RlRXF1YWxgIGZvciBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBpc0RpZmZlcmVudChhLCBiLCBjaGVja05vQ2hhbmdlc01vZGUpIHtcbiAgICBpZiAobmdEZXZNb2RlICYmIGNoZWNrTm9DaGFuZ2VzTW9kZSkge1xuICAgICAgICByZXR1cm4gIWRldk1vZGVFcXVhbChhLCBiKTtcbiAgICB9XG4gICAgLy8gTmFOIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZiBzbyB0aGUgZmlyc3RcbiAgICAvLyB0ZXN0IGNoZWNrcyBpZiBib3RoIGEgYW5kIGIgYXJlIG5vdCBOYU5cbiAgICByZXR1cm4gIShhICE9PSBhICYmIGIgIT09IGIpICYmIGEgIT09IGI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkkMSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZhbHVlLm5hbWUgfHwgdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG59XG4vKipcbiAqIEZsYXR0ZW5zIGFuIGFycmF5IGluIG5vbi1yZWN1cnNpdmUgd2F5LiBJbnB1dCBhcnJheXMgYXJlIG5vdCBtb2RpZmllZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gaXRlbS5jb25jYXQobGlzdC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGFueSBgTFZpZXdEYXRhYCBvciBgVERhdGFgLiAqL1xuZnVuY3Rpb24gbG9hZEludGVybmFsKGluZGV4LCBhcnIpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGF0YUluUmFuZ2VJbnRlcm5hbChpbmRleCArIEhFQURFUl9PRkZTRVQsIGFycik7XG4gICAgcmV0dXJuIGFycltpbmRleCArIEhFQURFUl9PRkZTRVRdO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGF0YUluUmFuZ2VJbnRlcm5hbChpbmRleCwgYXJyKSB7XG4gICAgYXNzZXJ0TGVzc1RoYW4oaW5kZXgsIGFyciA/IGFyci5sZW5ndGggOiAwLCAnaW5kZXggZXhwZWN0ZWQgdG8gYmUgYSB2YWxpZCBkYXRhIGluZGV4Jyk7XG59XG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIHNsb3QgaW4gYExWaWV3RGF0YWAgYW5kIHJldHVybnMgdGhlIGVsZW1lbnQgbm9kZS5cbiAqXG4gKiBOb3JtYWxseSwgZWxlbWVudCBub2RlcyBhcmUgc3RvcmVkIGZsYXQsIGJ1dCBpZiB0aGUgbm9kZSBoYXMgc3R5bGVzL2NsYXNzZXMgb24gaXQsXG4gKiBpdCBtaWdodCBiZSB3cmFwcGVkIGluIGEgc3R5bGluZyBjb250ZXh0LiBPciBpZiB0aGF0IG5vZGUgaGFzIGEgZGlyZWN0aXZlIHRoYXQgaW5qZWN0c1xuICogVmlld0NvbnRhaW5lclJlZiwgaXQgbWF5IGJlIHdyYXBwZWQgaW4gYW4gTENvbnRhaW5lci4gT3IgaWYgdGhhdCBub2RlIGlzIGEgY29tcG9uZW50LFxuICogaXQgd2lsbCBiZSB3cmFwcGVkIGluIExWaWV3RGF0YS4gSXQgY291bGQgZXZlbiBoYXZlIGFsbCB0aHJlZSwgc28gd2Uga2VlcCBsb29waW5nXG4gKiB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB0aGF0IGlzbid0IGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgaW5pdGlhbCB2YWx1ZSBpbiBgTFZpZXdEYXRhYFxuICovXG5mdW5jdGlvbiByZWFkRWxlbWVudFZhbHVlKHZhbHVlKSB7XG4gICAgd2hpbGUgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVbSE9TVF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogUmV0cmlldmVzIGFuIGVsZW1lbnQgdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWQgYHZpZXdEYXRhYCwgYnkgdW53cmFwcGluZ1xuICogZnJvbSBhbnkgY29udGFpbmVycywgY29tcG9uZW50IHZpZXdzLCBvciBzdHlsZSBjb250ZXh0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQnlJbmRleChpbmRleCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlYWRFbGVtZW50VmFsdWUoYXJyW2luZGV4ICsgSEVBREVSX09GRlNFVF0pO1xufVxuZnVuY3Rpb24gZ2V0TmF0aXZlQnlUTm9kZSh0Tm9kZSwgaG9zdFZpZXcpIHtcbiAgICByZXR1cm4gcmVhZEVsZW1lbnRWYWx1ZShob3N0Vmlld1t0Tm9kZS5pbmRleF0pO1xufVxuZnVuY3Rpb24gZ2V0VE5vZGUoaW5kZXgsIHZpZXcpIHtcbiAgICByZXR1cm4gdmlld1tUVklFV10uZGF0YVtpbmRleCArIEhFQURFUl9PRkZTRVRdO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Vmlld0J5SW5kZXgobm9kZUluZGV4LCBob3N0Vmlldykge1xuICAgIC8vIENvdWxkIGJlIGFuIExWaWV3RGF0YSBvciBhbiBMQ29udGFpbmVyLiBJZiBMQ29udGFpbmVyLCB1bndyYXAgdG8gZmluZCBMVmlld0RhdGEuXG4gICAgdmFyIHNsb3RWYWx1ZSA9IGhvc3RWaWV3W25vZGVJbmRleF07XG4gICAgcmV0dXJuIHNsb3RWYWx1ZS5sZW5ndGggPj0gSEVBREVSX09GRlNFVCA/IHNsb3RWYWx1ZSA6IHNsb3RWYWx1ZVtIT1NUXTtcbn1cbmZ1bmN0aW9uIGlzQ29udGVudFF1ZXJ5SG9zdCh0Tm9kZSkge1xuICAgIHJldHVybiAodE5vZGUuZmxhZ3MgJiAxNjM4NCAvKiBoYXNDb250ZW50UXVlcnkgKi8pICE9PSAwO1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnQodE5vZGUpIHtcbiAgICByZXR1cm4gKHROb2RlLmZsYWdzICYgNDA5NiAvKiBpc0NvbXBvbmVudCAqLykgPT09IDQwOTYgLyogaXNDb21wb25lbnQgKi87XG59XG5mdW5jdGlvbiBpc0xDb250YWluZXIodmFsdWUpIHtcbiAgICAvLyBTdHlsaW5nIGNvbnRleHRzIGFyZSBhbHNvIGFycmF5cywgYnV0IHRoZWlyIGZpcnN0IGluZGV4IGNvbnRhaW5zIGFuIGVsZW1lbnQgbm9kZVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbQUNUSVZFX0lOREVYXSA9PT0gJ251bWJlcic7XG59XG4vKipcbiAqIFJldHJpZXZlIHRoZSByb290IHZpZXcgZnJvbSBhbnkgY29tcG9uZW50IGJ5IHdhbGtpbmcgdGhlIHBhcmVudCBgTFZpZXdEYXRhYCB1bnRpbFxuICogcmVhY2hpbmcgdGhlIHJvb3QgYExWaWV3RGF0YWAuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCBhbnkgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RWaWV3KHRhcmdldCkge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHRhcmdldCwgJ2NvbXBvbmVudCcpO1xuICAgIHZhciBsVmlld0RhdGEgPSBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQgOiByZWFkUGF0Y2hlZExWaWV3RGF0YSh0YXJnZXQpO1xuICAgIHdoaWxlIChsVmlld0RhdGEgJiYgIShsVmlld0RhdGFbRkxBR1NdICYgNjQgLyogSXNSb290ICovKSkge1xuICAgICAgICBsVmlld0RhdGEgPSBsVmlld0RhdGFbUEFSRU5UXTtcbiAgICB9XG4gICAgcmV0dXJuIGxWaWV3RGF0YTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RDb250ZXh0KHZpZXdPckNvbXBvbmVudCkge1xuICAgIHJldHVybiBnZXRSb290Vmlldyh2aWV3T3JDb21wb25lbnQpW0NPTlRFWFRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb25rZXktcGF0Y2ggdmFsdWUgZGF0YSBwcmVzZW50IG9uIHRoZSB0YXJnZXQgKHdoaWNoIGNvdWxkIGJlXG4gKiBhIGNvbXBvbmVudCwgZGlyZWN0aXZlIG9yIGEgRE9NIG5vZGUpLlxuICovXG5mdW5jdGlvbiByZWFkUGF0Y2hlZERhdGEodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldFtNT05LRVlfUEFUQ0hfS0VZX05BTUVdO1xufVxuZnVuY3Rpb24gcmVhZFBhdGNoZWRMVmlld0RhdGEodGFyZ2V0KSB7XG4gICAgdmFyIHZhbHVlID0gcmVhZFBhdGNoZWREYXRhKHRhcmdldCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogdmFsdWUubFZpZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIFJldHVybnMgdGhlIG1hdGNoaW5nIGBMQ29udGV4dGAgZGF0YSBmb3IgYSBnaXZlbiBET00gbm9kZSwgZGlyZWN0aXZlIG9yIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZXhhbWluZSB0aGUgcHJvdmlkZWQgRE9NIGVsZW1lbnQsIGNvbXBvbmVudCwgb3IgZGlyZWN0aXZlIGluc3RhbmNlXFwnc1xuICogbW9ua2V5LXBhdGNoZWQgcHJvcGVydHkgdG8gZGVyaXZlIHRoZSBgTENvbnRleHRgIGRhdGEuIE9uY2UgY2FsbGVkIHRoZW4gdGhlIG1vbmtleS1wYXRjaGVkXG4gKiB2YWx1ZSB3aWxsIGJlIHRoYXQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYExDb250ZXh0YC5cbiAqXG4gKiBJZiB0aGUgbW9ua2V5LXBhdGNoZWQgdmFsdWUgaXMgdGhlIGBMVmlld0RhdGFgIGluc3RhbmNlIHRoZW4gdGhlIGNvbnRleHQgdmFsdWUgZm9yIHRoYXRcbiAqIHRhcmdldCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSBtb25rZXktcGF0Y2ggcmVmZXJlbmNlIHdpbGwgYmUgdXBkYXRlZC4gVGhlcmVmb3JlIHdoZW4gdGhpc1xuICogZnVuY3Rpb24gaXMgY2FsbGVkIGl0IG1heSBtdXRhdGUgdGhlIHByb3ZpZGVkIGVsZW1lbnRcXCdzLCBjb21wb25lbnRcXCdzIG9yIGFueSBvZiB0aGUgYXNzb2NpYXRlZFxuICogZGlyZWN0aXZlXFwncyBtb25rZXktcGF0Y2ggdmFsdWVzLlxuICpcbiAqIElmIHRoZSBtb25rZXktcGF0Y2ggdmFsdWUgaXMgbm90IGRldGVjdGVkIHRoZW4gdGhlIGNvZGUgd2lsbCB3YWxrIHVwIHRoZSBET00gdW50aWwgYW4gZWxlbWVudFxuICogaXMgZm91bmQgd2hpY2ggY29udGFpbnMgYSBtb25rZXktcGF0Y2ggcmVmZXJlbmNlLiBXaGVuIHRoYXQgb2NjdXJzIHRoZW4gdGhlIHByb3ZpZGVkIGVsZW1lbnRcbiAqIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGEgbmV3IGNvbnRleHQgKHdoaWNoIGlzIHRoZW4gcmV0dXJuZWQpLiBJZiB0aGUgbW9ua2V5LXBhdGNoIHZhbHVlIGlzIG5vdFxuICogZGV0ZWN0ZWQgZm9yIGEgY29tcG9uZW50L2RpcmVjdGl2ZSBpbnN0YW5jZSB0aGVuIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgKGFsbCBjb21wb25lbnRzIGFuZFxuICogZGlyZWN0aXZlcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBtb25rZXktcGF0Y2hlZCBieSBpdnkpLlxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0KHRhcmdldCkge1xuICAgIHZhciBtcFZhbHVlID0gcmVhZFBhdGNoZWREYXRhKHRhcmdldCk7XG4gICAgaWYgKG1wVmFsdWUpIHtcbiAgICAgICAgLy8gb25seSB3aGVuIGl0J3MgYW4gYXJyYXkgaXMgaXQgY29uc2lkZXJlZCBhbiBMVmlld0RhdGEgaW5zdGFuY2VcbiAgICAgICAgLy8gLi4uIG90aGVyd2lzZSBpdCdzIGFuIGFscmVhZHkgY29uc3RydWN0ZWQgTENvbnRleHQgaW5zdGFuY2VcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsVmlld0RhdGEgPSBtcFZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudEluc3RhbmNlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBmaW5kVmlhQ29tcG9uZW50KGxWaWV3RGF0YSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGNvbXBvbmVudCB3YXMgbm90IGZvdW5kIGluIHRoZSBhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RpcmVjdGl2ZUluc3RhbmNlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBmaW5kVmlhRGlyZWN0aXZlKGxWaWV3RGF0YSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZUluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGRpcmVjdGl2ZSB3YXMgbm90IGZvdW5kIGluIHRoZSBhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzID0gZGlzY292ZXJEaXJlY3RpdmVzKG5vZGVJbmRleCwgbFZpZXdEYXRhLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBmaW5kVmlhTmF0aXZlRWxlbWVudChsVmlld0RhdGEsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgZ29hbCBpcyBub3QgdG8gZmlsbCB0aGUgZW50aXJlIGNvbnRleHQgZnVsbCBvZiBkYXRhIGJlY2F1c2UgdGhlIGxvb2t1cHNcbiAgICAgICAgICAgIC8vIGFyZSBleHBlbnNpdmUuIEluc3RlYWQsIG9ubHkgdGhlIHRhcmdldCBkYXRhICh0aGUgZWxlbWVudCwgY29tcG9udGVudCBvclxuICAgICAgICAgICAgLy8gZGlyZWN0aXZlIGRldGFpbHMpIGFyZSBmaWxsZWQgaW50byB0aGUgY29udGV4dC4gSWYgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCB0YXJnZXQgdmFsdWVzIHRoZW4gdGhlIG1pc3NpbmcgdGFyZ2V0IGRhdGEgd2lsbCBiZSBmaWxsZWQgaW4uXG4gICAgICAgICAgICB2YXIgbmF0aXZlID0gcmVhZEVsZW1lbnRWYWx1ZShsVmlld0RhdGFbbm9kZUluZGV4XSk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdDdHggPSByZWFkUGF0Y2hlZERhdGEobmF0aXZlKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gKGV4aXN0aW5nQ3R4ICYmICFBcnJheS5pc0FycmF5KGV4aXN0aW5nQ3R4KSkgP1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ3R4IDpcbiAgICAgICAgICAgICAgICBjcmVhdGVMQ29udGV4dChsVmlld0RhdGEsIG5vZGVJbmRleCwgbmF0aXZlKTtcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGRpc2NvdmVyZWQgdGhlbiB1cGRhdGUgdGhlIG1vbmtleS1wYXRjaFxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb250ZXh0LmNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYXR0YWNoUGF0Y2hEYXRhKGNvbnRleHQuY29tcG9uZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiB0aGUgZGlyZWN0aXZlcyBoYXZlIGJlZW4gZGlzY292ZXJlZCB0aGVuIHVwZGF0ZSB0aGUgbW9ua2V5LXBhdGNoXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlcyAmJiBjb250ZXh0LmRpcmVjdGl2ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBhdGNoRGF0YShkaXJlY3RpdmVzW2ldLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRhY2hQYXRjaERhdGEoY29udGV4dC5uYXRpdmUsIGNvbnRleHQpO1xuICAgICAgICAgICAgbXBWYWx1ZSA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByRWxlbWVudCA9IHRhcmdldDtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERvbUVsZW1lbnQockVsZW1lbnQpO1xuICAgICAgICAvLyBpZiB0aGUgY29udGV4dCBpcyBub3QgZm91bmQgdGhlbiB3ZSBuZWVkIHRvIHRyYXZlcnNlIHVwd2FyZHMgdXAgdGhlIERPTVxuICAgICAgICAvLyB0byBmaW5kIHRoZSBuZWFyZXN0IGVsZW1lbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIG1vbmtleSBwYXRjaGVkIHdpdGggZGF0YVxuICAgICAgICB2YXIgcGFyZW50XzEgPSByRWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudF8xID0gcGFyZW50XzEucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRleHQgPSByZWFkUGF0Y2hlZERhdGEocGFyZW50XzEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbFZpZXdEYXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxWaWV3RGF0YSA9IHBhcmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsVmlld0RhdGEgPSBwYXJlbnRDb250ZXh0LmxWaWV3RGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhlIGVkZ2Ugb2YgdGhlIGFwcCB3YXMgYWxzbyByZWFjaGVkIGhlcmUgdGhyb3VnaCBhbm90aGVyIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gKG1heWJlIGJlY2F1c2UgdGhlIERPTSB3YXMgY2hhbmdlZCBtYW51YWxseSkuXG4gICAgICAgICAgICAgICAgaWYgKCFsVmlld0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGZpbmRWaWFOYXRpdmVFbGVtZW50KGxWaWV3RGF0YSwgckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmUgPSByZWFkRWxlbWVudFZhbHVlKGxWaWV3RGF0YVtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNyZWF0ZUxDb250ZXh0KGxWaWV3RGF0YSwgaW5kZXgsIG5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBhdGNoRGF0YShuYXRpdmUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBtcFZhbHVlID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtcFZhbHVlIHx8IG51bGw7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgaW5zdGFuY2Ugb2YgYSBgTENvbnRleHRgIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTENvbnRleHQobFZpZXdEYXRhLCBub2RlSW5kZXgsIG5hdGl2ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxWaWV3RGF0YTogbFZpZXdEYXRhLFxuICAgICAgICBub2RlSW5kZXg6IG5vZGVJbmRleCwgbmF0aXZlOiBuYXRpdmUsXG4gICAgICAgIGNvbXBvbmVudDogdW5kZWZpbmVkLFxuICAgICAgICBkaXJlY3RpdmVzOiB1bmRlZmluZWQsXG4gICAgICAgIGxvY2FsUmVmczogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIFRha2VzIGEgY29tcG9uZW50IGluc3RhbmNlIGFuZCByZXR1cm5zIHRoZSB2aWV3IGZvciB0aGF0IGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50SW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBjb21wb25lbnQncyB2aWV3XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudFZpZXdCeUluc3RhbmNlKGNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgdmFyIGxWaWV3RGF0YSA9IHJlYWRQYXRjaGVkRGF0YShjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgdmFyIHZpZXc7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobFZpZXdEYXRhKSkge1xuICAgICAgICB2YXIgbm9kZUluZGV4ID0gZmluZFZpYUNvbXBvbmVudChsVmlld0RhdGEsIGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgdmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KG5vZGVJbmRleCwgbFZpZXdEYXRhKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjcmVhdGVMQ29udGV4dChsVmlld0RhdGEsIG5vZGVJbmRleCwgdmlld1tIT1NUXSk7XG4gICAgICAgIGNvbnRleHQuY29tcG9uZW50ID0gY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIGF0dGFjaFBhdGNoRGF0YShjb21wb25lbnRJbnN0YW5jZSwgY29udGV4dCk7XG4gICAgICAgIGF0dGFjaFBhdGNoRGF0YShjb250ZXh0Lm5hdGl2ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY29udGV4dCA9IGxWaWV3RGF0YTtcbiAgICAgICAgdmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KGNvbnRleHQubm9kZUluZGV4LCBjb250ZXh0LmxWaWV3RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3O1xufVxuLyoqXG4gKiBBc3NpZ25zIHRoZSBnaXZlbiBkYXRhIHRvIHRoZSBnaXZlbiB0YXJnZXQgKHdoaWNoIGNvdWxkIGJlIGEgY29tcG9uZW50LFxuICogZGlyZWN0aXZlIG9yIERPTSBub2RlIGluc3RhbmNlKSB1c2luZyBtb25rZXktcGF0Y2hpbmcuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFBhdGNoRGF0YSh0YXJnZXQsIGRhdGEpIHtcbiAgICB0YXJnZXRbTU9OS0VZX1BBVENIX0tFWV9OQU1FXSA9IGRhdGE7XG59XG5mdW5jdGlvbiBpc0NvbXBvbmVudEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLm5nQ29tcG9uZW50RGVmO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RpdmVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5uZ0RpcmVjdGl2ZURlZjtcbn1cbi8qKlxuICogTG9jYXRlcyB0aGUgZWxlbWVudCB3aXRoaW4gdGhlIGdpdmVuIExWaWV3RGF0YSBhbmQgcmV0dXJucyB0aGUgbWF0Y2hpbmcgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmluZFZpYU5hdGl2ZUVsZW1lbnQobFZpZXdEYXRhLCB0YXJnZXQpIHtcbiAgICB2YXIgdE5vZGUgPSBsVmlld0RhdGFbVFZJRVddLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHROb2RlKSB7XG4gICAgICAgIHZhciBuYXRpdmUgPSBnZXROYXRpdmVCeVROb2RlKHROb2RlLCBsVmlld0RhdGEpO1xuICAgICAgICBpZiAobmF0aXZlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0Tm9kZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0Tm9kZSA9IHRyYXZlcnNlTmV4dEVsZW1lbnQodE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIExvY2F0ZXMgdGhlIG5leHQgdE5vZGUgKGNoaWxkLCBzaWJsaW5nIG9yIHBhcmVudCkuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlTmV4dEVsZW1lbnQodE5vZGUpIHtcbiAgICBpZiAodE5vZGUuY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHROb2RlLmNoaWxkO1xuICAgIH1cbiAgICBlbHNlIGlmICh0Tm9kZS5uZXh0KSB7XG4gICAgICAgIHJldHVybiB0Tm9kZS5uZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0Tm9kZS5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHROb2RlLnBhcmVudC5uZXh0IHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBMb2NhdGVzIHRoZSBjb21wb25lbnQgd2l0aGluIHRoZSBnaXZlbiBMVmlld0RhdGEgYW5kIHJldHVybnMgdGhlIG1hdGNoaW5nIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGZpbmRWaWFDb21wb25lbnQobFZpZXdEYXRhLCBjb21wb25lbnRJbnN0YW5jZSkge1xuICAgIHZhciBjb21wb25lbnRJbmRpY2VzID0gbFZpZXdEYXRhW1RWSUVXXS5jb21wb25lbnRzO1xuICAgIGlmIChjb21wb25lbnRJbmRpY2VzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRDb21wb25lbnRJbmRleCA9IGNvbXBvbmVudEluZGljZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KGVsZW1lbnRDb21wb25lbnRJbmRleCwgbFZpZXdEYXRhKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRWaWV3W0NPTlRFWFRdID09PSBjb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q29tcG9uZW50SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByb290Q29tcG9uZW50VmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KEhFQURFUl9PRkZTRVQsIGxWaWV3RGF0YSk7XG4gICAgICAgIHZhciByb290Q29tcG9uZW50ID0gcm9vdENvbXBvbmVudFZpZXdbQ09OVEVYVF07XG4gICAgICAgIGlmIChyb290Q29tcG9uZW50ID09PSBjb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIGRlYWxpbmcgd2l0aCB0aGUgcm9vdCBlbGVtZW50IGhlcmUgdGhlcmVmb3JlIHdlIGtub3cgdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgdGhlIHZlcnkgZmlyc3QgZWxlbWVudCBhZnRlciB0aGUgSEVBREVSIGRhdGEgaW4gdGhlIGxWaWV3XG4gICAgICAgICAgICByZXR1cm4gSEVBREVSX09GRlNFVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIExvY2F0ZXMgdGhlIGRpcmVjdGl2ZSB3aXRoaW4gdGhlIGdpdmVuIExWaWV3RGF0YSBhbmQgcmV0dXJucyB0aGUgbWF0Y2hpbmcgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmluZFZpYURpcmVjdGl2ZShsVmlld0RhdGEsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgLy8gaWYgYSBkaXJlY3RpdmUgaXMgbW9ua2V5IHBhdGNoZWQgdGhlbiBpdCB3aWxsIChieSBkZWZhdWx0KVxuICAgIC8vIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIExWaWV3RGF0YSBvZiB0aGUgY3VycmVudCB2aWV3LiBUaGVcbiAgICAvLyBlbGVtZW50IGJvdW5kIHRvIHRoZSBkaXJlY3RpdmUgYmVpbmcgc2VhcmNoIGxpdmVzIHNvbWV3aGVyZVxuICAgIC8vIGluIHRoZSB2aWV3IGRhdGEuIFdlIGxvb3AgdGhyb3VnaCB0aGUgbm9kZXMgYW5kIGNoZWNrIHRoZWlyXG4gICAgLy8gbGlzdCBvZiBkaXJlY3RpdmVzIGZvciB0aGUgaW5zdGFuY2UuXG4gICAgdmFyIHROb2RlID0gbFZpZXdEYXRhW1RWSUVXXS5maXJzdENoaWxkO1xuICAgIHdoaWxlICh0Tm9kZSkge1xuICAgICAgICB2YXIgZGlyZWN0aXZlSW5kZXhTdGFydCA9IGdldERpcmVjdGl2ZVN0YXJ0SW5kZXgodE5vZGUpO1xuICAgICAgICB2YXIgZGlyZWN0aXZlSW5kZXhFbmQgPSBnZXREaXJlY3RpdmVFbmRJbmRleCh0Tm9kZSwgZGlyZWN0aXZlSW5kZXhTdGFydCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBkaXJlY3RpdmVJbmRleFN0YXJ0OyBpIDwgZGlyZWN0aXZlSW5kZXhFbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxWaWV3RGF0YVtpXSA9PT0gZGlyZWN0aXZlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdE5vZGUuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdE5vZGUgPSB0cmF2ZXJzZU5leHRFbGVtZW50KHROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gYXNzZXJ0RG9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgYXNzZXJ0RXF1YWwoZWxlbWVudC5ub2RlVHlwZSwgMSwgJ1RoZSBwcm92aWRlZCB2YWx1ZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGFuIEhUTUxFbGVtZW50Jyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGRpcmVjdGl2ZXMgZXh0cmFjdGVkIGZyb20gdGhlIGdpdmVuIHZpZXcgYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBsaXN0IG9mIGRpcmVjdGl2ZSBpbmRleCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIG5vZGVJbmRleCBUaGUgbm9kZSBpbmRleFxuICogQHBhcmFtIGxWaWV3RGF0YSBUaGUgdGFyZ2V0IHZpZXcgZGF0YVxuICogQHBhcmFtIGluY2x1ZGVDb21wb25lbnRzIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgY29tcG9uZW50cyBpbiByZXR1cm5lZCBkaXJlY3RpdmVzXG4gKi9cbmZ1bmN0aW9uIGRpc2NvdmVyRGlyZWN0aXZlcyhub2RlSW5kZXgsIGxWaWV3RGF0YSwgaW5jbHVkZUNvbXBvbmVudHMpIHtcbiAgICB2YXIgdE5vZGUgPSBsVmlld0RhdGFbVFZJRVddLmRhdGFbbm9kZUluZGV4XTtcbiAgICB2YXIgZGlyZWN0aXZlU3RhcnRJbmRleCA9IGdldERpcmVjdGl2ZVN0YXJ0SW5kZXgodE5vZGUpO1xuICAgIHZhciBkaXJlY3RpdmVFbmRJbmRleCA9IGdldERpcmVjdGl2ZUVuZEluZGV4KHROb2RlLCBkaXJlY3RpdmVTdGFydEluZGV4KTtcbiAgICBpZiAoIWluY2x1ZGVDb21wb25lbnRzICYmIHROb2RlLmZsYWdzICYgNDA5NiAvKiBpc0NvbXBvbmVudCAqLylcbiAgICAgICAgZGlyZWN0aXZlU3RhcnRJbmRleCsrO1xuICAgIHJldHVybiBsVmlld0RhdGEuc2xpY2UoZGlyZWN0aXZlU3RhcnRJbmRleCwgZGlyZWN0aXZlRW5kSW5kZXgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIG9mIGxvY2FsIHJlZmVyZW5jZXMgKGxvY2FsIHJlZmVyZW5jZSBuYW1lID0+IGVsZW1lbnQgb3IgZGlyZWN0aXZlIGluc3RhbmNlKSB0aGF0XG4gKiBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRpc2NvdmVyTG9jYWxSZWZzKGxWaWV3RGF0YSwgbm9kZUluZGV4KSB7XG4gICAgdmFyIHROb2RlID0gbFZpZXdEYXRhW1RWSUVXXS5kYXRhW25vZGVJbmRleF07XG4gICAgaWYgKHROb2RlICYmIHROb2RlLmxvY2FsTmFtZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHROb2RlLmxvY2FsTmFtZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFJlZk5hbWUgPSB0Tm9kZS5sb2NhbE5hbWVzW2ldO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluZGV4ID0gdE5vZGUubG9jYWxOYW1lc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHRbbG9jYWxSZWZOYW1lXSA9XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlSW5kZXggPT09IC0xID8gZ2V0TmF0aXZlQnlUTm9kZSh0Tm9kZSwgbFZpZXdEYXRhKSA6IGxWaWV3RGF0YVtkaXJlY3RpdmVJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVTdGFydEluZGV4KHROb2RlKSB7XG4gICAgLy8gdGhlIHROb2RlIGluc3RhbmNlcyBzdG9yZSBhIGZsYWcgdmFsdWUgd2hpY2ggdGhlbiBoYXMgYVxuICAgIC8vIHBvaW50ZXIgd2hpY2ggdGVsbHMgdGhlIHN0YXJ0aW5nIGluZGV4IG9mIHdoZXJlIGFsbCB0aGVcbiAgICAvLyBhY3RpdmUgZGlyZWN0aXZlcyBhcmUgaW4gdGhlIG1hc3RlciBkaXJlY3RpdmUgYXJyYXlcbiAgICByZXR1cm4gdE5vZGUuZmxhZ3MgPj4gMTUgLyogRGlyZWN0aXZlU3RhcnRpbmdJbmRleFNoaWZ0ICovO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlRW5kSW5kZXgodE5vZGUsIHN0YXJ0SW5kZXgpIHtcbiAgICAvLyBUaGUgZW5kIHZhbHVlIGlzIGFsc28gYSBwYXJ0IG9mIHRoZSBzYW1lIGZsYWdcbiAgICAvLyAoc2VlIGBUTm9kZUZsYWdzYCB0byBzZWUgaG93IHRoZSBmbGFnIGJpdCBzaGlmdGluZ1xuICAgIC8vIHZhbHVlcyBhcmUgdXNlZCkuXG4gICAgdmFyIGNvdW50ID0gdE5vZGUuZmxhZ3MgJiA0MDk1IC8qIERpcmVjdGl2ZUNvdW50TWFzayAqLztcbiAgICByZXR1cm4gY291bnQgPyAoc3RhcnRJbmRleCArIGNvdW50KSA6IC0xO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRlbXBsYXRlIHBhc3MsIGFueSBuZ09uSW5pdCBvciBuZ0RvQ2hlY2sgaG9va3Mgd2lsbCBiZSBxdWV1ZWQgaW50b1xuICogVFZpZXcuaW5pdEhvb2tzIGR1cmluZyBkaXJlY3RpdmVDcmVhdGUuXG4gKlxuICogVGhlIGRpcmVjdGl2ZSBpbmRleCBhbmQgaG9vayB0eXBlIGFyZSBlbmNvZGVkIGludG8gb25lIG51bWJlciAoMXN0IGJpdDogdHlwZSwgcmVtYWluaW5nIGJpdHM6XG4gKiBkaXJlY3RpdmUgaW5kZXgpLCB0aGVuIHNhdmVkIGluIHRoZSBldmVuIGluZGljZXMgb2YgdGhlIGluaXRIb29rcyBhcnJheS4gVGhlIG9kZCBpbmRpY2VzXG4gKiBob2xkIHRoZSBob29rIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICpcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGRpcmVjdGl2ZSBpbiBMVmlld0RhdGFcbiAqIEBwYXJhbSBob29rcyBUaGUgc3RhdGljIGhvb2tzIG1hcCBvbiB0aGUgZGlyZWN0aXZlIGRlZlxuICogQHBhcmFtIHRWaWV3IFRoZSBjdXJyZW50IFRWaWV3XG4gKi9cbmZ1bmN0aW9uIHF1ZXVlSW5pdEhvb2tzKGluZGV4LCBvbkluaXQsIGRvQ2hlY2ssIHRWaWV3KSB7XG4gICAgbmdEZXZNb2RlICYmXG4gICAgICAgIGFzc2VydEVxdWFsKHRWaWV3LmZpcnN0VGVtcGxhdGVQYXNzLCB0cnVlLCAnU2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGZpcnN0IHRlbXBsYXRlIHBhc3MnKTtcbiAgICBpZiAob25Jbml0KSB7XG4gICAgICAgICh0Vmlldy5pbml0SG9va3MgfHwgKHRWaWV3LmluaXRIb29rcyA9IFtdKSkucHVzaChpbmRleCwgb25Jbml0KTtcbiAgICB9XG4gICAgaWYgKGRvQ2hlY2spIHtcbiAgICAgICAgKHRWaWV3LmluaXRIb29rcyB8fCAodFZpZXcuaW5pdEhvb2tzID0gW10pKS5wdXNoKGluZGV4LCBkb0NoZWNrKTtcbiAgICAgICAgKHRWaWV3LmNoZWNrSG9va3MgfHwgKHRWaWV3LmNoZWNrSG9va3MgPSBbXSkpLnB1c2goaW5kZXgsIGRvQ2hlY2spO1xuICAgIH1cbn1cbi8qKlxuICogTG9vcHMgdGhyb3VnaCB0aGUgZGlyZWN0aXZlcyBvbiBhIG5vZGUgYW5kIHF1ZXVlcyBhbGwgdGhlaXIgaG9va3MgZXhjZXB0IG5nT25Jbml0XG4gKiBhbmQgbmdEb0NoZWNrLCB3aGljaCBhcmUgcXVldWVkIHNlcGFyYXRlbHkgaW4gZGlyZWN0aXZlQ3JlYXRlLlxuICovXG5mdW5jdGlvbiBxdWV1ZUxpZmVjeWNsZUhvb2tzKGZsYWdzLCB0Vmlldykge1xuICAgIGlmICh0Vmlldy5maXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBmbGFncyA+PiAxNSAvKiBEaXJlY3RpdmVTdGFydGluZ0luZGV4U2hpZnQgKi87XG4gICAgICAgIHZhciBjb3VudCA9IGZsYWdzICYgNDA5NSAvKiBEaXJlY3RpdmVDb3VudE1hc2sgKi87XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgICAgICAvLyBJdCdzIG5lY2Vzc2FyeSB0byBsb29wIHRocm91Z2ggdGhlIGRpcmVjdGl2ZXMgYXQgZWxlbWVudEVuZCgpIChyYXRoZXIgdGhhbiBwcm9jZXNzaW5nIGluXG4gICAgICAgIC8vIGRpcmVjdGl2ZUNyZWF0ZSkgc28gd2UgY2FuIHByZXNlcnZlIHRoZSBjdXJyZW50IGhvb2sgb3JkZXIuIENvbnRlbnQsIHZpZXcsIGFuZCBkZXN0cm95XG4gICAgICAgIC8vIGhvb2tzIGZvciBwcm9qZWN0ZWQgY29tcG9uZW50cyBhbmQgZGlyZWN0aXZlcyBtdXN0IGJlIGNhbGxlZCAqYmVmb3JlKiB0aGVpciBob3N0cy5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB0Vmlldy5kYXRhW2ldO1xuICAgICAgICAgICAgcXVldWVDb250ZW50SG9va3MoZGVmLCB0VmlldywgaSk7XG4gICAgICAgICAgICBxdWV1ZVZpZXdIb29rcyhkZWYsIHRWaWV3LCBpKTtcbiAgICAgICAgICAgIHF1ZXVlRGVzdHJveUhvb2tzKGRlZiwgdFZpZXcsIGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIFF1ZXVlcyBhZnRlckNvbnRlbnRJbml0IGFuZCBhZnRlckNvbnRlbnRDaGVja2VkIGhvb2tzIG9uIFRWaWV3ICovXG5mdW5jdGlvbiBxdWV1ZUNvbnRlbnRIb29rcyhkZWYsIHRWaWV3LCBpKSB7XG4gICAgaWYgKGRlZi5hZnRlckNvbnRlbnRJbml0KSB7XG4gICAgICAgICh0Vmlldy5jb250ZW50SG9va3MgfHwgKHRWaWV3LmNvbnRlbnRIb29rcyA9IFtdKSkucHVzaChpLCBkZWYuYWZ0ZXJDb250ZW50SW5pdCk7XG4gICAgfVxuICAgIGlmIChkZWYuYWZ0ZXJDb250ZW50Q2hlY2tlZCkge1xuICAgICAgICAodFZpZXcuY29udGVudEhvb2tzIHx8ICh0Vmlldy5jb250ZW50SG9va3MgPSBbXSkpLnB1c2goaSwgZGVmLmFmdGVyQ29udGVudENoZWNrZWQpO1xuICAgICAgICAodFZpZXcuY29udGVudENoZWNrSG9va3MgfHwgKHRWaWV3LmNvbnRlbnRDaGVja0hvb2tzID0gW10pKS5wdXNoKGksIGRlZi5hZnRlckNvbnRlbnRDaGVja2VkKTtcbiAgICB9XG59XG4vKiogUXVldWVzIGFmdGVyVmlld0luaXQgYW5kIGFmdGVyVmlld0NoZWNrZWQgaG9va3Mgb24gVFZpZXcgKi9cbmZ1bmN0aW9uIHF1ZXVlVmlld0hvb2tzKGRlZiwgdFZpZXcsIGkpIHtcbiAgICBpZiAoZGVmLmFmdGVyVmlld0luaXQpIHtcbiAgICAgICAgKHRWaWV3LnZpZXdIb29rcyB8fCAodFZpZXcudmlld0hvb2tzID0gW10pKS5wdXNoKGksIGRlZi5hZnRlclZpZXdJbml0KTtcbiAgICB9XG4gICAgaWYgKGRlZi5hZnRlclZpZXdDaGVja2VkKSB7XG4gICAgICAgICh0Vmlldy52aWV3SG9va3MgfHwgKHRWaWV3LnZpZXdIb29rcyA9IFtdKSkucHVzaChpLCBkZWYuYWZ0ZXJWaWV3Q2hlY2tlZCk7XG4gICAgICAgICh0Vmlldy52aWV3Q2hlY2tIb29rcyB8fCAodFZpZXcudmlld0NoZWNrSG9va3MgPSBbXSkpLnB1c2goaSwgZGVmLmFmdGVyVmlld0NoZWNrZWQpO1xuICAgIH1cbn1cbi8qKiBRdWV1ZXMgb25EZXN0cm95IGhvb2tzIG9uIFRWaWV3ICovXG5mdW5jdGlvbiBxdWV1ZURlc3Ryb3lIb29rcyhkZWYsIHRWaWV3LCBpKSB7XG4gICAgaWYgKGRlZi5vbkRlc3Ryb3kgIT0gbnVsbCkge1xuICAgICAgICAodFZpZXcuZGVzdHJveUhvb2tzIHx8ICh0Vmlldy5kZXN0cm95SG9va3MgPSBbXSkpLnB1c2goaSwgZGVmLm9uRGVzdHJveSk7XG4gICAgfVxufVxuLyoqXG4gKiBDYWxscyBvbkluaXQgYW5kIGRvQ2hlY2sgY2FsbHMgaWYgdGhleSBoYXZlbid0IGFscmVhZHkgYmVlbiBjYWxsZWQuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWaWV3IFRoZSBjdXJyZW50IHZpZXdcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZUluaXRIb29rcyhjdXJyZW50VmlldywgdFZpZXcsIGNyZWF0aW9uTW9kZSkge1xuICAgIGlmIChjdXJyZW50Vmlld1tGTEFHU10gJiAxNiAvKiBSdW5Jbml0ICovKSB7XG4gICAgICAgIGV4ZWN1dGVIb29rcyhjdXJyZW50VmlldywgdFZpZXcuaW5pdEhvb2tzLCB0Vmlldy5jaGVja0hvb2tzLCBjcmVhdGlvbk1vZGUpO1xuICAgICAgICBjdXJyZW50Vmlld1tGTEFHU10gJj0gfjE2IC8qIFJ1bkluaXQgKi87XG4gICAgfVxufVxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFmdGVyVmlld0luaXQgYW5kIGFmdGVyVmlld0NoZWNrZWQgZnVuY3Rpb25zIGFuZCBjYWxscyB0aGVtLlxuICpcbiAqIEBwYXJhbSBjdXJyZW50VmlldyBUaGUgY3VycmVudCB2aWV3XG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVIb29rcyhkYXRhLCBhbGxIb29rcywgY2hlY2tIb29rcywgY3JlYXRpb25Nb2RlKSB7XG4gICAgdmFyIGhvb2tzVG9DYWxsID0gY3JlYXRpb25Nb2RlID8gYWxsSG9va3MgOiBjaGVja0hvb2tzO1xuICAgIGlmIChob29rc1RvQ2FsbCkge1xuICAgICAgICBjYWxsSG9va3MoZGF0YSwgaG9va3NUb0NhbGwpO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsbHMgbGlmZWN5Y2xlIGhvb2tzIHdpdGggdGhlaXIgY29udGV4dHMsIHNraXBwaW5nIGluaXQgaG9va3MgaWYgaXQncyBub3RcbiAqIGNyZWF0aW9uIG1vZGUuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWaWV3IFRoZSBjdXJyZW50IHZpZXdcbiAqIEBwYXJhbSBhcnIgVGhlIGFycmF5IGluIHdoaWNoIHRoZSBob29rcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gY2FsbEhvb2tzKGN1cnJlbnRWaWV3LCBhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBhcnJbaSArIDFdLmNhbGwoY3VycmVudFZpZXdbYXJyW2ldXSk7XG4gICAgfVxufVxuXG4vKiogQ2FsbGVkIHdoZW4gZGlyZWN0aXZlcyBpbmplY3QgZWFjaCBvdGhlciAoY3JlYXRpbmcgYSBjaXJjdWxhciBkZXBlbmRlbmN5KSAqL1xuZnVuY3Rpb24gdGhyb3dDeWNsaWNEZXBlbmRlbmN5RXJyb3IodG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4pO1xufVxuLyoqIENhbGxlZCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBjb21wb25lbnQgc2VsZWN0b3JzIHRoYXQgbWF0Y2ggYSBnaXZlbiBub2RlICovXG5mdW5jdGlvbiB0aHJvd011bHRpcGxlQ29tcG9uZW50RXJyb3IodE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aXBsZSBjb21wb25lbnRzIG1hdGNoIG5vZGUgd2l0aCB0YWduYW1lIFwiICsgdE5vZGUudGFnTmFtZSk7XG59XG4vKiogVGhyb3dzIGFuIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJDaGVja2VkIGVycm9yIGlmIGNoZWNrTm9DaGFuZ2VzIG1vZGUgaXMgb24uICovXG5mdW5jdGlvbiB0aHJvd0Vycm9ySWZOb0NoYW5nZXNNb2RlKGNyZWF0aW9uTW9kZSwgY2hlY2tOb0NoYW5nZXNNb2RlLCBvbGRWYWx1ZSwgY3VyclZhbHVlKSB7XG4gICAgaWYgKGNoZWNrTm9DaGFuZ2VzTW9kZSkge1xuICAgICAgICB2YXIgbXNnID0gXCJFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yOiBFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJy5cIjtcbiAgICAgICAgaWYgKGNyZWF0aW9uTW9kZSkge1xuICAgICAgICAgICAgbXNnICs9XG4gICAgICAgICAgICAgICAgXCIgSXQgc2VlbXMgbGlrZSB0aGUgdmlldyBoYXMgYmVlbiBjcmVhdGVkIGFmdGVyIGl0cyBwYXJlbnQgYW5kIGl0cyBjaGlsZHJlbiBoYXZlIGJlZW4gZGlydHkgY2hlY2tlZC5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIEhhcyBpdCBiZWVuIGNyZWF0ZWQgaW4gYSBjaGFuZ2UgZGV0ZWN0aW9uIGhvb2sgP1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGluY2x1ZGUgZGVidWcgY29udGV4dFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUTk9ERSA9IDg7XG52YXIgUEFSRU5UX0lOSkVDVE9SID0gODtcbnZhciBJTkpFQ1RPUl9TSVpFID0gOTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE5HX1BST0pFQ1RfQVNfQVRUUl9OQU1FID0gJ25nUHJvamVjdEFzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gVE9ETzogY2xlYW51cCBvbmNlIHRoZSBjb2RlIGlzIG1lcmdlZCBpbiBhbmd1bGFyL2FuZ3VsYXJcbnZhciBSZW5kZXJlclN0eWxlRmxhZ3MzO1xuKGZ1bmN0aW9uIChSZW5kZXJlclN0eWxlRmxhZ3MzKSB7XG4gICAgUmVuZGVyZXJTdHlsZUZsYWdzM1tSZW5kZXJlclN0eWxlRmxhZ3MzW1wiSW1wb3J0YW50XCJdID0gMV0gPSBcIkltcG9ydGFudFwiO1xuICAgIFJlbmRlcmVyU3R5bGVGbGFnczNbUmVuZGVyZXJTdHlsZUZsYWdzM1tcIkRhc2hDYXNlXCJdID0gMl0gPSBcIkRhc2hDYXNlXCI7XG59KShSZW5kZXJlclN0eWxlRmxhZ3MzIHx8IChSZW5kZXJlclN0eWxlRmxhZ3MzID0ge30pKTtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGByZW5kZXJlcmAgaXMgYSBgUHJvY2VkdXJhbFJlbmRlcmVyM2AgKi9cbmZ1bmN0aW9uIGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgcmV0dXJuICEhKHJlbmRlcmVyLmxpc3Rlbik7XG59XG52YXIgZG9tUmVuZGVyZXJGYWN0b3J5MyA9IHtcbiAgICBjcmVhdGVSZW5kZXJlcjogZnVuY3Rpb24gKGhvc3RFbGVtZW50LCByZW5kZXJlclR5cGUpIHsgcmV0dXJuIGRvY3VtZW50OyB9XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZSh0Tm9kZSwgdHlwZSkge1xuICAgIGFzc2VydERlZmluZWQodE5vZGUsICdzaG91bGQgYmUgY2FsbGVkIHdpdGggYSBUTm9kZScpO1xuICAgIGFzc2VydEVxdWFsKHROb2RlLnR5cGUsIHR5cGUsIFwic2hvdWxkIGJlIGEgXCIgKyB0eXBlTmFtZSh0eXBlKSk7XG59XG5mdW5jdGlvbiBhc3NlcnROb2RlT2ZQb3NzaWJsZVR5cGVzKHROb2RlKSB7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdHlwZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGFzc2VydERlZmluZWQodE5vZGUsICdzaG91bGQgYmUgY2FsbGVkIHdpdGggYSBUTm9kZScpO1xuICAgIHZhciBmb3VuZCA9IHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHROb2RlLnR5cGUgPT09IHR5cGU7IH0pO1xuICAgIGFzc2VydEVxdWFsKGZvdW5kLCB0cnVlLCBcIlNob3VsZCBiZSBvbmUgb2YgXCIgKyB0eXBlcy5tYXAodHlwZU5hbWUpLmpvaW4oJywgJykgKyBcIiBidXQgZ290IFwiICsgdHlwZU5hbWUodE5vZGUudHlwZSkpO1xufVxuZnVuY3Rpb24gdHlwZU5hbWUodHlwZSkge1xuICAgIGlmICh0eXBlID09IDEgLyogUHJvamVjdGlvbiAqLylcbiAgICAgICAgcmV0dXJuICdQcm9qZWN0aW9uJztcbiAgICBpZiAodHlwZSA9PSAwIC8qIENvbnRhaW5lciAqLylcbiAgICAgICAgcmV0dXJuICdDb250YWluZXInO1xuICAgIGlmICh0eXBlID09IDIgLyogVmlldyAqLylcbiAgICAgICAgcmV0dXJuICdWaWV3JztcbiAgICBpZiAodHlwZSA9PSAzIC8qIEVsZW1lbnQgKi8pXG4gICAgICAgIHJldHVybiAnRWxlbWVudCc7XG4gICAgaWYgKHR5cGUgPT0gNCAvKiBFbGVtZW50Q29udGFpbmVyICovKVxuICAgICAgICByZXR1cm4gJ0VsZW1lbnRDb250YWluZXInO1xuICAgIHJldHVybiAnPHVua25vd24+Jztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogUmV0cmlldmVzIHRoZSBwYXJlbnQgZWxlbWVudCBvZiBhIGdpdmVuIG5vZGUuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROYXRpdmUodE5vZGUsIGN1cnJlbnRWaWV3KSB7XG4gICAgcmV0dXJuIHROb2RlLnBhcmVudCA9PSBudWxsID8gZ2V0SG9zdE5hdGl2ZShjdXJyZW50VmlldykgOlxuICAgICAgICBnZXROYXRpdmVCeVROb2RlKHROb2RlLnBhcmVudCwgY3VycmVudFZpZXcpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBob3N0IGVsZW1lbnQgZ2l2ZW4gYSB2aWV3LiBXaWxsIHJldHVybiBudWxsIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgYW4gZW1iZWRkZWQgdmlldyxcbiAqIHdoaWNoIGRvZXMgbm90IGhhdmUgYSBob3N0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEhvc3ROYXRpdmUoY3VycmVudFZpZXcpIHtcbiAgICB2YXIgaG9zdFROb2RlID0gY3VycmVudFZpZXdbSE9TVF9OT0RFXTtcbiAgICByZXR1cm4gaG9zdFROb2RlICYmIGhvc3RUTm9kZS50eXBlICE9PSAyIC8qIFZpZXcgKi8gP1xuICAgICAgICBnZXROYXRpdmVCeVROb2RlKGhvc3RUTm9kZSwgY3VycmVudFZpZXdbUEFSRU5UXSkgOlxuICAgICAgICBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TENvbnRhaW5lcih0Tm9kZSwgZW1iZWRkZWRWaWV3KSB7XG4gICAgaWYgKHROb2RlLmluZGV4ID09PSAtMSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZHluYW1pY2FsbHkgY3JlYXRlZCB2aWV3IGluc2lkZSBhIGR5bmFtaWMgY29udGFpbmVyLlxuICAgICAgICAvLyBJZiB0aGUgaG9zdCBpbmRleCBpcyAtMSwgdGhlIHZpZXcgaGFzIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZCwgc28gaXQgaGFzIG5vIHBhcmVudC5cbiAgICAgICAgdmFyIGNvbnRhaW5lckhvc3RJbmRleCA9IGVtYmVkZGVkVmlld1tDT05UQUlORVJfSU5ERVhdO1xuICAgICAgICByZXR1cm4gY29udGFpbmVySG9zdEluZGV4ID4gLTEgPyBlbWJlZGRlZFZpZXdbUEFSRU5UXVtjb250YWluZXJIb3N0SW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBpbmxpbmUgdmlldyBub2RlIChlLmcuIGVtYmVkZGVkVmlld1N0YXJ0KVxuICAgICAgICByZXR1cm4gZW1iZWRkZWRWaWV3W1BBUkVOVF1bdE5vZGUucGFyZW50LmluZGV4XTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyByZW5kZXIgcGFyZW50IGZvciBhIGdpdmVuIHZpZXcuXG4gKiBNaWdodCBiZSBudWxsIGlmIGEgdmlldyBpcyBub3QgeWV0IGF0dGFjaGVkIHRvIGFueSBjb250YWluZXIuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRhaW5lclJlbmRlclBhcmVudCh0Vmlld05vZGUsIHZpZXcpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZ2V0TENvbnRhaW5lcih0Vmlld05vZGUsIHZpZXcpO1xuICAgIHJldHVybiBjb250YWluZXIgPyBjb250YWluZXJbUkVOREVSX1BBUkVOVF0gOiBudWxsO1xufVxuLyoqXG4gKiBTdGFjayB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgcHJvamVjdGlvbiBub2RlcyBpbiB3YWxrVE5vZGVUcmVlLlxuICpcbiAqIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGNyZWF0ZWQgb3V0c2lkZSBvZiB3YWxrVE5vZGVUcmVlIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAqIGEgbmV3IGFycmF5IGVhY2ggdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJbnN0ZWFkIHRoZSBhcnJheSB3aWxsIGJlXG4gKiByZS11c2VkIGJ5IGVhY2ggaW52b2NhdGlvbi4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVlbnRyYW50LlxuICovXG52YXIgcHJvamVjdGlvbk5vZGVTdGFjayA9IFtdO1xuLyoqXG4gKiBXYWxrcyBhIHRyZWUgb2YgVE5vZGVzLCBhcHBseWluZyBhIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSBlbGVtZW50IG5vZGVzLCBlaXRoZXIgb25seSBvbiB0aGUgZmlyc3RcbiAqIG9uZSBmb3VuZCwgb3Igb24gYWxsIG9mIHRoZW0uXG4gKlxuICogQHBhcmFtIHZpZXdUb1dhbGsgdGhlIHZpZXcgdG8gd2Fsa1xuICogQHBhcmFtIGFjdGlvbiBpZGVudGlmaWVzIHRoZSBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIG9uIHRoZSBlbGVtZW50c1xuICogQHBhcmFtIHJlbmRlcmVyIHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICogQHBhcmFtIHJlbmRlclBhcmVudCBPcHRpb25hbCB0aGUgcmVuZGVyIHBhcmVudCBub2RlIHRvIGJlIHNldCBpbiBhbGwgTENvbnRhaW5lcnMgZm91bmQsXG4gKiByZXF1aXJlZCBmb3IgYWN0aW9uIG1vZGVzIEluc2VydCBhbmQgRGVzdHJveS5cbiAqIEBwYXJhbSBiZWZvcmVOb2RlIE9wdGlvbmFsIHRoZSBub2RlIGJlZm9yZSB3aGljaCBlbGVtZW50cyBzaG91bGQgYmUgYWRkZWQsIHJlcXVpcmVkIGZvciBhY3Rpb25cbiAqIEluc2VydC5cbiAqL1xuZnVuY3Rpb24gd2Fsa1ROb2RlVHJlZSh2aWV3VG9XYWxrLCBhY3Rpb24sIHJlbmRlcmVyLCByZW5kZXJQYXJlbnQsIGJlZm9yZU5vZGUpIHtcbiAgICB2YXIgcm9vdFROb2RlID0gdmlld1RvV2Fsa1tUVklFV10ubm9kZTtcbiAgICB2YXIgcHJvamVjdGlvbk5vZGVJbmRleCA9IC0xO1xuICAgIHZhciBjdXJyZW50VmlldyA9IHZpZXdUb1dhbGs7XG4gICAgdmFyIHROb2RlID0gcm9vdFROb2RlLmNoaWxkO1xuICAgIHdoaWxlICh0Tm9kZSkge1xuICAgICAgICB2YXIgbmV4dFROb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKHROb2RlLnR5cGUgPT09IDMgLyogRWxlbWVudCAqLykge1xuICAgICAgICAgICAgZXhlY3V0ZU5vZGVBY3Rpb24oYWN0aW9uLCByZW5kZXJlciwgcmVuZGVyUGFyZW50LCBnZXROYXRpdmVCeVROb2RlKHROb2RlLCBjdXJyZW50VmlldyksIGJlZm9yZU5vZGUpO1xuICAgICAgICAgICAgdmFyIG5vZGVPckNvbnRhaW5lciA9IGN1cnJlbnRWaWV3W3ROb2RlLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChpc0xDb250YWluZXIobm9kZU9yQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZWxlbWVudCBoYXMgYW4gTENvbnRhaW5lciwgYW5kIGl0cyBjb21tZW50IG5lZWRzIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlTm9kZUFjdGlvbihhY3Rpb24sIHJlbmRlcmVyLCByZW5kZXJQYXJlbnQsIG5vZGVPckNvbnRhaW5lcltOQVRJVkVdLCBiZWZvcmVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0Tm9kZS50eXBlID09PSAwIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgdmFyIGxDb250YWluZXIgPSBjdXJyZW50Vmlld1t0Tm9kZS5pbmRleF07XG4gICAgICAgICAgICBleGVjdXRlTm9kZUFjdGlvbihhY3Rpb24sIHJlbmRlcmVyLCByZW5kZXJQYXJlbnQsIGxDb250YWluZXJbTkFUSVZFXSwgYmVmb3JlTm9kZSk7XG4gICAgICAgICAgICBpZiAocmVuZGVyUGFyZW50KVxuICAgICAgICAgICAgICAgIGxDb250YWluZXJbUkVOREVSX1BBUkVOVF0gPSByZW5kZXJQYXJlbnQ7XG4gICAgICAgICAgICBpZiAobENvbnRhaW5lcltWSUVXU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBsQ29udGFpbmVyW1ZJRVdTXVswXTtcbiAgICAgICAgICAgICAgICBuZXh0VE5vZGUgPSBjdXJyZW50Vmlld1tUVklFV10ubm9kZTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSB3YWxrZXIgZW50ZXJzIGEgY29udGFpbmVyLCB0aGVuIHRoZSBiZWZvcmVOb2RlIGhhcyB0byBiZWNvbWUgdGhlIGxvY2FsIG5hdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZS5cbiAgICAgICAgICAgICAgICBiZWZvcmVOb2RlID0gbENvbnRhaW5lcltOQVRJVkVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHROb2RlLnR5cGUgPT09IDEgLyogUHJvamVjdGlvbiAqLykge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSBmaW5kQ29tcG9uZW50VmlldyhjdXJyZW50Vmlldyk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50SG9zdCA9IGNvbXBvbmVudFZpZXdbSE9TVF9OT0RFXTtcbiAgICAgICAgICAgIHZhciBoZWFkID0gY29tcG9uZW50SG9zdC5wcm9qZWN0aW9uW3ROb2RlLnByb2plY3Rpb25dO1xuICAgICAgICAgICAgLy8gTXVzdCBzdG9yZSBib3RoIHRoZSBUTm9kZSBhbmQgdGhlIHZpZXcgYmVjYXVzZSB0aGlzIHByb2plY3Rpb24gbm9kZSBjb3VsZCBiZSBuZXN0ZWRcbiAgICAgICAgICAgIC8vIGRlZXBseSBpbnNpZGUgZW1iZWRkZWQgdmlld3MsIGFuZCB3ZSBuZWVkIHRvIGdldCBiYWNrIGRvd24gdG8gdGhpcyBwYXJ0aWN1bGFyIG5lc3RlZCB2aWV3LlxuICAgICAgICAgICAgcHJvamVjdGlvbk5vZGVTdGFja1srK3Byb2plY3Rpb25Ob2RlSW5kZXhdID0gdE5vZGU7XG4gICAgICAgICAgICBwcm9qZWN0aW9uTm9kZVN0YWNrWysrcHJvamVjdGlvbk5vZGVJbmRleF0gPSBjdXJyZW50VmlldztcbiAgICAgICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBjb21wb25lbnRWaWV3W1BBUkVOVF07XG4gICAgICAgICAgICAgICAgbmV4dFROb2RlID0gY3VycmVudFZpZXdbVFZJRVddLmRhdGFbaGVhZC5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSBWaWV3IG9yIGFuIEVsZW1lbnRDb250YWluZXJcbiAgICAgICAgICAgIG5leHRUTm9kZSA9IHROb2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0VE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbGFzdCBub2RlIHdhcyBwcm9qZWN0ZWQsIHdlIG5lZWQgdG8gZ2V0IGJhY2sgZG93biB0byBpdHMgcHJvamVjdGlvbiBub2RlXG4gICAgICAgICAgICBpZiAodE5vZGUubmV4dCA9PT0gbnVsbCAmJiAodE5vZGUuZmxhZ3MgJiA4MTkyIC8qIGlzUHJvamVjdGVkICovKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3ID0gcHJvamVjdGlvbk5vZGVTdGFja1twcm9qZWN0aW9uTm9kZUluZGV4LS1dO1xuICAgICAgICAgICAgICAgIHROb2RlID0gcHJvamVjdGlvbk5vZGVTdGFja1twcm9qZWN0aW9uTm9kZUluZGV4LS1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dFROb2RlID0gdE5vZGUubmV4dDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmluZCB0aGUgbmV4dCBub2RlIGluIHRoZSBUTm9kZSB0cmVlLCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBwbGFjZSB3aGVyZSBhIG5vZGUgaXNcbiAgICAgICAgICAgICAqIHByb2plY3RlZCAoaW4gdGhlIHNoYWRvdyBET00pIHJhdGhlciB0aGFuIHdoZXJlIGl0IGNvbWVzIGZyb20gKGluIHRoZSBsaWdodCBET00pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElmIHRoZXJlIGlzIG5vIHNpYmxpbmcgbm9kZSwgdGhlbiBpdCBnb2VzIHRvIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIHBhcmVudCBub2RlLi4uXG4gICAgICAgICAgICAgKiB1bnRpbCBpdCByZWFjaGVzIHJvb3ROb2RlIChhdCB3aGljaCBwb2ludCBudWxsIGlzIHJldHVybmVkKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2hpbGUgKCFuZXh0VE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXJlbnQgaXMgbnVsbCwgd2UncmUgY3Jvc3NpbmcgdGhlIHZpZXcgYm91bmRhcnksIHNvIHdlIHNob3VsZCBnZXQgdGhlIGhvc3QgVE5vZGUuXG4gICAgICAgICAgICAgICAgdE5vZGUgPSB0Tm9kZS5wYXJlbnQgfHwgY3VycmVudFZpZXdbVFZJRVddLm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHROb2RlID09PSBudWxsIHx8IHROb2RlID09PSByb290VE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gZXhpdGluZyBhIGNvbnRhaW5lciwgdGhlIGJlZm9yZU5vZGUgbXVzdCBiZSByZXN0b3JlZCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodE5vZGUudHlwZSA9PT0gMCAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBjdXJyZW50Vmlld1tQQVJFTlRdO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVOb2RlID0gY3VycmVudFZpZXdbdE5vZGUuaW5kZXhdW05BVElWRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0Tm9kZS50eXBlID09PSAyIC8qIFZpZXcgKi8gJiYgY3VycmVudFZpZXdbTkVYVF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBjdXJyZW50Vmlld1tORVhUXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFROb2RlID0gY3VycmVudFZpZXdbVFZJRVddLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0VE5vZGUgPSB0Tm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0Tm9kZSA9IG5leHRUTm9kZTtcbiAgICB9XG59XG4vKipcbiAqIEdpdmVuIGEgY3VycmVudCB2aWV3LCBmaW5kcyB0aGUgbmVhcmVzdCBjb21wb25lbnQncyBob3N0IChMRWxlbWVudCkuXG4gKlxuICogQHBhcmFtIGxWaWV3RGF0YSBMVmlld0RhdGEgZm9yIHdoaWNoIHdlIHdhbnQgYSBob3N0IGVsZW1lbnQgbm9kZVxuICogQHJldHVybnMgVGhlIGhvc3Qgbm9kZVxuICovXG5mdW5jdGlvbiBmaW5kQ29tcG9uZW50VmlldyhsVmlld0RhdGEpIHtcbiAgICB2YXIgcm9vdFROb2RlID0gbFZpZXdEYXRhW0hPU1RfTk9ERV07XG4gICAgd2hpbGUgKHJvb3RUTm9kZSAmJiByb290VE5vZGUudHlwZSA9PT0gMiAvKiBWaWV3ICovKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGxWaWV3RGF0YVtQQVJFTlRdLCAndmlld0RhdGEucGFyZW50Jyk7XG4gICAgICAgIGxWaWV3RGF0YSA9IGxWaWV3RGF0YVtQQVJFTlRdO1xuICAgICAgICByb290VE5vZGUgPSBsVmlld0RhdGFbSE9TVF9OT0RFXTtcbiAgICB9XG4gICAgcmV0dXJuIGxWaWV3RGF0YTtcbn1cbi8qKlxuICogTk9URTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRoZSBwb3NzaWJsZSBhY3Rpb25zIGFyZSBpbmxpbmVkIHdpdGhpbiB0aGUgZnVuY3Rpb24gaW5zdGVhZCBvZlxuICogYmVpbmcgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBleGVjdXRlTm9kZUFjdGlvbihhY3Rpb24sIHJlbmRlcmVyLCBwYXJlbnQsIG5vZGUsIGJlZm9yZU5vZGUpIHtcbiAgICBpZiAoYWN0aW9uID09PSAwIC8qIEluc2VydCAqLykge1xuICAgICAgICBpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikgP1xuICAgICAgICAgICAgcmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgYmVmb3JlTm9kZSkgOlxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBiZWZvcmVOb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWN0aW9uID09PSAxIC8qIERldGFjaCAqLykge1xuICAgICAgICBpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikgP1xuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2hpbGQocGFyZW50LCBub2RlKSA6XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gMiAvKiBEZXN0cm95ICovKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJEZXN0cm95Tm9kZSsrO1xuICAgICAgICByZW5kZXJlci5kZXN0cm95Tm9kZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh2YWx1ZSwgcmVuZGVyZXIpIHtcbiAgICByZXR1cm4gaXNQcm9jZWR1cmFsUmVuZGVyZXIocmVuZGVyZXIpID8gcmVuZGVyZXIuY3JlYXRlVGV4dChzdHJpbmdpZnkkMSh2YWx1ZSkpIDpcbiAgICAgICAgcmVuZGVyZXIuY3JlYXRlVGV4dE5vZGUoc3RyaW5naWZ5JDEodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFJlbW92ZVZpZXdGcm9tQ29udGFpbmVyKHZpZXdUb1dhbGssIGluc2VydE1vZGUsIGJlZm9yZU5vZGUpIHtcbiAgICB2YXIgcmVuZGVyUGFyZW50ID0gZ2V0Q29udGFpbmVyUmVuZGVyUGFyZW50KHZpZXdUb1dhbGtbVFZJRVddLm5vZGUsIHZpZXdUb1dhbGspO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlVHlwZSh2aWV3VG9XYWxrW1RWSUVXXS5ub2RlLCAyIC8qIFZpZXcgKi8pO1xuICAgIGlmIChyZW5kZXJQYXJlbnQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdmlld1RvV2Fsa1tSRU5ERVJFUl07XG4gICAgICAgIHdhbGtUTm9kZVRyZWUodmlld1RvV2FsaywgaW5zZXJ0TW9kZSA/IDAgLyogSW5zZXJ0ICovIDogMSAvKiBEZXRhY2ggKi8sIHJlbmRlcmVyLCByZW5kZXJQYXJlbnQsIGJlZm9yZU5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogVHJhdmVyc2VzIGRvd24gYW5kIHVwIHRoZSB0cmVlIG9mIHZpZXdzIGFuZCBjb250YWluZXJzIHRvIHJlbW92ZSBsaXN0ZW5lcnMgYW5kXG4gKiBjYWxsIG9uRGVzdHJveSBjYWxsYmFja3MuXG4gKlxuICogTm90ZXM6XG4gKiAgLSBCZWNhdXNlIGl0J3MgdXNlZCBmb3Igb25EZXN0cm95IGNhbGxzLCBpdCBuZWVkcyB0byBiZSBib3R0b20tdXAuXG4gKiAgLSBNdXN0IHByb2Nlc3MgY29udGFpbmVycyBpbnN0ZWFkIG9mIHRoZWlyIHZpZXdzIHRvIGF2b2lkIHNwbGljaW5nXG4gKiAgd2hlbiB2aWV3cyBhcmUgZGVzdHJveWVkIGFuZCByZS1hZGRlZC5cbiAqICAtIFVzaW5nIGEgd2hpbGUgbG9vcCBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gcmVjdXJzaW9uXG4gKiAgLSBEZXN0cm95IG9ubHkgY2FsbGVkIG9uIG1vdmVtZW50IHRvIHNpYmxpbmcgb3IgbW92ZW1lbnQgdG8gcGFyZW50IChsYXRlcmFsbHkgb3IgdXApXG4gKlxuICogIEBwYXJhbSByb290VmlldyBUaGUgdmlldyB0byBkZXN0cm95XG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lWaWV3VHJlZShyb290Vmlldykge1xuICAgIC8vIElmIHRoZSB2aWV3IGhhcyBubyBjaGlsZHJlbiwgd2UgY2FuIGNsZWFuIGl0IHVwIGFuZCByZXR1cm4gZWFybHkuXG4gICAgaWYgKHJvb3RWaWV3W1RWSUVXXS5jaGlsZEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gY2xlYW5VcFZpZXcocm9vdFZpZXcpO1xuICAgIH1cbiAgICB2YXIgdmlld09yQ29udGFpbmVyID0gZ2V0TFZpZXdDaGlsZChyb290Vmlldyk7XG4gICAgd2hpbGUgKHZpZXdPckNvbnRhaW5lcikge1xuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgICAgIGlmICh2aWV3T3JDb250YWluZXIubGVuZ3RoID49IEhFQURFUl9PRkZTRVQpIHtcbiAgICAgICAgICAgIC8vIElmIExWaWV3RGF0YSwgdHJhdmVyc2UgZG93biB0byBjaGlsZC5cbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld09yQ29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKHZpZXdbVFZJRVddLmNoaWxkSW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICBuZXh0ID0gZ2V0TFZpZXdDaGlsZCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNvbnRhaW5lciwgdHJhdmVyc2UgZG93biB0byBpdHMgZmlyc3QgTFZpZXdEYXRhLlxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHZpZXdPckNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJbVklFV1NdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBuZXh0ID0gY29udGFpbmVyW1ZJRVdTXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNsZWFuIHVwIHZpZXcgd2hlbiBtb3ZpbmcgdG8gdGhlIHNpZGUgb3IgdXAsIGFzIGRlc3Ryb3kgaG9va3NcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBjYWxsZWQgaW4gb3JkZXIgZnJvbSB0aGUgYm90dG9tIHVwLlxuICAgICAgICAgICAgd2hpbGUgKHZpZXdPckNvbnRhaW5lciAmJiAhdmlld09yQ29udGFpbmVyW05FWFRdICYmIHZpZXdPckNvbnRhaW5lciAhPT0gcm9vdFZpZXcpIHtcbiAgICAgICAgICAgICAgICBjbGVhblVwVmlldyh2aWV3T3JDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHZpZXdPckNvbnRhaW5lciA9IGdldFBhcmVudFN0YXRlKHZpZXdPckNvbnRhaW5lciwgcm9vdFZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW5VcFZpZXcodmlld09yQ29udGFpbmVyIHx8IHJvb3RWaWV3KTtcbiAgICAgICAgICAgIG5leHQgPSB2aWV3T3JDb250YWluZXIgJiYgdmlld09yQ29udGFpbmVyW05FWFRdO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdPckNvbnRhaW5lciA9IG5leHQ7XG4gICAgfVxufVxuLyoqXG4gKiBJbnNlcnRzIGEgdmlldyBpbnRvIGEgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgYWRkcyB0aGUgdmlldyB0byB0aGUgY29udGFpbmVyJ3MgYXJyYXkgb2YgYWN0aXZlIHZpZXdzIGluIHRoZSBjb3JyZWN0XG4gKiBwb3NpdGlvbi4gSXQgYWxzbyBhZGRzIHRoZSB2aWV3J3MgZWxlbWVudHMgdG8gdGhlIERPTSBpZiB0aGUgY29udGFpbmVyIGlzbid0IGFcbiAqIHJvb3Qgbm9kZSBvZiBhbm90aGVyIHZpZXcgKGluIHRoYXQgY2FzZSwgdGhlIHZpZXcncyBlbGVtZW50cyB3aWxsIGJlIGFkZGVkIHdoZW5cbiAqIHRoZSBjb250YWluZXIncyBwYXJlbnQgdmlldyBpcyBhZGRlZCBsYXRlcikuXG4gKlxuICogQHBhcmFtIGxWaWV3IFRoZSB2aWV3IHRvIGluc2VydFxuICogQHBhcmFtIGxDb250YWluZXIgVGhlIGNvbnRhaW5lciBpbnRvIHdoaWNoIHRoZSB2aWV3IHNob3VsZCBiZSBpbnNlcnRlZFxuICogQHBhcmFtIHBhcmVudFZpZXcgVGhlIG5ldyBwYXJlbnQgb2YgdGhlIGluc2VydGVkIHZpZXdcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSB2aWV3XG4gKiBAcGFyYW0gY29udGFpbmVySW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb250YWluZXIgbm9kZSwgaWYgZHluYW1pY1xuICovXG5mdW5jdGlvbiBpbnNlcnRWaWV3KGxWaWV3LCBsQ29udGFpbmVyLCBwYXJlbnRWaWV3LCBpbmRleCwgY29udGFpbmVySW5kZXgpIHtcbiAgICB2YXIgdmlld3MgPSBsQ29udGFpbmVyW1ZJRVdTXTtcbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgdmlldywgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGNoaWxkcmVuLlxuICAgICAgICB2aWV3c1tpbmRleCAtIDFdW05FWFRdID0gbFZpZXc7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IHZpZXdzLmxlbmd0aCkge1xuICAgICAgICBsVmlld1tORVhUXSA9IHZpZXdzW2luZGV4XTtcbiAgICAgICAgdmlld3Muc3BsaWNlKGluZGV4LCAwLCBsVmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3cy5wdXNoKGxWaWV3KTtcbiAgICAgICAgbFZpZXdbTkVYVF0gPSBudWxsO1xuICAgIH1cbiAgICAvLyBEeW5hbWljYWxseSBpbnNlcnRlZCB2aWV3cyBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZWlyIHBhcmVudCBjb250YWluZXIncyBob3N0IHNvIGl0J3NcbiAgICAvLyBwb3NzaWJsZSB0byBqdW1wIGZyb20gYSB2aWV3IHRvIGl0cyBjb250YWluZXIncyBuZXh0IHdoZW4gd2Fsa2luZyB0aGUgbm9kZSB0cmVlLlxuICAgIGlmIChjb250YWluZXJJbmRleCA+IC0xKSB7XG4gICAgICAgIGxWaWV3W0NPTlRBSU5FUl9JTkRFWF0gPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgbFZpZXdbUEFSRU5UXSA9IHBhcmVudFZpZXc7XG4gICAgfVxuICAgIC8vIE5vdGlmeSBxdWVyeSB0aGF0IGEgbmV3IHZpZXcgaGFzIGJlZW4gYWRkZWRcbiAgICBpZiAobFZpZXdbUVVFUklFU10pIHtcbiAgICAgICAgbFZpZXdbUVVFUklFU10uaW5zZXJ0VmlldyhpbmRleCk7XG4gICAgfVxuICAgIC8vIFNldHMgdGhlIGF0dGFjaGVkIGZsYWdcbiAgICBsVmlld1tGTEFHU10gfD0gOCAvKiBBdHRhY2hlZCAqLztcbn1cbi8qKlxuICogRGV0YWNoZXMgYSB2aWV3IGZyb20gYSBjb250YWluZXIuXG4gKlxuICogVGhpcyBtZXRob2Qgc3BsaWNlcyB0aGUgdmlldyBmcm9tIHRoZSBjb250YWluZXIncyBhcnJheSBvZiBhY3RpdmUgdmlld3MuIEl0IGFsc29cbiAqIHJlbW92ZXMgdGhlIHZpZXcncyBlbGVtZW50cyBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIGxDb250YWluZXIgVGhlIGNvbnRhaW5lciBmcm9tIHdoaWNoIHRvIGRldGFjaCBhIHZpZXdcbiAqIEBwYXJhbSByZW1vdmVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHZpZXcgdG8gZGV0YWNoXG4gKiBAcGFyYW0gZGV0YWNoZWQgV2hldGhlciBvciBub3QgdGhpcyB2aWV3IGlzIGFscmVhZHkgZGV0YWNoZWQuXG4gKi9cbmZ1bmN0aW9uIGRldGFjaFZpZXcobENvbnRhaW5lciwgcmVtb3ZlSW5kZXgsIGRldGFjaGVkKSB7XG4gICAgdmFyIHZpZXdzID0gbENvbnRhaW5lcltWSUVXU107XG4gICAgdmFyIHZpZXdUb0RldGFjaCA9IHZpZXdzW3JlbW92ZUluZGV4XTtcbiAgICBpZiAocmVtb3ZlSW5kZXggPiAwKSB7XG4gICAgICAgIHZpZXdzW3JlbW92ZUluZGV4IC0gMV1bTkVYVF0gPSB2aWV3VG9EZXRhY2hbTkVYVF07XG4gICAgfVxuICAgIHZpZXdzLnNwbGljZShyZW1vdmVJbmRleCwgMSk7XG4gICAgaWYgKCFkZXRhY2hlZCkge1xuICAgICAgICBhZGRSZW1vdmVWaWV3RnJvbUNvbnRhaW5lcih2aWV3VG9EZXRhY2gsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHZpZXdUb0RldGFjaFtRVUVSSUVTXSkge1xuICAgICAgICB2aWV3VG9EZXRhY2hbUVVFUklFU10ucmVtb3ZlVmlldygpO1xuICAgIH1cbiAgICB2aWV3VG9EZXRhY2hbQ09OVEFJTkVSX0lOREVYXSA9IC0xO1xuICAgIHZpZXdUb0RldGFjaFtQQVJFTlRdID0gbnVsbDtcbiAgICAvLyBVbnNldHMgdGhlIGF0dGFjaGVkIGZsYWdcbiAgICB2aWV3VG9EZXRhY2hbRkxBR1NdICY9IH44IC8qIEF0dGFjaGVkICovO1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgdmlldyBmcm9tIGEgY29udGFpbmVyLCBpLmUuIGRldGFjaGVzIGl0IGFuZCB0aGVuIGRlc3Ryb3lzIHRoZSB1bmRlcmx5aW5nIExWaWV3LlxuICpcbiAqIEBwYXJhbSBsQ29udGFpbmVyIFRoZSBjb250YWluZXIgZnJvbSB3aGljaCB0byByZW1vdmUgYSB2aWV3XG4gKiBAcGFyYW0gdENvbnRhaW5lciBUaGUgVENvbnRhaW5lciBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgTENvbnRhaW5lclxuICogQHBhcmFtIHJlbW92ZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdmlldyB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVmlldyhsQ29udGFpbmVyLCBjb250YWluZXJIb3N0LCByZW1vdmVJbmRleCkge1xuICAgIHZhciB2aWV3ID0gbENvbnRhaW5lcltWSUVXU11bcmVtb3ZlSW5kZXhdO1xuICAgIGRldGFjaFZpZXcobENvbnRhaW5lciwgcmVtb3ZlSW5kZXgsICEhY29udGFpbmVySG9zdC5kZXRhY2hlZCk7XG4gICAgZGVzdHJveUxWaWV3KHZpZXcpO1xufVxuLyoqIEdldHMgdGhlIGNoaWxkIG9mIHRoZSBnaXZlbiBMVmlld0RhdGEgKi9cbmZ1bmN0aW9uIGdldExWaWV3Q2hpbGQodmlld0RhdGEpIHtcbiAgICB2YXIgY2hpbGRJbmRleCA9IHZpZXdEYXRhW1RWSUVXXS5jaGlsZEluZGV4O1xuICAgIHJldHVybiBjaGlsZEluZGV4ID09PSAtMSA/IG51bGwgOiB2aWV3RGF0YVtjaGlsZEluZGV4XTtcbn1cbi8qKlxuICogQSBzdGFuZGFsb25lIGZ1bmN0aW9uIHdoaWNoIGRlc3Ryb3lzIGFuIExWaWV3LFxuICogY29uZHVjdGluZyBjbGVhbnVwIChlLmcuIHJlbW92aW5nIGxpc3RlbmVycywgY2FsbGluZyBvbkRlc3Ryb3lzKS5cbiAqXG4gKiBAcGFyYW0gdmlldyBUaGUgdmlldyB0byBiZSBkZXN0cm95ZWQuXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lMVmlldyh2aWV3KSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdmlld1tSRU5ERVJFUl07XG4gICAgaWYgKGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSAmJiByZW5kZXJlci5kZXN0cm95Tm9kZSkge1xuICAgICAgICB3YWxrVE5vZGVUcmVlKHZpZXcsIDIgLyogRGVzdHJveSAqLywgcmVuZGVyZXIsIG51bGwpO1xuICAgIH1cbiAgICBkZXN0cm95Vmlld1RyZWUodmlldyk7XG4gICAgLy8gU2V0cyB0aGUgZGVzdHJveWVkIGZsYWdcbiAgICB2aWV3W0ZMQUdTXSB8PSAzMiAvKiBEZXN0cm95ZWQgKi87XG59XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggTFZpZXdPckxDb250YWluZXIgdG8ganVtcCB0byB3aGVuIHRyYXZlcnNpbmcgYmFjayB1cCB0aGVcbiAqIHRyZWUgaW4gZGVzdHJveVZpZXdUcmVlLlxuICpcbiAqIE5vcm1hbGx5LCB0aGUgdmlldydzIHBhcmVudCBMVmlldyBzaG91bGQgYmUgY2hlY2tlZCwgYnV0IGluIHRoZSBjYXNlIG9mXG4gKiBlbWJlZGRlZCB2aWV3cywgdGhlIGNvbnRhaW5lciAod2hpY2ggaXMgdGhlIHZpZXcgbm9kZSdzIHBhcmVudCwgYnV0IG5vdCB0aGVcbiAqIExWaWV3J3MgcGFyZW50KSBuZWVkcyB0byBiZSBjaGVja2VkIGZvciBhIHBvc3NpYmxlIG5leHQgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHN0YXRlIFRoZSBMVmlld09yTENvbnRhaW5lciBmb3Igd2hpY2ggd2UgbmVlZCBhIHBhcmVudCBzdGF0ZVxuICogQHBhcmFtIHJvb3RWaWV3IFRoZSByb290Vmlldywgc28gd2UgZG9uJ3QgcHJvcGFnYXRlIHRvbyBmYXIgdXAgdGhlIHZpZXcgdHJlZVxuICogQHJldHVybnMgVGhlIGNvcnJlY3QgcGFyZW50IExWaWV3T3JMQ29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudFN0YXRlKHN0YXRlLCByb290Vmlldykge1xuICAgIHZhciB0Tm9kZTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID49IEhFQURFUl9PRkZTRVQgJiYgKHROb2RlID0gc3RhdGVbSE9TVF9OT0RFXSkgJiZcbiAgICAgICAgdE5vZGUudHlwZSA9PT0gMiAvKiBWaWV3ICovKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYW4gZW1iZWRkZWQgdmlldywgdGhlIHN0YXRlIG5lZWRzIHRvIGdvIHVwIHRvIHRoZSBjb250YWluZXIsIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIGNvbnRhaW5lciBoYXMgYSBuZXh0XG4gICAgICAgIHJldHVybiBnZXRMQ29udGFpbmVyKHROb2RlLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIHVzZSBwYXJlbnQgdmlldyBmb3IgY29udGFpbmVycyBvciBjb21wb25lbnQgdmlld3NcbiAgICAgICAgcmV0dXJuIHN0YXRlW1BBUkVOVF0gPT09IHJvb3RWaWV3ID8gbnVsbCA6IHN0YXRlW1BBUkVOVF07XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgYW5kIGNhbGwgYWxsIG9uRGVzdHJveXMgaW4gYSBnaXZlbiB2aWV3LlxuICpcbiAqIEBwYXJhbSB2aWV3IFRoZSBMVmlld0RhdGEgdG8gY2xlYW4gdXBcbiAqL1xuZnVuY3Rpb24gY2xlYW5VcFZpZXcodmlld09yQ29udGFpbmVyKSB7XG4gICAgaWYgKHZpZXdPckNvbnRhaW5lci5sZW5ndGggPj0gSEVBREVSX09GRlNFVCkge1xuICAgICAgICB2YXIgdmlldyA9IHZpZXdPckNvbnRhaW5lcjtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKHZpZXcpO1xuICAgICAgICBleGVjdXRlT25EZXN0cm95cyh2aWV3KTtcbiAgICAgICAgZXhlY3V0ZVBpcGVPbkRlc3Ryb3lzKHZpZXcpO1xuICAgICAgICAvLyBGb3IgY29tcG9uZW50IHZpZXdzIG9ubHksIHRoZSBsb2NhbCByZW5kZXJlciBpcyBkZXN0cm95ZWQgYXMgY2xlYW4gdXAgdGltZS5cbiAgICAgICAgaWYgKHZpZXdbVFZJRVddLmlkID09PSAtMSAmJiBpc1Byb2NlZHVyYWxSZW5kZXJlcih2aWV3W1JFTkRFUkVSXSkpIHtcbiAgICAgICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJEZXN0cm95Kys7XG4gICAgICAgICAgICB2aWV3W1JFTkRFUkVSXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogUmVtb3ZlcyBsaXN0ZW5lcnMgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIG91dHB1dCBzdWJzY3JpcHRpb25zICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnModmlld0RhdGEpIHtcbiAgICB2YXIgY2xlYW51cCA9IHZpZXdEYXRhW1RWSUVXXS5jbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhbnVwLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXN0ZW5lciB3aXRoIHRoZSBuYXRpdmUgcmVuZGVyZXJcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlID0gcmVhZEVsZW1lbnRWYWx1ZSh2aWV3RGF0YVtjbGVhbnVwW2kgKyAxXV0pO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHZpZXdEYXRhW0NMRUFOVVBdW2NsZWFudXBbaSArIDJdXTtcbiAgICAgICAgICAgICAgICBuYXRpdmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihjbGVhbnVwW2ldLCBsaXN0ZW5lciwgY2xlYW51cFtpICsgM10pO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjbGVhbnVwW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXN0ZW5lciB3aXRoIHJlbmRlcmVyMiAoY2xlYW51cCBmbiBjYW4gYmUgZm91bmQgYnkgaW5kZXgpXG4gICAgICAgICAgICAgICAgdmFyIGNsZWFudXBGbiA9IHZpZXdEYXRhW0NMRUFOVVBdW2NsZWFudXBbaV1dO1xuICAgICAgICAgICAgICAgIGNsZWFudXBGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBpcyBncm91cGVkIHdpdGggdGhlIGluZGV4IG9mIGl0cyBjb250ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB2aWV3RGF0YVtDTEVBTlVQXVtjbGVhbnVwW2kgKyAxXV07XG4gICAgICAgICAgICAgICAgY2xlYW51cFtpXS5jYWxsKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXdEYXRhW0NMRUFOVVBdID0gbnVsbDtcbiAgICB9XG59XG4vKiogQ2FsbHMgb25EZXN0cm95IGhvb2tzIGZvciB0aGlzIHZpZXcgKi9cbmZ1bmN0aW9uIGV4ZWN1dGVPbkRlc3Ryb3lzKHZpZXcpIHtcbiAgICB2YXIgdFZpZXcgPSB2aWV3W1RWSUVXXTtcbiAgICB2YXIgZGVzdHJveUhvb2tzO1xuICAgIGlmICh0VmlldyAhPSBudWxsICYmIChkZXN0cm95SG9va3MgPSB0Vmlldy5kZXN0cm95SG9va3MpICE9IG51bGwpIHtcbiAgICAgICAgY2FsbEhvb2tzKHZpZXcsIGRlc3Ryb3lIb29rcyk7XG4gICAgfVxufVxuLyoqIENhbGxzIHBpcGUgZGVzdHJveSBob29rcyBmb3IgdGhpcyB2aWV3ICovXG5mdW5jdGlvbiBleGVjdXRlUGlwZU9uRGVzdHJveXModmlld0RhdGEpIHtcbiAgICB2YXIgcGlwZURlc3Ryb3lIb29rcyA9IHZpZXdEYXRhW1RWSUVXXSAmJiB2aWV3RGF0YVtUVklFV10ucGlwZURlc3Ryb3lIb29rcztcbiAgICBpZiAocGlwZURlc3Ryb3lIb29rcykge1xuICAgICAgICBjYWxsSG9va3Modmlld0RhdGEsIHBpcGVEZXN0cm95SG9va3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlbmRlclBhcmVudCh0Tm9kZSwgY3VycmVudFZpZXcpIHtcbiAgICBpZiAoY2FuSW5zZXJ0TmF0aXZlTm9kZSh0Tm9kZSwgY3VycmVudFZpZXcpKSB7XG4gICAgICAgIHZhciBob3N0VE5vZGUgPSBjdXJyZW50Vmlld1tIT1NUX05PREVdO1xuICAgICAgICByZXR1cm4gdE5vZGUucGFyZW50ID09IG51bGwgJiYgaG9zdFROb2RlLnR5cGUgPT09IDIgLyogVmlldyAqLyA/XG4gICAgICAgICAgICBnZXRDb250YWluZXJSZW5kZXJQYXJlbnQoaG9zdFROb2RlLCBjdXJyZW50VmlldykgOlxuICAgICAgICAgICAgZ2V0UGFyZW50TmF0aXZlKHROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2FuSW5zZXJ0TmF0aXZlQ2hpbGRPZkVsZW1lbnQodE5vZGUpIHtcbiAgICAvLyBJZiB0aGUgcGFyZW50IGlzIG51bGwsIHRoZW4gd2UgYXJlIGluc2VydGluZyBhY3Jvc3Mgdmlld3MuIFRoaXMgaGFwcGVucyB3aGVuIHdlXG4gICAgLy8gaW5zZXJ0IGEgcm9vdCBlbGVtZW50IG9mIHRoZSBjb21wb25lbnQgdmlldyBpbnRvIHRoZSBjb21wb25lbnQgaG9zdCBlbGVtZW50IGFuZCBpdFxuICAgIC8vIHNob3VsZCBhbHdheXMgYmUgZWFnZXIuXG4gICAgaWYgKHROb2RlLnBhcmVudCA9PSBudWxsIHx8XG4gICAgICAgIC8vIFdlIHNob3VsZCBhbHNvIGVhZ2VybHkgaW5zZXJ0IGlmIHRoZSBwYXJlbnQgaXMgYSByZWd1bGFyLCBub24tY29tcG9uZW50IGVsZW1lbnRcbiAgICAgICAgLy8gc2luY2Ugd2Uga25vdyB0aGF0IHRoaXMgcmVsYXRpb25zaGlwIHdpbGwgbmV2ZXIgYmUgYnJva2VuLlxuICAgICAgICB0Tm9kZS5wYXJlbnQudHlwZSA9PT0gMyAvKiBFbGVtZW50ICovICYmICEodE5vZGUucGFyZW50LmZsYWdzICYgNDA5NiAvKiBpc0NvbXBvbmVudCAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFBhcmVudCBpcyBhIENvbXBvbmVudC4gQ29tcG9uZW50J3MgY29udGVudCBub2RlcyBhcmUgbm90IGluc2VydGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgcHJvamVjdGVkLCBhbmQgc28gZG9pbmcgaW5zZXJ0IGF0IHRoaXMgcG9pbnQgd291bGQgYmUgd2FzdGVmdWwuXG4gICAgLy8gU2luY2UgdGhlIHByb2plY3Rpb24gd291bGQgdGhhbiBtb3ZlIGl0IHRvIGl0cyBmaW5hbCBkZXN0aW5hdGlvbi5cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFdlIG1pZ2h0IGRlbGF5IGluc2VydGlvbiBvZiBjaGlsZHJlbiBmb3IgYSBnaXZlbiB2aWV3IGlmIGl0IGlzIGRpc2Nvbm5lY3RlZC5cbiAqIFRoaXMgbWlnaHQgaGFwcGVuIGZvciAyIG1haW4gcmVhc29uczpcbiAqIC0gdmlldyBpcyBub3QgaW5zZXJ0ZWQgaW50byBhbnkgY29udGFpbmVyICh2aWV3IHdhcyBjcmVhdGVkIGJ1dCBub3QgaW5zZXJ0ZWQgeWV0KVxuICogLSB2aWV3IGlzIGluc2VydGVkIGludG8gYSBjb250YWluZXIgYnV0IHRoZSBjb250YWluZXIgaXRzZWxmIGlzIG5vdCBpbnNlcnRlZCBpbnRvIHRoZSBET01cbiAqIChjb250YWluZXIgbWlnaHQgYmUgcGFydCBvZiBwcm9qZWN0aW9uIG9yIGNoaWxkIG9mIGEgdmlldyB0aGF0IGlzIG5vdCBpbnNlcnRlZCB5ZXQpLlxuICpcbiAqIEluIG90aGVyIHdvcmRzIHdlIGNhbiBpbnNlcnQgY2hpbGRyZW4gb2YgYSBnaXZlbiB2aWV3IGlmIHRoaXMgdmlldyB3YXMgaW5zZXJ0ZWQgaW50byBhIGNvbnRhaW5lclxuICogYW5kXG4gKiB0aGUgY29udGFpbmVyIGl0c2VsZiBoYXMgaXRzIHJlbmRlciBwYXJlbnQgZGV0ZXJtaW5lZC5cbiAqL1xuZnVuY3Rpb24gY2FuSW5zZXJ0TmF0aXZlQ2hpbGRPZlZpZXcodmlld1ROb2RlLCB2aWV3KSB7XG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgaW5zZXJ0aW5nIGludG8gYSBgVmlld2AgdGhlIGBWaWV3YCBtYXkgYmUgZGlzY29ubmVjdGVkLlxuICAgIHZhciBjb250YWluZXIgPSBnZXRMQ29udGFpbmVyKHZpZXdUTm9kZSwgdmlldyk7XG4gICAgaWYgKGNvbnRhaW5lciA9PSBudWxsIHx8IGNvbnRhaW5lcltSRU5ERVJfUEFSRU5UXSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBgVmlld2AgaXMgbm90IGluc2VydGVkIGludG8gYSBgQ29udGFpbmVyYCBvciB0aGUgcGFyZW50IGBDb250YWluZXJgXG4gICAgICAgIC8vIGl0c2VsZiBpcyBkaXNjb25uZWN0ZWQuIFNvIHdlIGhhdmUgdG8gZGVsYXkuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIHBhcmVudCBgQ29udGFpbmVyYCBpcyBpbiBpbnNlcnRlZCBzdGF0ZSwgc28gd2UgY2FuIGVhZ2VybHkgaW5zZXJ0IGludG9cbiAgICAvLyB0aGlzIGxvY2F0aW9uLlxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBuYXRpdmUgZWxlbWVudCBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgZ2l2ZW4gcGFyZW50LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gcmVhc29ucyB3aHkgd2UgbWF5IG5vdCBiZSBhYmxlIHRvIGluc2VydCBhIGVsZW1lbnQgaW1tZWRpYXRlbHkuXG4gKiAtIFByb2plY3Rpb246IFdoZW4gY3JlYXRpbmcgYSBjaGlsZCBjb250ZW50IGVsZW1lbnQgb2YgYSBjb21wb25lbnQsIHdlIGhhdmUgdG8gc2tpcCB0aGVcbiAqICAgaW5zZXJ0aW9uIGJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBjb21wb25lbnQgd2lsbCBiZSBwcm9qZWN0ZWQuXG4gKiAgIGA8Y29tcG9uZW50Pjxjb250ZW50PmRlbGF5ZWQgZHVlIHRvIHByb2plY3Rpb248L2NvbnRlbnQ+PC9jb21wb25lbnQ+YFxuICogLSBQYXJlbnQgY29udGFpbmVyIGlzIGRpc2Nvbm5lY3RlZDogVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYXJlIGluc2VydGluZyBhIHZpZXcgaW50b1xuICogICBwYXJlbnQgY29udGFpbmVyLCB3aGljaCBpdHNlbGYgaXMgZGlzY29ubmVjdGVkLiBGb3IgZXhhbXBsZSB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBwYXJ0XG4gKiAgIG9mIGEgVmlldyB3aGljaCBoYXMgbm90IGJlIGluc2VydGVkIG9yIGlzIG1hcmUgZm9yIHByb2plY3Rpb24gYnV0IGhhcyBub3QgYmVlbiBpbnNlcnRlZFxuICogICBpbnRvIGRlc3RpbmF0aW9uLlxuICpcblxuICpcbiAqIEBwYXJhbSBwYXJlbnQgVGhlIHBhcmVudCB3aGVyZSB0aGUgY2hpbGQgd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICogQHBhcmFtIGN1cnJlbnRWaWV3IEN1cnJlbnQgTFZpZXcgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHJldHVybiBib29sZWFuIFdoZXRoZXIgdGhlIGNoaWxkIHNob3VsZCBiZSBpbnNlcnRlZCBub3cgKG9yIGRlbGF5ZWQgdW50aWwgbGF0ZXIpLlxuICovXG5mdW5jdGlvbiBjYW5JbnNlcnROYXRpdmVOb2RlKHROb2RlLCBjdXJyZW50Vmlldykge1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IHROb2RlO1xuICAgIHZhciBwYXJlbnQgPSB0Tm9kZS5wYXJlbnQ7XG4gICAgaWYgKHROb2RlLnBhcmVudCAmJiB0Tm9kZS5wYXJlbnQudHlwZSA9PT0gNCAvKiBFbGVtZW50Q29udGFpbmVyICovKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gZ2V0SGlnaGVzdEVsZW1lbnRDb250YWluZXIodE5vZGUpO1xuICAgICAgICBwYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICAgIHBhcmVudCA9IGN1cnJlbnRWaWV3W0hPU1RfTk9ERV07XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gMiAvKiBWaWV3ICovKSB7XG4gICAgICAgIHJldHVybiBjYW5JbnNlcnROYXRpdmVDaGlsZE9mVmlldyhwYXJlbnQsIGN1cnJlbnRWaWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFBhcmVudCBpcyBhIHJlZ3VsYXIgZWxlbWVudCBvciBhIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gY2FuSW5zZXJ0TmF0aXZlQ2hpbGRPZkVsZW1lbnQoY3VycmVudE5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogSW5zZXJ0cyBhIG5hdGl2ZSBub2RlIGJlZm9yZSBhbm90aGVyIG5hdGl2ZSBub2RlIGZvciBhIGdpdmVuIHBhcmVudCB1c2luZyB7QGxpbmsgUmVuZGVyZXIzfS5cbiAqIFRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBuYXRpdmUgbm9kZXMgd2VyZSBkZXRlcm1pbmVkIC0gaXQgYWJzdHJhY3RzIGFuXG4gKiBhY3R1YWwgcmVuZGVyZXIgYmVpbmcgdXNlZC5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlSW5zZXJ0QmVmb3JlKHJlbmRlcmVyLCBwYXJlbnQsIGNoaWxkLCBiZWZvcmVOb2RlKSB7XG4gICAgaWYgKGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSkge1xuICAgICAgICByZW5kZXJlci5pbnNlcnRCZWZvcmUocGFyZW50LCBjaGlsZCwgYmVmb3JlTm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVOb2RlLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGVuZHMgdGhlIGBjaGlsZGAgZWxlbWVudCB0byB0aGUgYHBhcmVudGAuXG4gKlxuICogVGhlIGVsZW1lbnQgaW5zZXJ0aW9uIG1pZ2h0IGJlIGRlbGF5ZWQge0BsaW5rIGNhbkluc2VydE5hdGl2ZU5vZGV9LlxuICpcbiAqIEBwYXJhbSBjaGlsZEVsIFRoZSBjaGlsZCB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZFxuICogQHBhcmFtIGNoaWxkVE5vZGUgVGhlIFROb2RlIG9mIHRoZSBjaGlsZCBlbGVtZW50XG4gKiBAcGFyYW0gY3VycmVudFZpZXcgVGhlIGN1cnJlbnQgTFZpZXdcbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlsZCB3YXMgYXBwZW5kZWRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY2hpbGRFbCwgY2hpbGRUTm9kZSwgY3VycmVudFZpZXcpIHtcbiAgICBpZiAoY2hpbGRFbCAhPT0gbnVsbCAmJiBjYW5JbnNlcnROYXRpdmVOb2RlKGNoaWxkVE5vZGUsIGN1cnJlbnRWaWV3KSkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBjdXJyZW50Vmlld1tSRU5ERVJFUl07XG4gICAgICAgIHZhciBwYXJlbnRFbCA9IGdldFBhcmVudE5hdGl2ZShjaGlsZFROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgICAgIHZhciBwYXJlbnRUTm9kZSA9IGNoaWxkVE5vZGUucGFyZW50IHx8IGN1cnJlbnRWaWV3W0hPU1RfTk9ERV07XG4gICAgICAgIGlmIChwYXJlbnRUTm9kZS50eXBlID09PSAyIC8qIFZpZXcgKi8pIHtcbiAgICAgICAgICAgIHZhciBsQ29udGFpbmVyID0gZ2V0TENvbnRhaW5lcihwYXJlbnRUTm9kZSwgY3VycmVudFZpZXcpO1xuICAgICAgICAgICAgdmFyIHZpZXdzID0gbENvbnRhaW5lcltWSUVXU107XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB2aWV3cy5pbmRleE9mKGN1cnJlbnRWaWV3KTtcbiAgICAgICAgICAgIG5hdGl2ZUluc2VydEJlZm9yZShyZW5kZXJlciwgbENvbnRhaW5lcltSRU5ERVJfUEFSRU5UXSwgY2hpbGRFbCwgZ2V0QmVmb3JlTm9kZUZvclZpZXcoaW5kZXgsIHZpZXdzLCBsQ29udGFpbmVyW05BVElWRV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRUTm9kZS50eXBlID09PSA0IC8qIEVsZW1lbnRDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50Q29udGFpbmVyID0gZ2V0SGlnaGVzdEVsZW1lbnRDb250YWluZXIoY2hpbGRUTm9kZSk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyUGFyZW50ID0gZ2V0UmVuZGVyUGFyZW50KGVsZW1lbnRDb250YWluZXIsIGN1cnJlbnRWaWV3KTtcbiAgICAgICAgICAgIG5hdGl2ZUluc2VydEJlZm9yZShyZW5kZXJlciwgcmVuZGVyUGFyZW50LCBjaGlsZEVsLCBwYXJlbnRFbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikgPyByZW5kZXJlci5hcHBlbmRDaGlsZChwYXJlbnRFbCwgY2hpbGRFbCkgOlxuICAgICAgICAgICAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNoaWxkRWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdldHMgdGhlIHRvcC1sZXZlbCBuZy1jb250YWluZXIgaWYgbmctY29udGFpbmVycyBhcmUgbmVzdGVkLlxuICpcbiAqIEBwYXJhbSBuZ0NvbnRhaW5lciBUaGUgVE5vZGUgb2YgdGhlIHN0YXJ0aW5nIG5nLWNvbnRhaW5lclxuICogQHJldHVybnMgdE5vZGUgVGhlIFROb2RlIG9mIHRoZSBoaWdoZXN0IGxldmVsIG5nLWNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBnZXRIaWdoZXN0RWxlbWVudENvbnRhaW5lcihuZ0NvbnRhaW5lcikge1xuICAgIHdoaWxlIChuZ0NvbnRhaW5lci5wYXJlbnQgIT0gbnVsbCAmJiBuZ0NvbnRhaW5lci5wYXJlbnQudHlwZSA9PT0gNCAvKiBFbGVtZW50Q29udGFpbmVyICovKSB7XG4gICAgICAgIG5nQ29udGFpbmVyID0gbmdDb250YWluZXIucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmdDb250YWluZXI7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVOb2RlRm9yVmlldyhpbmRleCwgdmlld3MsIGNvbnRhaW5lck5hdGl2ZSkge1xuICAgIGlmIChpbmRleCArIDEgPCB2aWV3cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3c1tpbmRleCArIDFdO1xuICAgICAgICB2YXIgdmlld1ROb2RlID0gdmlld1tIT1NUX05PREVdO1xuICAgICAgICByZXR1cm4gdmlld1ROb2RlLmNoaWxkID8gZ2V0TmF0aXZlQnlUTm9kZSh2aWV3VE5vZGUuY2hpbGQsIHZpZXcpIDogY29udGFpbmVyTmF0aXZlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lck5hdGl2ZTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGBjaGlsZGAgZWxlbWVudCBmcm9tIHRoZSBET00gaWYgbm90IGluIHZpZXcgYW5kIG5vdCBwcm9qZWN0ZWQuXG4gKlxuICogQHBhcmFtIGNoaWxkVE5vZGUgVGhlIFROb2RlIG9mIHRoZSBjaGlsZCB0byByZW1vdmVcbiAqIEBwYXJhbSBjaGlsZEVsIFRoZSBjaGlsZCB0aGF0IHNob3VsZCBiZSByZW1vdmVkXG4gKiBAcGFyYW0gY3VycmVudFZpZXcgVGhlIGN1cnJlbnQgTFZpZXdcbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlsZCB3YXMgcmVtb3ZlZFxuICovXG5mdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZFROb2RlLCBjaGlsZEVsLCBjdXJyZW50Vmlldykge1xuICAgIC8vIFdlIG9ubHkgcmVtb3ZlIHRoZSBlbGVtZW50IGlmIG5vdCBpbiBWaWV3IG9yIG5vdCBwcm9qZWN0ZWQuXG4gICAgaWYgKGNoaWxkRWwgIT09IG51bGwgJiYgY2FuSW5zZXJ0TmF0aXZlTm9kZShjaGlsZFROb2RlLCBjdXJyZW50VmlldykpIHtcbiAgICAgICAgdmFyIHBhcmVudE5hdGl2ZSA9IGdldFBhcmVudE5hdGl2ZShjaGlsZFROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGN1cnJlbnRWaWV3W1JFTkRFUkVSXTtcbiAgICAgICAgaXNQcm9jZWR1cmFsUmVuZGVyZXIocmVuZGVyZXIpID8gcmVuZGVyZXIucmVtb3ZlQ2hpbGQocGFyZW50TmF0aXZlLCBjaGlsZEVsKSA6XG4gICAgICAgICAgICBwYXJlbnROYXRpdmUucmVtb3ZlQ2hpbGQoY2hpbGRFbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEFwcGVuZHMgYSBwcm9qZWN0ZWQgbm9kZSB0byB0aGUgRE9NLCBvciBpbiB0aGUgY2FzZSBvZiBhIHByb2plY3RlZCBjb250YWluZXIsXG4gKiBhcHBlbmRzIHRoZSBub2RlcyBmcm9tIGFsbCBvZiB0aGUgY29udGFpbmVyJ3MgYWN0aXZlIHZpZXdzIHRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHByb2plY3RlZFROb2RlIFRoZSBUTm9kZSB0byBiZSBwcm9qZWN0ZWRcbiAqIEBwYXJhbSB0UHJvamVjdGlvbk5vZGUgVGhlIHByb2plY3Rpb24gKG5nLWNvbnRlbnQpIFROb2RlXG4gKiBAcGFyYW0gY3VycmVudFZpZXcgQ3VycmVudCBMVmlld1xuICogQHBhcmFtIHByb2plY3Rpb25WaWV3IFByb2plY3Rpb24gdmlldyAodmlldyBhYm92ZSBjdXJyZW50KVxuICovXG5mdW5jdGlvbiBhcHBlbmRQcm9qZWN0ZWROb2RlKHByb2plY3RlZFROb2RlLCB0UHJvamVjdGlvbk5vZGUsIGN1cnJlbnRWaWV3LCBwcm9qZWN0aW9uVmlldykge1xuICAgIHZhciBuYXRpdmUgPSBnZXROYXRpdmVCeVROb2RlKHByb2plY3RlZFROb2RlLCBwcm9qZWN0aW9uVmlldyk7XG4gICAgYXBwZW5kQ2hpbGQobmF0aXZlLCB0UHJvamVjdGlvbk5vZGUsIGN1cnJlbnRWaWV3KTtcbiAgICAvLyB0aGUgcHJvamVjdGVkIGNvbnRlbnRzIGFyZSBwcm9jZXNzZWQgd2hpbGUgaW4gdGhlIHNoYWRvdyB2aWV3ICh3aGljaCBpcyB0aGUgY3VycmVudFZpZXcpXG4gICAgLy8gdGhlcmVmb3JlIHdlIG5lZWQgdG8gZXh0cmFjdCB0aGUgdmlldyB3aGVyZSB0aGUgaG9zdCBlbGVtZW50IGxpdmVzIHNpbmNlIGl0J3MgdGhlXG4gICAgLy8gbG9naWNhbCBjb250YWluZXIgb2YgdGhlIGNvbnRlbnQgcHJvamVjdGVkIHZpZXdzXG4gICAgYXR0YWNoUGF0Y2hEYXRhKG5hdGl2ZSwgcHJvamVjdGlvblZpZXcpO1xuICAgIHZhciByZW5kZXJQYXJlbnQgPSBnZXRSZW5kZXJQYXJlbnQodFByb2plY3Rpb25Ob2RlLCBjdXJyZW50Vmlldyk7XG4gICAgdmFyIG5vZGVPckNvbnRhaW5lciA9IHByb2plY3Rpb25WaWV3W3Byb2plY3RlZFROb2RlLmluZGV4XTtcbiAgICBpZiAocHJvamVjdGVkVE5vZGUudHlwZSA9PT0gMCAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgd2UgYXJlIGFkZGluZyBpcyBhIGNvbnRhaW5lciBhbmQgd2UgYXJlIGFkZGluZyBpdCB0byBhbiBlbGVtZW50IHdoaWNoXG4gICAgICAgIC8vIGlzIG5vdCBhIGNvbXBvbmVudCAobm8gbW9yZSByZS1wcm9qZWN0aW9uKS5cbiAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSBhIGNvbnRhaW5lciBpcyBwcm9qZWN0ZWQgYXQgdGhlIHJvb3Qgb2YgYSBjb21wb25lbnQncyB0ZW1wbGF0ZVxuICAgICAgICAvLyBhbmQgY2FuJ3QgYmUgcmUtcHJvamVjdGVkIChhcyBub3QgY29udGVudCBvZiBhbnkgY29tcG9uZW50KS5cbiAgICAgICAgLy8gQXNzaWduIHRoZSBmaW5hbCBwcm9qZWN0aW9uIGxvY2F0aW9uIGluIHRob3NlIGNhc2VzLlxuICAgICAgICBub2RlT3JDb250YWluZXJbUkVOREVSX1BBUkVOVF0gPSByZW5kZXJQYXJlbnQ7XG4gICAgICAgIHZhciB2aWV3cyA9IG5vZGVPckNvbnRhaW5lcltWSUVXU107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZFJlbW92ZVZpZXdGcm9tQ29udGFpbmVyKHZpZXdzW2ldLCB0cnVlLCBub2RlT3JDb250YWluZXJbTkFUSVZFXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcm9qZWN0ZWRUTm9kZS50eXBlID09PSA0IC8qIEVsZW1lbnRDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgIHZhciBuZ0NvbnRhaW5lckNoaWxkVE5vZGUgPSBwcm9qZWN0ZWRUTm9kZS5jaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChuZ0NvbnRhaW5lckNoaWxkVE5vZGUpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRQcm9qZWN0ZWROb2RlKG5nQ29udGFpbmVyQ2hpbGRUTm9kZSwgdFByb2plY3Rpb25Ob2RlLCBjdXJyZW50VmlldywgcHJvamVjdGlvblZpZXcpO1xuICAgICAgICAgICAgICAgIG5nQ29udGFpbmVyQ2hpbGRUTm9kZSA9IG5nQ29udGFpbmVyQ2hpbGRUTm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xDb250YWluZXIobm9kZU9yQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgbm9kZU9yQ29udGFpbmVyW1JFTkRFUl9QQVJFTlRdID0gcmVuZGVyUGFyZW50O1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGQobm9kZU9yQ29udGFpbmVyW05BVElWRV0sIHRQcm9qZWN0aW9uTm9kZSwgY3VycmVudFZpZXcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBpc0Nzc0NsYXNzTWF0Y2hpbmcobm9kZUNsYXNzQXR0clZhbCwgY3NzQ2xhc3NUb01hdGNoKSB7XG4gICAgdmFyIG5vZGVDbGFzc2VzTGVuID0gbm9kZUNsYXNzQXR0clZhbC5sZW5ndGg7XG4gICAgdmFyIG1hdGNoSW5kZXggPSBub2RlQ2xhc3NBdHRyVmFsLmluZGV4T2YoY3NzQ2xhc3NUb01hdGNoKTtcbiAgICB2YXIgbWF0Y2hFbmRJZHggPSBtYXRjaEluZGV4ICsgY3NzQ2xhc3NUb01hdGNoLmxlbmd0aDtcbiAgICBpZiAobWF0Y2hJbmRleCA9PT0gLTEgLy8gbm8gbWF0Y2hcbiAgICAgICAgfHwgKG1hdGNoSW5kZXggPiAwICYmIG5vZGVDbGFzc0F0dHJWYWxbbWF0Y2hJbmRleCAtIDFdICE9PSAnICcpIC8vIG5vIHNwYWNlIGJlZm9yZVxuICAgICAgICB8fFxuICAgICAgICAgICAgKG1hdGNoRW5kSWR4IDwgbm9kZUNsYXNzZXNMZW4gJiYgbm9kZUNsYXNzQXR0clZhbFttYXRjaEVuZElkeF0gIT09ICcgJykpIC8vIG5vIHNwYWNlIGFmdGVyXG4gICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIG1hdGNoIGFuIEl2eSBub2RlIHN0YXRpYyBkYXRhIGFnYWluc3QgYSBzaW1wbGUgQ1NTIHNlbGVjdG9yXG4gKlxuICogQHBhcmFtIG5vZGUgc3RhdGljIGRhdGEgdG8gbWF0Y2hcbiAqIEBwYXJhbSBzZWxlY3RvclxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yKHROb2RlLCBzZWxlY3Rvcikge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHNlbGVjdG9yWzBdLCAnU2VsZWN0b3Igc2hvdWxkIGhhdmUgYSB0YWcgbmFtZScpO1xuICAgIHZhciBtb2RlID0gNCAvKiBFTEVNRU5UICovO1xuICAgIHZhciBub2RlQXR0cnMgPSB0Tm9kZS5hdHRycztcbiAgICB2YXIgc2VsZWN0T25seU1hcmtlcklkeCA9IG5vZGVBdHRycyA/IG5vZGVBdHRycy5pbmRleE9mKDEgLyogU2VsZWN0T25seSAqLykgOiAtMTtcbiAgICAvLyBXaGVuIHByb2Nlc3NpbmcgXCI6bm90XCIgc2VsZWN0b3JzLCB3ZSBza2lwIHRvIHRoZSBuZXh0IFwiOm5vdFwiIGlmIHRoZVxuICAgIC8vIGN1cnJlbnQgb25lIGRvZXNuJ3QgbWF0Y2hcbiAgICB2YXIgc2tpcFRvTmV4dFNlbGVjdG9yID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rvci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHNlbGVjdG9yW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5pc2ggcHJvY2Vzc2luZyBhIDpub3Qgc2VsZWN0b3IgYW5kIGl0IGhhc24ndCBmYWlsZWQsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgaWYgKCFza2lwVG9OZXh0U2VsZWN0b3IgJiYgIWlzUG9zaXRpdmUobW9kZSkgJiYgIWlzUG9zaXRpdmUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcgdG8gdGhlIG5leHQgOm5vdCgpIGFuZCB0aGlzIG1vZGUgZmxhZyBpcyBwb3NpdGl2ZSxcbiAgICAgICAgICAgIC8vIGl0J3MgYSBwYXJ0IG9mIHRoZSBjdXJyZW50IDpub3QoKSBzZWxlY3RvciwgYW5kIHdlIHNob3VsZCBrZWVwIHNraXBwaW5nXG4gICAgICAgICAgICBpZiAoc2tpcFRvTmV4dFNlbGVjdG9yICYmIGlzUG9zaXRpdmUoY3VycmVudCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBza2lwVG9OZXh0U2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIG1vZGUgPSBjdXJyZW50IHwgKG1vZGUgJiAxIC8qIE5PVCAqLyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcFRvTmV4dFNlbGVjdG9yKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChtb2RlICYgNCAvKiBFTEVNRU5UICovKSB7XG4gICAgICAgICAgICBtb2RlID0gMiAvKiBBVFRSSUJVVEUgKi8gfCBtb2RlICYgMSAvKiBOT1QgKi87XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gJycgJiYgY3VycmVudCAhPT0gdE5vZGUudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1Bvc2l0aXZlKG1vZGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2tpcFRvTmV4dFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IG1vZGUgJiA4IC8qIENMQVNTICovID8gJ2NsYXNzJyA6IGN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgYXR0ckluZGV4SW5Ob2RlID0gZmluZEF0dHJJbmRleEluTm9kZShhdHRyTmFtZSwgbm9kZUF0dHJzKTtcbiAgICAgICAgICAgIGlmIChhdHRySW5kZXhJbk5vZGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUG9zaXRpdmUobW9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBza2lwVG9OZXh0U2VsZWN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yQXR0clZhbHVlID0gbW9kZSAmIDggLyogQ0xBU1MgKi8gPyBjdXJyZW50IDogc2VsZWN0b3JbKytpXTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RvckF0dHJWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUF0dHJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVBdHRyTmFtZSA9IG5vZGVBdHRyc1thdHRySW5kZXhJbk5vZGVdO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RPbmx5TWFya2VySWR4ID4gLTEgJiYgYXR0ckluZGV4SW5Ob2RlID4gc2VsZWN0T25seU1hcmtlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlQXR0clZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm90RXF1YWwobWF5YmVBdHRyTmFtZSwgMCAvKiBOYW1lc3BhY2VVUkkgKi8sICdXZSBkbyBub3QgbWF0Y2ggZGlyZWN0aXZlcyBvbiBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUF0dHJWYWx1ZSA9IG5vZGVBdHRyc1thdHRySW5kZXhJbk5vZGUgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgJiA4IC8qIENMQVNTICovICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0Nzc0NsYXNzTWF0Y2hpbmcobm9kZUF0dHJWYWx1ZSwgc2VsZWN0b3JBdHRyVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgJiAyIC8qIEFUVFJJQlVURSAqLyAmJiBzZWxlY3RvckF0dHJWYWx1ZSAhPT0gbm9kZUF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQb3NpdGl2ZShtb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFRvTmV4dFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzUG9zaXRpdmUobW9kZSkgfHwgc2tpcFRvTmV4dFNlbGVjdG9yO1xufVxuZnVuY3Rpb24gaXNQb3NpdGl2ZShtb2RlKSB7XG4gICAgcmV0dXJuIChtb2RlICYgMSAvKiBOT1QgKi8pID09PSAwO1xufVxuLyoqXG4gKiBFeGFtaW5lcyBhbiBhdHRyaWJ1dGVzIGRlZmluaXRpb24gYXJyYXkgZnJvbSBhIG5vZGUgdG8gZmluZCB0aGUgaW5kZXggb2YgdGhlXG4gKiBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKlxuICogTk9URTogV2lsbCBub3QgZmluZCBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBmaW5kXG4gKiBAcGFyYW0gYXR0cnMgdGhlIGF0dHJpYnV0ZSBhcnJheSB0byBleGFtaW5lXG4gKi9cbmZ1bmN0aW9uIGZpbmRBdHRySW5kZXhJbk5vZGUobmFtZSwgYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB2YXIgc2VsZWN0T25seU1vZGUgPSBmYWxzZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhdHRycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG1heWJlQXR0ck5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgaWYgKG1heWJlQXR0ck5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1heWJlQXR0ck5hbWUgPT09IDAgLyogTmFtZXNwYWNlVVJJICovKSB7XG4gICAgICAgICAgICAvLyBOT1RFKGJlbmxlc2gpOiB3aWxsIG5vdCBmaW5kIG5hbWVzcGFjZWQgYXR0cmlidXRlcy4gVGhpcyBpcyBieSBkZXNpZ24uXG4gICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWF5YmVBdHRyTmFtZSA9PT0gMSAvKiBTZWxlY3RPbmx5ICovKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0T25seU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSBzZWxlY3RPbmx5TW9kZSA/IDEgOiAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JMaXN0KHROb2RlLCBzZWxlY3Rvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzTm9kZU1hdGNoaW5nU2VsZWN0b3IodE5vZGUsIHNlbGVjdG9yW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvamVjdEFzQXR0clZhbHVlKHROb2RlKSB7XG4gICAgdmFyIG5vZGVBdHRycyA9IHROb2RlLmF0dHJzO1xuICAgIGlmIChub2RlQXR0cnMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmdQcm9qZWN0QXNBdHRySWR4ID0gbm9kZUF0dHJzLmluZGV4T2YoTkdfUFJPSkVDVF9BU19BVFRSX05BTUUpO1xuICAgICAgICAvLyBvbmx5IGNoZWNrIGZvciBuZ1Byb2plY3RBcyBpbiBhdHRyaWJ1dGUgbmFtZXMsIGRvbid0IGFjY2lkZW50YWxseSBtYXRjaCBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgICAvLyAoYXR0cmlidXRlIG5hbWVzIGFyZSBzdG9yZWQgYXQgZXZlbiBpbmRleGVzKVxuICAgICAgICBpZiAoKG5nUHJvamVjdEFzQXR0cklkeCAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUF0dHJzW25nUHJvamVjdEFzQXR0cklkeCArIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDaGVja3MgYSBnaXZlbiBub2RlIGFnYWluc3QgbWF0Y2hpbmcgc2VsZWN0b3JzIGFuZCByZXR1cm5zXG4gKiBzZWxlY3RvciBpbmRleCAob3IgMCBpZiBub25lIG1hdGNoZWQpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW50byBhY2NvdW50IHRoZSBuZ1Byb2plY3RBcyBhdHRyaWJ1dGU6IGlmIHByZXNlbnQgaXRzIHZhbHVlIHdpbGwgYmUgY29tcGFyZWRcbiAqIHRvIHRoZSByYXcgKHVuLXBhcnNlZCkgQ1NTIHNlbGVjdG9yIGluc3RlYWQgb2YgdXNpbmcgc3RhbmRhcmQgc2VsZWN0b3IgbWF0Y2hpbmcgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoaW5nU2VsZWN0b3JJbmRleCh0Tm9kZSwgc2VsZWN0b3JzLCB0ZXh0U2VsZWN0b3JzKSB7XG4gICAgdmFyIG5nUHJvamVjdEFzQXR0clZhbCA9IGdldFByb2plY3RBc0F0dHJWYWx1ZSh0Tm9kZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gaWYgYSBub2RlIGhhcyB0aGUgbmdQcm9qZWN0QXMgYXR0cmlidXRlIG1hdGNoIGl0IGFnYWluc3QgdW5wYXJzZWQgc2VsZWN0b3JcbiAgICAgICAgLy8gbWF0Y2ggYSBub2RlIGFnYWluc3QgYSBwYXJzZWQgc2VsZWN0b3Igb25seSBpZiBuZ1Byb2plY3RBcyBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnRcbiAgICAgICAgaWYgKG5nUHJvamVjdEFzQXR0clZhbCA9PT0gdGV4dFNlbGVjdG9yc1tpXSB8fFxuICAgICAgICAgICAgbmdQcm9qZWN0QXNBdHRyVmFsID09PSBudWxsICYmIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JMaXN0KHROb2RlLCBzZWxlY3RvcnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaSArIDE7IC8vIGZpcnN0IG1hdGNoaW5nIHNlbGVjdG9yIFwiY2FwdHVyZXNcIiBhIGdpdmVuIG5vZGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBDb21iaW5lcyB0aGUgYmluZGluZyB2YWx1ZSBhbmQgYSBmYWN0b3J5IGZvciBhbiBhbmltYXRpb24gcGxheWVyLlxuICpcbiAqIFVzZWQgdG8gYmluZCBhIHBsYXllciB0byBhbiBlbGVtZW50IHRlbXBsYXRlIGJpbmRpbmcgKGN1cnJlbnRseSBvbmx5XG4gKiBgW3N0eWxlXWAsIGBbc3R5bGUucHJvcF1gLCBgW2NsYXNzXWAgYW5kIGBbY2xhc3MubmFtZV1gIGJpbmRpbmdzXG4gKiBzdXBwb3J0ZWQpLiBUaGUgcHJvdmlkZWQgYGZhY3RvcnlGbmAgZnVuY3Rpb24gd2lsbCBiZSBydW4gb25jZSBhbGxcbiAqIHRoZSBhc3NvY2lhdGVkIGJpbmRpbmdzIGhhdmUgYmVlbiBldmFsdWF0ZWQgb24gdGhlIGVsZW1lbnQgYW5kIGlzXG4gKiBkZXNpZ25lZCB0byByZXR1cm4gYSBwbGF5ZXIgd2hpY2ggd2lsbCB0aGVuIGJlIHBsYWNlZCBvbiB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gZmFjdG9yeUZuIFRoZSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gY3JlYXRlIGEgcGxheWVyXG4gKiAgIG9uY2UgYWxsIHRoZSByZW5kZXJpbmctcmVsYXRlZCAoc3R5bGluZyB2YWx1ZXMpIGhhdmUgYmVlblxuICogICBwcm9jZXNzZWQgZm9yIHRoZSBlbGVtZW50IGJpbmRpbmcuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHJhdyB2YWx1ZSB0aGF0IHdpbGwgYmUgZXhwb3NlZCB0byB0aGUgYmluZGluZ1xuICogICBzbyB0aGF0IHRoZSBiaW5kaW5nIGNhbiB1cGRhdGUgaXRzIGludGVybmFsIHZhbHVlcyB3aGVuXG4gKiAgIGFueSBjaGFuZ2VzIGFyZSBldmFsdWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRQbGF5ZXJGYWN0b3J5KGZhY3RvcnlGbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kUGxheWVyRmFjdG9yeShmYWN0b3J5Rm4sIHZhbHVlKTtcbn1cbnZhciBCb3VuZFBsYXllckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRQbGF5ZXJGYWN0b3J5KGZuLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIEJvdW5kUGxheWVyRmFjdG9yeTtcbn0oKSk7XG5cbnZhciBDb3JlUGxheWVySGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3JlUGxheWVySGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5fcGxheWVycyA9IFtdO1xuICAgIH1cbiAgICBDb3JlUGxheWVySGFuZGxlci5wcm90b3R5cGUuZmx1c2hQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLl9wbGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKCFwbGF5ZXIucGFyZW50ICYmIHBsYXllci5zdGF0ZSA9PT0gMCAvKiBQZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBDb3JlUGxheWVySGFuZGxlci5wcm90b3R5cGUucXVldWVQbGF5ZXIgPSBmdW5jdGlvbiAocGxheWVyKSB7IHRoaXMuX3BsYXllcnMucHVzaChwbGF5ZXIpOyB9O1xuICAgIHJldHVybiBDb3JlUGxheWVySGFuZGxlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5U3R5bGluZ0NvbnRleHQoZWxlbWVudCwgc2FuaXRpemVyLCBpbml0aWFsU3R5bGluZ1ZhbHVlcykge1xuICAgIHJldHVybiBbXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNhbml0aXplciB8fCBudWxsLFxuICAgICAgICBpbml0aWFsU3R5bGluZ1ZhbHVlcyB8fCBbbnVsbF0sXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGVsZW1lbnQgfHwgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCAvLyBQcmV2aW91c011bHRpU3R5bGVWYWx1ZVxuICAgIF07XG59XG4vKipcbiAqIFVzZWQgY2xvbmUgYSBjb3B5IG9mIGEgcHJlLWNvbXB1dGVkIHRlbXBsYXRlIG9mIGEgc3R5bGluZyBjb250ZXh0LlxuICpcbiAqIEEgcHJlLWNvbXB1dGVkIHRlbXBsYXRlIGlzIGRlc2lnbmVkIHRvIGJlIGNvbXB1dGVkIG9uY2UgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICogKGluc3RydWN0aW9ucy50cyBoYXMgbG9naWMgZm9yIGNhY2hpbmcgdGhpcykuXG4gKi9cbmZ1bmN0aW9uIGFsbG9jU3R5bGluZ0NvbnRleHQoZWxlbWVudCwgdGVtcGxhdGVTdHlsZUNvbnRleHQpIHtcbiAgICAvLyBlYWNoIGluc3RhbmNlIGdldHMgYSBjb3B5XG4gICAgdmFyIGNvbnRleHQgPSB0ZW1wbGF0ZVN0eWxlQ29udGV4dC5zbGljZSgpO1xuICAgIGNvbnRleHRbNSAvKiBFbGVtZW50UG9zaXRpb24gKi9dID0gZWxlbWVudDtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogUmV0cmlldmUgdGhlIGBTdHlsaW5nQ29udGV4dGAgYXQgYSBnaXZlbiBpbmRleC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBsYXppbHkgY3JlYXRlcyB0aGUgYFN0eWxpbmdDb250ZXh0YC4gVGhpcyBpcyBiZWNhdXNlIGluIG1vc3QgY2FzZXNcbiAqIHdlIGhhdmUgc3R5bGluZyB3aXRob3V0IGFueSBiaW5kaW5ncy4gQ3JlYXRpbmcgYFN0eWxpbmdDb250ZXh0YCBlYWdlcmx5IHdvdWxkIG1lYW4gdGhhdFxuICogZXZlcnkgc3R5bGUgZGVjbGFyYXRpb24gc3VjaCBhcyBgPGRpdiBzdHlsZT1cImNvbG9yOiByZWRcIj5gIHdvdWxkIHJlc3VsdCBgU3R5bGVDb250ZXh0YFxuICogd2hpY2ggd291bGQgY3JlYXRlIHVubmVjZXNzYXJ5IG1lbW9yeSBwcmVzc3VyZS5cbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIHN0eWxlIGFsbG9jYXRpb24uIFNlZTogYGVsZW1lbnRTdHlsaW5nYC5cbiAqIEBwYXJhbSB2aWV3RGF0YSBUaGUgdmlldyB0byBzZWFyY2ggZm9yIHRoZSBzdHlsaW5nIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGluZ0NvbnRleHQoaW5kZXgsIHZpZXdEYXRhKSB7XG4gICAgdmFyIHN0b3JhZ2VJbmRleCA9IGluZGV4ICsgSEVBREVSX09GRlNFVDtcbiAgICB2YXIgc2xvdFZhbHVlID0gdmlld0RhdGFbc3RvcmFnZUluZGV4XTtcbiAgICB2YXIgd3JhcHBlciA9IHZpZXdEYXRhO1xuICAgIHdoaWxlIChBcnJheS5pc0FycmF5KHNsb3RWYWx1ZSkpIHtcbiAgICAgICAgd3JhcHBlciA9IHNsb3RWYWx1ZTtcbiAgICAgICAgc2xvdFZhbHVlID0gc2xvdFZhbHVlW0hPU1RdO1xuICAgIH1cbiAgICBpZiAoaXNTdHlsaW5nQ29udGV4dCh3cmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gTFZpZXdEYXRhIG9yIGFuIExDb250YWluZXJcbiAgICAgICAgdmFyIHN0eWxpbmdUZW1wbGF0ZSA9IGdldFROb2RlKGluZGV4LCB2aWV3RGF0YSkuc3R5bGluZ1RlbXBsYXRlO1xuICAgICAgICBpZiAod3JhcHBlciAhPT0gdmlld0RhdGEpIHtcbiAgICAgICAgICAgIHN0b3JhZ2VJbmRleCA9IEhPU1Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZXJbc3RvcmFnZUluZGV4XSA9IHN0eWxpbmdUZW1wbGF0ZSA/XG4gICAgICAgICAgICBhbGxvY1N0eWxpbmdDb250ZXh0KHNsb3RWYWx1ZSwgc3R5bGluZ1RlbXBsYXRlKSA6XG4gICAgICAgICAgICBjcmVhdGVFbXB0eVN0eWxpbmdDb250ZXh0KHNsb3RWYWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdHlsaW5nQ29udGV4dCh2YWx1ZSkge1xuICAgIC8vIE5vdCBhbiBMVmlld0RhdGEgb3IgYW4gTENvbnRhaW5lclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWVbRkxBR1NdICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWVbQUNUSVZFX0lOREVYXSAhPT0gJ251bWJlcic7XG59XG5mdW5jdGlvbiBhZGRQbGF5ZXJJbnRlcm5hbChwbGF5ZXJDb250ZXh0LCByb290Q29udGV4dCwgZWxlbWVudCwgcGxheWVyLCBwbGF5ZXJDb250ZXh0SW5kZXgsIHJlZikge1xuICAgIHJlZiA9IHJlZiB8fCBlbGVtZW50O1xuICAgIGlmIChwbGF5ZXJDb250ZXh0SW5kZXgpIHtcbiAgICAgICAgcGxheWVyQ29udGV4dFtwbGF5ZXJDb250ZXh0SW5kZXhdID0gcGxheWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGxheWVyQ29udGV4dC5wdXNoKHBsYXllcik7XG4gICAgfVxuICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgcGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoMjAwIC8qIERlc3Ryb3llZCAqLywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGxheWVyQ29udGV4dC5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICB2YXIgbm9uRmFjdG9yeVBsYXllckluZGV4ID0gcGxheWVyQ29udGV4dFswIC8qIE5vbkJ1aWxkZXJQbGF5ZXJzU3RhcnQgKi9dO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBsYXllciBpcyBiZWluZyByZW1vdmVkIGZyb20gdGhlIGZhY3Rvcnkgc2lkZSBvZiB0aGUgY29udGV4dFxuICAgICAgICAgICAgLy8gKHdoaWNoIGlzIHdoZXJlIHRoZSBbc3R5bGVdIGFuZCBbY2xhc3NdIGJpbmRpbmdzIGRvIHRoZWlyIHRoaW5nKSB0aGVuXG4gICAgICAgICAgICAvLyB0aGF0IHNpZGUgb2YgdGhlIGFycmF5IGNhbm5vdCBiZSByZXNpemVkIHNpbmNlIHRoZSByZXNwZWN0aXZlIGJpbmRpbmdzXG4gICAgICAgICAgICAvLyBoYXZlIHBvaW50ZXIgaW5kZXggdmFsdWVzIHRoYXQgcG9pbnQgdG8gdGhlIGFzc29jaWF0ZWQgZmFjdG9yeSBpbnN0YW5jZVxuICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbm9uRmFjdG9yeVBsYXllckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllckNvbnRleHRbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllckNvbnRleHQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBsYXllckhhbmRsZXIgPSByb290Q29udGV4dC5wbGF5ZXJIYW5kbGVyIHx8IChyb290Q29udGV4dC5wbGF5ZXJIYW5kbGVyID0gbmV3IENvcmVQbGF5ZXJIYW5kbGVyKCkpO1xuICAgICAgICBwbGF5ZXJIYW5kbGVyLnF1ZXVlUGxheWVyKHBsYXllciwgcmVmKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFBsYXllcnNJbnRlcm5hbChwbGF5ZXJDb250ZXh0KSB7XG4gICAgdmFyIHBsYXllcnMgPSBbXTtcbiAgICB2YXIgbm9uRmFjdG9yeVBsYXllcnNTdGFydCA9IHBsYXllckNvbnRleHRbMCAvKiBOb25CdWlsZGVyUGxheWVyc1N0YXJ0ICovXTtcbiAgICAvLyBhZGQgYWxsIGZhY3RvcnktYmFzZWQgcGxheWVycyAod2hpY2ggYXJlIGFwYXJ0IG9mIFtzdHlsZV0gYW5kIFtjbGFzc10gYmluZGluZ3MpXG4gICAgZm9yICh2YXIgaSA9IDEgLyogUGxheWVyQnVpbGRlcnNTdGFydFBvc2l0aW9uICovICsgMSAvKiBQbGF5ZXJPZmZzZXRQb3NpdGlvbiAqLzsgaSA8IG5vbkZhY3RvcnlQbGF5ZXJzU3RhcnQ7IGkgKz0gMiAvKiBQbGF5ZXJBbmRQbGF5ZXJCdWlsZGVyc1R1cGxlU2l6ZSAqLykge1xuICAgICAgICB2YXIgcGxheWVyID0gcGxheWVyQ29udGV4dFtpXTtcbiAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIGFsbCBjdXN0b20gcGxheWVycyAobm90IGFwYXJ0IG9mIFtzdHlsZV0gYW5kIFtjbGFzc10gYmluZGluZ3MpXG4gICAgZm9yICh2YXIgaSA9IG5vbkZhY3RvcnlQbGF5ZXJzU3RhcnQ7IGkgPCBwbGF5ZXJDb250ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBsYXllcnMucHVzaChwbGF5ZXJDb250ZXh0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYXllcnM7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVBsYXllckNvbnRleHQodGFyZ2V0LCBjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgZ2V0Q29udGV4dCh0YXJnZXQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgdGhyb3dJbnZhbGlkUmVmRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsVmlld0RhdGEgPSBjb250ZXh0LmxWaWV3RGF0YSwgbm9kZUluZGV4ID0gY29udGV4dC5ub2RlSW5kZXg7XG4gICAgdmFyIHN0eWxpbmdDb250ZXh0ID0gZ2V0U3R5bGluZ0NvbnRleHQobm9kZUluZGV4IC0gSEVBREVSX09GRlNFVCwgbFZpZXdEYXRhKTtcbiAgICByZXR1cm4gZ2V0UGxheWVyQ29udGV4dChzdHlsaW5nQ29udGV4dCkgfHwgYWxsb2NQbGF5ZXJDb250ZXh0KHN0eWxpbmdDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldFBsYXllckNvbnRleHQoc3R5bGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gc3R5bGluZ0NvbnRleHRbMCAvKiBQbGF5ZXJDb250ZXh0ICovXTtcbn1cbmZ1bmN0aW9uIGFsbG9jUGxheWVyQ29udGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGFbMCAvKiBQbGF5ZXJDb250ZXh0ICovXSA9XG4gICAgICAgIFs1IC8qIFNpbmdsZVBsYXllckJ1aWxkZXJzU3RhcnRQb3NpdGlvbiAqLywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG59XG5mdW5jdGlvbiB0aHJvd0ludmFsaWRSZWZFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZWxlbWVudHMgdGhhdCBleGlzdCBpbiBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIGNhbiBiZSB1c2VkIGZvciBhbmltYXRpb25zJyk7XG59XG5cbnZhciBFTVBUWV9BUlIgPSBbXTtcbnZhciBFTVBUWV9PQkogPSB7fTtcbi8qKlxuICogQ3JlYXRlcyBhIHN0eWxpbmcgY29udGV4dCB0ZW1wbGF0ZSB3aGVyZSBzdHlsaW5nIGluZm9ybWF0aW9uIGlzIHN0b3JlZC5cbiAqIEFueSBzdHlsZXMgdGhhdCBhcmUgbGF0ZXIgcmVmZXJlbmNlZCB1c2luZyBgdXBkYXRlU3R5bGVQcm9wYCBtdXN0IGJlXG4gKiBwYXNzZWQgaW4gd2l0aGluIHRoaXMgZnVuY3Rpb24uIEluaXRpYWwgdmFsdWVzIGZvciB0aG9zZSBzdHlsZXMgYXJlIHRvXG4gKiBiZSBkZWNsYXJlZCBhZnRlciBhbGwgaW5pdGlhbCBzdHlsZSBwcm9wZXJ0aWVzIGFyZSBkZWNsYXJlZCAodGhpcyBjaGFuZ2UgaW5cbiAqIG1vZGUgYmV0d2VlbiBkZWNsYXJhdGlvbnMgYW5kIGluaXRpYWwgc3R5bGVzIGlzIG1hZGUgcG9zc2libGUgdXNpbmcgYSBzcGVjaWFsXG4gKiBlbnVtIHZhbHVlIGZvdW5kIGluIGBkZWZpbml0aW9uLnRzYCkuXG4gKlxuICogQHBhcmFtIGluaXRpYWxTdHlsZURlY2xhcmF0aW9ucyBhIGxpc3Qgb2Ygc3R5bGUgZGVjbGFyYXRpb25zIGFuZCBpbml0aWFsIHN0eWxlIHZhbHVlc1xuICogICAgdGhhdCBhcmUgdXNlZCBsYXRlciB3aXRoaW4gdGhlIHN0eWxpbmcgY29udGV4dC5cbiAqXG4gKiAgICAtPiBbJ3dpZHRoJywgJ2hlaWdodCcsIFNQRUNJQUxfRU5VTV9WQUwsICd3aWR0aCcsICcxMDBweCddXG4gKiAgICAgICBUaGlzIGltcGxpZXMgdGhhdCBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB3aWxsIGJlIGxhdGVyIHN0eWxlZCBhbmQgdGhhdCB0aGUgYHdpZHRoYFxuICogICAgICAgcHJvcGVydHkgaGFzIGFuIGluaXRpYWwgdmFsdWUgb2YgYDEwMHB4YC5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbENsYXNzRGVjbGFyYXRpb25zIGEgbGlzdCBvZiBjbGFzcyBkZWNsYXJhdGlvbnMgYW5kIGluaXRpYWwgY2xhc3MgdmFsdWVzXG4gKiAgICB0aGF0IGFyZSB1c2VkIGxhdGVyIHdpdGhpbiB0aGUgc3R5bGluZyBjb250ZXh0LlxuICpcbiAqICAgIC0+IFsnZm9vJywgJ2JhcicsIFNQRUNJQUxfRU5VTV9WQUwsICdmb28nLCB0cnVlXVxuICogICAgICAgVGhpcyBpbXBsaWVzIHRoYXQgYGZvb2AgYW5kIGBiYXJgIHdpbGwgYmUgbGF0ZXIgc3R5bGVkIGFuZCB0aGF0IHRoZSBgZm9vYFxuICogICAgICAgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IGFzIGFuIGluaXRpYWwgY2xhc3Mgc2luY2UgaXQncyB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxpbmdDb250ZXh0VGVtcGxhdGUoaW5pdGlhbENsYXNzRGVjbGFyYXRpb25zLCBpbml0aWFsU3R5bGVEZWNsYXJhdGlvbnMsIHN0eWxlU2FuaXRpemVyKSB7XG4gICAgdmFyIGluaXRpYWxTdHlsaW5nVmFsdWVzID0gW251bGxdO1xuICAgIHZhciBjb250ZXh0ID0gY3JlYXRlRW1wdHlTdHlsaW5nQ29udGV4dChudWxsLCBzdHlsZVNhbml0aXplciwgaW5pdGlhbFN0eWxpbmdWYWx1ZXMpO1xuICAgIC8vIHdlIHVzZSB0d28gbWFwcyBzaW5jZSBhIGNsYXNzIG5hbWUgbWlnaHQgY29sbGlkZSB3aXRoIGEgQ1NTIHN0eWxlIHByb3BcbiAgICB2YXIgc3R5bGVzTG9va3VwID0ge307XG4gICAgdmFyIGNsYXNzZXNMb29rdXAgPSB7fTtcbiAgICB2YXIgdG90YWxTdHlsZURlY2xhcmF0aW9ucyA9IDA7XG4gICAgaWYgKGluaXRpYWxTdHlsZURlY2xhcmF0aW9ucykge1xuICAgICAgICB2YXIgaGFzUGFzc2VkRGVjbGFyYXRpb25zID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbFN0eWxlRGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGluaXRpYWxTdHlsZURlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIC8vIHRoaXMgZmxhZyB2YWx1ZSBtYXJrcyB3aGVyZSB0aGUgZGVjbGFyYXRpb25zIGVuZCB0aGUgaW5pdGlhbCB2YWx1ZXMgYmVnaW5cbiAgICAgICAgICAgIGlmICh2ID09PSAxIC8qIFZBTFVFU19NT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaGFzUGFzc2VkRGVjbGFyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gdjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGFzc2VkRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxTdHlsZURlY2xhcmF0aW9uc1srK2ldO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsU3R5bGluZ1ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzTG9va3VwW3Byb3BdID0gaW5pdGlhbFN0eWxpbmdWYWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU3R5bGVEZWNsYXJhdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzTG9va3VwW3Byb3BdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbWFrZSB3aGVyZSB0aGUgY2xhc3Mgb2Zmc2V0cyBiZWdpblxuICAgIGNvbnRleHRbNCAvKiBDbGFzc09mZnNldFBvc2l0aW9uICovXSA9IHRvdGFsU3R5bGVEZWNsYXJhdGlvbnM7XG4gICAgaWYgKGluaXRpYWxDbGFzc0RlY2xhcmF0aW9ucykge1xuICAgICAgICB2YXIgaGFzUGFzc2VkRGVjbGFyYXRpb25zID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbENsYXNzRGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGluaXRpYWxDbGFzc0RlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIC8vIHRoaXMgZmxhZyB2YWx1ZSBtYXJrcyB3aGVyZSB0aGUgZGVjbGFyYXRpb25zIGVuZCB0aGUgaW5pdGlhbCB2YWx1ZXMgYmVnaW5cbiAgICAgICAgICAgIGlmICh2ID09PSAxIC8qIFZBTFVFU19NT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaGFzUGFzc2VkRGVjbGFyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB2O1xuICAgICAgICAgICAgICAgIGlmIChoYXNQYXNzZWREZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5pdGlhbENsYXNzRGVjbGFyYXRpb25zWysraV07XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxTdHlsaW5nVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzTG9va3VwW2NsYXNzTmFtZV0gPSBpbml0aWFsU3R5bGluZ1ZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlc0xvb2t1cFtjbGFzc05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlUHJvcHMgPSBPYmplY3Qua2V5cyhzdHlsZXNMb29rdXApO1xuICAgIHZhciBjbGFzc05hbWVzID0gT2JqZWN0LmtleXMoY2xhc3Nlc0xvb2t1cCk7XG4gICAgdmFyIGNsYXNzTmFtZXNJbmRleFN0YXJ0ID0gc3R5bGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIHRvdGFsUHJvcHMgPSBzdHlsZVByb3BzLmxlbmd0aCArIGNsYXNzTmFtZXMubGVuZ3RoO1xuICAgIC8vICoyIGJlY2F1c2Ugd2UgYXJlIGZpbGxpbmcgZm9yIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBzdHlsZSBzcGFjZXNcbiAgICB2YXIgbWF4TGVuZ3RoID0gdG90YWxQcm9wcyAqIDQgLyogU2l6ZSAqLyAqIDIgKyA4IC8qIFNpbmdsZVN0eWxlc1N0YXJ0UG9zaXRpb24gKi87XG4gICAgLy8gd2UgbmVlZCB0byBmaWxsIHRoZSBhcnJheSBmcm9tIHRoZSBzdGFydCBzbyB0aGF0IHdlIGNhbiBhY2Nlc3NcbiAgICAvLyBib3RoIHRoZSBtdWx0aSBhbmQgdGhlIHNpbmdsZSBhcnJheSBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgbG9vcCBibG9ja1xuICAgIGZvciAodmFyIGkgPSA4IC8qIFNpbmdsZVN0eWxlc1N0YXJ0UG9zaXRpb24gKi87IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZXh0LnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHZhciBzaW5nbGVTdGFydCA9IDggLyogU2luZ2xlU3R5bGVzU3RhcnRQb3NpdGlvbiAqLztcbiAgICB2YXIgbXVsdGlTdGFydCA9IHRvdGFsUHJvcHMgKiA0IC8qIFNpemUgKi8gKyA4IC8qIFNpbmdsZVN0eWxlc1N0YXJ0UG9zaXRpb24gKi87XG4gICAgLy8gZmlsbCBzaW5nbGUgYW5kIG11bHRpLWxldmVsIHN0eWxlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxQcm9wczsgaSsrKSB7XG4gICAgICAgIHZhciBpc0NsYXNzQmFzZWRfMSA9IGkgPj0gY2xhc3NOYW1lc0luZGV4U3RhcnQ7XG4gICAgICAgIHZhciBwcm9wID0gaXNDbGFzc0Jhc2VkXzEgPyBjbGFzc05hbWVzW2kgLSBjbGFzc05hbWVzSW5kZXhTdGFydF0gOiBzdHlsZVByb3BzW2ldO1xuICAgICAgICB2YXIgaW5kZXhGb3JJbml0aWFsID0gaXNDbGFzc0Jhc2VkXzEgPyBjbGFzc2VzTG9va3VwW3Byb3BdIDogc3R5bGVzTG9va3VwW3Byb3BdO1xuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gaW5pdGlhbFN0eWxpbmdWYWx1ZXNbaW5kZXhGb3JJbml0aWFsXTtcbiAgICAgICAgdmFyIGluZGV4Rm9yTXVsdGkgPSBpICogNCAvKiBTaXplICovICsgbXVsdGlTdGFydDtcbiAgICAgICAgdmFyIGluZGV4Rm9yU2luZ2xlID0gaSAqIDQgLyogU2l6ZSAqLyArIHNpbmdsZVN0YXJ0O1xuICAgICAgICB2YXIgaW5pdGlhbEZsYWcgPSBwcmVwYXJlSW5pdGlhbEZsYWcocHJvcCwgaXNDbGFzc0Jhc2VkXzEsIHN0eWxlU2FuaXRpemVyIHx8IG51bGwpO1xuICAgICAgICBzZXRGbGFnKGNvbnRleHQsIGluZGV4Rm9yU2luZ2xlLCBwb2ludGVycyhpbml0aWFsRmxhZywgaW5kZXhGb3JJbml0aWFsLCBpbmRleEZvck11bHRpKSk7XG4gICAgICAgIHNldFByb3AoY29udGV4dCwgaW5kZXhGb3JTaW5nbGUsIHByb3ApO1xuICAgICAgICBzZXRWYWx1ZShjb250ZXh0LCBpbmRleEZvclNpbmdsZSwgbnVsbCk7XG4gICAgICAgIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleEZvclNpbmdsZSwgMCk7XG4gICAgICAgIHZhciBmbGFnRm9yTXVsdGkgPSBpbml0aWFsRmxhZyB8IChpbml0aWFsVmFsdWUgIT09IG51bGwgPyAxIC8qIERpcnR5ICovIDogMCAvKiBOb25lICovKTtcbiAgICAgICAgc2V0RmxhZyhjb250ZXh0LCBpbmRleEZvck11bHRpLCBwb2ludGVycyhmbGFnRm9yTXVsdGksIGluZGV4Rm9ySW5pdGlhbCwgaW5kZXhGb3JTaW5nbGUpKTtcbiAgICAgICAgc2V0UHJvcChjb250ZXh0LCBpbmRleEZvck11bHRpLCBwcm9wKTtcbiAgICAgICAgc2V0VmFsdWUoY29udGV4dCwgaW5kZXhGb3JNdWx0aSwgbnVsbCk7XG4gICAgICAgIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleEZvck11bHRpLCAwKTtcbiAgICB9XG4gICAgLy8gdGhlcmUgaXMgbm8gaW5pdGlhbCB2YWx1ZSBmbGFnIGZvciB0aGUgbWFzdGVyIGluZGV4IHNpbmNlIGl0IGRvZXNuJ3RcbiAgICAvLyByZWZlcmVuY2UgYW4gaW5pdGlhbCBzdHlsZSB2YWx1ZVxuICAgIHNldEZsYWcoY29udGV4dCwgMyAvKiBNYXN0ZXJGbGFnUG9zaXRpb24gKi8sIHBvaW50ZXJzKDAsIDAsIG11bHRpU3RhcnQpKTtcbiAgICBzZXRDb250ZXh0RGlydHkoY29udGV4dCwgaW5pdGlhbFN0eWxpbmdWYWx1ZXMubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG4vKipcbiAqIFNldHMgYW5kIHJlc29sdmVzIGFsbCBgbXVsdGlgIHN0eWxpbmcgb24gYW4gYFN0eWxpbmdDb250ZXh0YCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4gKiBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IG9uY2UgYHJlbmRlclN0eWxlQW5kQ2xhc3NCaW5kaW5nc2AgaXMgY2FsbGVkLlxuICpcbiAqIEFsbCBtaXNzaW5nIHN0eWxlcy9jbGFzcyAoYW55IHZhbHVlcyB0aGF0IGFyZSBub3QgcHJvdmlkZWQgaW4gdGhlIG5ldyBgc3R5bGVzYFxuICogb3IgYGNsYXNzZXNgIHBhcmFtcykgd2lsbCByZXNvbHZlIHRvIGBudWxsYCB3aXRoaW4gdGhlaXIgcmVzcGVjdGl2ZSBwb3NpdGlvbnNcbiAqIGluIHRoZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBzdHlsaW5nIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCB0aGVcbiAqICAgIG5ld2x5IHByb3ZpZGVkIHN0eWxlIHZhbHVlcy5cbiAqIEBwYXJhbSBjbGFzc2VzSW5wdXQgVGhlIGtleS92YWx1ZSBtYXAgb2YgQ1NTIGNsYXNzIG5hbWVzIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgdXBkYXRlLlxuICogQHBhcmFtIHN0eWxlc0lucHV0IFRoZSBrZXkvdmFsdWUgbWFwIG9mIENTUyBzdHlsZXMgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSB1cGRhdGUuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxpbmdNYXAoY29udGV4dCwgY2xhc3Nlc0lucHV0LCBzdHlsZXNJbnB1dCkge1xuICAgIHN0eWxlc0lucHV0ID0gc3R5bGVzSW5wdXQgfHwgbnVsbDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRbNSAvKiBFbGVtZW50UG9zaXRpb24gKi9dO1xuICAgIHZhciBjbGFzc2VzUGxheWVyQnVpbGRlciA9IGNsYXNzZXNJbnB1dCBpbnN0YW5jZW9mIEJvdW5kUGxheWVyRmFjdG9yeSA/XG4gICAgICAgIG5ldyBDbGFzc0FuZFN0eWxlUGxheWVyQnVpbGRlcihjbGFzc2VzSW5wdXQsIGVsZW1lbnQsIDIgLyogQ2xhc3MgKi8pIDpcbiAgICAgICAgbnVsbDtcbiAgICB2YXIgc3R5bGVzUGxheWVyQnVpbGRlciA9IHN0eWxlc0lucHV0IGluc3RhbmNlb2YgQm91bmRQbGF5ZXJGYWN0b3J5ID9cbiAgICAgICAgbmV3IENsYXNzQW5kU3R5bGVQbGF5ZXJCdWlsZGVyKHN0eWxlc0lucHV0LCBlbGVtZW50LCAzIC8qIFN0eWxlICovKSA6XG4gICAgICAgIG51bGw7XG4gICAgdmFyIGNsYXNzZXNWYWx1ZSA9IGNsYXNzZXNQbGF5ZXJCdWlsZGVyID9cbiAgICAgICAgY2xhc3Nlc0lucHV0LnZhbHVlIDpcbiAgICAgICAgY2xhc3Nlc0lucHV0O1xuICAgIHZhciBzdHlsZXNWYWx1ZSA9IHN0eWxlc1BsYXllckJ1aWxkZXIgPyBzdHlsZXNJbnB1dC52YWx1ZSA6IHN0eWxlc0lucHV0O1xuICAgIC8vIGVhcmx5IGV4aXQgKHRoaXMgaXMgd2hhdCdzIGRvbmUgdG8gYXZvaWQgdXNpbmcgY3R4LmJpbmQoKSB0byBjYWNoZSB0aGUgdmFsdWUpXG4gICAgdmFyIGlnbm9yZUFsbENsYXNzVXBkYXRlcyA9IGNsYXNzZXNWYWx1ZSA9PT0gY29udGV4dFs2IC8qIFByZXZpb3VzTXVsdGlDbGFzc1ZhbHVlICovXTtcbiAgICB2YXIgaWdub3JlQWxsU3R5bGVVcGRhdGVzID0gc3R5bGVzVmFsdWUgPT09IGNvbnRleHRbNyAvKiBQcmV2aW91c011bHRpU3R5bGVWYWx1ZSAqL107XG4gICAgaWYgKGlnbm9yZUFsbENsYXNzVXBkYXRlcyAmJiBpZ25vcmVBbGxTdHlsZVVwZGF0ZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjb250ZXh0WzYgLyogUHJldmlvdXNNdWx0aUNsYXNzVmFsdWUgKi9dID0gY2xhc3Nlc1ZhbHVlO1xuICAgIGNvbnRleHRbNyAvKiBQcmV2aW91c011bHRpU3R5bGVWYWx1ZSAqL10gPSBzdHlsZXNWYWx1ZTtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IEVNUFRZX0FSUjtcbiAgICB2YXIgYXBwbHlBbGxDbGFzc2VzID0gZmFsc2U7XG4gICAgdmFyIHBsYXllckJ1aWxkZXJzQXJlRGlydHkgPSBmYWxzZTtcbiAgICB2YXIgY2xhc3Nlc1BsYXllckJ1aWxkZXJJbmRleCA9IGNsYXNzZXNQbGF5ZXJCdWlsZGVyID8gMSAvKiBDbGFzc01hcFBsYXllckJ1aWxkZXJQb3NpdGlvbiAqLyA6IDA7XG4gICAgaWYgKGhhc1BsYXllckJ1aWxkZXJDaGFuZ2VkKGNvbnRleHQsIGNsYXNzZXNQbGF5ZXJCdWlsZGVyLCAxIC8qIENsYXNzTWFwUGxheWVyQnVpbGRlclBvc2l0aW9uICovKSkge1xuICAgICAgICBzZXRQbGF5ZXJCdWlsZGVyKGNvbnRleHQsIGNsYXNzZXNQbGF5ZXJCdWlsZGVyLCAxIC8qIENsYXNzTWFwUGxheWVyQnVpbGRlclBvc2l0aW9uICovKTtcbiAgICAgICAgcGxheWVyQnVpbGRlcnNBcmVEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBzdHlsZXNQbGF5ZXJCdWlsZGVySW5kZXggPSBzdHlsZXNQbGF5ZXJCdWlsZGVyID8gMyAvKiBTdHlsZU1hcFBsYXllckJ1aWxkZXJQb3NpdGlvbiAqLyA6IDA7XG4gICAgaWYgKGhhc1BsYXllckJ1aWxkZXJDaGFuZ2VkKGNvbnRleHQsIHN0eWxlc1BsYXllckJ1aWxkZXIsIDMgLyogU3R5bGVNYXBQbGF5ZXJCdWlsZGVyUG9zaXRpb24gKi8pKSB7XG4gICAgICAgIHNldFBsYXllckJ1aWxkZXIoY29udGV4dCwgc3R5bGVzUGxheWVyQnVpbGRlciwgMyAvKiBTdHlsZU1hcFBsYXllckJ1aWxkZXJQb3NpdGlvbiAqLyk7XG4gICAgICAgIHBsYXllckJ1aWxkZXJzQXJlRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBlYWNoIHRpbWUgYSBzdHJpbmctYmFzZWQgdmFsdWUgcG9wcyB1cCB0aGVuIGl0IHNob3VsZG4ndCByZXF1aXJlIGEgZGVlcFxuICAgIC8vIGNoZWNrIG9mIHdoYXQncyBjaGFuZ2VkLlxuICAgIGlmICghaWdub3JlQWxsQ2xhc3NVcGRhdGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3Nlc1ZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1ZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAvLyB0aGlzIGJvb2xlYW4gaXMgdXNlZCB0byBhdm9pZCBoYXZpbmcgdG8gY3JlYXRlIGEga2V5L3ZhbHVlIG1hcCBvZiBgdHJ1ZWAgdmFsdWVzXG4gICAgICAgICAgICAvLyBzaW5jZSBhIGNsYXNzbmFtZSBzdHJpbmcgaW1wbGllcyB0aGF0IGFsbCB0aG9zZSBjbGFzc2VzIGFyZSBhZGRlZFxuICAgICAgICAgICAgYXBwbHlBbGxDbGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc2VzVmFsdWUgPyBPYmplY3Qua2V5cyhjbGFzc2VzVmFsdWUpIDogRU1QVFlfQVJSO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjbGFzc2VzID0gKGNsYXNzZXNWYWx1ZSB8fCBFTVBUWV9PQkopO1xuICAgIHZhciBzdHlsZVByb3BzID0gc3R5bGVzVmFsdWUgPyBPYmplY3Qua2V5cyhzdHlsZXNWYWx1ZSkgOiBFTVBUWV9BUlI7XG4gICAgdmFyIHN0eWxlcyA9IHN0eWxlc1ZhbHVlIHx8IEVNUFRZX09CSjtcbiAgICB2YXIgY2xhc3Nlc1N0YXJ0SW5kZXggPSBzdHlsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgbXVsdGlTdGFydEluZGV4ID0gZ2V0TXVsdGlTdGFydEluZGV4KGNvbnRleHQpO1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xuICAgIHZhciBjdHhJbmRleCA9IG11bHRpU3RhcnRJbmRleDtcbiAgICB2YXIgcHJvcEluZGV4ID0gMDtcbiAgICB2YXIgcHJvcExpbWl0ID0gc3R5bGVQcm9wcy5sZW5ndGggKyBjbGFzc05hbWVzLmxlbmd0aDtcbiAgICAvLyB0aGUgbWFpbiBsb29wIGhlcmUgd2lsbCB0cnkgYW5kIGZpZ3VyZSBvdXQgaG93IHRoZSBzaGFwZSBvZiB0aGUgcHJvdmlkZWRcbiAgICAvLyBzdHlsZXMgZGlmZmVyIHdpdGggcmVzcGVjdCB0byB0aGUgY29udGV4dC4gTGF0ZXIgaWYgdGhlIGNvbnRleHQvc3R5bGVzL2NsYXNzZXNcbiAgICAvLyBhcmUgb2ZmLWJhbGFuY2UgdGhlbiB0aGV5IHdpbGwgYmUgZGVhbHQgaW4gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lXG4gICAgd2hpbGUgKGN0eEluZGV4IDwgY29udGV4dC5sZW5ndGggJiYgcHJvcEluZGV4IDwgcHJvcExpbWl0KSB7XG4gICAgICAgIHZhciBpc0NsYXNzQmFzZWRfMiA9IHByb3BJbmRleCA+PSBjbGFzc2VzU3RhcnRJbmRleDtcbiAgICAgICAgdmFyIHByb2Nlc3NWYWx1ZSA9ICghaXNDbGFzc0Jhc2VkXzIgJiYgIWlnbm9yZUFsbFN0eWxlVXBkYXRlcykgfHwgKGlzQ2xhc3NCYXNlZF8yICYmICFpZ25vcmVBbGxDbGFzc1VwZGF0ZXMpO1xuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIGEgY2FjaGUtaGl0IGZvciBhIHN0cmluZy1iYXNlZCBjbGFzcyB0aGVuIHdlIHNob3VsZFxuICAgICAgICAvLyBhdm9pZCBkb2luZyBhbnkgd29yayBkaWZmaW5nIGFueSBvZiB0aGUgY2hhbmdlc1xuICAgICAgICBpZiAocHJvY2Vzc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0ZWRQcm9wSW5kZXggPSBpc0NsYXNzQmFzZWRfMiA/IHByb3BJbmRleCAtIGNsYXNzZXNTdGFydEluZGV4IDogcHJvcEluZGV4O1xuICAgICAgICAgICAgdmFyIG5ld1Byb3AgPSBpc0NsYXNzQmFzZWRfMiA/IGNsYXNzTmFtZXNbYWRqdXN0ZWRQcm9wSW5kZXhdIDogc3R5bGVQcm9wc1thZGp1c3RlZFByb3BJbmRleF07XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBpc0NsYXNzQmFzZWRfMiA/IChhcHBseUFsbENsYXNzZXMgPyB0cnVlIDogY2xhc3Nlc1tuZXdQcm9wXSkgOiBzdHlsZXNbbmV3UHJvcF07XG4gICAgICAgICAgICB2YXIgcGxheWVyQnVpbGRlckluZGV4ID0gaXNDbGFzc0Jhc2VkXzIgPyBjbGFzc2VzUGxheWVyQnVpbGRlckluZGV4IDogc3R5bGVzUGxheWVyQnVpbGRlckluZGV4O1xuICAgICAgICAgICAgdmFyIHByb3AgPSBnZXRQcm9wKGNvbnRleHQsIGN0eEluZGV4KTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBuZXdQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoY29udGV4dCwgY3R4SW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBmbGFnID0gZ2V0UG9pbnRlcnMoY29udGV4dCwgY3R4SW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBjdHhJbmRleCwgcGxheWVyQnVpbGRlckluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWVDaGFuZ2VkKGZsYWcsIHZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoY29udGV4dCwgY3R4SW5kZXgsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyQnVpbGRlcnNBcmVEaXJ0eSA9IHBsYXllckJ1aWxkZXJzQXJlRGlydHkgfHwgISFwbGF5ZXJCdWlsZGVySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoY29udGV4dCwgZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGluIHNldHRpbmcgdGhpcyB0byBkaXJ0eSBpZiB0aGUgcHJldmlvdXNseVxuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXJlZCB2YWx1ZSB3YXMgYmVpbmcgcmVmZXJlbmNlZCBieSB0aGUgaW5pdGlhbCBzdHlsZSAob3IgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlQ2hhbmdlZChmbGFnLCBpbml0aWFsVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGlydHkoY29udGV4dCwgY3R4SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2ZFbnRyeSA9IGZpbmRFbnRyeVBvc2l0aW9uQnlQcm9wKGNvbnRleHQsIG5ld1Byb3AsIGN0eEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZkVudHJ5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCB3YXMgZm91bmQgYXQgYSBsYXRlciBwb2ludCAuLi4ganVzdCBzd2FwIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlVG9Db21wYXJlID0gZ2V0VmFsdWUoY29udGV4dCwgaW5kZXhPZkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdUb0NvbXBhcmUgPSBnZXRQb2ludGVycyhjb250ZXh0LCBpbmRleE9mRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBzd2FwTXVsdGlDb250ZXh0RW50cmllcyhjb250ZXh0LCBjdHhJbmRleCwgaW5kZXhPZkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlQ2hhbmdlZChmbGFnVG9Db21wYXJlLCB2YWx1ZVRvQ29tcGFyZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKGNvbnRleHQsIGZsYWdUb0NvbXBhcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoY29udGV4dCwgY3R4SW5kZXgsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZUNoYW5nZWQoZmxhZ1RvQ29tcGFyZSwgaW5pdGlhbFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREaXJ0eShjb250ZXh0LCBjdHhJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyQnVpbGRlcnNBcmVEaXJ0eSA9IHBsYXllckJ1aWxkZXJzQXJlRGlydHkgfHwgISFwbGF5ZXJCdWlsZGVySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IGNhcmUgdG8gZG8gdGhpcyBpZiB0aGUgaW5zZXJ0aW9uIGlzIGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ZsYWcgPSBwcmVwYXJlSW5pdGlhbEZsYWcobmV3UHJvcCwgaXNDbGFzc0Jhc2VkXzIsIGdldFN0eWxlU2FuaXRpemVyKGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyQnVpbGRlcnNBcmVEaXJ0eSA9IHBsYXllckJ1aWxkZXJzQXJlRGlydHkgfHwgISFwbGF5ZXJCdWlsZGVySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydE5ld011bHRpUHJvcGVydHkoY29udGV4dCwgY3R4SW5kZXgsIGlzQ2xhc3NCYXNlZF8yLCBuZXdQcm9wLCBuZXdGbGFnLCBuZXdWYWx1ZSwgcGxheWVyQnVpbGRlckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHhJbmRleCArPSA0IC8qIFNpemUgKi87XG4gICAgICAgIHByb3BJbmRleCsrO1xuICAgIH1cbiAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlcmUgYXJlIGxlZnQtb3ZlciB2YWx1ZXMgaW4gdGhlIGNvbnRleHQgdGhhdFxuICAgIC8vIHdlcmUgbm90IGluY2x1ZGVkIGluIHRoZSBwcm92aWRlZCBzdHlsZXMvY2xhc3NlcyBhbmQgaW4gdGhpc1xuICAgIC8vIGNhc2UgdGhlICBnb2FsIGlzIHRvIFwicmVtb3ZlXCIgdGhlbSBmcm9tIHRoZSBjb250ZXh0IChieSBudWxsaWZ5aW5nKVxuICAgIHdoaWxlIChjdHhJbmRleCA8IGNvbnRleHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmbGFnID0gZ2V0UG9pbnRlcnMoY29udGV4dCwgY3R4SW5kZXgpO1xuICAgICAgICB2YXIgaXNDbGFzc0Jhc2VkXzMgPSAoZmxhZyAmIDIgLyogQ2xhc3MgKi8pID09PSAyIC8qIENsYXNzICovO1xuICAgICAgICB2YXIgcHJvY2Vzc1ZhbHVlID0gKCFpc0NsYXNzQmFzZWRfMyAmJiAhaWdub3JlQWxsU3R5bGVVcGRhdGVzKSB8fCAoaXNDbGFzc0Jhc2VkXzMgJiYgIWlnbm9yZUFsbENsYXNzVXBkYXRlcyk7XG4gICAgICAgIGlmIChwcm9jZXNzVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGNvbnRleHQsIGN0eEluZGV4KTtcbiAgICAgICAgICAgIHZhciBkb1JlbW92ZVZhbHVlID0gdmFsdWVFeGlzdHModmFsdWUsIGlzQ2xhc3NCYXNlZF8zKTtcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0RGlydHkoY29udGV4dCwgY3R4SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKGNvbnRleHQsIGN0eEluZGV4LCBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBrZWVwIHRoZSBwbGF5ZXIgZmFjdG9yeSB0aGUgc2FtZSBzbyB0aGF0IHRoZSBgbnVsbGVkYCB2YWx1ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBiZSBpbnN0cnVjdGVkIGludG8gdGhlIHBsYXllciBiZWNhdXNlIHJlbW92aW5nIGEgc3R5bGUgYW5kL29yIGEgY2xhc3NcbiAgICAgICAgICAgICAgICAvLyBpcyBhIHZhbGlkIGFuaW1hdGlvbiBwbGF5ZXIgaW5zdHJ1Y3Rpb24uXG4gICAgICAgICAgICAgICAgdmFyIHBsYXllckJ1aWxkZXJJbmRleCA9IGlzQ2xhc3NCYXNlZF8zID8gY2xhc3Nlc1BsYXllckJ1aWxkZXJJbmRleCA6IHN0eWxlc1BsYXllckJ1aWxkZXJJbmRleDtcbiAgICAgICAgICAgICAgICBzZXRQbGF5ZXJCdWlsZGVySW5kZXgoY29udGV4dCwgY3R4SW5kZXgsIHBsYXllckJ1aWxkZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eEluZGV4ICs9IDQgLyogU2l6ZSAqLztcbiAgICB9XG4gICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZXJlIGFyZSBsZWZ0LW92ZXIgcHJvcGVydGllcyBpbiB0aGUgY29udGV4dCB0aGF0XG4gICAgLy8gd2VyZSBub3QgZGV0ZWN0ZWQgaW4gdGhlIGNvbnRleHQgZHVyaW5nIHRoZSBsb29wIGFib3ZlLiBJbiB0aGF0XG4gICAgLy8gY2FzZSB3ZSB3YW50IHRvIGFkZCB0aGUgbmV3IGVudHJpZXMgaW50byB0aGUgbGlzdFxuICAgIHZhciBzYW5pdGl6ZXIgPSBnZXRTdHlsZVNhbml0aXplcihjb250ZXh0KTtcbiAgICB3aGlsZSAocHJvcEluZGV4IDwgcHJvcExpbWl0KSB7XG4gICAgICAgIHZhciBpc0NsYXNzQmFzZWRfNCA9IHByb3BJbmRleCA+PSBjbGFzc2VzU3RhcnRJbmRleDtcbiAgICAgICAgdmFyIHByb2Nlc3NWYWx1ZSA9ICghaXNDbGFzc0Jhc2VkXzQgJiYgIWlnbm9yZUFsbFN0eWxlVXBkYXRlcykgfHwgKGlzQ2xhc3NCYXNlZF80ICYmICFpZ25vcmVBbGxDbGFzc1VwZGF0ZXMpO1xuICAgICAgICBpZiAocHJvY2Vzc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0ZWRQcm9wSW5kZXggPSBpc0NsYXNzQmFzZWRfNCA/IHByb3BJbmRleCAtIGNsYXNzZXNTdGFydEluZGV4IDogcHJvcEluZGV4O1xuICAgICAgICAgICAgdmFyIHByb3AgPSBpc0NsYXNzQmFzZWRfNCA/IGNsYXNzTmFtZXNbYWRqdXN0ZWRQcm9wSW5kZXhdIDogc3R5bGVQcm9wc1thZGp1c3RlZFByb3BJbmRleF07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpc0NsYXNzQmFzZWRfNCA/IChhcHBseUFsbENsYXNzZXMgPyB0cnVlIDogY2xhc3Nlc1twcm9wXSkgOiBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB2YXIgZmxhZyA9IHByZXBhcmVJbml0aWFsRmxhZyhwcm9wLCBpc0NsYXNzQmFzZWRfNCwgc2FuaXRpemVyKSB8IDEgLyogRGlydHkgKi87XG4gICAgICAgICAgICB2YXIgcGxheWVyQnVpbGRlckluZGV4ID0gaXNDbGFzc0Jhc2VkXzQgPyBjbGFzc2VzUGxheWVyQnVpbGRlckluZGV4IDogc3R5bGVzUGxheWVyQnVpbGRlckluZGV4O1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKGZsYWcsIHByb3AsIHZhbHVlLCBwbGF5ZXJCdWlsZGVySW5kZXgpO1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHByb3BJbmRleCsrO1xuICAgIH1cbiAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgc2V0Q29udGV4dERpcnR5KGNvbnRleHQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAocGxheWVyQnVpbGRlcnNBcmVEaXJ0eSkge1xuICAgICAgICBzZXRDb250ZXh0UGxheWVyc0RpcnR5KGNvbnRleHQsIHRydWUpO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyBhbmQgcmVzb2x2ZXMgYSBzaW5nbGUgc3R5bGluZyBwcm9wZXJ0eS92YWx1ZSBvbiB0aGUgcHJvdmlkZWQgYFN0eWxpbmdDb250ZXh0YCBzb1xuICogdGhhdCB0aGV5IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IG9uY2UgYHJlbmRlclN0eWxlQW5kQ2xhc3NCaW5kaW5nc2AgaXMgY2FsbGVkLlxuICpcbiAqIE5vdGUgdGhhdCBwcm9wLWxldmVsIHN0eWxpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIGhpZ2hlciBwcmlvcml0eSB0aGFuIGFueSBzdHlsaW5nIHRoYXRcbiAqIGhhcyBiZWVuIGFwcGxpZWQgdXNpbmcgYHVwZGF0ZVN0eWxpbmdNYXBgLCB0aGVyZWZvcmUsIHdoZW4gc3R5bGluZyB2YWx1ZXMgYXJlIHJlbmRlcmVkXG4gKiB0aGVuIGFueSBzdHlsZXMvY2xhc3NlcyB0aGF0IGhhdmUgYmVlbiBhcHBsaWVkIHVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjb25zaWRlcmVkIGZpcnN0XG4gKiAodGhlbiBtdWx0aSB2YWx1ZXMgc2Vjb25kIGFuZCB0aGVuIGluaXRpYWwgdmFsdWVzIGFzIGEgYmFja3VwKS5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgc3R5bGluZyBjb250ZXh0IHRoYXQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlXG4gKiAgICBuZXdseSBwcm92aWRlZCBzdHlsZSB2YWx1ZS5cbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHByb3BlcnR5IHdoaWNoIGlzIGJlaW5nIHVwZGF0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIENTUyBzdHlsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgYXNzaWduZWRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlU3R5bGVQcm9wKGNvbnRleHQsIGluZGV4LCBpbnB1dCkge1xuICAgIHZhciBzaW5nbGVJbmRleCA9IDggLyogU2luZ2xlU3R5bGVzU3RhcnRQb3NpdGlvbiAqLyArIGluZGV4ICogNCAvKiBTaXplICovO1xuICAgIHZhciBjdXJyVmFsdWUgPSBnZXRWYWx1ZShjb250ZXh0LCBzaW5nbGVJbmRleCk7XG4gICAgdmFyIGN1cnJGbGFnID0gZ2V0UG9pbnRlcnMoY29udGV4dCwgc2luZ2xlSW5kZXgpO1xuICAgIHZhciB2YWx1ZSA9IChpbnB1dCBpbnN0YW5jZW9mIEJvdW5kUGxheWVyRmFjdG9yeSkgPyBpbnB1dC52YWx1ZSA6IGlucHV0O1xuICAgIC8vIGRpZG4ndCBjaGFuZ2UgLi4uIG5vdGhpbmcgdG8gbWFrZSBhIG5vdGUgb2ZcbiAgICBpZiAoaGFzVmFsdWVDaGFuZ2VkKGN1cnJGbGFnLCBjdXJyVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICB2YXIgaXNDbGFzc0Jhc2VkXzUgPSAoY3VyckZsYWcgJiAyIC8qIENsYXNzICovKSA9PT0gMiAvKiBDbGFzcyAqLztcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0WzUgLyogRWxlbWVudFBvc2l0aW9uICovXTtcbiAgICAgICAgdmFyIHBsYXllckJ1aWxkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIEJvdW5kUGxheWVyRmFjdG9yeSA/XG4gICAgICAgICAgICBuZXcgQ2xhc3NBbmRTdHlsZVBsYXllckJ1aWxkZXIoaW5wdXQsIGVsZW1lbnQsIGlzQ2xhc3NCYXNlZF81ID8gMiAvKiBDbGFzcyAqLyA6IDMgLyogU3R5bGUgKi8pIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgIHZhciB2YWx1ZV8xID0gKHBsYXllckJ1aWxkZXIgPyBpbnB1dC52YWx1ZSA6IGlucHV0KTtcbiAgICAgICAgdmFyIGN1cnJQbGF5ZXJJbmRleCA9IGdldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBzaW5nbGVJbmRleCk7XG4gICAgICAgIHZhciBwbGF5ZXJCdWlsZGVyc0FyZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBwbGF5ZXJCdWlsZGVySW5kZXggPSBwbGF5ZXJCdWlsZGVyID8gY3VyclBsYXllckluZGV4IDogMDtcbiAgICAgICAgaWYgKGhhc1BsYXllckJ1aWxkZXJDaGFuZ2VkKGNvbnRleHQsIHBsYXllckJ1aWxkZXIsIGN1cnJQbGF5ZXJJbmRleCkpIHtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IHNldFBsYXllckJ1aWxkZXIoY29udGV4dCwgcGxheWVyQnVpbGRlciwgY3VyclBsYXllckluZGV4KTtcbiAgICAgICAgICAgIHBsYXllckJ1aWxkZXJJbmRleCA9IHBsYXllckJ1aWxkZXIgPyBuZXdJbmRleCA6IDA7XG4gICAgICAgICAgICBzZXRQbGF5ZXJCdWlsZGVySW5kZXgoY29udGV4dCwgc2luZ2xlSW5kZXgsIHBsYXllckJ1aWxkZXJJbmRleCk7XG4gICAgICAgICAgICBwbGF5ZXJCdWlsZGVyc0FyZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgdmFsdWUgd2lsbCBhbHdheXMgZ2V0IHVwZGF0ZWQgKGV2ZW4gaWYgdGhlIGRpcnR5IGZsYWcgaXMgc2tpcHBlZClcbiAgICAgICAgc2V0VmFsdWUoY29udGV4dCwgc2luZ2xlSW5kZXgsIHZhbHVlXzEpO1xuICAgICAgICB2YXIgaW5kZXhGb3JNdWx0aSA9IGdldE11bHRpT3JTaW5nbGVJbmRleChjdXJyRmxhZyk7XG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSBpbiB0aGUgbXVsdGktYXJlYSB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gcmUtYXNzZW1ibGluZ1xuICAgICAgICB2YXIgdmFsdWVGb3JNdWx0aSA9IGdldFZhbHVlKGNvbnRleHQsIGluZGV4Rm9yTXVsdGkpO1xuICAgICAgICBpZiAoIXZhbHVlRm9yTXVsdGkgfHwgaGFzVmFsdWVDaGFuZ2VkKGN1cnJGbGFnLCB2YWx1ZUZvck11bHRpLCB2YWx1ZV8xKSkge1xuICAgICAgICAgICAgdmFyIG11bHRpRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzaW5nbGVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAvLyBvbmx5IHdoZW4gdGhlIHZhbHVlIGlzIHNldCB0byBgbnVsbGAgc2hvdWxkIHRoZSBtdWx0aS12YWx1ZSBnZXQgZmxhZ2dlZFxuICAgICAgICAgICAgaWYgKCF2YWx1ZUV4aXN0cyh2YWx1ZV8xLCBpc0NsYXNzQmFzZWRfNSkgJiYgdmFsdWVFeGlzdHModmFsdWVGb3JNdWx0aSwgaXNDbGFzc0Jhc2VkXzUpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2luZ2xlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERpcnR5KGNvbnRleHQsIGluZGV4Rm9yTXVsdGksIG11bHRpRGlydHkpO1xuICAgICAgICAgICAgc2V0RGlydHkoY29udGV4dCwgc2luZ2xlSW5kZXgsIHNpbmdsZURpcnR5KTtcbiAgICAgICAgICAgIHNldENvbnRleHREaXJ0eShjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxheWVyQnVpbGRlcnNBcmVEaXJ0eSkge1xuICAgICAgICAgICAgc2V0Q29udGV4dFBsYXllcnNEaXJ0eShjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhpcyBtZXRob2Qgd2lsbCB0b2dnbGUgdGhlIHJlZmVyZW5jZWQgQ1NTIGNsYXNzIChieSB0aGUgcHJvdmlkZWQgaW5kZXgpXG4gKiB3aXRoaW4gdGhlIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgVGhlIHN0eWxpbmcgY29udGV4dCB0aGF0IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZVxuICogICAgbmV3bHkgcHJvdmlkZWQgY2xhc3MgdmFsdWUuXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBDU1MgY2xhc3Mgd2hpY2ggaXMgYmVpbmcgdXBkYXRlZC5cbiAqIEBwYXJhbSBhZGRPclJlbW92ZSBXaGV0aGVyIG9yIG5vdCB0byBhZGQgb3IgcmVtb3ZlIHRoZSBDU1MgY2xhc3NcbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2xhc3NQcm9wKGNvbnRleHQsIGluZGV4LCBhZGRPclJlbW92ZSkge1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggKyBjb250ZXh0WzQgLyogQ2xhc3NPZmZzZXRQb3NpdGlvbiAqL107XG4gICAgdXBkYXRlU3R5bGVQcm9wKGNvbnRleHQsIGFkanVzdGVkSW5kZXgsIGFkZE9yUmVtb3ZlKTtcbn1cbi8qKlxuICogUmVuZGVycyBhbGwgcXVldWVkIHN0eWxpbmcgdXNpbmcgYSByZW5kZXJlciBvbnRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3MgYnkgcmVuZGVyaW5nIGFueSBzdHlsZXMgKHRoYXQgaGF2ZSBiZWVuIGFwcGxpZWRcbiAqIHVzaW5nIGB1cGRhdGVTdHlsaW5nTWFwYCkgYW5kIGFueSBjbGFzc2VzICh0aGF0IGhhdmUgYmVlbiBhcHBsaWVkIHVzaW5nXG4gKiBgdXBkYXRlU3R5bGVQcm9wYCkgb250byB0aGUgcHJvdmlkZWQgZWxlbWVudCB1c2luZyB0aGUgcHJvdmlkZWQgcmVuZGVyZXIuXG4gKiBKdXN0IGJlZm9yZSB0aGUgc3R5bGVzL2NsYXNzZXMgYXJlIHJlbmRlcmVkIGEgZmluYWwga2V5L3ZhbHVlIHN0eWxlIG1hcFxuICogd2lsbCBiZSBhc3NlbWJsZWQgKGlmIGBzdHlsZVN0b3JlYCBvciBgY2xhc3NTdG9yZWAgYXJlIHByb3ZpZGVkKS5cbiAqXG4gKiBAcGFyYW0gbEVsZW1lbnQgdGhlIGVsZW1lbnQgdGhhdCB0aGUgc3R5bGVzIHdpbGwgYmUgcmVuZGVyZWQgb25cbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBzdHlsaW5nIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lXG4gKiAgICAgIHdoYXQgc3R5bGVzIHdpbGwgYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSByZW5kZXJlciB0aGUgcmVuZGVyZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXBwbHkgdGhlIHN0eWxpbmdcbiAqIEBwYXJhbSBjbGFzc2VzU3RvcmUgaWYgcHJvdmlkZWQsIHRoZSB1cGRhdGVkIGNsYXNzIHZhbHVlcyB3aWxsIGJlIGFwcGxpZWRcbiAqICAgIHRvIHRoaXMga2V5L3ZhbHVlIG1hcCBpbnN0ZWFkIG9mIGJlaW5nIHJlbmRlcmVyZWQgdmlhIHRoZSByZW5kZXJlci5cbiAqIEBwYXJhbSBzdHlsZXNTdG9yZSBpZiBwcm92aWRlZCwgdGhlIHVwZGF0ZWQgc3R5bGUgdmFsdWVzIHdpbGwgYmUgYXBwbGllZFxuICogICAgdG8gdGhpcyBrZXkvdmFsdWUgbWFwIGluc3RlYWQgb2YgYmVpbmcgcmVuZGVyZXJlZCB2aWEgdGhlIHJlbmRlcmVyLlxuICogQHJldHVybnMgbnVtYmVyIHRoZSB0b3RhbCBhbW91bnQgb2YgcGxheWVycyB0aGF0IGdvdCBxdWV1ZWQgZm9yIGFuaW1hdGlvbiAoaWYgYW55KVxuICovXG5mdW5jdGlvbiByZW5kZXJTdHlsZUFuZENsYXNzQmluZGluZ3MoY29udGV4dCwgcmVuZGVyZXIsIHJvb3RPclZpZXcsIGNsYXNzZXNTdG9yZSwgc3R5bGVzU3RvcmUpIHtcbiAgICB2YXIgdG90YWxQbGF5ZXJzUXVldWVkID0gMDtcbiAgICBpZiAoaXNDb250ZXh0RGlydHkoY29udGV4dCkpIHtcbiAgICAgICAgdmFyIGZsdXNoUGxheWVyQnVpbGRlcnMgPSBjb250ZXh0WzMgLyogTWFzdGVyRmxhZ1Bvc2l0aW9uICovXSAmIDggLyogUGxheWVyQnVpbGRlcnNEaXJ0eSAqLztcbiAgICAgICAgdmFyIG5hdGl2ZSA9IGNvbnRleHRbNSAvKiBFbGVtZW50UG9zaXRpb24gKi9dO1xuICAgICAgICB2YXIgbXVsdGlTdGFydEluZGV4ID0gZ2V0TXVsdGlTdGFydEluZGV4KGNvbnRleHQpO1xuICAgICAgICB2YXIgc3R5bGVTYW5pdGl6ZXIgPSBnZXRTdHlsZVNhbml0aXplcihjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDggLyogU2luZ2xlU3R5bGVzU3RhcnRQb3NpdGlvbiAqLzsgaSA8IGNvbnRleHQubGVuZ3RoOyBpICs9IDQgLyogU2l6ZSAqLykge1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVuZGVyaW5nIHN0eWxlcyB0aGF0IGhhdmUgbm90IGNoYW5nZWQgb24gc2NyZWVuXG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShjb250ZXh0LCBpKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZ2V0UHJvcChjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IGdldFBvaW50ZXJzKGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgICAgIHZhciBwbGF5ZXJCdWlsZGVyID0gZ2V0UGxheWVyQnVpbGRlcihjb250ZXh0LCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNDbGFzc0Jhc2VkXzYgPSBmbGFnICYgMiAvKiBDbGFzcyAqLyA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJblNpbmdsZVJlZ2lvbiA9IGkgPCBtdWx0aVN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlVG9BcHBseSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFZBTFVFIERFRkVSIENBU0UgMTogVXNlIGEgbXVsdGkgdmFsdWUgaW5zdGVhZCBvZiBhIG51bGwgc2luZ2xlIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGVjayBpbXBsaWVzIHRoYXQgYSBzaW5nbGUgdmFsdWUgd2FzIHJlbW92ZWQgYW5kIHdlXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdyBkZWZlciB0byBhIG11bHRpIHZhbHVlIGFuZCB1c2UgdGhhdCAoaWYgc2V0KS5cbiAgICAgICAgICAgICAgICBpZiAoaXNJblNpbmdsZVJlZ2lvbiAmJiAhdmFsdWVFeGlzdHModmFsdWVUb0FwcGx5LCBpc0NsYXNzQmFzZWRfNikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIHZhbHVlcyBBTFdBWVMgaGF2ZSBhIHJlZmVyZW5jZSB0byBhIG11bHRpIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aUluZGV4ID0gZ2V0TXVsdGlPclNpbmdsZUluZGV4KGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvQXBwbHkgPSBnZXRWYWx1ZShjb250ZXh0LCBtdWx0aUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVkFMVUUgREVGRVIgQ0FTRSAyOiBVc2UgdGhlIGluaXRpYWwgdmFsdWUgaWYgYWxsIGVsc2UgZmFpbHMgKGlzIGZhbHN5KVxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbml0aWFsIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGEgc3RyaW5nIG9yIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlIHdlIGNhbiBzYWZlbHkgYWRvcHQgaXQgaW5jYXNlIHRoZXJlJ3Mgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBhIGZhbHN5IGNoZWNrIHNpbmNlIGBmYWxzZWAgaXMgdXNlZFxuICAgICAgICAgICAgICAgIC8vIGZvciBib3RoIGNsYXNzIGFuZCBzdHlsZSBjb21wYXJpc29ucyAoc3R5bGVzIGNhbid0IGJlIGZhbHNlIGFuZCBmYWxzZVxuICAgICAgICAgICAgICAgIC8vIGNsYXNzZXMgYXJlIHR1cm5lZCBvZmYgYW5kIHNob3VsZCB0aGVyZWZvcmUgZGVmZXIgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMpXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZUV4aXN0cyh2YWx1ZVRvQXBwbHksIGlzQ2xhc3NCYXNlZF82KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRvQXBwbHkgPSBnZXRJbml0aWFsVmFsdWUoY29udGV4dCwgZmxhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0NsYXNzQmFzZWRfNikge1xuICAgICAgICAgICAgICAgICAgICBzZXRDbGFzcyhuYXRpdmUsIHByb3AsIHZhbHVlVG9BcHBseSA/IHRydWUgOiBmYWxzZSwgcmVuZGVyZXIsIGNsYXNzZXNTdG9yZSwgcGxheWVyQnVpbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVyID0gKGZsYWcgJiA0IC8qIFNhbml0aXplICovKSA/IHN0eWxlU2FuaXRpemVyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUobmF0aXZlLCBwcm9wLCB2YWx1ZVRvQXBwbHksIHJlbmRlcmVyLCBzYW5pdGl6ZXIsIHN0eWxlc1N0b3JlLCBwbGF5ZXJCdWlsZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0RGlydHkoY29udGV4dCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaFBsYXllckJ1aWxkZXJzKSB7XG4gICAgICAgICAgICB2YXIgcm9vdENvbnRleHQgPSBBcnJheS5pc0FycmF5KHJvb3RPclZpZXcpID8gZ2V0Um9vdENvbnRleHQocm9vdE9yVmlldykgOiByb290T3JWaWV3O1xuICAgICAgICAgICAgdmFyIHBsYXllckNvbnRleHQgPSBnZXRQbGF5ZXJDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIHBsYXllcnNTdGFydEluZGV4ID0gcGxheWVyQ29udGV4dFswIC8qIE5vbkJ1aWxkZXJQbGF5ZXJzU3RhcnQgKi9dO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEgLyogUGxheWVyQnVpbGRlcnNTdGFydFBvc2l0aW9uICovOyBpIDwgcGxheWVyc1N0YXJ0SW5kZXg7IGkgKz0gMiAvKiBQbGF5ZXJBbmRQbGF5ZXJCdWlsZGVyc1R1cGxlU2l6ZSAqLykge1xuICAgICAgICAgICAgICAgIHZhciBidWlsZGVyID0gcGxheWVyQ29udGV4dFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVySW5zZXJ0aW9uSW5kZXggPSBpICsgMSAvKiBQbGF5ZXJPZmZzZXRQb3NpdGlvbiAqLztcbiAgICAgICAgICAgICAgICB2YXIgb2xkUGxheWVyID0gcGxheWVyQ29udGV4dFtwbGF5ZXJJbnNlcnRpb25JbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IGJ1aWxkZXIuYnVpbGRQbGF5ZXIob2xkUGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2FzUXVldWVkID0gYWRkUGxheWVySW50ZXJuYWwocGxheWVyQ29udGV4dCwgcm9vdENvbnRleHQsIG5hdGl2ZSwgcGxheWVyLCBwbGF5ZXJJbnNlcnRpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzUXVldWVkICYmIHRvdGFsUGxheWVyc1F1ZXVlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkUGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwbGF5ZXIgYnVpbGRlciBoYXMgYmVlbiByZW1vdmVkIC4uLiB0aGVyZWZvcmUgd2Ugc2hvdWxkIGRlbGV0ZSB0aGUgYXNzb2NpYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBwbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgb2xkUGxheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDb250ZXh0UGxheWVyc0RpcnR5KGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb250ZXh0RGlydHkoY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG90YWxQbGF5ZXJzUXVldWVkO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJlbmRlcnMgYSBnaXZlbiBDU1MgcHJvcC92YWx1ZSBlbnRyeSB1c2luZyB0aGVcbiAqIHByb3ZpZGVkIHJlbmRlcmVyLiBJZiBhIGBzdG9yZWAgdmFsdWUgaXMgcHJvdmlkZWQgdGhlblxuICogdGhhdCB3aWxsIGJlIHVzZWQgYSByZW5kZXIgY29udGV4dCBpbnN0ZWFkIG9mIHRoZSBwcm92aWRlZFxuICogcmVuZGVyZXIuXG4gKlxuICogQHBhcmFtIG5hdGl2ZSB0aGUgRE9NIEVsZW1lbnRcbiAqIEBwYXJhbSBwcm9wIHRoZSBDU1Mgc3R5bGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHJlbmRlcmVkXG4gKiBAcGFyYW0gdmFsdWUgdGhlIENTUyBzdHlsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSByZW5kZXJlclxuICogQHBhcmFtIHN0b3JlIGFuIG9wdGlvbmFsIGtleS92YWx1ZSBtYXAgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYSBjb250ZXh0IHRvIHJlbmRlciBzdHlsZXMgb25cbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGUobmF0aXZlLCBwcm9wLCB2YWx1ZSwgcmVuZGVyZXIsIHNhbml0aXplciwgc3RvcmUsIHBsYXllckJ1aWxkZXIpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplciAmJiB2YWx1ZSA/IHNhbml0aXplcihwcm9wLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICBpZiAoc3RvcmUgfHwgcGxheWVyQnVpbGRlcikge1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFZhbHVlKHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxheWVyQnVpbGRlcikge1xuICAgICAgICAgICAgcGxheWVyQnVpbGRlci5zZXRWYWx1ZShwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlclNldFN0eWxlKys7XG4gICAgICAgIGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSA/XG4gICAgICAgICAgICByZW5kZXJlci5zZXRTdHlsZShuYXRpdmUsIHByb3AsIHZhbHVlLCBSZW5kZXJlclN0eWxlRmxhZ3MzLkRhc2hDYXNlKSA6XG4gICAgICAgICAgICBuYXRpdmVbJ3N0eWxlJ10uc2V0UHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlclJlbW92ZVN0eWxlKys7XG4gICAgICAgIGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSA/XG4gICAgICAgICAgICByZW5kZXJlci5yZW1vdmVTdHlsZShuYXRpdmUsIHByb3AsIFJlbmRlcmVyU3R5bGVGbGFnczMuRGFzaENhc2UpIDpcbiAgICAgICAgICAgIG5hdGl2ZVsnc3R5bGUnXS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmVuZGVycyBhIGdpdmVuIENTUyBjbGFzcyB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWRcbiAqIHJlbmRlcmVyIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudCkuXG4gKiBJZiBhIGBzdG9yZWAgdmFsdWUgaXMgcHJvdmlkZWQgdGhlbiB0aGF0IHdpbGwgYmUgdXNlZCBhIHJlbmRlclxuICogY29udGV4dCBpbnN0ZWFkIG9mIHRoZSBwcm92aWRlZCByZW5kZXJlci5cbiAqXG4gKiBAcGFyYW0gbmF0aXZlIHRoZSBET00gRWxlbWVudFxuICogQHBhcmFtIHByb3AgdGhlIENTUyBzdHlsZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgQ1NTIHN0eWxlIHZhbHVlIHRoYXQgd2lsbCBiZSByZW5kZXJlZFxuICogQHBhcmFtIHJlbmRlcmVyXG4gKiBAcGFyYW0gc3RvcmUgYW4gb3B0aW9uYWwga2V5L3ZhbHVlIG1hcCB0aGF0IHdpbGwgYmUgdXNlZCBhcyBhIGNvbnRleHQgdG8gcmVuZGVyIHN0eWxlcyBvblxuICovXG5mdW5jdGlvbiBzZXRDbGFzcyhuYXRpdmUsIGNsYXNzTmFtZSwgYWRkLCByZW5kZXJlciwgc3RvcmUsIHBsYXllckJ1aWxkZXIpIHtcbiAgICBpZiAoc3RvcmUgfHwgcGxheWVyQnVpbGRlcikge1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFZhbHVlKGNsYXNzTmFtZSwgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxheWVyQnVpbGRlcikge1xuICAgICAgICAgICAgcGxheWVyQnVpbGRlci5zZXRWYWx1ZShjbGFzc05hbWUsIGFkZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJBZGRDbGFzcysrO1xuICAgICAgICBpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikgPyByZW5kZXJlci5hZGRDbGFzcyhuYXRpdmUsIGNsYXNzTmFtZSkgOlxuICAgICAgICAgICAgbmF0aXZlWydjbGFzc0xpc3QnXS5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJSZW1vdmVDbGFzcysrO1xuICAgICAgICBpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikgPyByZW5kZXJlci5yZW1vdmVDbGFzcyhuYXRpdmUsIGNsYXNzTmFtZSkgOlxuICAgICAgICAgICAgbmF0aXZlWydjbGFzc0xpc3QnXS5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXREaXJ0eShjb250ZXh0LCBpbmRleCwgaXNEaXJ0eVllcykge1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggPj0gOCAvKiBTaW5nbGVTdHlsZXNTdGFydFBvc2l0aW9uICovID8gKGluZGV4ICsgMCAvKiBGbGFnc09mZnNldCAqLykgOiBpbmRleDtcbiAgICBpZiAoaXNEaXJ0eVllcykge1xuICAgICAgICBjb250ZXh0W2FkanVzdGVkSW5kZXhdIHw9IDEgLyogRGlydHkgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZXh0W2FkanVzdGVkSW5kZXhdICY9IH4xIC8qIERpcnR5ICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRGlydHkoY29udGV4dCwgaW5kZXgpIHtcbiAgICB2YXIgYWRqdXN0ZWRJbmRleCA9IGluZGV4ID49IDggLyogU2luZ2xlU3R5bGVzU3RhcnRQb3NpdGlvbiAqLyA/IChpbmRleCArIDAgLyogRmxhZ3NPZmZzZXQgKi8pIDogaW5kZXg7XG4gICAgcmV0dXJuIChjb250ZXh0W2FkanVzdGVkSW5kZXhdICYgMSAvKiBEaXJ0eSAqLykgPT0gMSAvKiBEaXJ0eSAqLztcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NCYXNlZChjb250ZXh0LCBpbmRleCkge1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggPj0gOCAvKiBTaW5nbGVTdHlsZXNTdGFydFBvc2l0aW9uICovID8gKGluZGV4ICsgMCAvKiBGbGFnc09mZnNldCAqLykgOiBpbmRleDtcbiAgICByZXR1cm4gKGNvbnRleHRbYWRqdXN0ZWRJbmRleF0gJiAyIC8qIENsYXNzICovKSA9PSAyIC8qIENsYXNzICovO1xufVxuZnVuY3Rpb24gaXNTYW5pdGl6YWJsZShjb250ZXh0LCBpbmRleCkge1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggPj0gOCAvKiBTaW5nbGVTdHlsZXNTdGFydFBvc2l0aW9uICovID8gKGluZGV4ICsgMCAvKiBGbGFnc09mZnNldCAqLykgOiBpbmRleDtcbiAgICByZXR1cm4gKGNvbnRleHRbYWRqdXN0ZWRJbmRleF0gJiA0IC8qIFNhbml0aXplICovKSA9PSA0IC8qIFNhbml0aXplICovO1xufVxuZnVuY3Rpb24gcG9pbnRlcnMoY29uZmlnRmxhZywgc3RhdGljSW5kZXgsIGR5bmFtaWNJbmRleCkge1xuICAgIHJldHVybiAoY29uZmlnRmxhZyAmIDE1IC8qIEJpdE1hc2sgKi8pIHwgKHN0YXRpY0luZGV4IDw8IDQgLyogQml0Q291bnRTaXplICovKSB8XG4gICAgICAgIChkeW5hbWljSW5kZXggPDwgKDE0IC8qIEJpdENvdW50U2l6ZSAqLyArIDQgLyogQml0Q291bnRTaXplICovKSk7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoY29udGV4dCwgZmxhZykge1xuICAgIHZhciBpbmRleCA9IGdldEluaXRpYWxJbmRleChmbGFnKTtcbiAgICByZXR1cm4gY29udGV4dFsyIC8qIEluaXRpYWxTdHlsZXNQb3NpdGlvbiAqL11baW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbEluZGV4KGZsYWcpIHtcbiAgICByZXR1cm4gKGZsYWcgPj4gNCAvKiBCaXRDb3VudFNpemUgKi8pICYgMTYzODMgLyogQml0TWFzayAqLztcbn1cbmZ1bmN0aW9uIGdldE11bHRpT3JTaW5nbGVJbmRleChmbGFnKSB7XG4gICAgdmFyIGluZGV4ID0gKGZsYWcgPj4gKDE0IC8qIEJpdENvdW50U2l6ZSAqLyArIDQgLyogQml0Q291bnRTaXplICovKSkgJiAxNjM4MyAvKiBCaXRNYXNrICovO1xuICAgIHJldHVybiBpbmRleCA+PSA4IC8qIFNpbmdsZVN0eWxlc1N0YXJ0UG9zaXRpb24gKi8gPyBpbmRleCA6IC0xO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlTdGFydEluZGV4KGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ2V0TXVsdGlPclNpbmdsZUluZGV4KGNvbnRleHRbMyAvKiBNYXN0ZXJGbGFnUG9zaXRpb24gKi9dKTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlU2FuaXRpemVyKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dFsxIC8qIFN0eWxlU2FuaXRpemVyUG9zaXRpb24gKi9dO1xufVxuZnVuY3Rpb24gc2V0UHJvcChjb250ZXh0LCBpbmRleCwgcHJvcCkge1xuICAgIGNvbnRleHRbaW5kZXggKyAxIC8qIFByb3BlcnR5T2Zmc2V0ICovXSA9IHByb3A7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZShjb250ZXh0LCBpbmRleCwgdmFsdWUpIHtcbiAgICBjb250ZXh0W2luZGV4ICsgMiAvKiBWYWx1ZU9mZnNldCAqL10gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1BsYXllckJ1aWxkZXJDaGFuZ2VkKGNvbnRleHQsIGJ1aWxkZXIsIGluZGV4KSB7XG4gICAgdmFyIHBsYXllckNvbnRleHQgPSBjb250ZXh0WzAgLyogUGxheWVyQ29udGV4dCAqL107XG4gICAgaWYgKGJ1aWxkZXIpIHtcbiAgICAgICAgaWYgKCFwbGF5ZXJDb250ZXh0IHx8IGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghcGxheWVyQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwbGF5ZXJDb250ZXh0W2luZGV4XSAhPT0gYnVpbGRlcjtcbn1cbmZ1bmN0aW9uIHNldFBsYXllckJ1aWxkZXIoY29udGV4dCwgYnVpbGRlciwgaW5zZXJ0aW9uSW5kZXgpIHtcbiAgICB2YXIgcGxheWVyQ29udGV4dCA9IGNvbnRleHRbMCAvKiBQbGF5ZXJDb250ZXh0ICovXSB8fCBhbGxvY1BsYXllckNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKGluc2VydGlvbkluZGV4ID4gMCkge1xuICAgICAgICBwbGF5ZXJDb250ZXh0W2luc2VydGlvbkluZGV4XSA9IGJ1aWxkZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnNlcnRpb25JbmRleCA9IHBsYXllckNvbnRleHRbMCAvKiBOb25CdWlsZGVyUGxheWVyc1N0YXJ0ICovXTtcbiAgICAgICAgcGxheWVyQ29udGV4dC5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIGJ1aWxkZXIsIG51bGwpO1xuICAgICAgICBwbGF5ZXJDb250ZXh0WzAgLyogTm9uQnVpbGRlclBsYXllcnNTdGFydCAqL10gKz1cbiAgICAgICAgICAgIDIgLyogUGxheWVyQW5kUGxheWVyQnVpbGRlcnNUdXBsZVNpemUgKi87XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnRpb25JbmRleDtcbn1cbmZ1bmN0aW9uIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleCwgcGxheWVyQnVpbGRlckluZGV4KSB7XG4gICAgY29udGV4dFtpbmRleCArIDMgLyogUGxheWVyQnVpbGRlckluZGV4T2Zmc2V0ICovXSA9IHBsYXllckJ1aWxkZXJJbmRleDtcbn1cbmZ1bmN0aW9uIGdldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleCkge1xuICAgIHJldHVybiBjb250ZXh0W2luZGV4ICsgMyAvKiBQbGF5ZXJCdWlsZGVySW5kZXhPZmZzZXQgKi9dIHx8IDA7XG59XG5mdW5jdGlvbiBnZXRQbGF5ZXJCdWlsZGVyKGNvbnRleHQsIGluZGV4KSB7XG4gICAgdmFyIHBsYXllckJ1aWxkZXJJbmRleCA9IGdldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleCk7XG4gICAgaWYgKHBsYXllckJ1aWxkZXJJbmRleCkge1xuICAgICAgICB2YXIgcGxheWVyQ29udGV4dCA9IGNvbnRleHRbMCAvKiBQbGF5ZXJDb250ZXh0ICovXTtcbiAgICAgICAgaWYgKHBsYXllckNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXJDb250ZXh0W3BsYXllckJ1aWxkZXJJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZXRGbGFnKGNvbnRleHQsIGluZGV4LCBmbGFnKSB7XG4gICAgdmFyIGFkanVzdGVkSW5kZXggPSBpbmRleCA9PT0gMyAvKiBNYXN0ZXJGbGFnUG9zaXRpb24gKi8gPyBpbmRleCA6IChpbmRleCArIDAgLyogRmxhZ3NPZmZzZXQgKi8pO1xuICAgIGNvbnRleHRbYWRqdXN0ZWRJbmRleF0gPSBmbGFnO1xufVxuZnVuY3Rpb24gZ2V0UG9pbnRlcnMoY29udGV4dCwgaW5kZXgpIHtcbiAgICB2YXIgYWRqdXN0ZWRJbmRleCA9IGluZGV4ID09PSAzIC8qIE1hc3RlckZsYWdQb3NpdGlvbiAqLyA/IGluZGV4IDogKGluZGV4ICsgMCAvKiBGbGFnc09mZnNldCAqLyk7XG4gICAgcmV0dXJuIGNvbnRleHRbYWRqdXN0ZWRJbmRleF07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShjb250ZXh0LCBpbmRleCkge1xuICAgIHJldHVybiBjb250ZXh0W2luZGV4ICsgMiAvKiBWYWx1ZU9mZnNldCAqL107XG59XG5mdW5jdGlvbiBnZXRQcm9wKGNvbnRleHQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGNvbnRleHRbaW5kZXggKyAxIC8qIFByb3BlcnR5T2Zmc2V0ICovXTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dERpcnR5KGNvbnRleHQpIHtcbiAgICByZXR1cm4gaXNEaXJ0eShjb250ZXh0LCAzIC8qIE1hc3RlckZsYWdQb3NpdGlvbiAqLyk7XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0RGlydHkoY29udGV4dCwgaXNEaXJ0eVllcykge1xuICAgIHNldERpcnR5KGNvbnRleHQsIDMgLyogTWFzdGVyRmxhZ1Bvc2l0aW9uICovLCBpc0RpcnR5WWVzKTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHRQbGF5ZXJzRGlydHkoY29udGV4dCwgaXNEaXJ0eVllcykge1xuICAgIGlmIChpc0RpcnR5WWVzKSB7XG4gICAgICAgIGNvbnRleHRbMyAvKiBNYXN0ZXJGbGFnUG9zaXRpb24gKi9dIHw9IDggLyogUGxheWVyQnVpbGRlcnNEaXJ0eSAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHRbMyAvKiBNYXN0ZXJGbGFnUG9zaXRpb24gKi9dICY9IH44IC8qIFBsYXllckJ1aWxkZXJzRGlydHkgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEVudHJ5UG9zaXRpb25CeVByb3AoY29udGV4dCwgcHJvcCwgc3RhcnRJbmRleCkge1xuICAgIGZvciAodmFyIGkgPSAoc3RhcnRJbmRleCB8fCAwKSArIDEgLyogUHJvcGVydHlPZmZzZXQgKi87IGkgPCBjb250ZXh0Lmxlbmd0aDsgaSArPSA0IC8qIFNpemUgKi8pIHtcbiAgICAgICAgdmFyIHRoaXNQcm9wID0gY29udGV4dFtpXTtcbiAgICAgICAgaWYgKHRoaXNQcm9wID09IHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gMSAvKiBQcm9wZXJ0eU9mZnNldCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBzd2FwTXVsdGlDb250ZXh0RW50cmllcyhjb250ZXh0LCBpbmRleEEsIGluZGV4Qikge1xuICAgIHZhciB0bXBWYWx1ZSA9IGdldFZhbHVlKGNvbnRleHQsIGluZGV4QSk7XG4gICAgdmFyIHRtcFByb3AgPSBnZXRQcm9wKGNvbnRleHQsIGluZGV4QSk7XG4gICAgdmFyIHRtcEZsYWcgPSBnZXRQb2ludGVycyhjb250ZXh0LCBpbmRleEEpO1xuICAgIHZhciB0bXBQbGF5ZXJCdWlsZGVySW5kZXggPSBnZXRQbGF5ZXJCdWlsZGVySW5kZXgoY29udGV4dCwgaW5kZXhBKTtcbiAgICB2YXIgZmxhZ0EgPSB0bXBGbGFnO1xuICAgIHZhciBmbGFnQiA9IGdldFBvaW50ZXJzKGNvbnRleHQsIGluZGV4Qik7XG4gICAgdmFyIHNpbmdsZUluZGV4QSA9IGdldE11bHRpT3JTaW5nbGVJbmRleChmbGFnQSk7XG4gICAgaWYgKHNpbmdsZUluZGV4QSA+PSAwKSB7XG4gICAgICAgIHZhciBfZmxhZyA9IGdldFBvaW50ZXJzKGNvbnRleHQsIHNpbmdsZUluZGV4QSk7XG4gICAgICAgIHZhciBfaW5pdGlhbCA9IGdldEluaXRpYWxJbmRleChfZmxhZyk7XG4gICAgICAgIHNldEZsYWcoY29udGV4dCwgc2luZ2xlSW5kZXhBLCBwb2ludGVycyhfZmxhZywgX2luaXRpYWwsIGluZGV4QikpO1xuICAgIH1cbiAgICB2YXIgc2luZ2xlSW5kZXhCID0gZ2V0TXVsdGlPclNpbmdsZUluZGV4KGZsYWdCKTtcbiAgICBpZiAoc2luZ2xlSW5kZXhCID49IDApIHtcbiAgICAgICAgdmFyIF9mbGFnID0gZ2V0UG9pbnRlcnMoY29udGV4dCwgc2luZ2xlSW5kZXhCKTtcbiAgICAgICAgdmFyIF9pbml0aWFsID0gZ2V0SW5pdGlhbEluZGV4KF9mbGFnKTtcbiAgICAgICAgc2V0RmxhZyhjb250ZXh0LCBzaW5nbGVJbmRleEIsIHBvaW50ZXJzKF9mbGFnLCBfaW5pdGlhbCwgaW5kZXhBKSk7XG4gICAgfVxuICAgIHNldFZhbHVlKGNvbnRleHQsIGluZGV4QSwgZ2V0VmFsdWUoY29udGV4dCwgaW5kZXhCKSk7XG4gICAgc2V0UHJvcChjb250ZXh0LCBpbmRleEEsIGdldFByb3AoY29udGV4dCwgaW5kZXhCKSk7XG4gICAgc2V0RmxhZyhjb250ZXh0LCBpbmRleEEsIGdldFBvaW50ZXJzKGNvbnRleHQsIGluZGV4QikpO1xuICAgIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleEEsIGdldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleEIpKTtcbiAgICBzZXRWYWx1ZShjb250ZXh0LCBpbmRleEIsIHRtcFZhbHVlKTtcbiAgICBzZXRQcm9wKGNvbnRleHQsIGluZGV4QiwgdG1wUHJvcCk7XG4gICAgc2V0RmxhZyhjb250ZXh0LCBpbmRleEIsIHRtcEZsYWcpO1xuICAgIHNldFBsYXllckJ1aWxkZXJJbmRleChjb250ZXh0LCBpbmRleEIsIHRtcFBsYXllckJ1aWxkZXJJbmRleCk7XG59XG5mdW5jdGlvbiB1cGRhdGVTaW5nbGVQb2ludGVyVmFsdWVzKGNvbnRleHQsIGluZGV4U3RhcnRQb3NpdGlvbikge1xuICAgIGZvciAodmFyIGkgPSBpbmRleFN0YXJ0UG9zaXRpb247IGkgPCBjb250ZXh0Lmxlbmd0aDsgaSArPSA0IC8qIFNpemUgKi8pIHtcbiAgICAgICAgdmFyIG11bHRpRmxhZyA9IGdldFBvaW50ZXJzKGNvbnRleHQsIGkpO1xuICAgICAgICB2YXIgc2luZ2xlSW5kZXggPSBnZXRNdWx0aU9yU2luZ2xlSW5kZXgobXVsdGlGbGFnKTtcbiAgICAgICAgaWYgKHNpbmdsZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUZsYWcgPSBnZXRQb2ludGVycyhjb250ZXh0LCBzaW5nbGVJbmRleCk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEluZGV4Rm9yU2luZ2xlID0gZ2V0SW5pdGlhbEluZGV4KHNpbmdsZUZsYWcpO1xuICAgICAgICAgICAgdmFyIGZsYWdWYWx1ZSA9IChpc0RpcnR5KGNvbnRleHQsIHNpbmdsZUluZGV4KSA/IDEgLyogRGlydHkgKi8gOiAwIC8qIE5vbmUgKi8pIHxcbiAgICAgICAgICAgICAgICAoaXNDbGFzc0Jhc2VkKGNvbnRleHQsIHNpbmdsZUluZGV4KSA/IDIgLyogQ2xhc3MgKi8gOiAwIC8qIE5vbmUgKi8pIHxcbiAgICAgICAgICAgICAgICAoaXNTYW5pdGl6YWJsZShjb250ZXh0LCBzaW5nbGVJbmRleCkgPyA0IC8qIFNhbml0aXplICovIDogMCAvKiBOb25lICovKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkRmxhZyA9IHBvaW50ZXJzKGZsYWdWYWx1ZSwgaW5pdGlhbEluZGV4Rm9yU2luZ2xlLCBpKTtcbiAgICAgICAgICAgIHNldEZsYWcoY29udGV4dCwgc2luZ2xlSW5kZXgsIHVwZGF0ZWRGbGFnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydE5ld011bHRpUHJvcGVydHkoY29udGV4dCwgaW5kZXgsIGNsYXNzQmFzZWQsIG5hbWUsIGZsYWcsIHZhbHVlLCBwbGF5ZXJJbmRleCkge1xuICAgIHZhciBkb1NoaWZ0ID0gaW5kZXggPCBjb250ZXh0Lmxlbmd0aDtcbiAgICAvLyBwcm9wIGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0LCBhZGQgaXQgaW5cbiAgICBjb250ZXh0LnNwbGljZShpbmRleCwgMCwgZmxhZyB8IDEgLyogRGlydHkgKi8gfCAoY2xhc3NCYXNlZCA/IDIgLyogQ2xhc3MgKi8gOiAwIC8qIE5vbmUgKi8pLCBuYW1lLCB2YWx1ZSwgcGxheWVySW5kZXgpO1xuICAgIGlmIChkb1NoaWZ0KSB7XG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHZhbHVlIHdhcyBpbnNlcnRlZCBtaWR3YXkgaW50byB0aGUgYXJyYXkgdGhlbiB3ZVxuICAgICAgICAvLyBuZWVkIHRvIHVwZGF0ZSBhbGwgdGhlIHNoaWZ0ZWQgbXVsdGkgdmFsdWVzJyBzaW5nbGUgdmFsdWVcbiAgICAgICAgLy8gcG9pbnRlcnMgdG8gcG9pbnQgdG8gdGhlIG5ld2x5IHNoaWZ0ZWQgbG9jYXRpb25cbiAgICAgICAgdXBkYXRlU2luZ2xlUG9pbnRlclZhbHVlcyhjb250ZXh0LCBpbmRleCArIDQgLyogU2l6ZSAqLyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsdWVFeGlzdHModmFsdWUsIGlzQ2xhc3NCYXNlZCkge1xuICAgIGlmIChpc0NsYXNzQmFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBwcmVwYXJlSW5pdGlhbEZsYWcobmFtZSwgaXNDbGFzc0Jhc2VkLCBzYW5pdGl6ZXIpIHtcbiAgICBpZiAoaXNDbGFzc0Jhc2VkKSB7XG4gICAgICAgIHJldHVybiAyIC8qIENsYXNzICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChzYW5pdGl6ZXIgJiYgc2FuaXRpemVyKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiA0IC8qIFNhbml0aXplICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufVxuZnVuY3Rpb24gaGFzVmFsdWVDaGFuZ2VkKGZsYWcsIGEsIGIpIHtcbiAgICB2YXIgaXNDbGFzc0Jhc2VkID0gZmxhZyAmIDIgLyogQ2xhc3MgKi87XG4gICAgdmFyIGhhc1ZhbHVlcyA9IGEgJiYgYjtcbiAgICB2YXIgdXNlc1Nhbml0aXplciA9IGZsYWcgJiA0IC8qIFNhbml0aXplICovO1xuICAgIC8vIHRoZSB0b1N0cmluZygpIGNvbXBhcmlzb24gZW5zdXJlcyB0aGF0IGEgdmFsdWUgaXMgY2hlY2tlZFxuICAgIC8vIC4uLiBvdGhlcndpc2UgKGR1cmluZyBzYW5pdGl6YXRpb24gYnlwYXNzaW5nKSB0aGUgPT09IGNvbXBhcnNpb25cbiAgICAvLyB3b3VsZCBmYWlsIHNpbmNlIGEgbmV3IFN0cmluZygpIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICBpZiAoIWlzQ2xhc3NCYXNlZCAmJiBoYXNWYWx1ZXMgJiYgdXNlc1Nhbml0aXplcikge1xuICAgICAgICAvLyB3ZSBrbm93IGZvciBzdXJlIHdlJ3JlIGRlYWxpbmcgd2l0aCBzdHJpbmdzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgcmV0dXJuIGEudG9TdHJpbmcoKSAhPT0gYi50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGVsc2UgaXMgc2FmZSB0byBjaGVjayB3aXRoIGEgbm9ybWFsIGVxdWFsaXR5IGNoZWNrXG4gICAgcmV0dXJuIGEgIT09IGI7XG59XG52YXIgQ2xhc3NBbmRTdHlsZVBsYXllckJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NBbmRTdHlsZVBsYXllckJ1aWxkZXIoZmFjdG9yeSwgX2VsZW1lbnQsIF90eXBlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IF90eXBlO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuICAgIENsYXNzQW5kU3R5bGVQbGF5ZXJCdWlsZGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzW3Byb3BdICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsYXNzQW5kU3R5bGVQbGF5ZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZFBsYXllciA9IGZ1bmN0aW9uIChjdXJyZW50UGxheWVyKSB7XG4gICAgICAgIC8vIGlmIG5vIHZhbHVlcyBoYXZlIGJlZW4gc2V0IGhlcmUgdGhlbiB0aGlzIG1lYW5zIHRoZSBiaW5kaW5nIGRpZG4ndFxuICAgICAgICAvLyBjaGFuZ2UgYW5kIHRoZXJlZm9yZSB0aGUgYmluZGluZyB2YWx1ZXMgd2VyZSBub3QgdXBkYXRlZCB0aHJvdWdoXG4gICAgICAgIC8vIGBzZXRWYWx1ZWAgd2hpY2ggbWVhbnMgbm8gbmV3IHBsYXllciB3aWxsIGJlIHByb3ZpZGVkLlxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLl9mYWN0b3J5LmZuKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3R5cGUsIHRoaXMuX3ZhbHVlcywgY3VycmVudFBsYXllciB8fCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc0FuZFN0eWxlUGxheWVyQnVpbGRlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBwZXJtYW5lbnQgbWFya2VyIHByb21pc2Ugd2hpY2ggc2lnbmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgQ0QgdHJlZSBpc1xuICogY2xlYW4uXG4gKi9cbnZhciBfQ0xFQU5fUFJPTUlTRSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbi8qKlxuICogVG9rZW4gc2V0IGluIGN1cnJlbnRNYXRjaGVzIHdoaWxlIGRlcGVuZGVuY2llcyBhcmUgYmVpbmcgcmVzb2x2ZWQuXG4gKlxuICogSWYgd2UgdmlzaXQgYSBkaXJlY3RpdmUgdGhhdCBoYXMgYSB2YWx1ZSBzZXQgdG8gQ0lSQ1VMQVIsIHdlIGtub3cgd2UndmVcbiAqIGFscmVhZHkgc2VlbiBpdCwgYW5kIHRodXMgaGF2ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBDSVJDVUxBUiQxID0gJ19fQ0lSQ1VMQVJfXyc7XG4vKipcbiAqIFRoaXMgcHJvcGVydHkgZ2V0cyBzZXQgYmVmb3JlIGVudGVyaW5nIGEgdGVtcGxhdGUuXG4gKlxuICogVGhpcyByZW5kZXJlciBjYW4gYmUgb25lIG9mIHR3byB2YXJpZXRpZXMgb2YgUmVuZGVyZXIzOlxuICpcbiAqIC0gT2JqZWN0ZWRPcmllbnRlZFJlbmRlcmVyM1xuICpcbiAqIFRoaXMgaXMgdGhlIG5hdGl2ZSBicm93c2VyIEFQSSBzdHlsZSwgZS5nLiBvcGVyYXRpb25zIGFyZSBtZXRob2RzIG9uIGluZGl2aWR1YWwgb2JqZWN0c1xuICogbGlrZSBIVE1MRWxlbWVudC4gV2l0aCB0aGlzIHN0eWxlLCBubyBhZGRpdGlvbmFsIGNvZGUgaXMgbmVlZGVkIGFzIGEgZmFjYWRlIChyZWR1Y2luZyBwYXlsb2FkXG4gKiBzaXplKS5cbiAqXG4gKiAtIFByb2NlZHVyYWxSZW5kZXJlcjNcbiAqXG4gKiBJbiBub24tbmF0aXZlIGJyb3dzZXIgZW52aXJvbm1lbnRzIChlLmcuIHBsYXRmb3JtcyBzdWNoIGFzIHdlYi13b3JrZXJzKSwgdGhpcyBpcyB0aGUgZmFjYWRlXG4gKiB0aGF0IGVuYWJsZXMgZWxlbWVudCBtYW5pcHVsYXRpb24uIFRoaXMgYWxzbyBmYWNpbGl0YXRlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXG4gKiBSZW5kZXJlcjIuXG4gKi9cbnZhciByZW5kZXJlcjtcbmZ1bmN0aW9uIGdldFJlbmRlcmVyKCkge1xuICAgIC8vIHRvcCBsZXZlbCB2YXJpYWJsZXMgc2hvdWxkIG5vdCBiZSBleHBvcnRlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoUEVSRl9OT1RFUy5tZClcbiAgICByZXR1cm4gcmVuZGVyZXI7XG59XG52YXIgcmVuZGVyZXJGYWN0b3J5O1xuZnVuY3Rpb24gZ2V0UmVuZGVyZXJGYWN0b3J5KCkge1xuICAgIC8vIHRvcCBsZXZlbCB2YXJpYWJsZXMgc2hvdWxkIG5vdCBiZSBleHBvcnRlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoUEVSRl9OT1RFUy5tZClcbiAgICByZXR1cm4gcmVuZGVyZXJGYWN0b3J5O1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFNhbml0aXplcigpIHtcbiAgICByZXR1cm4gdmlld0RhdGEgJiYgdmlld0RhdGFbU0FOSVRJWkVSXTtcbn1cbi8qKlxuICogU3RvcmUgdGhlIGVsZW1lbnQgZGVwdGggY291bnQuIFRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgcm9vdCBlbGVtZW50cyBvZiB0aGUgdGVtcGxhdGVcbiAqIHNvIHRoYXQgd2UgY2FuIHRoYW4gYXR0YWNoIGBMVmlld0RhdGFgIHRvIG9ubHkgdGhvc2UgZWxlbWVudHMuXG4gKi9cbnZhciBlbGVtZW50RGVwdGhDb3VudDtcbi8qKlxuICogU3RvcmVzIHdoZXRoZXIgZGlyZWN0aXZlcyBzaG91bGQgYmUgbWF0Y2hlZCB0byBlbGVtZW50cy5cbiAqXG4gKiBXaGVuIHRlbXBsYXRlIGNvbnRhaW5zIGBuZ05vbkJpbmRhYmxlYCB0aGFuIHdlIG5lZWQgdG8gcHJldmVudCB0aGUgcnVudGltZSBmb3JtIG1hdGNoaW5nXG4gKiBkaXJlY3RpdmVzIG9uIGNoaWxkcmVuIG9mIHRoYXQgZWxlbWVudC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiA8bXktY29tcCBteS1kaXJlY3RpdmU+XG4gKiAgIFNob3VsZCBtYXRjaCBjb21wb25lbnQgLyBkaXJlY3RpdmUuXG4gKiA8L215LWNvbXA+XG4gKiA8ZGl2IG5nTm9uQmluZGFibGU+XG4gKiAgIDxteS1jb21wIG15LWRpcmVjdGl2ZT5cbiAqICAgICBTaG91bGQgbm90IG1hdGNoIGNvbXBvbmVudCAvIGRpcmVjdGl2ZSBiZWNhdXNlIHdlIGFyZSBpbiBuZ05vbkJpbmRhYmxlLlxuICogICA8L215LWNvbXA+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICovXG52YXIgYmluZGluZ3NFbmFibGVkO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IE9wYXF1ZVZpZXdTdGF0ZSBpbnN0YW5jZS5cbiAqXG4gKiBVc2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHJlc3RvcmVWaWV3KCkgaW5zdHJ1Y3Rpb24gdG8gc2F2ZSBhIHNuYXBzaG90XG4gKiBvZiB0aGUgY3VycmVudCB2aWV3IGFuZCByZXN0b3JlIGl0IHdoZW4gbGlzdGVuZXJzIGFyZSBpbnZva2VkLiBUaGlzIGFsbG93c1xuICogd2Fsa2luZyB0aGUgZGVjbGFyYXRpb24gdmlldyB0cmVlIGluIGxpc3RlbmVycyB0byBnZXQgdmFycyBmcm9tIHBhcmVudCB2aWV3cy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXcoKSB7XG4gICAgcmV0dXJuIHZpZXdEYXRhO1xufVxuLyoqXG4gKiBSZXN0b3JlcyBgY29udGV4dFZpZXdEYXRhYCB0byB0aGUgZ2l2ZW4gT3BhcXVlVmlld1N0YXRlIGluc3RhbmNlLlxuICpcbiAqIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZ2V0Q3VycmVudFZpZXcoKSBpbnN0cnVjdGlvbiB0byBzYXZlIGEgc25hcHNob3RcbiAqIG9mIHRoZSBjdXJyZW50IHZpZXcgYW5kIHJlc3RvcmUgaXQgd2hlbiBsaXN0ZW5lcnMgYXJlIGludm9rZWQuIFRoaXMgYWxsb3dzXG4gKiB3YWxraW5nIHRoZSBkZWNsYXJhdGlvbiB2aWV3IHRyZWUgaW4gbGlzdGVuZXJzIHRvIGdldCB2YXJzIGZyb20gcGFyZW50IHZpZXdzLlxuICpcbiAqIEBwYXJhbSB2aWV3VG9SZXN0b3JlIFRoZSBPcGFxdWVWaWV3U3RhdGUgaW5zdGFuY2UgdG8gcmVzdG9yZS5cbiAqL1xuZnVuY3Rpb24gcmVzdG9yZVZpZXcodmlld1RvUmVzdG9yZSkge1xuICAgIGNvbnRleHRWaWV3RGF0YSA9IHZpZXdUb1Jlc3RvcmU7XG59XG4vKiogVXNlZCB0byBzZXQgdGhlIHBhcmVudCBwcm9wZXJ0eSB3aGVuIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCB0cmFjayBxdWVyeSByZXN1bHRzLiAqL1xudmFyIHByZXZpb3VzT3JQYXJlbnRUTm9kZTtcbmZ1bmN0aW9uIGdldFByZXZpb3VzT3JQYXJlbnRUTm9kZSgpIHtcbiAgICAvLyB0b3AgbGV2ZWwgdmFyaWFibGVzIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKFBFUkZfTk9URVMubWQpXG4gICAgcmV0dXJuIHByZXZpb3VzT3JQYXJlbnRUTm9kZTtcbn1cbmZ1bmN0aW9uIHNldEVudmlyb25tZW50KHROb2RlLCB2aWV3KSB7XG4gICAgcHJldmlvdXNPclBhcmVudFROb2RlID0gdE5vZGU7XG4gICAgdmlld0RhdGEgPSB2aWV3O1xufVxuLyoqXG4gKiBJZiBgaXNQYXJlbnRgIGlzOlxuICogIC0gYHRydWVgOiB0aGVuIGBwcmV2aW91c09yUGFyZW50VE5vZGVgIHBvaW50cyB0byBhIHBhcmVudCBub2RlLlxuICogIC0gYGZhbHNlYDogdGhlbiBgcHJldmlvdXNPclBhcmVudFROb2RlYCBwb2ludHMgdG8gcHJldmlvdXMgbm9kZSAoc2libGluZykuXG4gKi9cbnZhciBpc1BhcmVudDtcbnZhciB0VmlldztcbnZhciBjdXJyZW50UXVlcmllcztcbi8qKlxuICogUXVlcnkgaW5zdHJ1Y3Rpb25zIGNhbiBhc2sgZm9yIFwiY3VycmVudCBxdWVyaWVzXCIgaW4gMiBkaWZmZXJlbnQgY2FzZXM6XG4gKiAtIHdoZW4gY3JlYXRpbmcgdmlldyBxdWVyaWVzIChhdCB0aGUgcm9vdCBvZiBhIGNvbXBvbmVudCB2aWV3LCBiZWZvcmUgYW55IG5vZGUgaXMgY3JlYXRlZCAtIGluXG4gKiB0aGlzIGNhc2UgY3VycmVudFF1ZXJpZXMgcG9pbnRzIHRvIHZpZXcgcXVlcmllcylcbiAqIC0gd2hlbiBjcmVhdGluZyBjb250ZW50IHF1ZXJpZXMgKGkuZS4gdGhpcyBwcmV2aW91c09yUGFyZW50VE5vZGUgcG9pbnRzIHRvIGEgbm9kZSBvbiB3aGljaCB3ZVxuICogY3JlYXRlIGNvbnRlbnQgcXVlcmllcykuXG4gKi9cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ3VycmVudFF1ZXJpZXMoUXVlcnlUeXBlKSB7XG4gICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgY29udGVudCBxdWVyeSBvbiBhIG5vZGUsIGFueSBleGlzdGluZyBMUXVlcmllcyBuZWVkcyB0byBiZSBjbG9uZWRcbiAgICAvLyBpbiBzdWJzZXF1ZW50IHRlbXBsYXRlIHBhc3NlcywgdGhlIGNsb25pbmcgb2NjdXJzIGJlZm9yZSBkaXJlY3RpdmUgaW5zdGFudGlhdGlvbi5cbiAgICBpZiAocHJldmlvdXNPclBhcmVudFROb2RlICYmIHByZXZpb3VzT3JQYXJlbnRUTm9kZSAhPT0gdmlld0RhdGFbSE9TVF9OT0RFXSAmJlxuICAgICAgICAhaXNDb250ZW50UXVlcnlIb3N0KHByZXZpb3VzT3JQYXJlbnRUTm9kZSkpIHtcbiAgICAgICAgY3VycmVudFF1ZXJpZXMgJiYgKGN1cnJlbnRRdWVyaWVzID0gY3VycmVudFF1ZXJpZXMuY2xvbmUoKSk7XG4gICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5mbGFncyB8PSAxNjM4NCAvKiBoYXNDb250ZW50UXVlcnkgKi87XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50UXVlcmllcyB8fCAoY3VycmVudFF1ZXJpZXMgPSBuZXcgUXVlcnlUeXBlKG51bGwsIG51bGwsIG51bGwpKTtcbn1cbi8qKlxuICogVGhpcyBwcm9wZXJ0eSBnZXRzIHNldCBiZWZvcmUgZW50ZXJpbmcgYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIGNyZWF0aW9uTW9kZTtcbmZ1bmN0aW9uIGdldENyZWF0aW9uTW9kZSgpIHtcbiAgICAvLyB0b3AgbGV2ZWwgdmFyaWFibGVzIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKFBFUkZfTk9URVMubWQpXG4gICAgcmV0dXJuIGNyZWF0aW9uTW9kZTtcbn1cbi8qKlxuICogU3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldyBiZWluZyBwcm9jZXNzZWQuXG4gKlxuICogQW4gYXJyYXkgb2Ygbm9kZXMgKHRleHQsIGVsZW1lbnQsIGNvbnRhaW5lciwgZXRjKSwgcGlwZXMsIHRoZWlyIGJpbmRpbmdzLCBhbmRcbiAqIGFueSBsb2NhbCB2YXJpYWJsZXMgdGhhdCBuZWVkIHRvIGJlIHN0b3JlZCBiZXR3ZWVuIGludm9jYXRpb25zLlxuICovXG52YXIgdmlld0RhdGE7XG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBMVmlld0RhdGEgaW5zdGFuY2UuXG4gKlxuICogVGhlIGdldEN1cnJlbnRWaWV3KCkgaW5zdHJ1Y3Rpb24gc2hvdWxkIGJlIHVzZWQgZm9yIGFueXRoaW5nIHB1YmxpYy5cbiAqL1xuZnVuY3Rpb24gX2dldFZpZXdEYXRhKCkge1xuICAgIC8vIHRvcCBsZXZlbCB2YXJpYWJsZXMgc2hvdWxkIG5vdCBiZSBleHBvcnRlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoUEVSRl9OT1RFUy5tZClcbiAgICByZXR1cm4gdmlld0RhdGE7XG59XG4vKipcbiAqIFRoZSBsYXN0IHZpZXdEYXRhIHJldHJpZXZlZCBieSBuZXh0Q29udGV4dCgpLlxuICogQWxsb3dzIGJ1aWxkaW5nIG5leHRDb250ZXh0KCkgYW5kIHJlZmVyZW5jZSgpIGNhbGxzLlxuICpcbiAqIGUuZy4gY29uc3QgaW5uZXIgPSB4KCkuJGltcGxpY2l0OyBjb25zdCBvdXRlciA9IHgoKS4kaW1wbGljaXQ7XG4gKi9cbnZhciBjb250ZXh0Vmlld0RhdGEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q2xlYW51cCh2aWV3KSB7XG4gICAgLy8gdG9wIGxldmVsIHZhcmlhYmxlcyBzaG91bGQgbm90IGJlIGV4cG9ydGVkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIChQRVJGX05PVEVTLm1kKVxuICAgIHJldHVybiB2aWV3W0NMRUFOVVBdIHx8ICh2aWV3W0NMRUFOVVBdID0gW10pO1xufVxuZnVuY3Rpb24gZ2V0VFZpZXdDbGVhbnVwKHZpZXcpIHtcbiAgICByZXR1cm4gdmlld1tUVklFV10uY2xlYW51cCB8fCAodmlld1tUVklFV10uY2xlYW51cCA9IFtdKTtcbn1cbi8qKlxuICogSW4gdGhpcyBtb2RlLCBhbnkgY2hhbmdlcyBpbiBiaW5kaW5ncyB3aWxsIHRocm93IGFuIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJDaGVja2VkIGVycm9yLlxuICpcbiAqIE5lY2Vzc2FyeSB0byBzdXBwb3J0IENoYW5nZURldGVjdG9yUmVmLmNoZWNrTm9DaGFuZ2VzKCkuXG4gKi9cbnZhciBjaGVja05vQ2hhbmdlc01vZGUgPSBmYWxzZTtcbi8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBjdXJyZW50IHZpZXcgaGFzIGJlZW4gcHJvY2Vzc2VkLiAqL1xudmFyIGZpcnN0VGVtcGxhdGVQYXNzID0gdHJ1ZTtcbi8qKlxuICogVGhlIHJvb3QgaW5kZXggZnJvbSB3aGljaCBwdXJlIGZ1bmN0aW9uIGluc3RydWN0aW9ucyBzaG91bGQgY2FsY3VsYXRlIHRoZWlyIGJpbmRpbmdcbiAqIGluZGljZXMuIEluIGNvbXBvbmVudCB2aWV3cywgdGhpcyBpcyBUVmlldy5iaW5kaW5nU3RhcnRJbmRleC4gSW4gYSBob3N0IGJpbmRpbmdcbiAqIGNvbnRleHQsIHRoaXMgaXMgdGhlIFRWaWV3LmV4cGFuZG9TdGFydEluZGV4ICsgYW55IGRpcnMvaG9zdFZhcnMgYmVmb3JlIHRoZSBnaXZlbiBkaXIuXG4gKi9cbnZhciBiaW5kaW5nUm9vdEluZGV4ID0gLTE7XG4vLyB0b3AgbGV2ZWwgdmFyaWFibGVzIHNob3VsZCBub3QgYmUgZXhwb3J0ZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKFBFUkZfTk9URVMubWQpXG5mdW5jdGlvbiBnZXRCaW5kaW5nUm9vdCgpIHtcbiAgICByZXR1cm4gYmluZGluZ1Jvb3RJbmRleDtcbn1cbi8qKlxuICogU3dhcCB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIGEgbmV3IHN0YXRlLlxuICpcbiAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zIHdlIHN0b3JlIHRoZSBzdGF0ZSBpbiB0aGUgdG9wIGxldmVsIG9mIHRoZSBtb2R1bGUuXG4gKiBUaGlzIHdheSB3ZSBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMgdG8gcmVhZC4gV2hlbmV2ZXIgYSBuZXcgdmlld1xuICogaXMgZW50ZXJlZCB3ZSBoYXZlIHRvIHN0b3JlIHRoZSBzdGF0ZSBmb3IgbGF0ZXIsIGFuZCB3aGVuIHRoZSB2aWV3IGlzXG4gKiBleGl0ZWQgdGhlIHN0YXRlIGhhcyB0byBiZSByZXN0b3JlZFxuICpcbiAqIEBwYXJhbSBuZXdWaWV3IE5ldyBzdGF0ZSB0byBiZWNvbWUgYWN0aXZlXG4gKiBAcGFyYW0gaG9zdCBFbGVtZW50IHRvIHdoaWNoIHRoZSBWaWV3IGlzIGEgY2hpbGQgb2ZcbiAqIEByZXR1cm5zIHRoZSBwcmV2aW91cyBzdGF0ZTtcbiAqL1xuZnVuY3Rpb24gZW50ZXJWaWV3KG5ld1ZpZXcsIGhvc3RUTm9kZSkge1xuICAgIHZhciBvbGRWaWV3ID0gdmlld0RhdGE7XG4gICAgdFZpZXcgPSBuZXdWaWV3ICYmIG5ld1ZpZXdbVFZJRVddO1xuICAgIGNyZWF0aW9uTW9kZSA9IG5ld1ZpZXcgJiYgKG5ld1ZpZXdbRkxBR1NdICYgMSAvKiBDcmVhdGlvbk1vZGUgKi8pID09PSAxIC8qIENyZWF0aW9uTW9kZSAqLztcbiAgICBmaXJzdFRlbXBsYXRlUGFzcyA9IG5ld1ZpZXcgJiYgdFZpZXcuZmlyc3RUZW1wbGF0ZVBhc3M7XG4gICAgYmluZGluZ1Jvb3RJbmRleCA9IG5ld1ZpZXcgJiYgdFZpZXcuYmluZGluZ1N0YXJ0SW5kZXg7XG4gICAgcmVuZGVyZXIgPSBuZXdWaWV3ICYmIG5ld1ZpZXdbUkVOREVSRVJdO1xuICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IGhvc3RUTm9kZTtcbiAgICBpc1BhcmVudCA9IHRydWU7XG4gICAgdmlld0RhdGEgPSBjb250ZXh0Vmlld0RhdGEgPSBuZXdWaWV3O1xuICAgIG9sZFZpZXcgJiYgKG9sZFZpZXdbUVVFUklFU10gPSBjdXJyZW50UXVlcmllcyk7XG4gICAgY3VycmVudFF1ZXJpZXMgPSBuZXdWaWV3ICYmIG5ld1ZpZXdbUVVFUklFU107XG4gICAgcmV0dXJuIG9sZFZpZXc7XG59XG4vKipcbiAqIFVzZWQgaW4gbGlldSBvZiBlbnRlclZpZXcgdG8gbWFrZSBpdCBjbGVhciB3aGVuIHdlIGFyZSBleGl0aW5nIGEgY2hpbGQgdmlldy4gVGhpcyBtYWtlc1xuICogdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZXJzYWwgKHVwIG9yIGRvd24gdGhlIHZpZXcgdHJlZSkgYSBiaXQgY2xlYXJlci5cbiAqXG4gKiBAcGFyYW0gbmV3VmlldyBOZXcgc3RhdGUgdG8gYmVjb21lIGFjdGl2ZVxuICogQHBhcmFtIGNyZWF0aW9uT25seSBBbiBvcHRpb25hbCBib29sZWFuIHRvIGluZGljYXRlIHRoYXQgdGhlIHZpZXcgd2FzIHByb2Nlc3NlZCBpbiBjcmVhdGlvbiBtb2RlXG4gKiBvbmx5LCBpLmUuIHRoZSBmaXJzdCB1cGRhdGUgd2lsbCBiZSBkb25lIGxhdGVyLiBPbmx5IHBvc3NpYmxlIGZvciBkeW5hbWljYWxseSBjcmVhdGVkIHZpZXdzLlxuICovXG5mdW5jdGlvbiBsZWF2ZVZpZXcobmV3VmlldywgY3JlYXRpb25Pbmx5KSB7XG4gICAgaWYgKCFjcmVhdGlvbk9ubHkpIHtcbiAgICAgICAgaWYgKCFjaGVja05vQ2hhbmdlc01vZGUpIHtcbiAgICAgICAgICAgIGV4ZWN1dGVIb29rcyh2aWV3RGF0YSwgdFZpZXcudmlld0hvb2tzLCB0Vmlldy52aWV3Q2hlY2tIb29rcywgY3JlYXRpb25Nb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWaWV3cyBhcmUgY2xlYW4gYW5kIGluIHVwZGF0ZSBtb2RlIGFmdGVyIGJlaW5nIGNoZWNrZWQsIHNvIHRoZXNlIGJpdHMgYXJlIGNsZWFyZWRcbiAgICAgICAgdmlld0RhdGFbRkxBR1NdICY9IH4oMSAvKiBDcmVhdGlvbk1vZGUgKi8gfCA0IC8qIERpcnR5ICovKTtcbiAgICB9XG4gICAgdmlld0RhdGFbRkxBR1NdIHw9IDE2IC8qIFJ1bkluaXQgKi87XG4gICAgdmlld0RhdGFbQklORElOR19JTkRFWF0gPSB0Vmlldy5iaW5kaW5nU3RhcnRJbmRleDtcbiAgICBlbnRlclZpZXcobmV3VmlldywgbnVsbCk7XG59XG4vKipcbiAqIFJlZnJlc2hlcyB0aGUgdmlldywgZXhlY3V0aW5nIHRoZSBmb2xsb3dpbmcgc3RlcHMgaW4gdGhhdCBvcmRlcjpcbiAqIHRyaWdnZXJzIGluaXQgaG9va3MsIHJlZnJlc2hlcyBkeW5hbWljIGVtYmVkZGVkIHZpZXdzLCB0cmlnZ2VycyBjb250ZW50IGhvb2tzLCBzZXRzIGhvc3RcbiAqIGJpbmRpbmdzLCByZWZyZXNoZXMgY2hpbGQgY29tcG9uZW50cy5cbiAqIE5vdGU6IHZpZXcgaG9va3MgYXJlIHRyaWdnZXJlZCBsYXRlciB3aGVuIGxlYXZpbmcgdGhlIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIHJlZnJlc2hEZXNjZW5kYW50Vmlld3MoKSB7XG4gICAgc2V0SG9zdEJpbmRpbmdzKCk7XG4gICAgdmFyIHBhcmVudEZpcnN0VGVtcGxhdGVQYXNzID0gZmlyc3RUZW1wbGF0ZVBhc3M7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIGNoaWxkcmVuIGFyZSBwcm9jZXNzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmUgY29tcG9uZW50c1xuICAgIHRWaWV3LmZpcnN0VGVtcGxhdGVQYXNzID0gZmlyc3RUZW1wbGF0ZVBhc3MgPSBmYWxzZTtcbiAgICBpZiAoIWNoZWNrTm9DaGFuZ2VzTW9kZSkge1xuICAgICAgICBleGVjdXRlSW5pdEhvb2tzKHZpZXdEYXRhLCB0VmlldywgY3JlYXRpb25Nb2RlKTtcbiAgICB9XG4gICAgcmVmcmVzaER5bmFtaWNFbWJlZGRlZFZpZXdzKHZpZXdEYXRhKTtcbiAgICAvLyBDb250ZW50IHF1ZXJ5IHJlc3VsdHMgbXVzdCBiZSByZWZyZXNoZWQgYmVmb3JlIGNvbnRlbnQgaG9va3MgYXJlIGNhbGxlZC5cbiAgICByZWZyZXNoQ29udGVudFF1ZXJpZXModFZpZXcpO1xuICAgIGlmICghY2hlY2tOb0NoYW5nZXNNb2RlKSB7XG4gICAgICAgIGV4ZWN1dGVIb29rcyh2aWV3RGF0YSwgdFZpZXcuY29udGVudEhvb2tzLCB0Vmlldy5jb250ZW50Q2hlY2tIb29rcywgY3JlYXRpb25Nb2RlKTtcbiAgICB9XG4gICAgcmVmcmVzaENoaWxkQ29tcG9uZW50cyh0Vmlldy5jb21wb25lbnRzLCBwYXJlbnRGaXJzdFRlbXBsYXRlUGFzcyk7XG59XG4vKiogU2V0cyB0aGUgaG9zdCBiaW5kaW5ncyBmb3IgdGhlIGN1cnJlbnQgdmlldy4gKi9cbmZ1bmN0aW9uIHNldEhvc3RCaW5kaW5ncygpIHtcbiAgICBpZiAodFZpZXcuZXhwYW5kb0luc3RydWN0aW9ucykge1xuICAgICAgICBiaW5kaW5nUm9vdEluZGV4ID0gdmlld0RhdGFbQklORElOR19JTkRFWF0gPSB0Vmlldy5leHBhbmRvU3RhcnRJbmRleDtcbiAgICAgICAgdmFyIGN1cnJlbnREaXJlY3RpdmVJbmRleCA9IC0xO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnRJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRWaWV3LmV4cGFuZG9JbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IHRWaWV3LmV4cGFuZG9JbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgbWVhbiB0aGF0IHdlIGFyZSBzdGFydGluZyBuZXcgRVhQQU5ETyBibG9jayBhbmQgbmVlZCB0byB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZWxlbWVudCBhbmQgZGlyZWN0aXZlIGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudEluZGV4ID0gLWluc3RydWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZpZXdEYXRhW2JpbmRpbmdSb290SW5kZXhdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgaGl0IGFuIGluamVjdG9yLiBJdCBtYXkgb3IgbWF5IG5vdCBleGlzdCBkZXBlbmRpbmcgb24gd2hldGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBwdWJsaWMgZGlyZWN0aXZlIG9uIHRoaXMgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdSb290SW5kZXggKz0gSU5KRUNUT1JfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0aXZlSW5kZXggPSBiaW5kaW5nUm9vdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBlaXRoZXIgdGhlIGluamVjdG9yIHNpemUgKHNvIHRoZSBiaW5kaW5nIHJvb3QgY2FuIHNraXAgb3ZlciBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBnZXQgdG8gdGhlIGZpcnN0IHNldCBvZiBob3N0IGJpbmRpbmdzIG9uIHRoaXMgbm9kZSkgb3IgdGhlIGhvc3QgdmFyIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIC8vICh0byBnZXQgdG8gdGhlIG5leHQgc2V0IG9mIGhvc3QgYmluZGluZ3Mgb24gdGhpcyBub2RlKS5cbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ1Jvb3RJbmRleCArPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciwgaXQncyBhIGhvc3QgYmluZGluZyBmdW5jdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICAgIHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdID0gYmluZGluZ1Jvb3RJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHN1YnRyYWN0IHRoZSBoZWFkZXIgb2Zmc2V0IGJlY2F1c2UgdGhlIGxvYWQoKSBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIC8vIGV4cGVjdHMgYSByYXcsIHVuYWRqdXN0ZWQgaW5kZXguXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24oY3VycmVudERpcmVjdGl2ZUluZGV4IC0gSEVBREVSX09GRlNFVCwgY3VycmVudEVsZW1lbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgY3VycmVudERpcmVjdGl2ZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogUmVmcmVzaGVzIGNvbnRlbnQgcXVlcmllcyBmb3IgYWxsIGRpcmVjdGl2ZXMgaW4gdGhlIGdpdmVuIHZpZXcuICovXG5mdW5jdGlvbiByZWZyZXNoQ29udGVudFF1ZXJpZXModFZpZXcpIHtcbiAgICBpZiAodFZpZXcuY29udGVudFF1ZXJpZXMgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRWaWV3LmNvbnRlbnRRdWVyaWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlRGVmSWR4ID0gdFZpZXcuY29udGVudFF1ZXJpZXNbaV07XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlRGVmID0gdFZpZXcuZGF0YVtkaXJlY3RpdmVEZWZJZHhdO1xuICAgICAgICAgICAgZGlyZWN0aXZlRGVmLmNvbnRlbnRRdWVyaWVzUmVmcmVzaChkaXJlY3RpdmVEZWZJZHggLSBIRUFERVJfT0ZGU0VULCB0Vmlldy5jb250ZW50UXVlcmllc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIFJlZnJlc2hlcyBjaGlsZCBjb21wb25lbnRzIGluIHRoZSBjdXJyZW50IHZpZXcuICovXG5mdW5jdGlvbiByZWZyZXNoQ2hpbGRDb21wb25lbnRzKGNvbXBvbmVudHMsIHBhcmVudEZpcnN0VGVtcGxhdGVQYXNzKSB7XG4gICAgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZnJlc2goY29tcG9uZW50c1tpXSwgcGFyZW50Rmlyc3RUZW1wbGF0ZVBhc3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZUluaXRBbmRDb250ZW50SG9va3MoKSB7XG4gICAgaWYgKCFjaGVja05vQ2hhbmdlc01vZGUpIHtcbiAgICAgICAgZXhlY3V0ZUluaXRIb29rcyh2aWV3RGF0YSwgdFZpZXcsIGNyZWF0aW9uTW9kZSk7XG4gICAgICAgIGV4ZWN1dGVIb29rcyh2aWV3RGF0YSwgdFZpZXcuY29udGVudEhvb2tzLCB0Vmlldy5jb250ZW50Q2hlY2tIb29rcywgY3JlYXRpb25Nb2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVMVmlld0RhdGEocmVuZGVyZXIsIHRWaWV3LCBjb250ZXh0LCBmbGFncywgc2FuaXRpemVyKSB7XG4gICAgdmFyIGluc3RhbmNlID0gdFZpZXcuYmx1ZXByaW50LnNsaWNlKCk7XG4gICAgaW5zdGFuY2VbRkxBR1NdID0gZmxhZ3MgfCAxIC8qIENyZWF0aW9uTW9kZSAqLyB8IDggLyogQXR0YWNoZWQgKi8gfCAxNiAvKiBSdW5Jbml0ICovO1xuICAgIGluc3RhbmNlW1BBUkVOVF0gPSBpbnN0YW5jZVtERUNMQVJBVElPTl9WSUVXXSA9IHZpZXdEYXRhO1xuICAgIGluc3RhbmNlW0NPTlRFWFRdID0gY29udGV4dDtcbiAgICBpbnN0YW5jZVtJTkpFQ1RPUiQxXSA9IHZpZXdEYXRhID8gdmlld0RhdGFbSU5KRUNUT1IkMV0gOiBudWxsO1xuICAgIGluc3RhbmNlW1JFTkRFUkVSXSA9IHJlbmRlcmVyO1xuICAgIGluc3RhbmNlW1NBTklUSVpFUl0gPSBzYW5pdGl6ZXIgfHwgbnVsbDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQXRJbmRleChpbmRleCwgdHlwZSwgbmF0aXZlLCBuYW1lLCBhdHRycykge1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggKyBIRUFERVJfT0ZGU0VUO1xuICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICBhc3NlcnRMZXNzVGhhbihhZGp1c3RlZEluZGV4LCB2aWV3RGF0YS5sZW5ndGgsIFwiU2xvdCBzaG91bGQgaGF2ZSBiZWVuIGluaXRpYWxpemVkIHdpdGggbnVsbFwiKTtcbiAgICB2aWV3RGF0YVthZGp1c3RlZEluZGV4XSA9IG5hdGl2ZTtcbiAgICB2YXIgdE5vZGUgPSB0Vmlldy5kYXRhW2FkanVzdGVkSW5kZXhdO1xuICAgIGlmICh0Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHROb2RlID0gdFZpZXcuZGF0YVthZGp1c3RlZEluZGV4XSA9IGNyZWF0ZVROb2RlKHR5cGUsIGFkanVzdGVkSW5kZXgsIG5hbWUsIGF0dHJzLCBudWxsKTtcbiAgICAgICAgLy8gTm93IGxpbmsgb3Vyc2VsdmVzIGludG8gdGhlIHRyZWUuXG4gICAgICAgIGlmIChwcmV2aW91c09yUGFyZW50VE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChpc1BhcmVudCAmJiBwcmV2aW91c09yUGFyZW50VE5vZGUuY2hpbGQgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICh0Tm9kZS5wYXJlbnQgIT09IG51bGwgfHwgcHJldmlvdXNPclBhcmVudFROb2RlLnR5cGUgPT09IDIgLyogVmlldyAqLykpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgaW4gdGhlIHNhbWUgdmlldywgd2hpY2ggbWVhbnMgd2UgYXJlIGFkZGluZyBjb250ZW50IG5vZGUgdG8gdGhlIHBhcmVudCB2aWV3LlxuICAgICAgICAgICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5jaGlsZCA9IHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNPclBhcmVudFROb2RlLm5leHQgPSB0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodFZpZXcuZmlyc3RDaGlsZCA9PSBudWxsICYmIHR5cGUgPT09IDMgLyogRWxlbWVudCAqLykge1xuICAgICAgICB0Vmlldy5maXJzdENoaWxkID0gdE5vZGU7XG4gICAgfVxuICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IHROb2RlO1xuICAgIGlzUGFyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gdE5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3Tm9kZShpbmRleCwgdmlldykge1xuICAgIC8vIFZpZXcgbm9kZXMgYXJlIG5vdCBzdG9yZWQgaW4gZGF0YSBiZWNhdXNlIHRoZXkgY2FuIGJlIGFkZGVkIC8gcmVtb3ZlZCBhdCBydW50aW1lICh3aGljaFxuICAgIC8vIHdvdWxkIGNhdXNlIGluZGljZXMgdG8gY2hhbmdlKS4gVGhlaXIgVE5vZGVzIGFyZSBpbnN0ZWFkIHN0b3JlZCBpbiB0Vmlldy5ub2RlLlxuICAgIGlmICh2aWV3W1RWSUVXXS5ub2RlID09IG51bGwpIHtcbiAgICAgICAgdmlld1tUVklFV10ubm9kZSA9IGNyZWF0ZVROb2RlKDIgLyogVmlldyAqLywgaW5kZXgsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBpc1BhcmVudCA9IHRydWU7XG4gICAgcmV0dXJuIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IHZpZXdbSE9TVF9OT0RFXSA9IHZpZXdbVFZJRVddLm5vZGU7XG59XG4vKipcbiAqIFdoZW4gZWxlbWVudHMgYXJlIGNyZWF0ZWQgZHluYW1pY2FsbHkgYWZ0ZXIgYSB2aWV3IGJsdWVwcmludCBpcyBjcmVhdGVkIChlLmcuIHRocm91Z2hcbiAqIGkxOG5BcHBseSgpIG9yIENvbXBvbmVudEZhY3RvcnkuY3JlYXRlKSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGJsdWVwcmludCBmb3IgZnV0dXJlXG4gKiB0ZW1wbGF0ZSBwYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIGFkanVzdEJsdWVwcmludEZvck5ld05vZGUodmlldykge1xuICAgIHZhciB0VmlldyA9IHZpZXdbVFZJRVddO1xuICAgIGlmICh0Vmlldy5maXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB0Vmlldy5leHBhbmRvU3RhcnRJbmRleCsrO1xuICAgICAgICB0Vmlldy5ibHVlcHJpbnQucHVzaChudWxsKTtcbiAgICAgICAgdmlldy5wdXNoKG51bGwpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vIFJlbmRlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogUmVzZXRzIHRoZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRDb21wb25lbnRTdGF0ZSgpIHtcbiAgICBpc1BhcmVudCA9IGZhbHNlO1xuICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IG51bGw7XG4gICAgZWxlbWVudERlcHRoQ291bnQgPSAwO1xuICAgIGJpbmRpbmdzRW5hYmxlZCA9IHRydWU7XG59XG4vKipcbiAqIFVzZWQgZm9yIGNyZWF0aW5nIHRoZSBMVmlld05vZGUgb2YgYSBkeW5hbWljIGVtYmVkZGVkIHZpZXcsXG4gKiBlaXRoZXIgdGhyb3VnaCBWaWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldygpIG9yIFRlbXBsYXRlUmVmLmNyZWF0ZUVtYmVkZGVkVmlldygpLlxuICogU3VjaCBsVmlld05vZGUgd2lsbCB0aGVuIGJlIHJlbmRlcmVyIHdpdGggcmVuZGVyRW1iZWRkZWRUZW1wbGF0ZSgpIChzZWUgYmVsb3cpLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRlZFZpZXdBbmROb2RlKHRWaWV3LCBjb250ZXh0LCBkZWNsYXJhdGlvblZpZXcsIHJlbmRlcmVyLCBxdWVyaWVzLCBpbmplY3RvckluZGV4KSB7XG4gICAgdmFyIF9pc1BhcmVudCA9IGlzUGFyZW50O1xuICAgIHZhciBfcHJldmlvdXNPclBhcmVudFROb2RlID0gcHJldmlvdXNPclBhcmVudFROb2RlO1xuICAgIGlzUGFyZW50ID0gdHJ1ZTtcbiAgICBwcmV2aW91c09yUGFyZW50VE5vZGUgPSBudWxsO1xuICAgIHZhciBsVmlldyA9IGNyZWF0ZUxWaWV3RGF0YShyZW5kZXJlciwgdFZpZXcsIGNvbnRleHQsIDIgLyogQ2hlY2tBbHdheXMgKi8sIGdldEN1cnJlbnRTYW5pdGl6ZXIoKSk7XG4gICAgbFZpZXdbREVDTEFSQVRJT05fVklFV10gPSBkZWNsYXJhdGlvblZpZXc7XG4gICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgbFZpZXdbUVVFUklFU10gPSBxdWVyaWVzLmNyZWF0ZVZpZXcoKTtcbiAgICB9XG4gICAgY3JlYXRlVmlld05vZGUoLTEsIGxWaWV3KTtcbiAgICBpZiAodFZpZXcuZmlyc3RUZW1wbGF0ZVBhc3MpIHtcbiAgICAgICAgdFZpZXcubm9kZS5pbmplY3RvckluZGV4ID0gaW5qZWN0b3JJbmRleDtcbiAgICB9XG4gICAgaXNQYXJlbnQgPSBfaXNQYXJlbnQ7XG4gICAgcHJldmlvdXNPclBhcmVudFROb2RlID0gX3ByZXZpb3VzT3JQYXJlbnRUTm9kZTtcbiAgICByZXR1cm4gbFZpZXc7XG59XG4vKipcbiAqIFVzZWQgZm9yIHJlbmRlcmluZyBlbWJlZGRlZCB2aWV3cyAoZS5nLiBkeW5hbWljYWxseSBjcmVhdGVkIHZpZXdzKVxuICpcbiAqIER5bmFtaWNhbGx5IGNyZWF0ZWQgdmlld3MgbXVzdCBzdG9yZS9yZXRyaWV2ZSB0aGVpciBUVmlld3MgZGlmZmVyZW50bHkgZnJvbSBjb21wb25lbnQgdmlld3NcbiAqIGJlY2F1c2UgdGhlaXIgdGVtcGxhdGUgZnVuY3Rpb25zIGFyZSBuZXN0ZWQgaW4gdGhlIHRlbXBsYXRlIGZ1bmN0aW9ucyBvZiB0aGVpciBob3N0cywgY3JlYXRpbmdcbiAqIGNsb3N1cmVzLiBJZiB0aGVpciBob3N0IHRlbXBsYXRlIGhhcHBlbnMgdG8gYmUgYW4gZW1iZWRkZWQgdGVtcGxhdGUgaW4gYSBsb29wIChlLmcuIG5nRm9yIGluc2lkZVxuICogYW4gbmdGb3IpLCB0aGUgbmVzdGluZyB3b3VsZCBtZWFuIHdlJ2QgaGF2ZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLCBzbyB3ZVxuICogY2FuJ3Qgc3RvcmUgVFZpZXdzIGluIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiBpdHNlbGYgKGFzIHdlIGRvIGZvciBjb21wcykuIEluc3RlYWQsIHdlIHN0b3JlIHRoZVxuICogVFZpZXcgZm9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgdmlld3Mgb24gdGhlaXIgaG9zdCBUTm9kZSwgd2hpY2ggb25seSBoYXMgb25lIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiByZW5kZXJFbWJlZGRlZFRlbXBsYXRlKHZpZXdUb1JlbmRlciwgdFZpZXcsIGNvbnRleHQsIHJmKSB7XG4gICAgdmFyIF9pc1BhcmVudCA9IGlzUGFyZW50O1xuICAgIHZhciBfcHJldmlvdXNPclBhcmVudFROb2RlID0gcHJldmlvdXNPclBhcmVudFROb2RlO1xuICAgIHZhciBvbGRWaWV3O1xuICAgIGlmICh2aWV3VG9SZW5kZXJbRkxBR1NdICYgNjQgLyogSXNSb290ICovKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSByb290IHZpZXcgaW5zaWRlIHRoZSB2aWV3IHRyZWVcbiAgICAgICAgdGlja1Jvb3RDb250ZXh0KHZpZXdUb1JlbmRlcltDT05URVhUXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgcHJldmlvdXNPclBhcmVudFROb2RlID0gbnVsbDtcbiAgICAgICAgICAgIG9sZFZpZXcgPSBlbnRlclZpZXcodmlld1RvUmVuZGVyLCB2aWV3VG9SZW5kZXJbSE9TVF9OT0RFXSk7XG4gICAgICAgICAgICBuYW1lc3BhY2VIVE1MKCk7XG4gICAgICAgICAgICB0Vmlldy50ZW1wbGF0ZShyZiwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmYgJiAyIC8qIFVwZGF0ZSAqLykge1xuICAgICAgICAgICAgICAgIHJlZnJlc2hEZXNjZW5kYW50Vmlld3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBzZXQgdG8gZmFsc2UgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGZpcnN0IGNyZWF0aW9uIHJ1biBiZWNhdXNlIGluIGFuXG4gICAgICAgICAgICAgICAgLy8gbmdGb3IgbG9vcCwgYWxsIHRoZSB2aWV3cyB3aWxsIGJlIGNyZWF0ZWQgdG9nZXRoZXIgYmVmb3JlIHVwZGF0ZSBtb2RlIHJ1bnMgYW5kIHR1cm5zXG4gICAgICAgICAgICAgICAgLy8gb2ZmIGZpcnN0VGVtcGxhdGVQYXNzLiBJZiB3ZSBkb24ndCBzZXQgaXQgaGVyZSwgaW5zdGFuY2VzIHdpbGwgcGVyZm9ybSBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAvLyBtYXRjaGluZywgZXRjIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB2aWV3VG9SZW5kZXJbVFZJRVddLmZpcnN0VGVtcGxhdGVQYXNzID0gZmlyc3RUZW1wbGF0ZVBhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIHJlbmRlckVtYmVkZGVkVGVtcGxhdGUoKSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgZm9yIGNyZWF0aW9uIG9ubHkgYW5kIHRoZW4gb25jZSBmb3JcbiAgICAgICAgICAgIC8vIHVwZGF0ZS4gV2hlbiBmb3IgY3JlYXRpb24gb25seSwgbGVhdmVWaWV3KCkgbXVzdCBub3QgdHJpZ2dlciB2aWV3IGhvb2tzLCBub3IgY2xlYW4gZmxhZ3MuXG4gICAgICAgICAgICB2YXIgaXNDcmVhdGlvbk9ubHkgPSAocmYgJiAxIC8qIENyZWF0ZSAqLykgPT09IDEgLyogQ3JlYXRlICovO1xuICAgICAgICAgICAgbGVhdmVWaWV3KG9sZFZpZXcsIGlzQ3JlYXRpb25Pbmx5KTtcbiAgICAgICAgICAgIGlzUGFyZW50ID0gX2lzUGFyZW50O1xuICAgICAgICAgICAgcHJldmlvdXNPclBhcmVudFROb2RlID0gX3ByZXZpb3VzT3JQYXJlbnRUTm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIGEgY29udGV4dCBhdCB0aGUgbGV2ZWwgc3BlY2lmaWVkIGFuZCBzYXZlcyBpdCBhcyB0aGUgZ2xvYmFsLCBjb250ZXh0Vmlld0RhdGEuXG4gKiBXaWxsIGdldCB0aGUgbmV4dCBsZXZlbCB1cCBpZiBsZXZlbCBpcyBub3Qgc3BlY2lmaWVkLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBzYXZlIGNvbnRleHRzIG9mIHBhcmVudCB2aWV3cyBzbyB0aGV5IGNhbiBiZSBib3VuZCBpbiBlbWJlZGRlZCB2aWV3cywgb3JcbiAqIGluIGNvbmp1bmN0aW9uIHdpdGggcmVmZXJlbmNlKCkgdG8gYmluZCBhIHJlZiBmcm9tIGEgcGFyZW50IHZpZXcuXG4gKlxuICogQHBhcmFtIGxldmVsIFRoZSByZWxhdGl2ZSBsZXZlbCBvZiB0aGUgdmlldyBmcm9tIHdoaWNoIHRvIGdyYWIgY29udGV4dCBjb21wYXJlZCB0byBjb250ZXh0VmV3RGF0YVxuICogQHJldHVybnMgY29udGV4dFxuICovXG5mdW5jdGlvbiBuZXh0Q29udGV4dChsZXZlbCkge1xuICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gMTsgfVxuICAgIGNvbnRleHRWaWV3RGF0YSA9IHdhbGtVcFZpZXdzKGxldmVsLCBjb250ZXh0Vmlld0RhdGEpO1xuICAgIHJldHVybiBjb250ZXh0Vmlld0RhdGFbQ09OVEVYVF07XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRPclRlbXBsYXRlKGhvc3RWaWV3LCBjb21wb25lbnRPckNvbnRleHQsIHRlbXBsYXRlRm4pIHtcbiAgICB2YXIgb2xkVmlldyA9IGVudGVyVmlldyhob3N0VmlldywgaG9zdFZpZXdbSE9TVF9OT0RFXSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlbmRlcmVyRmFjdG9yeS5iZWdpbikge1xuICAgICAgICAgICAgcmVuZGVyZXJGYWN0b3J5LmJlZ2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBsYXRlRm4pIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZUhUTUwoKTtcbiAgICAgICAgICAgIHRlbXBsYXRlRm4oZ2V0UmVuZGVyRmxhZ3MoaG9zdFZpZXcpLCBjb21wb25lbnRPckNvbnRleHQpO1xuICAgICAgICAgICAgcmVmcmVzaERlc2NlbmRhbnRWaWV3cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhlY3V0ZUluaXRBbmRDb250ZW50SG9va3MoKTtcbiAgICAgICAgICAgIC8vIEVsZW1lbnQgd2FzIHN0b3JlZCBhdCAwIGluIGRhdGEgYW5kIGRpcmVjdGl2ZSB3YXMgc3RvcmVkIGF0IDAgaW4gZGlyZWN0aXZlc1xuICAgICAgICAgICAgLy8gaW4gcmVuZGVyQ29tcG9uZW50KClcbiAgICAgICAgICAgIHNldEhvc3RCaW5kaW5ncygpO1xuICAgICAgICAgICAgY29tcG9uZW50UmVmcmVzaChIRUFERVJfT0ZGU0VULCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChyZW5kZXJlckZhY3RvcnkuZW5kKSB7XG4gICAgICAgICAgICByZW5kZXJlckZhY3RvcnkuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmVWaWV3KG9sZFZpZXcpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb2YgcmVuZGVyaW5nIGZsYWdzIGRlcGVuZGluZyBvbiB3aGVuIHRoZVxuICogdGVtcGxhdGUgaXMgaW4gY3JlYXRpb24gbW9kZSBvciB1cGRhdGUgbW9kZS4gQnkgZGVmYXVsdCwgdGhlIHVwZGF0ZSBibG9jayBpcyBydW4gd2l0aCB0aGVcbiAqIGNyZWF0aW9uIGJsb2NrIHdoZW4gdGhlIHZpZXcgaXMgaW4gY3JlYXRpb24gbW9kZS4gT3RoZXJ3aXNlLCB0aGUgdXBkYXRlIGJsb2NrIGlzIHJ1blxuICogYWxvbmUuXG4gKlxuICogRHluYW1pY2FsbHkgY3JlYXRlZCB2aWV3cyBkbyBOT1QgdXNlIHRoaXMgY29uZmlndXJhdGlvbiAodXBkYXRlIGJsb2NrIGFuZCBjcmVhdGUgYmxvY2sgYXJlXG4gKiBhbHdheXMgcnVuIHNlcGFyYXRlbHkpLlxuICovXG5mdW5jdGlvbiBnZXRSZW5kZXJGbGFncyh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXdbRkxBR1NdICYgMSAvKiBDcmVhdGlvbk1vZGUgKi8gPyAxIC8qIENyZWF0ZSAqLyB8IDIgLyogVXBkYXRlICovIDpcbiAgICAgICAgMiAvKiBVcGRhdGUgKi87XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyBOYW1lc3BhY2Vcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgX2N1cnJlbnROYW1lc3BhY2UgPSBudWxsO1xuZnVuY3Rpb24gbmFtZXNwYWNlU1ZHKCkge1xuICAgIF9jdXJyZW50TmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnLyc7XG59XG5mdW5jdGlvbiBuYW1lc3BhY2VNYXRoTUwoKSB7XG4gICAgX2N1cnJlbnROYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoTUwvJztcbn1cbmZ1bmN0aW9uIG5hbWVzcGFjZUhUTUwoKSB7XG4gICAgX2N1cnJlbnROYW1lc3BhY2UgPSBudWxsO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gRWxlbWVudFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBlbGVtZW50IHVzaW5nIHtAbGluayBlbGVtZW50U3RhcnR9IGFuZCB7QGxpbmsgZWxlbWVudEVuZH1cbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRhdGEgYXJyYXlcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIERPTSBOb2RlXG4gKiBAcGFyYW0gYXR0cnMgU3RhdGljYWxseSBib3VuZCBzZXQgb2YgYXR0cmlidXRlcyB0byBiZSB3cml0dGVuIGludG8gdGhlIERPTSBlbGVtZW50IG9uIGNyZWF0aW9uLlxuICogQHBhcmFtIGxvY2FsUmVmcyBBIHNldCBvZiBsb2NhbCByZWZlcmVuY2UgYmluZGluZ3Mgb24gdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnQoaW5kZXgsIG5hbWUsIGF0dHJzLCBsb2NhbFJlZnMpIHtcbiAgICBlbGVtZW50U3RhcnQoaW5kZXgsIG5hbWUsIGF0dHJzLCBsb2NhbFJlZnMpO1xuICAgIGVsZW1lbnRFbmQoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2ljYWwgY29udGFpbmVyIGZvciBvdGhlciBub2RlcyAoPG5nLWNvbnRhaW5lcj4pIGJhY2tlZCBieSBhIGNvbW1lbnQgbm9kZSBpbiB0aGUgRE9NLlxuICogVGhlIGluc3RydWN0aW9uIG11c3QgbGF0ZXIgYmUgZm9sbG93ZWQgYnkgYGVsZW1lbnRDb250YWluZXJFbmQoKWAgY2FsbC5cbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIExWaWV3RGF0YSBhcnJheVxuICogQHBhcmFtIGF0dHJzIFNldCBvZiBhdHRyaWJ1dGVzIHRvIGJlIHVzZWQgd2hlbiBtYXRjaGluZyBkaXJlY3RpdmVzLlxuICogQHBhcmFtIGxvY2FsUmVmcyBBIHNldCBvZiBsb2NhbCByZWZlcmVuY2UgYmluZGluZ3Mgb24gdGhlIGVsZW1lbnQuXG4gKlxuICogRXZlbiBpZiB0aGlzIGluc3RydWN0aW9uIGFjY2VwdHMgYSBzZXQgb2YgYXR0cmlidXRlcyBubyBhY3R1YWwgYXR0cmlidXRlIHZhbHVlcyBhcmUgcHJvcGFnYXRlZCB0b1xuICogdGhlIERPTSAoYXMgYSBjb21tZW50IG5vZGUgY2FuJ3QgaGF2ZSBhdHRyaWJ1dGVzKS4gQXR0cmlidXRlcyBhcmUgaGVyZSBvbmx5IGZvciBkaXJlY3RpdmVcbiAqIG1hdGNoaW5nIHB1cnBvc2VzIGFuZCBzZXR0aW5nIGluaXRpYWwgaW5wdXRzIG9mIGRpcmVjdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRDb250YWluZXJTdGFydChpbmRleCwgYXR0cnMsIGxvY2FsUmVmcykge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdFZpZXcuYmluZGluZ1N0YXJ0SW5kZXgsICdlbGVtZW50IGNvbnRhaW5lcnMgc2hvdWxkIGJlIGNyZWF0ZWQgYmVmb3JlIGFueSBiaW5kaW5ncycpO1xuICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJDcmVhdGVDb21tZW50Kys7XG4gICAgdmFyIG5hdGl2ZSA9IHJlbmRlcmVyLmNyZWF0ZUNvbW1lbnQobmdEZXZNb2RlID8gJ25nLWNvbnRhaW5lcicgOiAnJyk7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERhdGFJblJhbmdlKGluZGV4IC0gMSk7XG4gICAgdmFyIHROb2RlID0gY3JlYXRlTm9kZUF0SW5kZXgoaW5kZXgsIDQgLyogRWxlbWVudENvbnRhaW5lciAqLywgbmF0aXZlLCBudWxsLCBhdHRycyB8fCBudWxsKTtcbiAgICBhcHBlbmRDaGlsZChuYXRpdmUsIHROb2RlLCB2aWV3RGF0YSk7XG4gICAgY3JlYXRlRGlyZWN0aXZlc0FuZExvY2Fscyhsb2NhbFJlZnMpO1xufVxuLyoqIE1hcmsgdGhlIGVuZCBvZiB0aGUgPG5nLWNvbnRhaW5lcj4uICovXG5mdW5jdGlvbiBlbGVtZW50Q29udGFpbmVyRW5kKCkge1xuICAgIGlmIChpc1BhcmVudCkge1xuICAgICAgICBpc1BhcmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydEhhc1BhcmVudCgpO1xuICAgICAgICBwcmV2aW91c09yUGFyZW50VE5vZGUgPSBwcmV2aW91c09yUGFyZW50VE5vZGUucGFyZW50O1xuICAgIH1cbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm9kZVR5cGUocHJldmlvdXNPclBhcmVudFROb2RlLCA0IC8qIEVsZW1lbnRDb250YWluZXIgKi8pO1xuICAgIGN1cnJlbnRRdWVyaWVzICYmXG4gICAgICAgIChjdXJyZW50UXVlcmllcyA9IGN1cnJlbnRRdWVyaWVzLmFkZE5vZGUocHJldmlvdXNPclBhcmVudFROb2RlKSk7XG4gICAgcXVldWVMaWZlY3ljbGVIb29rcyhwcmV2aW91c09yUGFyZW50VE5vZGUuZmxhZ3MsIHRWaWV3KTtcbn1cbi8qKlxuICogQ3JlYXRlIERPTSBlbGVtZW50LiBUaGUgaW5zdHJ1Y3Rpb24gbXVzdCBsYXRlciBiZSBmb2xsb3dlZCBieSBgZWxlbWVudEVuZCgpYCBjYWxsLlxuICpcbiAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTFZpZXdEYXRhIGFycmF5XG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBET00gTm9kZVxuICogQHBhcmFtIGF0dHJzIFN0YXRpY2FsbHkgYm91bmQgc2V0IG9mIGF0dHJpYnV0ZXMgdG8gYmUgd3JpdHRlbiBpbnRvIHRoZSBET00gZWxlbWVudCBvbiBjcmVhdGlvbi5cbiAqIEBwYXJhbSBsb2NhbFJlZnMgQSBzZXQgb2YgbG9jYWwgcmVmZXJlbmNlIGJpbmRpbmdzIG9uIHRoZSBlbGVtZW50LlxuICpcbiAqIEF0dHJpYnV0ZXMgYW5kIGxvY2FsUmVmcyBhcmUgcGFzc2VkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3Mgd2hlcmUgZWxlbWVudHMgd2l0aCBhbiBldmVuIGluZGV4XG4gKiBob2xkIGFuIGF0dHJpYnV0ZSBuYW1lIGFuZCBlbGVtZW50cyB3aXRoIGFuIG9kZCBpbmRleCBob2xkIGFuIGF0dHJpYnV0ZSB2YWx1ZSwgZXguOlxuICogWydpZCcsICd3YXJuaW5nNScsICdjbGFzcycsICdhbGVydCddXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRTdGFydChpbmRleCwgbmFtZSwgYXR0cnMsIGxvY2FsUmVmcykge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdFZpZXcuYmluZGluZ1N0YXJ0SW5kZXgsICdlbGVtZW50cyBzaG91bGQgYmUgY3JlYXRlZCBiZWZvcmUgYW55IGJpbmRpbmdzICcpO1xuICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJDcmVhdGVFbGVtZW50Kys7XG4gICAgdmFyIG5hdGl2ZSA9IGVsZW1lbnRDcmVhdGUobmFtZSk7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERhdGFJblJhbmdlKGluZGV4IC0gMSk7XG4gICAgdmFyIHROb2RlID0gY3JlYXRlTm9kZUF0SW5kZXgoaW5kZXgsIDMgLyogRWxlbWVudCAqLywgbmF0aXZlLCBuYW1lLCBhdHRycyB8fCBudWxsKTtcbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgc2V0VXBBdHRyaWJ1dGVzKG5hdGl2ZSwgYXR0cnMpO1xuICAgIH1cbiAgICBhcHBlbmRDaGlsZChuYXRpdmUsIHROb2RlLCB2aWV3RGF0YSk7XG4gICAgY3JlYXRlRGlyZWN0aXZlc0FuZExvY2Fscyhsb2NhbFJlZnMpO1xuICAgIC8vIGFueSBpbW1lZGlhdGUgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgb3IgdGVtcGxhdGUgY29udGFpbmVyIG11c3QgYmUgcHJlLWVtcHRpdmVseVxuICAgIC8vIG1vbmtleS1wYXRjaGVkIHdpdGggdGhlIGNvbXBvbmVudCB2aWV3IGRhdGEgc28gdGhhdCB0aGUgZWxlbWVudCBjYW4gYmUgaW5zcGVjdGVkXG4gICAgLy8gbGF0ZXIgb24gdXNpbmcgYW55IGVsZW1lbnQgZGlzY292ZXJ5IHV0aWxpdHkgbWV0aG9kcyAoc2VlIGBlbGVtZW50X2Rpc2NvdmVyeS50c2ApXG4gICAgaWYgKGVsZW1lbnREZXB0aENvdW50ID09PSAwKSB7XG4gICAgICAgIGF0dGFjaFBhdGNoRGF0YShuYXRpdmUsIHZpZXdEYXRhKTtcbiAgICB9XG4gICAgZWxlbWVudERlcHRoQ291bnQrKztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5hdGl2ZSBlbGVtZW50IGZyb20gYSB0YWcgbmFtZSwgdXNpbmcgYSByZW5kZXJlci5cbiAqIEBwYXJhbSBuYW1lIHRoZSB0YWcgbmFtZVxuICogQHBhcmFtIG92ZXJyaWRkZW5SZW5kZXJlciBPcHRpb25hbCBBIHJlbmRlcmVyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9uZVxuICogQHJldHVybnMgdGhlIGVsZW1lbnQgY3JlYXRlZFxuICovXG5mdW5jdGlvbiBlbGVtZW50Q3JlYXRlKG5hbWUsIG92ZXJyaWRkZW5SZW5kZXJlcikge1xuICAgIHZhciBuYXRpdmU7XG4gICAgdmFyIHJlbmRlcmVyVG9Vc2UgPSBvdmVycmlkZGVuUmVuZGVyZXIgfHwgcmVuZGVyZXI7XG4gICAgaWYgKGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyVG9Vc2UpKSB7XG4gICAgICAgIG5hdGl2ZSA9IHJlbmRlcmVyVG9Vc2UuY3JlYXRlRWxlbWVudChuYW1lLCBfY3VycmVudE5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoX2N1cnJlbnROYW1lc3BhY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IHJlbmRlcmVyVG9Vc2UuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IHJlbmRlcmVyVG9Vc2UuY3JlYXRlRWxlbWVudE5TKF9jdXJyZW50TmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGRpcmVjdGl2ZSBpbnN0YW5jZXMgYW5kIHBvcHVsYXRlcyBsb2NhbCByZWZzLlxuICpcbiAqIEBwYXJhbSBsb2NhbFJlZnMgTG9jYWwgcmVmcyBvZiB0aGUgbm9kZSBpbiBxdWVzdGlvblxuICogQHBhcmFtIGxvY2FsUmVmRXh0cmFjdG9yIG1hcHBpbmcgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyBsb2NhbCByZWYgdmFsdWUgZnJvbSBUTm9kZVxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVzQW5kTG9jYWxzKGxvY2FsUmVmcywgbG9jYWxSZWZFeHRyYWN0b3IpIHtcbiAgICBpZiAobG9jYWxSZWZFeHRyYWN0b3IgPT09IHZvaWQgMCkgeyBsb2NhbFJlZkV4dHJhY3RvciA9IGdldE5hdGl2ZUJ5VE5vZGU7IH1cbiAgICBpZiAoIWJpbmRpbmdzRW5hYmxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgbmdEZXZNb2RlLmZpcnN0VGVtcGxhdGVQYXNzKys7XG4gICAgICAgIGNhY2hlTWF0Y2hpbmdEaXJlY3RpdmVzRm9yTm9kZShwcmV2aW91c09yUGFyZW50VE5vZGUsIHRWaWV3LCBsb2NhbFJlZnMgfHwgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnN0YW50aWF0ZURpcmVjdGl2ZXNEaXJlY3RseSgpO1xuICAgIH1cbiAgICBzYXZlUmVzb2x2ZWRMb2NhbHNJbkRhdGEobG9jYWxSZWZFeHRyYWN0b3IpO1xufVxuLyoqXG4gKiBPbiBmaXJzdCB0ZW1wbGF0ZSBwYXNzLCB3ZSBtYXRjaCBlYWNoIG5vZGUgYWdhaW5zdCBhdmFpbGFibGUgZGlyZWN0aXZlIHNlbGVjdG9ycyBhbmQgc2F2ZVxuICogdGhlIHJlc3VsdGluZyBkZWZzIGluIHRoZSBjb3JyZWN0IGluc3RhbnRpYXRpb24gb3JkZXIgZm9yIHN1YnNlcXVlbnQgY2hhbmdlIGRldGVjdGlvbiBydW5zXG4gKiAoc28gZGVwZW5kZW5jaWVzIGFyZSBhbHdheXMgY3JlYXRlZCBiZWZvcmUgdGhlIGRpcmVjdGl2ZXMgdGhhdCBpbmplY3QgdGhlbSkuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlTWF0Y2hpbmdEaXJlY3RpdmVzRm9yTm9kZSh0Tm9kZSwgdFZpZXcsIGxvY2FsUmVmcykge1xuICAgIC8vIFBsZWFzZSBtYWtlIHN1cmUgdG8gaGF2ZSBleHBsaWNpdCB0eXBlIGZvciBgZXhwb3J0c01hcGAuIEluZmVycmVkIHR5cGUgdHJpZ2dlcnMgYnVnIGluIHRzaWNrbGUuXG4gICAgdmFyIGV4cG9ydHNNYXAgPSBsb2NhbFJlZnMgPyB7ICcnOiAtMSB9IDogbnVsbDtcbiAgICB2YXIgbWF0Y2hlcyA9IHRWaWV3LmN1cnJlbnRNYXRjaGVzID0gZmluZERpcmVjdGl2ZU1hdGNoZXModE5vZGUpO1xuICAgIGdlbmVyYXRlRXhwYW5kb0Jsb2NrKHROb2RlLCBtYXRjaGVzKTtcbiAgICB2YXIgdG90YWxIb3N0VmFycyA9IDA7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICByZXNvbHZlRGlyZWN0aXZlKGRlZiwgdmFsdWVJbmRleCwgbWF0Y2hlcyk7XG4gICAgICAgICAgICB0b3RhbEhvc3RWYXJzICs9IGRlZi5ob3N0VmFycztcbiAgICAgICAgICAgIHNhdmVOYW1lVG9FeHBvcnRNYXAobWF0Y2hlc1t2YWx1ZUluZGV4XSwgZGVmLCBleHBvcnRzTWFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwb3J0c01hcClcbiAgICAgICAgY2FjaGVNYXRjaGluZ0xvY2FsTmFtZXModE5vZGUsIGxvY2FsUmVmcywgZXhwb3J0c01hcCk7XG4gICAgcHJlZmlsbEhvc3RWYXJzKHRvdGFsSG9zdFZhcnMpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBuZXcgYmxvY2sgaW4gVFZpZXcuZXhwYW5kb0luc3RydWN0aW9ucyBmb3IgdGhpcyBub2RlLlxuICpcbiAqIEVhY2ggZXhwYW5kbyBibG9jayBzdGFydHMgd2l0aCB0aGUgZWxlbWVudCBpbmRleCAodHVybmVkIG5lZ2F0aXZlIHNvIHdlIGNhbiBkaXN0aW5ndWlzaFxuICogaXQgZnJvbSB0aGUgaG9zdFZhciBjb3VudCkgYW5kIHRoZSBkaXJlY3RpdmUgY291bnQuIFNlZSBtb3JlIGluIFZJRVdfREFUQS5tZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVFeHBhbmRvQmxvY2sodE5vZGUsIG1hdGNoZXMpIHtcbiAgICB2YXIgZGlyZWN0aXZlQ291bnQgPSBtYXRjaGVzID8gbWF0Y2hlcy5sZW5ndGggLyAyIDogMDtcbiAgICB2YXIgZWxlbWVudEluZGV4ID0gLSh0Tm9kZS5pbmRleCAtIEhFQURFUl9PRkZTRVQpO1xuICAgIGlmIChkaXJlY3RpdmVDb3VudCA+IDApIHtcbiAgICAgICAgKHRWaWV3LmV4cGFuZG9JbnN0cnVjdGlvbnMgfHwgKHRWaWV3LmV4cGFuZG9JbnN0cnVjdGlvbnMgPSBbXSkpLnB1c2goZWxlbWVudEluZGV4LCBkaXJlY3RpdmVDb3VudCk7XG4gICAgfVxufVxuLyoqXG4gKiBPbiB0aGUgZmlyc3QgdGVtcGxhdGUgcGFzcywgd2UgbmVlZCB0byByZXNlcnZlIHNwYWNlIGZvciBob3N0IGJpbmRpbmcgdmFsdWVzXG4gKiBhZnRlciBkaXJlY3RpdmVzIGFyZSBtYXRjaGVkIChzbyBhbGwgZGlyZWN0aXZlcyBhcmUgc2F2ZWQsIHRoZW4gYmluZGluZ3MpLlxuICogQmVjYXVzZSB3ZSBhcmUgdXBkYXRpbmcgdGhlIGJsdWVwcmludCwgd2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgb25jZS5cbiAqL1xuZnVuY3Rpb24gcHJlZmlsbEhvc3RWYXJzKHRvdGFsSG9zdFZhcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsSG9zdFZhcnM7IGkrKykge1xuICAgICAgICB2aWV3RGF0YS5wdXNoKE5PX0NIQU5HRSk7XG4gICAgICAgIHRWaWV3LmJsdWVwcmludC5wdXNoKE5PX0NIQU5HRSk7XG4gICAgICAgIHRWaWV3LmRhdGEucHVzaChudWxsKTtcbiAgICB9XG59XG4vKiogTWF0Y2hlcyB0aGUgY3VycmVudCBub2RlIGFnYWluc3QgYWxsIGF2YWlsYWJsZSBzZWxlY3RvcnMuICovXG5mdW5jdGlvbiBmaW5kRGlyZWN0aXZlTWF0Y2hlcyh0Tm9kZSkge1xuICAgIHZhciByZWdpc3RyeSA9IHRWaWV3LmRpcmVjdGl2ZVJlZ2lzdHJ5O1xuICAgIHZhciBtYXRjaGVzID0gbnVsbDtcbiAgICBpZiAocmVnaXN0cnkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHJlZ2lzdHJ5W2ldO1xuICAgICAgICAgICAgaWYgKGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JMaXN0KHROb2RlLCBkZWYuc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgfHwgKG1hdGNoZXMgPSBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5kaVB1YmxpYylcbiAgICAgICAgICAgICAgICAgICAgZGVmLmRpUHVibGljKGRlZik7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodE5vZGUuZmxhZ3MgJiA0MDk2IC8qIGlzQ29tcG9uZW50ICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dNdWx0aXBsZUNvbXBvbmVudEVycm9yKHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29tcG9uZW50TG9naWMoZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNvbXBvbmVudCBpcyBhbHdheXMgc3RvcmVkIGZpcnN0IHdpdGggZGlyZWN0aXZlcyBhZnRlci5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy51bnNoaWZ0KGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZGVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKGRlZiwgdmFsdWVJbmRleCwgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaGVzW3ZhbHVlSW5kZXhdID09PSBudWxsKSB7XG4gICAgICAgIG1hdGNoZXNbdmFsdWVJbmRleF0gPSBDSVJDVUxBUiQxO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBkZWYuZmFjdG9yeSgpO1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlQ3JlYXRlKG1hdGNoZXNbdmFsdWVJbmRleF0gPSB2aWV3RGF0YS5sZW5ndGgsIGluc3RhbmNlLCBkZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXRjaGVzW3ZhbHVlSW5kZXhdID09PSBDSVJDVUxBUiQxKSB7XG4gICAgICAgIC8vIElmIHdlIHJldmlzaXQgdGhpcyBkaXJlY3RpdmUgYmVmb3JlIGl0J3MgcmVzb2x2ZWQsIHdlIGtub3cgaXQncyBjaXJjdWxhclxuICAgICAgICB0aHJvd0N5Y2xpY0RlcGVuZGVuY3lFcnJvcihkZWYudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqIFN0b3JlcyBpbmRleCBvZiBjb21wb25lbnQncyBob3N0IGVsZW1lbnQgc28gaXQgd2lsbCBiZSBxdWV1ZWQgZm9yIHZpZXcgcmVmcmVzaCBkdXJpbmcgQ0QuICovXG5mdW5jdGlvbiBxdWV1ZUNvbXBvbmVudEluZGV4Rm9yQ2hlY2soKSB7XG4gICAgaWYgKGZpcnN0VGVtcGxhdGVQYXNzKSB7XG4gICAgICAgICh0Vmlldy5jb21wb25lbnRzIHx8ICh0Vmlldy5jb21wb25lbnRzID0gW10pKS5wdXNoKHByZXZpb3VzT3JQYXJlbnRUTm9kZS5pbmRleCk7XG4gICAgfVxufVxuLyoqIFN0b3JlcyBpbmRleCBvZiBkaXJlY3RpdmUgYW5kIGhvc3QgZWxlbWVudCBzbyBpdCB3aWxsIGJlIHF1ZXVlZCBmb3IgYmluZGluZyByZWZyZXNoIGR1cmluZyBDRC5cbiAqL1xuZnVuY3Rpb24gcXVldWVIb3N0QmluZGluZ0ZvckNoZWNrKGRpckluZGV4LCBkZWYpIHtcbiAgICBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYXNzZXJ0RXF1YWwoZmlyc3RUZW1wbGF0ZVBhc3MsIHRydWUsICdTaG91bGQgb25seSBiZSBjYWxsZWQgaW4gZmlyc3QgdGVtcGxhdGUgcGFzcy4nKTtcbiAgICB0Vmlldy5leHBhbmRvSW5zdHJ1Y3Rpb25zLnB1c2goZGVmLmhvc3RCaW5kaW5ncywgZGVmLmhvc3RWYXJzKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbnN0YW50aWF0ZXMgdGhlIGdpdmVuIGRpcmVjdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlRGlyZWN0aXZlc0RpcmVjdGx5KCkge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbChmaXJzdFRlbXBsYXRlUGFzcywgZmFsc2UsIFwiRGlyZWN0aXZlcyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkgYWZ0ZXIgZmlyc3QgdGVtcGxhdGUgcGFzc1wiKTtcbiAgICB2YXIgY291bnQgPSBwcmV2aW91c09yUGFyZW50VE5vZGUuZmxhZ3MgJiA0MDk1IC8qIERpcmVjdGl2ZUNvdW50TWFzayAqLztcbiAgICBpZiAoaXNDb250ZW50UXVlcnlIb3N0KHByZXZpb3VzT3JQYXJlbnRUTm9kZSkgJiYgY3VycmVudFF1ZXJpZXMpIHtcbiAgICAgICAgY3VycmVudFF1ZXJpZXMgPSBjdXJyZW50UXVlcmllcy5jbG9uZSgpO1xuICAgIH1cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByZXZpb3VzT3JQYXJlbnRUTm9kZS5mbGFncyA+PiAxNSAvKiBEaXJlY3RpdmVTdGFydGluZ0luZGV4U2hpZnQgKi87XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRWaWV3LmRhdGFbaV07XG4gICAgICAgICAgICAvLyBDb21wb25lbnQgdmlldyBtdXN0IGJlIHNldCBvbiBub2RlIGJlZm9yZSB0aGUgZmFjdG9yeSBpcyBjcmVhdGVkIHNvXG4gICAgICAgICAgICAvLyBDaGFuZ2VEZXRlY3RvclJlZnMgaGF2ZSBhIHdheSB0byBzdG9yZSBjb21wb25lbnQgdmlldyBvbiBjcmVhdGlvbi5cbiAgICAgICAgICAgIGlmIChkZWYudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBhZGRDb21wb25lbnRMb2dpYyhkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlQ3JlYXRlKGksIGRlZi5mYWN0b3J5KCksIGRlZik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQ2FjaGVzIGxvY2FsIG5hbWVzIGFuZCB0aGVpciBtYXRjaGluZyBkaXJlY3RpdmUgaW5kaWNlcyBmb3IgcXVlcnkgYW5kIHRlbXBsYXRlIGxvb2t1cHMuICovXG5mdW5jdGlvbiBjYWNoZU1hdGNoaW5nTG9jYWxOYW1lcyh0Tm9kZSwgbG9jYWxSZWZzLCBleHBvcnRzTWFwKSB7XG4gICAgaWYgKGxvY2FsUmVmcykge1xuICAgICAgICB2YXIgbG9jYWxOYW1lcyA9IHROb2RlLmxvY2FsTmFtZXMgPSBbXTtcbiAgICAgICAgLy8gTG9jYWwgbmFtZXMgbXVzdCBiZSBzdG9yZWQgaW4gdE5vZGUgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCBsb2NhbFJlZnMgYXJlIGRlZmluZWRcbiAgICAgICAgLy8gaW4gdGhlIHRlbXBsYXRlIHRvIGVuc3VyZSB0aGUgZGF0YSBpcyBsb2FkZWQgaW4gdGhlIHNhbWUgc2xvdHMgYXMgdGhlaXIgcmVmc1xuICAgICAgICAvLyBpbiB0aGUgdGVtcGxhdGUgKGZvciB0ZW1wbGF0ZSBxdWVyaWVzKS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbFJlZnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGV4cG9ydHNNYXBbbG9jYWxSZWZzW2kgKyAxXV07XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBvcnQgb2YgbmFtZSAnXCIgKyBsb2NhbFJlZnNbaSArIDFdICsgXCInIG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICBsb2NhbE5hbWVzLnB1c2gobG9jYWxSZWZzW2ldLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEJ1aWxkcyB1cCBhbiBleHBvcnQgbWFwIGFzIGRpcmVjdGl2ZXMgYXJlIGNyZWF0ZWQsIHNvIGxvY2FsIHJlZnMgY2FuIGJlIHF1aWNrbHkgbWFwcGVkXG4gKiB0byB0aGVpciBkaXJlY3RpdmUgaW5zdGFuY2VzLlxuICovXG5mdW5jdGlvbiBzYXZlTmFtZVRvRXhwb3J0TWFwKGluZGV4LCBkZWYsIGV4cG9ydHNNYXApIHtcbiAgICBpZiAoZXhwb3J0c01hcCkge1xuICAgICAgICBpZiAoZGVmLmV4cG9ydEFzKVxuICAgICAgICAgICAgZXhwb3J0c01hcFtkZWYuZXhwb3J0QXNdID0gaW5kZXg7XG4gICAgICAgIGlmIChkZWYudGVtcGxhdGUpXG4gICAgICAgICAgICBleHBvcnRzTWFwWycnXSA9IGluZGV4O1xuICAgIH1cbn1cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIGxvY2FsIG5hbWVzIGFuZCBpbmRpY2VzIGFuZCBwdXNoZXMgdGhlIHJlc29sdmVkIGxvY2FsIHZhcmlhYmxlIHZhbHVlc1xuICogdG8gTFZpZXdEYXRhIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgYXJlIGxvYWRlZCBpbiB0aGUgdGVtcGxhdGUgd2l0aCBsb2FkKCkuXG4gKi9cbmZ1bmN0aW9uIHNhdmVSZXNvbHZlZExvY2Fsc0luRGF0YShsb2NhbFJlZkV4dHJhY3Rvcikge1xuICAgIHZhciBsb2NhbE5hbWVzID0gcHJldmlvdXNPclBhcmVudFROb2RlLmxvY2FsTmFtZXM7XG4gICAgdmFyIHROb2RlID0gcHJldmlvdXNPclBhcmVudFROb2RlO1xuICAgIGlmIChsb2NhbE5hbWVzKSB7XG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gcHJldmlvdXNPclBhcmVudFROb2RlLmluZGV4ICsgMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhbE5hbWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsb2NhbE5hbWVzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4ID09PSAtMSA/IGxvY2FsUmVmRXh0cmFjdG9yKHROb2RlLCB2aWV3RGF0YSkgOiB2aWV3RGF0YVtpbmRleF07XG4gICAgICAgICAgICB2aWV3RGF0YVtsb2NhbEluZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdldHMgVFZpZXcgZnJvbSBhIHRlbXBsYXRlIGZ1bmN0aW9uIG9yIGNyZWF0ZXMgYSBuZXcgVFZpZXdcbiAqIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGVGbiBUaGUgdGVtcGxhdGUgZnJvbSB3aGljaCB0byBnZXQgc3RhdGljIGRhdGFcbiAqIEBwYXJhbSBjb25zdHMgVGhlIG51bWJlciBvZiBub2RlcywgbG9jYWwgcmVmcywgYW5kIHBpcGVzIGluIHRoaXMgdmlld1xuICogQHBhcmFtIHZhcnMgVGhlIG51bWJlciBvZiBiaW5kaW5ncyBhbmQgcHVyZSBmdW5jdGlvbiBiaW5kaW5ncyBpbiB0aGlzIHZpZXdcbiAqIEBwYXJhbSBkaXJlY3RpdmVzIERpcmVjdGl2ZSBkZWZzIHRoYXQgc2hvdWxkIGJlIHNhdmVkIG9uIFRWaWV3XG4gKiBAcGFyYW0gcGlwZXMgUGlwZSBkZWZzIHRoYXQgc2hvdWxkIGJlIHNhdmVkIG9uIFRWaWV3XG4gKiBAcmV0dXJucyBUVmlld1xuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVRWaWV3KHRlbXBsYXRlRm4sIGNvbnN0cywgdmFycywgZGlyZWN0aXZlcywgcGlwZXMsIHZpZXdRdWVyeSkge1xuICAgIC8vIFRPRE8obWlza28pOiByZWFkaW5nIGBuZ1ByaXZhdGVEYXRhYCBoZXJlIGlzIHByb2JsZW1hdGljIGZvciB0d28gcmVhc29uc1xuICAgIC8vIDEuIEl0IGlzIGEgbWVnYW1vcnBoaWMgY2FsbCBvbiBlYWNoIGludm9jYXRpb24uXG4gICAgLy8gMi4gRm9yIG5lc3RlZCBlbWJlZGRlZCB2aWV3cyAobmdGb3IgaW5zaWRlIG5nRm9yKSB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgaXMgcGVyXG4gICAgLy8gICAgb3V0ZXIgdGVtcGxhdGUgaW52b2NhdGlvbiwgd2hpY2ggbWVhbnMgdGhhdCBubyBzdWNoIHByb3BlcnR5IHdpbGwgZXhpc3RcbiAgICAvLyBDb3JyZWN0IHNvbHV0aW9uIGlzIHRvIG9ubHkgcHV0IGBuZ1ByaXZhdGVEYXRhYCBvbiB0aGUgQ29tcG9uZW50IHRlbXBsYXRlXG4gICAgLy8gYW5kIG5vdCBvbiBlbWJlZGRlZCB0ZW1wbGF0ZXMuXG4gICAgcmV0dXJuIHRlbXBsYXRlRm4ubmdQcml2YXRlRGF0YSB8fFxuICAgICAgICAodGVtcGxhdGVGbi5uZ1ByaXZhdGVEYXRhID1cbiAgICAgICAgICAgIGNyZWF0ZVRWaWV3KC0xLCB0ZW1wbGF0ZUZuLCBjb25zdHMsIHZhcnMsIGRpcmVjdGl2ZXMsIHBpcGVzLCB2aWV3UXVlcnkpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFRWaWV3IGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHZpZXdJbmRleCBUaGUgdmlld0Jsb2NrSWQgZm9yIGlubGluZSB2aWV3cywgb3IgLTEgaWYgaXQncyBhIGNvbXBvbmVudC9keW5hbWljXG4gKiBAcGFyYW0gdGVtcGxhdGVGbiBUZW1wbGF0ZSBmdW5jdGlvblxuICogQHBhcmFtIGNvbnN0cyBUaGUgbnVtYmVyIG9mIG5vZGVzLCBsb2NhbCByZWZzLCBhbmQgcGlwZXMgaW4gdGhpcyB0ZW1wbGF0ZVxuICogQHBhcmFtIGRpcmVjdGl2ZXMgUmVnaXN0cnkgb2YgZGlyZWN0aXZlcyBmb3IgdGhpcyB2aWV3XG4gKiBAcGFyYW0gcGlwZXMgUmVnaXN0cnkgb2YgcGlwZXMgZm9yIHRoaXMgdmlld1xuICovXG5mdW5jdGlvbiBjcmVhdGVUVmlldyh2aWV3SW5kZXgsIHRlbXBsYXRlRm4sIGNvbnN0cywgdmFycywgZGlyZWN0aXZlcywgcGlwZXMsIHZpZXdRdWVyeSkge1xuICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUudFZpZXcrKztcbiAgICB2YXIgYmluZGluZ1N0YXJ0SW5kZXggPSBIRUFERVJfT0ZGU0VUICsgY29uc3RzO1xuICAgIC8vIFRoaXMgbGVuZ3RoIGRvZXMgbm90IHlldCBjb250YWluIGhvc3QgYmluZGluZ3MgZnJvbSBjaGlsZCBkaXJlY3RpdmVzIGJlY2F1c2UgYXQgdGhpcyBwb2ludCxcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIGRpcmVjdGl2ZXMgYXJlIGFjdGl2ZSBvbiB0aGlzIHRlbXBsYXRlLiBBcyBzb29uIGFzIGEgZGlyZWN0aXZlIGlzIG1hdGNoZWRcbiAgICAvLyB0aGF0IGhhcyBhIGhvc3QgYmluZGluZywgd2Ugd2lsbCB1cGRhdGUgdGhlIGJsdWVwcmludCB3aXRoIHRoYXQgZGVmJ3MgaG9zdFZhcnMgY291bnQuXG4gICAgdmFyIGluaXRpYWxWaWV3TGVuZ3RoID0gYmluZGluZ1N0YXJ0SW5kZXggKyB2YXJzO1xuICAgIHZhciBibHVlcHJpbnQgPSBjcmVhdGVWaWV3Qmx1ZXByaW50KGJpbmRpbmdTdGFydEluZGV4LCBpbml0aWFsVmlld0xlbmd0aCk7XG4gICAgcmV0dXJuIGJsdWVwcmludFtUVklFV10gPSB7XG4gICAgICAgIGlkOiB2aWV3SW5kZXgsXG4gICAgICAgIGJsdWVwcmludDogYmx1ZXByaW50LFxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVGbixcbiAgICAgICAgdmlld1F1ZXJ5OiB2aWV3UXVlcnksXG4gICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgIGRhdGE6IGJsdWVwcmludC5zbGljZSgpLFxuICAgICAgICBjaGlsZEluZGV4OiAtMSxcbiAgICAgICAgYmluZGluZ1N0YXJ0SW5kZXg6IGJpbmRpbmdTdGFydEluZGV4LFxuICAgICAgICBleHBhbmRvU3RhcnRJbmRleDogaW5pdGlhbFZpZXdMZW5ndGgsXG4gICAgICAgIGV4cGFuZG9JbnN0cnVjdGlvbnM6IG51bGwsXG4gICAgICAgIGZpcnN0VGVtcGxhdGVQYXNzOiB0cnVlLFxuICAgICAgICBpbml0SG9va3M6IG51bGwsXG4gICAgICAgIGNoZWNrSG9va3M6IG51bGwsXG4gICAgICAgIGNvbnRlbnRIb29rczogbnVsbCxcbiAgICAgICAgY29udGVudENoZWNrSG9va3M6IG51bGwsXG4gICAgICAgIHZpZXdIb29rczogbnVsbCxcbiAgICAgICAgdmlld0NoZWNrSG9va3M6IG51bGwsXG4gICAgICAgIGRlc3Ryb3lIb29rczogbnVsbCxcbiAgICAgICAgcGlwZURlc3Ryb3lIb29rczogbnVsbCxcbiAgICAgICAgY2xlYW51cDogbnVsbCxcbiAgICAgICAgY29udGVudFF1ZXJpZXM6IG51bGwsXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgICAgIGRpcmVjdGl2ZVJlZ2lzdHJ5OiB0eXBlb2YgZGlyZWN0aXZlcyA9PT0gJ2Z1bmN0aW9uJyA/IGRpcmVjdGl2ZXMoKSA6IGRpcmVjdGl2ZXMsXG4gICAgICAgIHBpcGVSZWdpc3RyeTogdHlwZW9mIHBpcGVzID09PSAnZnVuY3Rpb24nID8gcGlwZXMoKSA6IHBpcGVzLFxuICAgICAgICBjdXJyZW50TWF0Y2hlczogbnVsbCxcbiAgICAgICAgZmlyc3RDaGlsZDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlld0JsdWVwcmludChiaW5kaW5nU3RhcnRJbmRleCwgaW5pdGlhbFZpZXdMZW5ndGgpIHtcbiAgICB2YXIgYmx1ZXByaW50ID0gbmV3IEFycmF5KGluaXRpYWxWaWV3TGVuZ3RoKVxuICAgICAgICAuZmlsbChudWxsLCAwLCBiaW5kaW5nU3RhcnRJbmRleClcbiAgICAgICAgLmZpbGwoTk9fQ0hBTkdFLCBiaW5kaW5nU3RhcnRJbmRleCk7XG4gICAgYmx1ZXByaW50W0NPTlRBSU5FUl9JTkRFWF0gPSAtMTtcbiAgICBibHVlcHJpbnRbQklORElOR19JTkRFWF0gPSBiaW5kaW5nU3RhcnRJbmRleDtcbiAgICByZXR1cm4gYmx1ZXByaW50O1xufVxuZnVuY3Rpb24gc2V0VXBBdHRyaWJ1dGVzKG5hdGl2ZSwgYXR0cnMpIHtcbiAgICB2YXIgaXNQcm9jID0gaXNQcm9jZWR1cmFsUmVuZGVyZXIocmVuZGVyZXIpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGF0dHJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgaWYgKGF0dHJOYW1lID09PSAxIC8qIFNlbGVjdE9ubHkgKi8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGF0dHJOYW1lID09PSBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSkge1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlclNldEF0dHJpYnV0ZSsrO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAwIC8qIE5hbWVzcGFjZVVSSSAqLykge1xuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2VVUkkgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lXzEgPSBhdHRyc1tpICsgMl07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWwgPSBhdHRyc1tpICsgM107XG4gICAgICAgICAgICAgICAgaXNQcm9jID9cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRBdHRyaWJ1dGUobmF0aXZlLCBhdHRyTmFtZV8xLCBhdHRyVmFsLCBuYW1lc3BhY2VVUkkpIDpcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgYXR0ck5hbWVfMSwgYXR0clZhbCk7XG4gICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlzUHJvYyA/XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0QXR0cmlidXRlKG5hdGl2ZSwgYXR0ck5hbWUsIGF0dHJWYWwpIDpcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbCk7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3IodGV4dCwgdG9rZW4pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiUmVuZGVyZXI6IFwiICsgdGV4dCArIFwiIFtcIiArIHN0cmluZ2lmeSQxKHRva2VuKSArIFwiXVwiKTtcbn1cbi8qKlxuICogTG9jYXRlcyB0aGUgaG9zdCBuYXRpdmUgZWxlbWVudCwgdXNlZCBmb3IgYm9vdHN0cmFwcGluZyBleGlzdGluZyBub2RlcyBpbnRvIHJlbmRlcmluZyBwaXBlbGluZS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudE9yU2VsZWN0b3IgUmVuZGVyIGVsZW1lbnQgb3IgQ1NTIHNlbGVjdG9yIHRvIGxvY2F0ZSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gbG9jYXRlSG9zdEVsZW1lbnQoZmFjdG9yeSwgZWxlbWVudE9yU2VsZWN0b3IpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGF0YUluUmFuZ2UoLTEpO1xuICAgIHJlbmRlcmVyRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgdmFyIGRlZmF1bHRSZW5kZXJlciA9IGZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XG4gICAgdmFyIHJOb2RlID0gdHlwZW9mIGVsZW1lbnRPclNlbGVjdG9yID09PSAnc3RyaW5nJyA/XG4gICAgICAgIChpc1Byb2NlZHVyYWxSZW5kZXJlcihkZWZhdWx0UmVuZGVyZXIpID9cbiAgICAgICAgICAgIGRlZmF1bHRSZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChlbGVtZW50T3JTZWxlY3RvcikgOlxuICAgICAgICAgICAgZGVmYXVsdFJlbmRlcmVyLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudE9yU2VsZWN0b3IpKSA6XG4gICAgICAgIGVsZW1lbnRPclNlbGVjdG9yO1xuICAgIGlmIChuZ0Rldk1vZGUgJiYgIXJOb2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudE9yU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcignSG9zdCBub2RlIHdpdGggc2VsZWN0b3Igbm90IGZvdW5kOicsIGVsZW1lbnRPclNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdIb3N0IG5vZGUgaXMgcmVxdWlyZWQ6JywgZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByTm9kZTtcbn1cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIElmIGFuIG91dHB1dCBleGlzdHMgb24gb25lIG9mIHRoZSBub2RlJ3MgZGlyZWN0aXZlcywgaXQgYWxzbyBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAqIGFuZCBzYXZlcyB0aGUgc3Vic2NyaXB0aW9uIGZvciBsYXRlciBjbGVhbnVwLlxuICpcbiAqIEBwYXJhbSBldmVudE5hbWUgTmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSBsaXN0ZW5lckZuIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBldmVudCBlbWl0c1xuICogQHBhcmFtIHVzZUNhcHR1cmUgV2hldGhlciBvciBub3QgdG8gdXNlIGNhcHR1cmUgaW4gZXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSkge1xuICAgIGlmICh1c2VDYXB0dXJlID09PSB2b2lkIDApIHsgdXNlQ2FwdHVyZSA9IGZhbHNlOyB9XG4gICAgdmFyIHROb2RlID0gcHJldmlvdXNPclBhcmVudFROb2RlO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlT2ZQb3NzaWJsZVR5cGVzKHROb2RlLCAzIC8qIEVsZW1lbnQgKi8sIDAgLyogQ29udGFpbmVyICovLCA0IC8qIEVsZW1lbnRDb250YWluZXIgKi8pO1xuICAgIC8vIGFkZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXIgLSBhcHBsaWNhYmxlIHRvIGVsZW1lbnRzIG9ubHlcbiAgICBpZiAodE5vZGUudHlwZSA9PT0gMyAvKiBFbGVtZW50ICovKSB7XG4gICAgICAgIHZhciBuYXRpdmUgPSBnZXROYXRpdmVCeVROb2RlKHByZXZpb3VzT3JQYXJlbnRUTm9kZSwgdmlld0RhdGEpO1xuICAgICAgICBuZ0Rldk1vZGUgJiYgbmdEZXZNb2RlLnJlbmRlcmVyQWRkRXZlbnRMaXN0ZW5lcisrO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBtYXRjaCBjdXJyZW50IGJlaGF2aW9yLCBuYXRpdmUgRE9NIGV2ZW50IGxpc3RlbmVycyBtdXN0IGJlIGFkZGVkIGZvciBhbGxcbiAgICAgICAgLy8gZXZlbnRzIChpbmNsdWRpbmcgb3V0cHV0cykuXG4gICAgICAgIGlmIChpc1Byb2NlZHVyYWxSZW5kZXJlcihyZW5kZXJlcikpIHtcbiAgICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSByZW5kZXJlci5saXN0ZW4obmF0aXZlLCBldmVudE5hbWUsIGxpc3RlbmVyRm4pO1xuICAgICAgICAgICAgc3RvcmVDbGVhbnVwRm4odmlld0RhdGEsIGNsZWFudXBGbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gd3JhcExpc3RlbmVyV2l0aFByZXZlbnREZWZhdWx0KGxpc3RlbmVyRm4pO1xuICAgICAgICAgICAgbmF0aXZlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB3cmFwcGVkTGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgdmFyIGNsZWFudXBJbnN0YW5jZXMgPSBnZXRDbGVhbnVwKHZpZXdEYXRhKTtcbiAgICAgICAgICAgIGNsZWFudXBJbnN0YW5jZXMucHVzaCh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGZpcnN0VGVtcGxhdGVQYXNzKSB7XG4gICAgICAgICAgICAgICAgZ2V0VFZpZXdDbGVhbnVwKHZpZXdEYXRhKS5wdXNoKGV2ZW50TmFtZSwgdE5vZGUuaW5kZXgsIGNsZWFudXBJbnN0YW5jZXMubGVuZ3RoIC0gMSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3Vic2NyaWJlIHRvIGRpcmVjdGl2ZSBvdXRwdXRzXG4gICAgaWYgKHROb2RlLm91dHB1dHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB3ZSBjcmVhdGUgVE5vZGUgaGVyZSwgaW5wdXRzIG11c3QgYmUgdW5kZWZpbmVkIHNvIHdlIGtub3cgdGhleSBzdGlsbCBuZWVkIHRvIGJlXG4gICAgICAgIC8vIGNoZWNrZWRcbiAgICAgICAgdE5vZGUub3V0cHV0cyA9IGdlbmVyYXRlUHJvcGVydHlBbGlhc2VzKHROb2RlLmZsYWdzLCAxIC8qIE91dHB1dCAqLyk7XG4gICAgfVxuICAgIHZhciBvdXRwdXRzID0gdE5vZGUub3V0cHV0cztcbiAgICB2YXIgb3V0cHV0RGF0YTtcbiAgICBpZiAob3V0cHV0cyAmJiAob3V0cHV0RGF0YSA9IG91dHB1dHNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgY3JlYXRlT3V0cHV0KG91dHB1dERhdGEsIGxpc3RlbmVyRm4pO1xuICAgIH1cbn1cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgb3V0cHV0cyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUgYW5kIHN1YnNjcmliZXMgdG9cbiAqIGVhY2ggb3V0cHV0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVPdXRwdXQob3V0cHV0cywgbGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERhdGFJblJhbmdlKG91dHB1dHNbaV0sIHZpZXdEYXRhKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHZpZXdEYXRhW291dHB1dHNbaV1dW291dHB1dHNbaSArIDFdXS5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgICAgICBzdG9yZUNsZWFudXBXaXRoQ29udGV4dCh2aWV3RGF0YSwgc3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpO1xuICAgIH1cbn1cbi8qKlxuICogU2F2ZXMgY29udGV4dCBmb3IgdGhpcyBjbGVhbnVwIGZ1bmN0aW9uIGluIExWaWV3LmNsZWFudXBJbnN0YW5jZXMuXG4gKlxuICogT24gdGhlIGZpcnN0IHRlbXBsYXRlIHBhc3MsIHNhdmVzIGluIFRWaWV3OlxuICogLSBDbGVhbnVwIGZ1bmN0aW9uXG4gKiAtIEluZGV4IG9mIGNvbnRleHQgd2UganVzdCBzYXZlZCBpbiBMVmlldy5jbGVhbnVwSW5zdGFuY2VzXG4gKi9cbmZ1bmN0aW9uIHN0b3JlQ2xlYW51cFdpdGhDb250ZXh0KHZpZXcsIGNvbnRleHQsIGNsZWFudXBGbikge1xuICAgIGlmICghdmlldylcbiAgICAgICAgdmlldyA9IHZpZXdEYXRhO1xuICAgIGdldENsZWFudXAodmlldykucHVzaChjb250ZXh0KTtcbiAgICBpZiAodmlld1tUVklFV10uZmlyc3RUZW1wbGF0ZVBhc3MpIHtcbiAgICAgICAgZ2V0VFZpZXdDbGVhbnVwKHZpZXcpLnB1c2goY2xlYW51cEZuLCB2aWV3W0NMRUFOVVBdLmxlbmd0aCAtIDEpO1xuICAgIH1cbn1cbi8qKlxuICogU2F2ZXMgdGhlIGNsZWFudXAgZnVuY3Rpb24gaXRzZWxmIGluIExWaWV3LmNsZWFudXBJbnN0YW5jZXMuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgZm9yIGZ1bmN0aW9ucyB0aGF0IGFyZSB3cmFwcGVkIHdpdGggdGhlaXIgY29udGV4dHMsIGxpa2UgaW4gcmVuZGVyZXIyXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogT24gdGhlIGZpcnN0IHRlbXBsYXRlIHBhc3MsIHRoZSBpbmRleCBvZiB0aGUgY2xlYW51cCBmdW5jdGlvbiBpcyBzYXZlZCBpbiBUVmlldy5cbiAqL1xuZnVuY3Rpb24gc3RvcmVDbGVhbnVwRm4odmlldywgY2xlYW51cEZuKSB7XG4gICAgZ2V0Q2xlYW51cCh2aWV3KS5wdXNoKGNsZWFudXBGbik7XG4gICAgaWYgKHZpZXdbVFZJRVddLmZpcnN0VGVtcGxhdGVQYXNzKSB7XG4gICAgICAgIGdldFRWaWV3Q2xlYW51cCh2aWV3KS5wdXNoKHZpZXdbQ0xFQU5VUF0ubGVuZ3RoIC0gMSwgbnVsbCk7XG4gICAgfVxufVxuLyoqIE1hcmsgdGhlIGVuZCBvZiB0aGUgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRFbmQoKSB7XG4gICAgaWYgKGlzUGFyZW50KSB7XG4gICAgICAgIGlzUGFyZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0SGFzUGFyZW50KCk7XG4gICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IHByZXZpb3VzT3JQYXJlbnRUTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlVHlwZShwcmV2aW91c09yUGFyZW50VE5vZGUsIDMgLyogRWxlbWVudCAqLyk7XG4gICAgY3VycmVudFF1ZXJpZXMgJiZcbiAgICAgICAgKGN1cnJlbnRRdWVyaWVzID0gY3VycmVudFF1ZXJpZXMuYWRkTm9kZShwcmV2aW91c09yUGFyZW50VE5vZGUpKTtcbiAgICBxdWV1ZUxpZmVjeWNsZUhvb2tzKHByZXZpb3VzT3JQYXJlbnRUTm9kZS5mbGFncywgdFZpZXcpO1xuICAgIGVsZW1lbnREZXB0aENvdW50LS07XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHJlbW92ZXMgYW4gYXR0cmlidXRlIG9uIGFuIEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIG51bWJlciBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRhdGEgYXJyYXlcbiAqIEBwYXJhbSBuYW1lIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBUaGUgYXR0cmlidXRlIGlzIHJlbW92ZWQgd2hlbiB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKiAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSB0aGUgYXR0cmlidXRlIHZhbHVlIGlzIHNldCB0byB0aGUgc3RyaW5naWZpZWQgdmFsdWUuXG4gKiBAcGFyYW0gc2FuaXRpemVyIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG8gc2FuaXRpemUgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbGVtZW50QXR0cmlidXRlKGluZGV4LCBuYW1lLCB2YWx1ZSwgc2FuaXRpemVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBOT19DSEFOR0UpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRfMSA9IGdldE5hdGl2ZUJ5SW5kZXgoaW5kZXgsIHZpZXdEYXRhKTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJSZW1vdmVBdHRyaWJ1dGUrKztcbiAgICAgICAgICAgIGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSA/IHJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZShlbGVtZW50XzEsIG5hbWUpIDpcbiAgICAgICAgICAgICAgICBlbGVtZW50XzEucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlclNldEF0dHJpYnV0ZSsrO1xuICAgICAgICAgICAgdmFyIHN0clZhbHVlID0gc2FuaXRpemVyID09IG51bGwgPyBzdHJpbmdpZnkkMSh2YWx1ZSkgOiBzYW5pdGl6ZXIodmFsdWUpO1xuICAgICAgICAgICAgaXNQcm9jZWR1cmFsUmVuZGVyZXIocmVuZGVyZXIpID8gcmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsZW1lbnRfMSwgbmFtZSwgc3RyVmFsdWUpIDpcbiAgICAgICAgICAgICAgICBlbGVtZW50XzEuc2V0QXR0cmlidXRlKG5hbWUsIHN0clZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVXBkYXRlIGEgcHJvcGVydHkgb24gYW4gRWxlbWVudC5cbiAqXG4gKiBJZiB0aGUgcHJvcGVydHkgbmFtZSBhbHNvIGV4aXN0cyBhcyBhbiBpbnB1dCBwcm9wZXJ0eSBvbiBvbmUgb2YgdGhlIGVsZW1lbnQncyBkaXJlY3RpdmVzLFxuICogdGhlIGNvbXBvbmVudCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IHByb3BlcnR5LiBUaGlzIGNoZWNrIG11c3RcbiAqIGJlIGNvbmR1Y3RlZCBhdCBydW50aW1lIHNvIGNoaWxkIGNvbXBvbmVudHMgdGhhdCBhZGQgbmV3IEBJbnB1dHMgZG9uJ3QgaGF2ZSB0byBiZSByZS1jb21waWxlZC5cbiAqXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHVwZGF0ZSBpbiB0aGUgZGF0YSBhcnJheVxuICogQHBhcmFtIHByb3BOYW1lIE5hbWUgb2YgcHJvcGVydHkuIEJlY2F1c2UgaXQgaXMgZ29pbmcgdG8gRE9NLCB0aGlzIGlzIG5vdCBzdWJqZWN0IHRvXG4gKiAgICAgICAgcmVuYW1pbmcgYXMgcGFydCBvZiBtaW5pZmljYXRpb24uXG4gKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIHRvIHdyaXRlLlxuICogQHBhcmFtIHNhbml0aXplciBBbiBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIHRvIHNhbml0aXplIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudFByb3BlcnR5KGluZGV4LCBwcm9wTmFtZSwgdmFsdWUsIHNhbml0aXplcikge1xuICAgIGlmICh2YWx1ZSA9PT0gTk9fQ0hBTkdFKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGVsZW1lbnQgPSBnZXROYXRpdmVCeUluZGV4KGluZGV4LCB2aWV3RGF0YSk7XG4gICAgdmFyIHROb2RlID0gZ2V0VE5vZGUoaW5kZXgsIHZpZXdEYXRhKTtcbiAgICAvLyBpZiB0Tm9kZS5pbnB1dHMgaXMgdW5kZWZpbmVkLCBhIGxpc3RlbmVyIGhhcyBjcmVhdGVkIG91dHB1dHMsIGJ1dCBpbnB1dHMgaGF2ZW4ndFxuICAgIC8vIHlldCBiZWVuIGNoZWNrZWRcbiAgICBpZiAodE5vZGUgJiYgdE5vZGUuaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbWFyayBpbnB1dHMgYXMgY2hlY2tlZFxuICAgICAgICB0Tm9kZS5pbnB1dHMgPSBnZW5lcmF0ZVByb3BlcnR5QWxpYXNlcyh0Tm9kZS5mbGFncywgMCAvKiBJbnB1dCAqLyk7XG4gICAgfVxuICAgIHZhciBpbnB1dERhdGEgPSB0Tm9kZSAmJiB0Tm9kZS5pbnB1dHM7XG4gICAgdmFyIGRhdGFWYWx1ZTtcbiAgICBpZiAoaW5wdXREYXRhICYmIChkYXRhVmFsdWUgPSBpbnB1dERhdGFbcHJvcE5hbWVdKSkge1xuICAgICAgICBzZXRJbnB1dHNGb3JQcm9wZXJ0eShkYXRhVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50KHROb2RlKSlcbiAgICAgICAgICAgIG1hcmtEaXJ0eUlmT25QdXNoKGluZGV4ICsgSEVBREVSX09GRlNFVCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHROb2RlLnR5cGUgPT09IDMgLyogRWxlbWVudCAqLykge1xuICAgICAgICAvLyBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHNhbml0aXplciBpcyBvbmx5IGFkZGVkIHdoZW4gdGhlIGNvbXBpbGVyIGRldGVybWluZXMgdGhhdCB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gaXMgcmlza3ksIHNvIHNhbml0aXphdGlvbiBjYW4gYmUgZG9uZSB3aXRob3V0IGZ1cnRoZXIgY2hlY2tzLlxuICAgICAgICB2YWx1ZSA9IHNhbml0aXplciAhPSBudWxsID8gc2FuaXRpemVyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBuZ0Rldk1vZGUgJiYgbmdEZXZNb2RlLnJlbmRlcmVyU2V0UHJvcGVydHkrKztcbiAgICAgICAgaXNQcm9jZWR1cmFsUmVuZGVyZXIocmVuZGVyZXIpID9cbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KGVsZW1lbnQsIHByb3BOYW1lLCB2YWx1ZSkgOlxuICAgICAgICAgICAgKGVsZW1lbnQuc2V0UHJvcGVydHkgPyBlbGVtZW50LnNldFByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkgOlxuICAgICAgICAgICAgICAgIGVsZW1lbnRbcHJvcE5hbWVdID0gdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5hYmxlcyBkaXJlY3RpdmUgbWF0Y2hpbmcgb24gZWxlbWVudHMuXG4gKlxuICogICogRXhhbXBsZTpcbiAqIGBgYFxuICogPG15LWNvbXAgbXktZGlyZWN0aXZlPlxuICogICBTaG91bGQgbWF0Y2ggY29tcG9uZW50IC8gZGlyZWN0aXZlLlxuICogPC9teS1jb21wPlxuICogPGRpdiBuZ05vbkJpbmRhYmxlPlxuICogICA8IS0tIGRpc2FibGVkQmluZGluZ3MoKSAtLT5cbiAqICAgPG15LWNvbXAgbXktZGlyZWN0aXZlPlxuICogICAgIFNob3VsZCBub3QgbWF0Y2ggY29tcG9uZW50IC8gZGlyZWN0aXZlIGJlY2F1c2Ugd2UgYXJlIGluIG5nTm9uQmluZGFibGUuXG4gKiAgIDwvbXktY29tcD5cbiAqICAgPCEtLSBlbmFibGVCaW5kaW5ncygpIC0tPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZW5hYmxlQmluZGluZ3MoKSB7XG4gICAgYmluZGluZ3NFbmFibGVkID0gdHJ1ZTtcbn1cbi8qKlxuICogRGlzYWJsZXMgZGlyZWN0aXZlIG1hdGNoaW5nIG9uIGVsZW1lbnQuXG4gKlxuICogICogRXhhbXBsZTpcbiAqIGBgYFxuICogPG15LWNvbXAgbXktZGlyZWN0aXZlPlxuICogICBTaG91bGQgbWF0Y2ggY29tcG9uZW50IC8gZGlyZWN0aXZlLlxuICogPC9teS1jb21wPlxuICogPGRpdiBuZ05vbkJpbmRhYmxlPlxuICogICA8IS0tIGRpc2FibGVkQmluZGluZ3MoKSAtLT5cbiAqICAgPG15LWNvbXAgbXktZGlyZWN0aXZlPlxuICogICAgIFNob3VsZCBub3QgbWF0Y2ggY29tcG9uZW50IC8gZGlyZWN0aXZlIGJlY2F1c2Ugd2UgYXJlIGluIG5nTm9uQmluZGFibGUuXG4gKiAgIDwvbXktY29tcD5cbiAqICAgPCEtLSBlbmFibGVCaW5kaW5ncygpIC0tPlxuICogPC9kaXY+XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUJpbmRpbmdzKCkge1xuICAgIGJpbmRpbmdzRW5hYmxlZCA9IGZhbHNlO1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgVE5vZGUgb2JqZWN0IGZyb20gdGhlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGFkanVzdGVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBUTm9kZSBpbiBUVmlldy5kYXRhLCBhZGp1c3RlZCBmb3IgSEVBREVSX09GRlNFVFxuICogQHBhcmFtIHRhZ05hbWUgVGhlIHRhZyBuYW1lIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgZGVmaW5lZCBvbiB0aGlzIG5vZGVcbiAqIEBwYXJhbSB0Vmlld3MgQW55IFRWaWV3cyBhdHRhY2hlZCB0byB0aGlzIG5vZGVcbiAqIEByZXR1cm5zIHRoZSBUTm9kZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVE5vZGUodHlwZSwgYWRqdXN0ZWRJbmRleCwgdGFnTmFtZSwgYXR0cnMsIHRWaWV3cykge1xuICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUudE5vZGUrKztcbiAgICB2YXIgcGFyZW50ID0gaXNQYXJlbnQgPyBwcmV2aW91c09yUGFyZW50VE5vZGUgOiBwcmV2aW91c09yUGFyZW50VE5vZGUgJiYgcHJldmlvdXNPclBhcmVudFROb2RlLnBhcmVudDtcbiAgICAvLyBQYXJlbnRzIGNhbm5vdCBjcm9zcyBjb21wb25lbnQgYm91bmRhcmllcyBiZWNhdXNlIGNvbXBvbmVudHMgd2lsbCBiZSB1c2VkIGluIG11bHRpcGxlIHBsYWNlcyxcbiAgICAvLyBzbyBpdCdzIG9ubHkgc2V0IGlmIHRoZSB2aWV3IGlzIHRoZSBzYW1lLlxuICAgIHZhciBwYXJlbnRJblNhbWVWaWV3ID0gcGFyZW50ICYmIHZpZXdEYXRhICYmIHBhcmVudCAhPT0gdmlld0RhdGFbSE9TVF9OT0RFXTtcbiAgICB2YXIgdFBhcmVudCA9IHBhcmVudEluU2FtZVZpZXcgPyBwYXJlbnQgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGluZGV4OiBhZGp1c3RlZEluZGV4LFxuICAgICAgICBpbmplY3RvckluZGV4OiB0UGFyZW50ID8gdFBhcmVudC5pbmplY3RvckluZGV4IDogLTEsXG4gICAgICAgIGZsYWdzOiAwLFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgIGxvY2FsTmFtZXM6IG51bGwsXG4gICAgICAgIGluaXRpYWxJbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIG91dHB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgdFZpZXdzOiB0Vmlld3MsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIGNoaWxkOiBudWxsLFxuICAgICAgICBwYXJlbnQ6IHRQYXJlbnQsXG4gICAgICAgIGRldGFjaGVkOiBudWxsLFxuICAgICAgICBzdHlsaW5nVGVtcGxhdGU6IG51bGwsXG4gICAgICAgIHByb2plY3Rpb246IG51bGxcbiAgICB9O1xufVxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgZGlyZWN0aXZlIGluZGljZXMgYW5kIG1pbmlmaWVkIGlucHV0IG5hbWVzLCBzZXRzIHRoZVxuICogaW5wdXQgcHJvcGVydGllcyBvbiB0aGUgY29ycmVzcG9uZGluZyBkaXJlY3RpdmVzLlxuICovXG5mdW5jdGlvbiBzZXRJbnB1dHNGb3JQcm9wZXJ0eShpbnB1dHMsIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERhdGFJblJhbmdlKGlucHV0c1tpXSwgdmlld0RhdGEpO1xuICAgICAgICB2aWV3RGF0YVtpbnB1dHNbaV1dW2lucHV0c1tpICsgMV1dID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBDb25zb2xpZGF0ZXMgYWxsIGlucHV0cyBvciBvdXRwdXRzIG9mIGFsbCBkaXJlY3RpdmVzIG9uIHRoaXMgbG9naWNhbCBub2RlLlxuICpcbiAqIEBwYXJhbSBudW1iZXIgdE5vZGVGbGFncyBub2RlIGZsYWdzXG4gKiBAcGFyYW0gRGlyZWN0aW9uIGRpcmVjdGlvbiB3aGV0aGVyIHRvIGNvbnNpZGVyIGlucHV0cyBvciBvdXRwdXRzXG4gKiBAcmV0dXJucyBQcm9wZXJ0eUFsaWFzZXN8bnVsbCBhZ2dyZWdhdGUgb2YgYWxsIHByb3BlcnRpZXMgaWYgYW55LCBgbnVsbGAgb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvcGVydHlBbGlhc2VzKHROb2RlRmxhZ3MsIGRpcmVjdGlvbikge1xuICAgIHZhciBjb3VudCA9IHROb2RlRmxhZ3MgJiA0MDk1IC8qIERpcmVjdGl2ZUNvdW50TWFzayAqLztcbiAgICB2YXIgcHJvcFN0b3JlID0gbnVsbDtcbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHROb2RlRmxhZ3MgPj4gMTUgLyogRGlyZWN0aXZlU3RhcnRpbmdJbmRleFNoaWZ0ICovO1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICAgICAgdmFyIGlzSW5wdXQgPSBkaXJlY3Rpb24gPT09IDAgLyogSW5wdXQgKi87XG4gICAgICAgIHZhciBkZWZzID0gdFZpZXcuZGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVEZWYgPSBkZWZzW2ldO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5QWxpYXNNYXAgPSBpc0lucHV0ID8gZGlyZWN0aXZlRGVmLmlucHV0cyA6IGRpcmVjdGl2ZURlZi5vdXRwdXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHVibGljTmFtZSBpbiBwcm9wZXJ0eUFsaWFzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QWxpYXNNYXAuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFN0b3JlID0gcHJvcFN0b3JlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxOYW1lID0gcHJvcGVydHlBbGlhc01hcFtwdWJsaWNOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gcHJvcFN0b3JlLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBoYXNQcm9wZXJ0eSA/IHByb3BTdG9yZVtwdWJsaWNOYW1lXS5wdXNoKGksIGludGVybmFsTmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb3BTdG9yZVtwdWJsaWNOYW1lXSA9IFtpLCBpbnRlcm5hbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BTdG9yZTtcbn1cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBhIGNsYXNzIGluIGEgYGNsYXNzTGlzdGAgb24gYSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGlzIG1lYW50IHRvIGhhbmRsZSB0aGUgW2NsYXNzLmZvb109XCJleHBcIiBjYXNlXG4gKlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byB1cGRhdGUgaW4gdGhlIGRhdGEgYXJyYXlcbiAqIEBwYXJhbSBjbGFzc05hbWUgTmFtZSBvZiBjbGFzcyB0byB0b2dnbGUuIEJlY2F1c2UgaXQgaXMgZ29pbmcgdG8gRE9NLCB0aGlzIGlzIG5vdCBzdWJqZWN0IHRvXG4gKiAgICAgICAgcmVuYW1pbmcgYXMgcGFydCBvZiBtaW5pZmljYXRpb24uXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSBpbmRpY2F0aW5nIGlmIGEgZ2l2ZW4gY2xhc3Mgc2hvdWxkIGJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRDbGFzc1Byb3AoaW5kZXgsIHN0eWxpbmdJbmRleCwgdmFsdWUpIHtcbiAgICB2YXIgdmFsID0gKHZhbHVlIGluc3RhbmNlb2YgQm91bmRQbGF5ZXJGYWN0b3J5KSA/IHZhbHVlIDogKCEhdmFsdWUpO1xuICAgIHVwZGF0ZUNsYXNzUHJvcChnZXRTdHlsaW5nQ29udGV4dChpbmRleCwgdmlld0RhdGEpLCBzdHlsaW5nSW5kZXgsIHZhbCk7XG59XG4vKipcbiAqIEFzc2lnbiBhbnkgaW5saW5lIHN0eWxlIHZhbHVlcyB0byB0aGUgZWxlbWVudCBkdXJpbmcgY3JlYXRpb24gbW9kZS5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGlzIG1lYW50IHRvIGJlIGNhbGxlZCBkdXJpbmcgY3JlYXRpb24gbW9kZSB0byBhcHBseSBhbGwgc3R5bGluZ1xuICogKGUuZy4gYHN0eWxlPVwiLi4uXCJgKSB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgYWxzbyB3aGVyZSB0aGUgcHJvdmlkZWQgaW5kZXhcbiAqIHZhbHVlIGlzIGFsbG9jYXRlZCBmb3IgdGhlIHN0eWxpbmcgZGV0YWlscyBmb3IgaXRzIGNvcnJlc3BvbmRpbmcgZWxlbWVudCAodGhlIGVsZW1lbnRcbiAqIGluZGV4IGlzIHRoZSBwcmV2aW91cyBpbmRleCB2YWx1ZSBmcm9tIHRoaXMgb25lKS5cbiAqXG4gKiAoTm90ZSB0aGlzIGZ1bmN0aW9uIGNhbGxzIGBlbGVtZW50U3R5bGluZ0FwcGx5YCBpbW1lZGlhdGVseSB3aGVuIGNhbGxlZC4pXG4gKlxuICpcbiAqIEBwYXJhbSBpbmRleCBJbmRleCB2YWx1ZSB3aGljaCB3aWxsIGJlIGFsbG9jYXRlZCB0byBzdG9yZSBzdHlsaW5nIGRhdGEgZm9yIHRoZSBlbGVtZW50LlxuICogICAgICAgIChOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlIGVsZW1lbnQgaW5kZXgsIGJ1dCByYXRoZXIgYW4gaW5kZXggdmFsdWUgYWxsb2NhdGVkXG4gKiAgICAgICAgc3BlY2lmaWNhbGx5IGZvciBlbGVtZW50IHN0eWxpbmctLXRoZSBpbmRleCBtdXN0IGJlIHRoZSBuZXh0IGluZGV4IGFmdGVyIHRoZSBlbGVtZW50XG4gKiAgICAgICAgaW5kZXguKVxuICogQHBhcmFtIGNsYXNzRGVjbGFyYXRpb25zIEEga2V5L3ZhbHVlIGFycmF5IG9mIENTUyBjbGFzc2VzIHRoYXQgd2lsbCBiZSByZWdpc3RlcmVkIG9uIHRoZSBlbGVtZW50LlxuICogICBFYWNoIGluZGl2aWR1YWwgc3R5bGUgd2lsbCBiZSB1c2VkIG9uIHRoZSBlbGVtZW50IGFzIGxvbmcgYXMgaXQgaXMgbm90IG92ZXJyaWRkZW5cbiAqICAgYnkgYW55IGNsYXNzZXMgcGxhY2VkIG9uIHRoZSBlbGVtZW50IGJ5IG11bHRpcGxlIChgW2NsYXNzXWApIG9yIHNpbmd1bGFyIChgW2NsYXNzLm5hbWVkXWApXG4gKiAgIGJpbmRpbmdzLiBJZiBhIGNsYXNzIGJpbmRpbmcgY2hhbmdlcyBpdHMgdmFsdWUgdG8gYSBmYWxzeSB2YWx1ZSB0aGVuIHRoZSBtYXRjaGluZyBpbml0aWFsXG4gKiAgIGNsYXNzIHZhbHVlIHRoYXQgYXJlIHBhc3NlZCBpbiBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCAoaWYgbWF0Y2hlZCkuXG4gKiBAcGFyYW0gc3R5bGVEZWNsYXJhdGlvbnMgQSBrZXkvdmFsdWUgYXJyYXkgb2YgQ1NTIHN0eWxlcyB0aGF0IHdpbGwgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgZWxlbWVudC5cbiAqICAgRWFjaCBpbmRpdmlkdWFsIHN0eWxlIHdpbGwgYmUgdXNlZCBvbiB0aGUgZWxlbWVudCBhcyBsb25nIGFzIGl0IGlzIG5vdCBvdmVycmlkZGVuXG4gKiAgIGJ5IGFueSBzdHlsZXMgcGxhY2VkIG9uIHRoZSBlbGVtZW50IGJ5IG11bHRpcGxlIChgW3N0eWxlXWApIG9yIHNpbmd1bGFyIChgW3N0eWxlLnByb3BdYClcbiAqICAgYmluZGluZ3MuIElmIGEgc3R5bGUgYmluZGluZyBjaGFuZ2VzIGl0cyB2YWx1ZSB0byBudWxsIHRoZW4gdGhlIGluaXRpYWwgc3R5bGluZ1xuICogICB2YWx1ZXMgdGhhdCBhcmUgcGFzc2VkIGluIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IChpZiBtYXRjaGVkKS5cbiAqIEBwYXJhbSBzdHlsZVNhbml0aXplciBBbiBvcHRpb25hbCBzYW5pdGl6ZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgKGlmIHByb3ZpZGVkKVxuICogICB0byBzYW5pdGl6ZSB0aGUgYW55IENTUyBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCAoZHVyaW5nIHJlbmRlcmluZykuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRTdHlsaW5nKGNsYXNzRGVjbGFyYXRpb25zLCBzdHlsZURlY2xhcmF0aW9ucywgc3R5bGVTYW5pdGl6ZXIpIHtcbiAgICB2YXIgdE5vZGUgPSBwcmV2aW91c09yUGFyZW50VE5vZGU7XG4gICAgaWYgKCF0Tm9kZS5zdHlsaW5nVGVtcGxhdGUpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc3R5bGluZyB0ZW1wbGF0ZS5cbiAgICAgICAgdE5vZGUuc3R5bGluZ1RlbXBsYXRlID1cbiAgICAgICAgICAgIGNyZWF0ZVN0eWxpbmdDb250ZXh0VGVtcGxhdGUoY2xhc3NEZWNsYXJhdGlvbnMsIHN0eWxlRGVjbGFyYXRpb25zLCBzdHlsZVNhbml0aXplcik7XG4gICAgfVxuICAgIGlmIChzdHlsZURlY2xhcmF0aW9ucyAmJiBzdHlsZURlY2xhcmF0aW9ucy5sZW5ndGggfHxcbiAgICAgICAgY2xhc3NEZWNsYXJhdGlvbnMgJiYgY2xhc3NEZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsaW5nQXBwbHkodE5vZGUuaW5kZXggLSBIRUFERVJfT0ZGU0VUKTtcbiAgICB9XG59XG4vKipcbiAqIEFwcGx5IGFsbCBzdHlsaW5nIHZhbHVlcyB0byB0aGUgZWxlbWVudCB3aGljaCBoYXZlIGJlZW4gcXVldWVkIGJ5IGFueSBzdHlsaW5nIGluc3RydWN0aW9ucy5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGlzIG1lYW50IHRvIGJlIHJ1biBvbmNlIG9uZSBvciBtb3JlIGBlbGVtZW50U3R5bGVgIGFuZC9vciBgZWxlbWVudFN0eWxlUHJvcGBcbiAqIGhhdmUgYmVlbiBpc3N1ZWQgYWdhaW5zdCB0aGUgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gZGV0ZXJtaW5lIGlmIGFueSBzdHlsZXMgaGF2ZVxuICogY2hhbmdlZCBhbmQgd2lsbCB0aGVuIHNraXAgdGhlIG9wZXJhdGlvbiBpZiB0aGVyZSBpcyBub3RoaW5nIG5ldyB0byByZW5kZXIuXG4gKlxuICogT25jZSBjYWxsZWQgdGhlbiBhbGwgcXVldWVkIHN0eWxlcyB3aWxsIGJlIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50J3Mgc3R5bGluZyBzdG9yYWdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cbiAqICAgICAgICAoTm90ZSB0aGF0IHRoaXMgaXMgbm90IHRoZSBlbGVtZW50IGluZGV4LCBidXQgcmF0aGVyIGFuIGluZGV4IHZhbHVlIGFsbG9jYXRlZFxuICogICAgICAgIHNwZWNpZmljYWxseSBmb3IgZWxlbWVudCBzdHlsaW5nLS10aGUgaW5kZXggbXVzdCBiZSB0aGUgbmV4dCBpbmRleCBhZnRlciB0aGUgZWxlbWVudFxuICogICAgICAgIGluZGV4LilcbiAqL1xuZnVuY3Rpb24gZWxlbWVudFN0eWxpbmdBcHBseShpbmRleCkge1xuICAgIHZhciB0b3RhbFBsYXllcnNRdWV1ZWQgPSByZW5kZXJTdHlsZUFuZENsYXNzQmluZGluZ3MoZ2V0U3R5bGluZ0NvbnRleHQoaW5kZXgsIHZpZXdEYXRhKSwgcmVuZGVyZXIsIHZpZXdEYXRhKTtcbiAgICBpZiAodG90YWxQbGF5ZXJzUXVldWVkID4gMCkge1xuICAgICAgICB2YXIgcm9vdENvbnRleHQgPSBnZXRSb290Q29udGV4dCh2aWV3RGF0YSk7XG4gICAgICAgIHNjaGVkdWxlVGljayhyb290Q29udGV4dCwgMiAvKiBGbHVzaFBsYXllcnMgKi8pO1xuICAgIH1cbn1cbi8qKlxuICogUXVldWUgYSBnaXZlbiBzdHlsZSB0byBiZSByZW5kZXJlZCBvbiBhbiBFbGVtZW50LlxuICpcbiAqIElmIHRoZSBzdHlsZSB2YWx1ZSBpcyBgbnVsbGAgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxuICogKG9yIGFzc2lnbmVkIGEgZGlmZmVyZW50IHZhbHVlIGRlcGVuZGluZyBpZiB0aGVyZSBhcmUgYW55IHN0eWxlcyBwbGFjZWRcbiAqIG9uIHRoZSBlbGVtZW50IHdpdGggYGVsZW1lbnRTdHlsZWAgb3IgYW55IHN0eWxlcyB0aGF0IGFyZSBwcmVzZW50XG4gKiBmcm9tIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGNyZWF0ZWQgKHdpdGggYGVsZW1lbnRTdHlsaW5nYCkuXG4gKlxuICogKE5vdGUgdGhhdCB0aGUgc3R5bGluZyBpbnN0cnVjdGlvbiB3aWxsIG5vdCBiZSBhcHBsaWVkIHVudGlsIGBlbGVtZW50U3R5bGluZ0FwcGx5YCBpcyBjYWxsZWQuKVxuICpcbiAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCdzIHN0eWxpbmcgc3RvcmFnZSB0byBjaGFuZ2UgaW4gdGhlIGRhdGEgYXJyYXkuXG4gKiAgICAgICAgKE5vdGUgdGhhdCB0aGlzIGlzIG5vdCB0aGUgZWxlbWVudCBpbmRleCwgYnV0IHJhdGhlciBhbiBpbmRleCB2YWx1ZSBhbGxvY2F0ZWRcbiAqICAgICAgICBzcGVjaWZpY2FsbHkgZm9yIGVsZW1lbnQgc3R5bGluZy0tdGhlIGluZGV4IG11c3QgYmUgdGhlIG5leHQgaW5kZXggYWZ0ZXIgdGhlIGVsZW1lbnRcbiAqICAgICAgICBpbmRleC4pXG4gKiBAcGFyYW0gc3R5bGVJbmRleCBJbmRleCBvZiB0aGUgc3R5bGUgcHJvcGVydHkgb24gdGhpcyBlbGVtZW50LiAoTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLilcbiAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgdG8gd3JpdGUgKG51bGwgdG8gcmVtb3ZlKS5cbiAqIEBwYXJhbSBzdWZmaXggT3B0aW9uYWwgc3VmZml4LiBVc2VkIHdpdGggc2NhbGFyIHZhbHVlcyB0byBhZGQgdW5pdCBzdWNoIGFzIGBweGAuXG4gKiAgICAgICAgTm90ZSB0aGF0IHdoZW4gYSBzdWZmaXggaXMgcHJvdmlkZWQgdGhlbiB0aGUgdW5kZXJseWluZyBzYW5pdGl6ZXIgd2lsbFxuICogICAgICAgIGJlIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRTdHlsZVByb3AoaW5kZXgsIHN0eWxlSW5kZXgsIHZhbHVlLCBzdWZmaXgpIHtcbiAgICB2YXIgdmFsdWVUb0FkZCA9IG51bGw7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gYSBzdWZmaXggaXMgYXBwbGllZCB0aGVuIGl0IHdpbGwgYnlwYXNzXG4gICAgICAgICAgICAvLyBzYW5pdGl6YXRpb24gZW50aXJlbHkgKGIvYyBhIG5ldyBzdHJpbmcgaXMgY3JlYXRlZClcbiAgICAgICAgICAgIHZhbHVlVG9BZGQgPSBzdHJpbmdpZnkkMSh2YWx1ZSkgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW5pdGl6YXRpb24gaGFwcGVucyBieSBkZWFsaW5nIHdpdGggYSBTdHJpbmcgdmFsdWVcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgc3RyaW5nIHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2hcbiAgICAgICAgICAgIC8vIGludG8gdGhlIHN0eWxlIHJlbmRlcmluZyBsYXRlciAod2hpY2ggaXMgd2hlcmUgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyB3aWxsIGJlIHNhbml0aXplZCBiZWZvcmUgaXQgaXMgYXBwbGllZClcbiAgICAgICAgICAgIHZhbHVlVG9BZGQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdHlsZVByb3AoZ2V0U3R5bGluZ0NvbnRleHQoaW5kZXgsIHZpZXdEYXRhKSwgc3R5bGVJbmRleCwgdmFsdWVUb0FkZCk7XG59XG4vKipcbiAqIFF1ZXVlIGEga2V5L3ZhbHVlIG1hcCBvZiBzdHlsZXMgdG8gYmUgcmVuZGVyZWQgb24gYW4gRWxlbWVudC5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGlzIG1lYW50IHRvIGhhbmRsZSB0aGUgYFtzdHlsZV09XCJleHBcImAgdXNhZ2UuIFdoZW4gc3R5bGVzIGFyZSBhcHBsaWVkIHRvXG4gKiB0aGUgRWxlbWVudCB0aGV5IHdpbGwgdGhlbiBiZSBwbGFjZWQgd2l0aCByZXNwZWN0IHRvIGFueSBzdHlsZXMgc2V0IHdpdGggYGVsZW1lbnRTdHlsZVByb3BgLlxuICogSWYgYW55IHN0eWxlcyBhcmUgc2V0IHRvIGBudWxsYCB0aGVuIHRoZXkgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQgKHVubGVzcyB0aGUgc2FtZVxuICogc3R5bGUgcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgdG8gdGhlIGVsZW1lbnQgZHVyaW5nIGNyZWF0aW9uIHVzaW5nIGBlbGVtZW50U3R5bGluZ2ApLlxuICpcbiAqIChOb3RlIHRoYXQgdGhlIHN0eWxpbmcgaW5zdHJ1Y3Rpb24gd2lsbCBub3QgYmUgYXBwbGllZCB1bnRpbCBgZWxlbWVudFN0eWxpbmdBcHBseWAgaXMgY2FsbGVkLilcbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQncyBzdHlsaW5nIHN0b3JhZ2UgdG8gY2hhbmdlIGluIHRoZSBkYXRhIGFycmF5LlxuICogICAgICAgIChOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlIGVsZW1lbnQgaW5kZXgsIGJ1dCByYXRoZXIgYW4gaW5kZXggdmFsdWUgYWxsb2NhdGVkXG4gKiAgICAgICAgc3BlY2lmaWNhbGx5IGZvciBlbGVtZW50IHN0eWxpbmctLXRoZSBpbmRleCBtdXN0IGJlIHRoZSBuZXh0IGluZGV4IGFmdGVyIHRoZSBlbGVtZW50XG4gKiAgICAgICAgaW5kZXguKVxuICogQHBhcmFtIGNsYXNzZXMgQSBrZXkvdmFsdWUgc3R5bGUgbWFwIG9mIENTUyBjbGFzc2VzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqICAgICAgICBBbnkgbWlzc2luZyBjbGFzc2VzICh0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlaGFuZCkgd2lsbCBiZVxuICogICAgICAgIHJlbW92ZWQgKHVuc2V0KSBmcm9tIHRoZSBlbGVtZW50J3MgbGlzdCBvZiBDU1MgY2xhc3Nlcy5cbiAqIEBwYXJhbSBzdHlsZXMgQSBrZXkvdmFsdWUgc3R5bGUgbWFwIG9mIHRoZSBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiAgICAgICAgQW55IG1pc3Npbmcgc3R5bGVzICh0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlaGFuZCkgd2lsbCBiZVxuICogICAgICAgIHJlbW92ZWQgKHVuc2V0KSBmcm9tIHRoZSBlbGVtZW50J3Mgc3R5bGluZy5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudFN0eWxpbmdNYXAoaW5kZXgsIGNsYXNzZXMsIHN0eWxlcykge1xuICAgIHVwZGF0ZVN0eWxpbmdNYXAoZ2V0U3R5bGluZ0NvbnRleHQoaW5kZXgsIHZpZXdEYXRhKSwgY2xhc3Nlcywgc3R5bGVzKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vIFRleHRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIENyZWF0ZSBzdGF0aWMgdGV4dCBub2RlXG4gKlxuICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBub2RlIGluIHRoZSBkYXRhIGFycmF5XG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gd3JpdGUuIFRoaXMgdmFsdWUgd2lsbCBiZSBzdHJpbmdpZmllZC5cbiAqL1xuZnVuY3Rpb24gdGV4dChpbmRleCwgdmFsdWUpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RXF1YWwodmlld0RhdGFbQklORElOR19JTkRFWF0sIHRWaWV3LmJpbmRpbmdTdGFydEluZGV4LCAndGV4dCBub2RlcyBzaG91bGQgYmUgY3JlYXRlZCBiZWZvcmUgYW55IGJpbmRpbmdzJyk7XG4gICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlckNyZWF0ZVRleHROb2RlKys7XG4gICAgdmFyIHRleHROYXRpdmUgPSBjcmVhdGVUZXh0Tm9kZSh2YWx1ZSwgcmVuZGVyZXIpO1xuICAgIHZhciB0Tm9kZSA9IGNyZWF0ZU5vZGVBdEluZGV4KGluZGV4LCAzIC8qIEVsZW1lbnQgKi8sIHRleHROYXRpdmUsIG51bGwsIG51bGwpO1xuICAgIC8vIFRleHQgbm9kZXMgYXJlIHNlbGYgY2xvc2luZy5cbiAgICBpc1BhcmVudCA9IGZhbHNlO1xuICAgIGFwcGVuZENoaWxkKHRleHROYXRpdmUsIHROb2RlLCB2aWV3RGF0YSk7XG59XG4vKipcbiAqIENyZWF0ZSB0ZXh0IG5vZGUgd2l0aCBiaW5kaW5nXG4gKiBCaW5kaW5ncyBzaG91bGQgYmUgaGFuZGxlZCBleHRlcm5hbGx5IHdpdGggdGhlIHByb3BlciBpbnRlcnBvbGF0aW9uKDEtOCkgbWV0aG9kXG4gKlxuICogQHBhcmFtIGluZGV4IEluZGV4IG9mIHRoZSBub2RlIGluIHRoZSBkYXRhIGFycmF5LlxuICogQHBhcmFtIHZhbHVlIFN0cmluZ2lmaWVkIHZhbHVlIHRvIHdyaXRlLlxuICovXG5mdW5jdGlvbiB0ZXh0QmluZGluZyhpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IE5PX0NIQU5HRSkge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGF0YUluUmFuZ2UoaW5kZXggKyBIRUFERVJfT0ZGU0VUKTtcbiAgICAgICAgdmFyIGVsZW1lbnRfMiA9IGdldE5hdGl2ZUJ5SW5kZXgoaW5kZXgsIHZpZXdEYXRhKTtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQoZWxlbWVudF8yLCAnbmF0aXZlIGVsZW1lbnQgc2hvdWxkIGV4aXN0Jyk7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBuZ0Rldk1vZGUucmVuZGVyZXJTZXRUZXh0Kys7XG4gICAgICAgIGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSA/IHJlbmRlcmVyLnNldFZhbHVlKGVsZW1lbnRfMiwgc3RyaW5naWZ5JDEodmFsdWUpKSA6XG4gICAgICAgICAgICBlbGVtZW50XzIudGV4dENvbnRlbnQgPSBzdHJpbmdpZnkkMSh2YWx1ZSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gRGlyZWN0aXZlXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBDcmVhdGUgYSBkaXJlY3RpdmUgYW5kIHRoZWlyIGFzc29jaWF0ZWQgY29udGVudCBxdWVyaWVzLlxuICpcbiAqIE5PVEU6IGRpcmVjdGl2ZXMgY2FuIGJlIGNyZWF0ZWQgaW4gb3JkZXIgb3RoZXIgdGhhbiB0aGUgaW5kZXggb3JkZXIuIFRoZXkgY2FuIGFsc29cbiAqICAgICAgIGJlIHJldHJpZXZlZCBiZWZvcmUgdGhleSBhcmUgY3JlYXRlZCBpbiB3aGljaCBjYXNlIHRoZSB2YWx1ZSB3aWxsIGJlIG51bGwuXG4gKlxuICogQHBhcmFtIGRpcmVjdGl2ZSBUaGUgZGlyZWN0aXZlIGluc3RhbmNlLlxuICogQHBhcmFtIGRpcmVjdGl2ZURlZiBEaXJlY3RpdmVEZWYgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0ZW1wbGF0ZS5cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aXZlQ3JlYXRlKGRpcmVjdGl2ZURlZklkeCwgZGlyZWN0aXZlLCBkaXJlY3RpdmVEZWYpIHtcbiAgICB2YXIgbmF0aXZlID0gZ2V0TmF0aXZlQnlUTm9kZShwcmV2aW91c09yUGFyZW50VE5vZGUsIHZpZXdEYXRhKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBiYXNlRGlyZWN0aXZlQ3JlYXRlKGRpcmVjdGl2ZURlZklkeCwgZGlyZWN0aXZlLCBkaXJlY3RpdmVEZWYsIG5hdGl2ZSk7XG4gICAgaWYgKGRpcmVjdGl2ZURlZi50ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KHByZXZpb3VzT3JQYXJlbnRUTm9kZS5pbmRleCwgdmlld0RhdGEpO1xuICAgICAgICBjb21wb25lbnRWaWV3W0NPTlRFWFRdID0gZGlyZWN0aXZlO1xuICAgIH1cbiAgICBpZiAoZmlyc3RUZW1wbGF0ZVBhc3MpIHtcbiAgICAgICAgLy8gSW5pdCBob29rcyBhcmUgcXVldWVkIG5vdyBzbyBuZ09uSW5pdCBpcyBjYWxsZWQgaW4gaG9zdCBjb21wb25lbnRzIGJlZm9yZVxuICAgICAgICAvLyBhbnkgcHJvamVjdGVkIGNvbXBvbmVudHMuXG4gICAgICAgIHF1ZXVlSW5pdEhvb2tzKGRpcmVjdGl2ZURlZklkeCwgZGlyZWN0aXZlRGVmLm9uSW5pdCwgZGlyZWN0aXZlRGVmLmRvQ2hlY2ssIHRWaWV3KTtcbiAgICB9XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQocHJldmlvdXNPclBhcmVudFROb2RlLCAncHJldmlvdXNPclBhcmVudFROb2RlJyk7XG4gICAgaWYgKHByZXZpb3VzT3JQYXJlbnRUTm9kZSAmJiBwcmV2aW91c09yUGFyZW50VE5vZGUuYXR0cnMpIHtcbiAgICAgICAgc2V0SW5wdXRzRnJvbUF0dHJzKGRpcmVjdGl2ZURlZklkeCwgaW5zdGFuY2UsIGRpcmVjdGl2ZURlZi5pbnB1dHMsIHByZXZpb3VzT3JQYXJlbnRUTm9kZSk7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVEZWYuY29udGVudFF1ZXJpZXMpIHtcbiAgICAgICAgZGlyZWN0aXZlRGVmLmNvbnRlbnRRdWVyaWVzKCk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGFkZENvbXBvbmVudExvZ2ljKGRlZikge1xuICAgIHZhciBuYXRpdmUgPSBnZXROYXRpdmVCeVROb2RlKHByZXZpb3VzT3JQYXJlbnRUTm9kZSwgdmlld0RhdGEpO1xuICAgIHZhciB0VmlldyA9IGdldE9yQ3JlYXRlVFZpZXcoZGVmLnRlbXBsYXRlLCBkZWYuY29uc3RzLCBkZWYudmFycywgZGVmLmRpcmVjdGl2ZURlZnMsIGRlZi5waXBlRGVmcywgZGVmLnZpZXdRdWVyeSk7XG4gICAgLy8gT25seSBjb21wb25lbnQgdmlld3Mgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSB2aWV3IHRyZWUgZGlyZWN0bHkuIEVtYmVkZGVkIHZpZXdzIGFyZVxuICAgIC8vIGFjY2Vzc2VkIHRocm91Z2ggdGhlaXIgY29udGFpbmVycyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJlbW92ZWQgLyByZS1hZGRlZCBsYXRlci5cbiAgICB2YXIgY29tcG9uZW50VmlldyA9IGFkZFRvVmlld1RyZWUodmlld0RhdGEsIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5pbmRleCwgY3JlYXRlTFZpZXdEYXRhKHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihuYXRpdmUsIGRlZiksIHRWaWV3LCBudWxsLCBkZWYub25QdXNoID8gNCAvKiBEaXJ0eSAqLyA6IDIgLyogQ2hlY2tBbHdheXMgKi8sIGdldEN1cnJlbnRTYW5pdGl6ZXIoKSkpO1xuICAgIGNvbXBvbmVudFZpZXdbSE9TVF9OT0RFXSA9IHByZXZpb3VzT3JQYXJlbnRUTm9kZTtcbiAgICAvLyBDb21wb25lbnQgdmlldyB3aWxsIGFsd2F5cyBiZSBjcmVhdGVkIGJlZm9yZSBhbnkgaW5qZWN0ZWQgTENvbnRhaW5lcnMsXG4gICAgLy8gc28gdGhpcyBpcyBhIHJlZ3VsYXIgZWxlbWVudCwgd3JhcCBpdCB3aXRoIHRoZSBjb21wb25lbnQgdmlld1xuICAgIGNvbXBvbmVudFZpZXdbSE9TVF0gPSB2aWV3RGF0YVtwcmV2aW91c09yUGFyZW50VE5vZGUuaW5kZXhdO1xuICAgIHZpZXdEYXRhW3ByZXZpb3VzT3JQYXJlbnRUTm9kZS5pbmRleF0gPSBjb21wb25lbnRWaWV3O1xuICAgIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICBxdWV1ZUNvbXBvbmVudEluZGV4Rm9yQ2hlY2soKTtcbiAgICAgICAgcHJldmlvdXNPclBhcmVudFROb2RlLmZsYWdzID1cbiAgICAgICAgICAgIHZpZXdEYXRhLmxlbmd0aCA8PCAxNSAvKiBEaXJlY3RpdmVTdGFydGluZ0luZGV4U2hpZnQgKi8gfCA0MDk2IC8qIGlzQ29tcG9uZW50ICovO1xuICAgIH1cbn1cbi8qKlxuICogQSBsaWdodGVyIHZlcnNpb24gb2YgZGlyZWN0aXZlQ3JlYXRlKCkgdGhhdCBpcyB1c2VkIGZvciB0aGUgcm9vdCBjb21wb25lbnRcbiAqXG4gKiBUaGlzIHZlcnNpb24gZG9lcyBub3QgY29udGFpbiBmZWF0dXJlcyB0aGF0IHdlIGRvbid0IGFscmVhZHkgc3VwcG9ydCBhdCByb290IGluXG4gKiBjdXJyZW50IEFuZ3VsYXIuIEV4YW1wbGU6IGxvY2FsIHJlZnMgYW5kIGlucHV0cyBvbiByb290IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gYmFzZURpcmVjdGl2ZUNyZWF0ZShpbmRleCwgZGlyZWN0aXZlLCBkaXJlY3RpdmVEZWYsIG5hdGl2ZSkge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdFZpZXcuYmluZGluZ1N0YXJ0SW5kZXgsICdkaXJlY3RpdmVzIHNob3VsZCBiZSBjcmVhdGVkIGJlZm9yZSBhbnkgYmluZGluZ3MnKTtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0UHJldmlvdXNJc1BhcmVudCgpO1xuICAgIGF0dGFjaFBhdGNoRGF0YShkaXJlY3RpdmUsIHZpZXdEYXRhKTtcbiAgICBpZiAobmF0aXZlKSB7XG4gICAgICAgIGF0dGFjaFBhdGNoRGF0YShuYXRpdmUsIHZpZXdEYXRhKTtcbiAgICB9XG4gICAgdmlld0RhdGFbaW5kZXhdID0gZGlyZWN0aXZlO1xuICAgIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB2YXIgZmxhZ3MgPSBwcmV2aW91c09yUGFyZW50VE5vZGUuZmxhZ3M7XG4gICAgICAgIGlmIChmbGFncyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgZmlyc3QgZGlyZWN0aXZlIGlzIGNyZWF0ZWQ6XG4gICAgICAgICAgICAvLyAtIHNhdmUgdGhlIGluZGV4LFxuICAgICAgICAgICAgLy8gLSBzZXQgdGhlIG51bWJlciBvZiBkaXJlY3RpdmVzIHRvIDFcbiAgICAgICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5mbGFncyA9XG4gICAgICAgICAgICAgICAgaW5kZXggPDwgMTUgLyogRGlyZWN0aXZlU3RhcnRpbmdJbmRleFNoaWZ0ICovIHwgZmxhZ3MgJiA0MDk2IC8qIGlzQ29tcG9uZW50ICovIHwgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0byBidW1wIHRoZSBzaXplIHdoZW4gc3Vic2VxdWVudCBkaXJlY3RpdmVzIGFyZSBjcmVhdGVkXG4gICAgICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm90RXF1YWwoZmxhZ3MgJiA0MDk1IC8qIERpcmVjdGl2ZUNvdW50TWFzayAqLywgNDA5NSAvKiBEaXJlY3RpdmVDb3VudE1hc2sgKi8sICdSZWFjaGVkIHRoZSBtYXggbnVtYmVyIG9mIGRpcmVjdGl2ZXMnKTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5mbGFncysrO1xuICAgICAgICB9XG4gICAgICAgIHRWaWV3LmRhdGEucHVzaChkaXJlY3RpdmVEZWYpO1xuICAgICAgICB0Vmlldy5ibHVlcHJpbnQucHVzaChudWxsKTtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZURlZi5ob3N0QmluZGluZ3MpXG4gICAgICAgICAgICBxdWV1ZUhvc3RCaW5kaW5nRm9yQ2hlY2soaW5kZXgsIGRpcmVjdGl2ZURlZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZGlQdWJsaWMgPSBkaXJlY3RpdmVEZWYuZGlQdWJsaWM7XG4gICAgICAgIGlmIChkaVB1YmxpYylcbiAgICAgICAgICAgIGRpUHVibGljKGRpcmVjdGl2ZURlZik7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVEZWYuYXR0cmlidXRlcyAhPSBudWxsICYmIHByZXZpb3VzT3JQYXJlbnRUTm9kZS50eXBlID09IDMgLyogRWxlbWVudCAqLykge1xuICAgICAgICBzZXRVcEF0dHJpYnV0ZXMobmF0aXZlLCBkaXJlY3RpdmVEZWYuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3RpdmU7XG59XG4vKipcbiAqIFNldHMgaW5pdGlhbCBpbnB1dCBwcm9wZXJ0aWVzIG9uIGRpcmVjdGl2ZSBpbnN0YW5jZXMgZnJvbSBhdHRyaWJ1dGUgZGF0YVxuICpcbiAqIEBwYXJhbSBkaXJlY3RpdmVJbmRleCBJbmRleCBvZiB0aGUgZGlyZWN0aXZlIGluIGRpcmVjdGl2ZXMgYXJyYXlcbiAqIEBwYXJhbSBpbnN0YW5jZSBJbnN0YW5jZSBvZiB0aGUgZGlyZWN0aXZlIG9uIHdoaWNoIHRvIHNldCB0aGUgaW5pdGlhbCBpbnB1dHNcbiAqIEBwYXJhbSBpbnB1dHMgVGhlIGxpc3Qgb2YgaW5wdXRzIGZyb20gdGhlIGRpcmVjdGl2ZSBkZWZcbiAqIEBwYXJhbSB0Tm9kZSBUaGUgc3RhdGljIGRhdGEgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBzZXRJbnB1dHNGcm9tQXR0cnMoZGlyZWN0aXZlSW5kZXgsIGluc3RhbmNlLCBpbnB1dHMsIHROb2RlKSB7XG4gICAgdmFyIGluaXRpYWxJbnB1dERhdGEgPSB0Tm9kZS5pbml0aWFsSW5wdXRzO1xuICAgIGlmIChpbml0aWFsSW5wdXREYXRhID09PSB1bmRlZmluZWQgfHwgZGlyZWN0aXZlSW5kZXggPj0gaW5pdGlhbElucHV0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaW5pdGlhbElucHV0RGF0YSA9IGdlbmVyYXRlSW5pdGlhbElucHV0cyhkaXJlY3RpdmVJbmRleCwgaW5wdXRzLCB0Tm9kZSk7XG4gICAgfVxuICAgIHZhciBpbml0aWFsSW5wdXRzID0gaW5pdGlhbElucHV0RGF0YVtkaXJlY3RpdmVJbmRleF07XG4gICAgaWYgKGluaXRpYWxJbnB1dHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsSW5wdXRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVtpbml0aWFsSW5wdXRzW2ldXSA9IGluaXRpYWxJbnB1dHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZXMgaW5pdGlhbElucHV0RGF0YSBmb3IgYSBub2RlIGFuZCBzdG9yZXMgaXQgaW4gdGhlIHRlbXBsYXRlJ3Mgc3RhdGljIHN0b3JhZ2VcbiAqIHNvIHN1YnNlcXVlbnQgdGVtcGxhdGUgaW52b2NhdGlvbnMgZG9uJ3QgaGF2ZSB0byByZWNhbGN1bGF0ZSBpdC5cbiAqXG4gKiBpbml0aWFsSW5wdXREYXRhIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBzZXQgYXMgaW5wdXQgcHJvcGVydGllc1xuICogZm9yIGRpcmVjdGl2ZXMgb24gdGhpcyBub2RlLCBidXQgb25seSBvbmNlIG9uIGNyZWF0aW9uLiBXZSBuZWVkIHRoaXMgYXJyYXkgdG8gc3VwcG9ydFxuICogdGhlIGNhc2Ugd2hlcmUgeW91IHNldCBhbiBASW5wdXQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgdXNpbmcgYXR0cmlidXRlLWxpa2Ugc3ludGF4LlxuICogZS5nLiBpZiB5b3UgaGF2ZSBhIGBuYW1lYCBASW5wdXQsIHlvdSBjYW4gc2V0IGl0IG9uY2UgbGlrZSB0aGlzOlxuICpcbiAqIDxteS1jb21wb25lbnQgbmFtZT1cIkJlc3NcIj48L215LWNvbXBvbmVudD5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aXZlSW5kZXggSW5kZXggdG8gc3RvcmUgdGhlIGluaXRpYWwgaW5wdXQgZGF0YVxuICogQHBhcmFtIGlucHV0cyBUaGUgbGlzdCBvZiBpbnB1dHMgZnJvbSB0aGUgZGlyZWN0aXZlIGRlZlxuICogQHBhcmFtIHROb2RlIFRoZSBzdGF0aWMgZGF0YSBvbiB0aGlzIG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFsSW5wdXRzKGRpcmVjdGl2ZUluZGV4LCBpbnB1dHMsIHROb2RlKSB7XG4gICAgdmFyIGluaXRpYWxJbnB1dERhdGEgPSB0Tm9kZS5pbml0aWFsSW5wdXRzIHx8ICh0Tm9kZS5pbml0aWFsSW5wdXRzID0gW10pO1xuICAgIGluaXRpYWxJbnB1dERhdGFbZGlyZWN0aXZlSW5kZXhdID0gbnVsbDtcbiAgICB2YXIgYXR0cnMgPSB0Tm9kZS5hdHRycztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhdHRycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0cnNbaV07XG4gICAgICAgIGlmIChhdHRyTmFtZSA9PT0gMSAvKiBTZWxlY3RPbmx5ICovKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChhdHRyTmFtZSA9PT0gMCAvKiBOYW1lc3BhY2VVUkkgKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBhbGxvdyBpbnB1dHMgb24gbmFtZXNwYWNlZCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbmlmaWVkSW5wdXROYW1lID0gaW5wdXRzW2F0dHJOYW1lXTtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgaWYgKG1pbmlmaWVkSW5wdXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHNUb1N0b3JlID0gaW5pdGlhbElucHV0RGF0YVtkaXJlY3RpdmVJbmRleF0gfHwgKGluaXRpYWxJbnB1dERhdGFbZGlyZWN0aXZlSW5kZXhdID0gW10pO1xuICAgICAgICAgICAgaW5wdXRzVG9TdG9yZS5wdXNoKG1pbmlmaWVkSW5wdXROYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gMjtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxJbnB1dERhdGE7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyBWaWV3Q29udGFpbmVyICYgVmlld1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlcyBhIExDb250YWluZXIsIGVpdGhlciBmcm9tIGEgY29udGFpbmVyIGluc3RydWN0aW9uLCBvciBmb3IgYSBWaWV3Q29udGFpbmVyUmVmLlxuICpcbiAqIEBwYXJhbSBob3N0TmF0aXZlIFRoZSBob3N0IGVsZW1lbnQgZm9yIHRoZSBMQ29udGFpbmVyXG4gKiBAcGFyYW0gaG9zdFROb2RlIFRoZSBob3N0IFROb2RlIGZvciB0aGUgTENvbnRhaW5lclxuICogQHBhcmFtIGN1cnJlbnRWaWV3IFRoZSBwYXJlbnQgdmlldyBvZiB0aGUgTENvbnRhaW5lclxuICogQHBhcmFtIG5hdGl2ZSBUaGUgbmF0aXZlIGNvbW1lbnQgZWxlbWVudFxuICogQHBhcmFtIGlzRm9yVmlld0NvbnRhaW5lclJlZiBPcHRpb25hbCBhIGZsYWcgaW5kaWNhdGluZyB0aGUgVmlld0NvbnRhaW5lclJlZiBjYXNlXG4gKiBAcmV0dXJucyBMQ29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxDb250YWluZXIoaG9zdE5hdGl2ZSwgaG9zdFROb2RlLCBjdXJyZW50VmlldywgbmF0aXZlLCBpc0ZvclZpZXdDb250YWluZXJSZWYpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpc0ZvclZpZXdDb250YWluZXJSZWYgPyAtMSA6IDAsXG4gICAgICAgIFtdLFxuICAgICAgICBjdXJyZW50VmlldyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaG9zdE5hdGl2ZSxcbiAgICAgICAgbmF0aXZlLFxuICAgICAgICBnZXRSZW5kZXJQYXJlbnQoaG9zdFROb2RlLCBjdXJyZW50VmlldykgLy8gcmVuZGVyUGFyZW50XG4gICAgXTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBMQ29udGFpbmVyIGZvciBhbiBuZy10ZW1wbGF0ZSAoZHluYW1pY2FsbHktaW5zZXJ0ZWQgdmlldyksIGUuZy5cbiAqXG4gKiA8bmctdGVtcGxhdGUgI2Zvbz5cbiAqICAgIDxkaXY+PC9kaXY+XG4gKiA8L25nLXRlbXBsYXRlPlxuICpcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiB0aGUgZGF0YSBhcnJheVxuICogQHBhcmFtIHRlbXBsYXRlRm4gSW5saW5lIHRlbXBsYXRlXG4gKiBAcGFyYW0gY29uc3RzIFRoZSBudW1iZXIgb2Ygbm9kZXMsIGxvY2FsIHJlZnMsIGFuZCBwaXBlcyBmb3IgdGhpcyB0ZW1wbGF0ZVxuICogQHBhcmFtIHZhcnMgVGhlIG51bWJlciBvZiBiaW5kaW5ncyBmb3IgdGhpcyB0ZW1wbGF0ZVxuICogQHBhcmFtIHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBpZiBhcHBsaWNhYmxlXG4gKiBAcGFyYW0gYXR0cnMgVGhlIGF0dHJzIGF0dGFjaGVkIHRvIHRoZSBjb250YWluZXIsIGlmIGFwcGxpY2FibGVcbiAqIEBwYXJhbSBsb2NhbFJlZnMgQSBzZXQgb2YgbG9jYWwgcmVmZXJlbmNlIGJpbmRpbmdzIG9uIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIGxvY2FsUmVmRXh0cmFjdG9yIEEgZnVuY3Rpb24gd2hpY2ggZXh0cmFjdHMgbG9jYWwtcmVmcyB2YWx1ZXMgZnJvbSB0aGUgdGVtcGxhdGUuXG4gKiAgICAgICAgRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGxvY2FsLXJlZi5cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoaW5kZXgsIHRlbXBsYXRlRm4sIGNvbnN0cywgdmFycywgdGFnTmFtZSwgYXR0cnMsIGxvY2FsUmVmcywgbG9jYWxSZWZFeHRyYWN0b3IpIHtcbiAgICAvLyBUT0RPOiBjb25zaWRlciBhIHNlcGFyYXRlIG5vZGUgdHlwZSBmb3IgdGVtcGxhdGVzXG4gICAgdmFyIHROb2RlID0gY29udGFpbmVySW50ZXJuYWwoaW5kZXgsIHRhZ05hbWUgfHwgbnVsbCwgYXR0cnMgfHwgbnVsbCk7XG4gICAgaWYgKGZpcnN0VGVtcGxhdGVQYXNzKSB7XG4gICAgICAgIHROb2RlLnRWaWV3cyA9IGNyZWF0ZVRWaWV3KC0xLCB0ZW1wbGF0ZUZuLCBjb25zdHMsIHZhcnMsIHRWaWV3LmRpcmVjdGl2ZVJlZ2lzdHJ5LCB0Vmlldy5waXBlUmVnaXN0cnksIG51bGwpO1xuICAgIH1cbiAgICBjcmVhdGVEaXJlY3RpdmVzQW5kTG9jYWxzKGxvY2FsUmVmcywgbG9jYWxSZWZFeHRyYWN0b3IpO1xuICAgIGN1cnJlbnRRdWVyaWVzICYmXG4gICAgICAgIChjdXJyZW50UXVlcmllcyA9IGN1cnJlbnRRdWVyaWVzLmFkZE5vZGUocHJldmlvdXNPclBhcmVudFROb2RlKSk7XG4gICAgcXVldWVMaWZlY3ljbGVIb29rcyh0Tm9kZS5mbGFncywgdFZpZXcpO1xuICAgIGlzUGFyZW50ID0gZmFsc2U7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gTENvbnRhaW5lciBmb3IgaW5saW5lIHZpZXdzLCBlLmcuXG4gKlxuICogJSBpZiAoc2hvd2luZykge1xuICogICA8ZGl2PjwvZGl2PlxuICogJSB9XG4gKlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY29udGFpbmVyIGluIHRoZSBkYXRhIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5lcihpbmRleCkge1xuICAgIHZhciB0Tm9kZSA9IGNvbnRhaW5lckludGVybmFsKGluZGV4LCBudWxsLCBudWxsKTtcbiAgICBmaXJzdFRlbXBsYXRlUGFzcyAmJiAodE5vZGUudFZpZXdzID0gW10pO1xuICAgIGlzUGFyZW50ID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjb250YWluZXJJbnRlcm5hbChpbmRleCwgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RXF1YWwodmlld0RhdGFbQklORElOR19JTkRFWF0sIHRWaWV3LmJpbmRpbmdTdGFydEluZGV4LCAnY29udGFpbmVyIG5vZGVzIHNob3VsZCBiZSBjcmVhdGVkIGJlZm9yZSBhbnkgYmluZGluZ3MnKTtcbiAgICB2YXIgYWRqdXN0ZWRJbmRleCA9IGluZGV4ICsgSEVBREVSX09GRlNFVDtcbiAgICB2YXIgY29tbWVudCA9IHJlbmRlcmVyLmNyZWF0ZUNvbW1lbnQobmdEZXZNb2RlID8gJ2NvbnRhaW5lcicgOiAnJyk7XG4gICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlckNyZWF0ZUNvbW1lbnQrKztcbiAgICB2YXIgdE5vZGUgPSBjcmVhdGVOb2RlQXRJbmRleChpbmRleCwgMCAvKiBDb250YWluZXIgKi8sIGNvbW1lbnQsIHRhZ05hbWUsIGF0dHJzKTtcbiAgICB2YXIgbENvbnRhaW5lciA9IHZpZXdEYXRhW2FkanVzdGVkSW5kZXhdID1cbiAgICAgICAgY3JlYXRlTENvbnRhaW5lcih2aWV3RGF0YVthZGp1c3RlZEluZGV4XSwgdE5vZGUsIHZpZXdEYXRhLCBjb21tZW50KTtcbiAgICBhcHBlbmRDaGlsZChjb21tZW50LCB0Tm9kZSwgdmlld0RhdGEpO1xuICAgIC8vIENvbnRhaW5lcnMgYXJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IHZpZXcgdHJlZSBpbnN0ZWFkIG9mIHRoZWlyIGVtYmVkZGVkIHZpZXdzXG4gICAgLy8gYmVjYXVzZSB2aWV3cyBjYW4gYmUgcmVtb3ZlZCBhbmQgcmUtaW5zZXJ0ZWQuXG4gICAgYWRkVG9WaWV3VHJlZSh2aWV3RGF0YSwgaW5kZXggKyBIRUFERVJfT0ZGU0VULCBsQ29udGFpbmVyKTtcbiAgICBpZiAoY3VycmVudFF1ZXJpZXMpIHtcbiAgICAgICAgLy8gcHJlcGFyZSBwbGFjZSBmb3IgbWF0Y2hpbmcgbm9kZXMgZnJvbSB2aWV3cyBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gY29udGFpbmVyXG4gICAgICAgIGxDb250YWluZXJbUVVFUklFU10gPSBjdXJyZW50UXVlcmllcy5jb250YWluZXIoKTtcbiAgICB9XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydE5vZGVUeXBlKHByZXZpb3VzT3JQYXJlbnRUTm9kZSwgMCAvKiBDb250YWluZXIgKi8pO1xuICAgIHJldHVybiB0Tm9kZTtcbn1cbi8qKlxuICogU2V0cyBhIGNvbnRhaW5lciB1cCB0byByZWNlaXZlIHZpZXdzLlxuICpcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiB0aGUgZGF0YSBhcnJheVxuICovXG5mdW5jdGlvbiBjb250YWluZXJSZWZyZXNoU3RhcnQoaW5kZXgpIHtcbiAgICBwcmV2aW91c09yUGFyZW50VE5vZGUgPSBsb2FkSW50ZXJuYWwoaW5kZXgsIHRWaWV3LmRhdGEpO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlVHlwZShwcmV2aW91c09yUGFyZW50VE5vZGUsIDAgLyogQ29udGFpbmVyICovKTtcbiAgICBpc1BhcmVudCA9IHRydWU7XG4gICAgdmlld0RhdGFbaW5kZXggKyBIRUFERVJfT0ZGU0VUXVtBQ1RJVkVfSU5ERVhdID0gMDtcbiAgICBpZiAoIWNoZWNrTm9DaGFuZ2VzTW9kZSkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGV4ZWN1dGUgaW5pdCBob29rcyBoZXJlIHNvIG5nT25Jbml0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdG9wIGxldmVsIHZpZXdzXG4gICAgICAgIC8vIGJlZm9yZSB0aGV5IGFyZSBjYWxsZWQgaW4gZW1iZWRkZWQgdmlld3MgKGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICAgIGV4ZWN1dGVJbml0SG9va3Modmlld0RhdGEsIHRWaWV3LCBjcmVhdGlvbk1vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogTWFya3MgdGhlIGVuZCBvZiB0aGUgTENvbnRhaW5lci5cbiAqXG4gKiBNYXJraW5nIHRoZSBlbmQgb2YgTENvbnRhaW5lciBpcyB0aGUgdGltZSB3aGVuIHRvIGNoaWxkIHZpZXdzIGdldCBpbnNlcnRlZCBvciByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBjb250YWluZXJSZWZyZXNoRW5kKCkge1xuICAgIGlmIChpc1BhcmVudCkge1xuICAgICAgICBpc1BhcmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydE5vZGVUeXBlKHByZXZpb3VzT3JQYXJlbnRUTm9kZSwgMiAvKiBWaWV3ICovKTtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydEhhc1BhcmVudCgpO1xuICAgICAgICBwcmV2aW91c09yUGFyZW50VE5vZGUgPSBwcmV2aW91c09yUGFyZW50VE5vZGUucGFyZW50O1xuICAgIH1cbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm9kZVR5cGUocHJldmlvdXNPclBhcmVudFROb2RlLCAwIC8qIENvbnRhaW5lciAqLyk7XG4gICAgdmFyIGxDb250YWluZXIgPSB2aWV3RGF0YVtwcmV2aW91c09yUGFyZW50VE5vZGUuaW5kZXhdO1xuICAgIHZhciBuZXh0SW5kZXggPSBsQ29udGFpbmVyW0FDVElWRV9JTkRFWF07XG4gICAgLy8gcmVtb3ZlIGV4dHJhIHZpZXdzIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lclxuICAgIHdoaWxlIChuZXh0SW5kZXggPCBsQ29udGFpbmVyW1ZJRVdTXS5sZW5ndGgpIHtcbiAgICAgICAgcmVtb3ZlVmlldyhsQ29udGFpbmVyLCBwcmV2aW91c09yUGFyZW50VE5vZGUsIG5leHRJbmRleCk7XG4gICAgfVxufVxuLyoqXG4gKiBHb2VzIG92ZXIgZHluYW1pYyBlbWJlZGRlZCB2aWV3cyAob25lcyBjcmVhdGVkIHRocm91Z2ggVmlld0NvbnRhaW5lclJlZiBBUElzKSBhbmQgcmVmcmVzaGVzIHRoZW1cbiAqIGJ5IGV4ZWN1dGluZyBhbiBhc3NvY2lhdGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiByZWZyZXNoRHluYW1pY0VtYmVkZGVkVmlld3MobFZpZXdEYXRhKSB7XG4gICAgZm9yICh2YXIgY3VycmVudCA9IGdldExWaWV3Q2hpbGQobFZpZXdEYXRhKTsgY3VycmVudCAhPT0gbnVsbDsgY3VycmVudCA9IGN1cnJlbnRbTkVYVF0pIHtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudCBjYW4gYmUgYW4gTFZpZXdEYXRhIG9yIGFuIExDb250YWluZXIgaW5zdGFuY2UsIGJ1dCBoZXJlIHdlIGFyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgLy8gaW4gTENvbnRhaW5lci4gV2UgY2FuIHRlbGwgaXQncyBhbiBMQ29udGFpbmVyIGJlY2F1c2UgaXRzIGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIExWaWV3RGF0YVxuICAgICAgICAvLyBoZWFkZXIuXG4gICAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA8IEhFQURFUl9PRkZTRVQgJiYgY3VycmVudFtBQ1RJVkVfSU5ERVhdID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lcl8xID0gY3VycmVudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVyXzFbVklFV1NdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNWaWV3RGF0YSA9IGNvbnRhaW5lcl8xW1ZJRVdTXVtpXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGlyZWN0aXZlcyBhbmQgcGlwZXMgYXJlIG5vdCBuZWVkZWQgaGVyZSBhcyBhbiBleGlzdGluZyB2aWV3IGlzIG9ubHkgYmVpbmcgcmVmcmVzaGVkLlxuICAgICAgICAgICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGR5bmFtaWNWaWV3RGF0YVtUVklFV10sICdUVmlldyBtdXN0IGJlIGFsbG9jYXRlZCcpO1xuICAgICAgICAgICAgICAgIHJlbmRlckVtYmVkZGVkVGVtcGxhdGUoZHluYW1pY1ZpZXdEYXRhLCBkeW5hbWljVmlld0RhdGFbVFZJRVddLCBkeW5hbWljVmlld0RhdGFbQ09OVEVYVF0sIDIgLyogVXBkYXRlICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTG9va3MgZm9yIGEgdmlldyB3aXRoIGEgZ2l2ZW4gdmlldyBibG9jayBpZCBpbnNpZGUgYSBwcm92aWRlZCBMQ29udGFpbmVyLlxuICogUmVtb3ZlcyB2aWV3cyB0aGF0IG5lZWQgdG8gYmUgZGVsZXRlZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiBAcGFyYW0gbENvbnRhaW5lciB0byBzZWFyY2ggZm9yIHZpZXdzXG4gKiBAcGFyYW0gdENvbnRhaW5lck5vZGUgdG8gc2VhcmNoIGZvciB2aWV3c1xuICogQHBhcmFtIHN0YXJ0SWR4IHN0YXJ0aW5nIGluZGV4IGluIHRoZSB2aWV3cyBhcnJheSB0byBzZWFyY2ggZnJvbVxuICogQHBhcmFtIHZpZXdCbG9ja0lkIGV4YWN0IHZpZXcgYmxvY2sgaWQgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIGluZGV4IG9mIGEgZm91bmQgdmlldyBvciAtMSBpZiBub3QgZm91bmRcbiAqL1xuZnVuY3Rpb24gc2NhbkZvclZpZXcobENvbnRhaW5lciwgdENvbnRhaW5lck5vZGUsIHN0YXJ0SWR4LCB2aWV3QmxvY2tJZCkge1xuICAgIHZhciB2aWV3cyA9IGxDb250YWluZXJbVklFV1NdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydElkeDsgaSA8IHZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2aWV3QXRQb3NpdGlvbklkID0gdmlld3NbaV1bVFZJRVddLmlkO1xuICAgICAgICBpZiAodmlld0F0UG9zaXRpb25JZCA9PT0gdmlld0Jsb2NrSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3QXRQb3NpdGlvbklkIDwgdmlld0Jsb2NrSWQpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIGEgdmlldyB0aGF0IHNob3VsZCBub3QgYmUgYXQgdGhpcyBwb3NpdGlvbiAtIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVmlldyhsQ29udGFpbmVyLCB0Q29udGFpbmVyTm9kZSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3VuZCBhIHZpZXcgd2l0aCBpZCBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCByZXF1aXJlZCB2aWV3IGRvZXNuJ3QgZXhpc3QgYW5kIGNhbid0IGJlIGZvdW5kIGF0XG4gICAgICAgICAgICAvLyBsYXRlciBwb3NpdGlvbnMgaW4gdGhlIHZpZXdzIGFycmF5IC0gc3RvcCB0aGUgc2VhcmNoIGhlcmVcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBNYXJrcyB0aGUgc3RhcnQgb2YgYW4gZW1iZWRkZWQgdmlldy5cbiAqXG4gKiBAcGFyYW0gdmlld0Jsb2NrSWQgVGhlIElEIG9mIHRoaXMgdmlld1xuICogQHJldHVybiBib29sZWFuIFdoZXRoZXIgb3Igbm90IHRoaXMgdmlldyBpcyBpbiBjcmVhdGlvbiBtb2RlXG4gKi9cbmZ1bmN0aW9uIGVtYmVkZGVkVmlld1N0YXJ0KHZpZXdCbG9ja0lkLCBjb25zdHMsIHZhcnMpIHtcbiAgICAvLyBUaGUgcHJldmlvdXMgbm9kZSBjYW4gYmUgYSB2aWV3IG5vZGUgaWYgd2UgYXJlIHByb2Nlc3NpbmcgYW4gaW5saW5lIGZvciBsb29wXG4gICAgdmFyIGNvbnRhaW5lclROb2RlID0gcHJldmlvdXNPclBhcmVudFROb2RlLnR5cGUgPT09IDIgLyogVmlldyAqLyA/XG4gICAgICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZS5wYXJlbnQgOlxuICAgICAgICBwcmV2aW91c09yUGFyZW50VE5vZGU7XG4gICAgdmFyIGxDb250YWluZXIgPSB2aWV3RGF0YVtjb250YWluZXJUTm9kZS5pbmRleF07XG4gICAgdmFyIGN1cnJlbnRWaWV3ID0gdmlld0RhdGE7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydE5vZGVUeXBlKGNvbnRhaW5lclROb2RlLCAwIC8qIENvbnRhaW5lciAqLyk7XG4gICAgdmFyIHZpZXdUb1JlbmRlciA9IHNjYW5Gb3JWaWV3KGxDb250YWluZXIsIGNvbnRhaW5lclROb2RlLCBsQ29udGFpbmVyW0FDVElWRV9JTkRFWF0sIHZpZXdCbG9ja0lkKTtcbiAgICBpZiAodmlld1RvUmVuZGVyKSB7XG4gICAgICAgIGlzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgZW50ZXJWaWV3KHZpZXdUb1JlbmRlciwgdmlld1RvUmVuZGVyW1RWSUVXXS5ub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gd2UgY3JlYXRlIGEgbmV3IExWaWV3LCB3ZSBhbHdheXMgcmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBpbnN0cnVjdGlvbnMuXG4gICAgICAgIHZpZXdUb1JlbmRlciA9IGNyZWF0ZUxWaWV3RGF0YShyZW5kZXJlciwgZ2V0T3JDcmVhdGVFbWJlZGRlZFRWaWV3KHZpZXdCbG9ja0lkLCBjb25zdHMsIHZhcnMsIGNvbnRhaW5lclROb2RlKSwgbnVsbCwgMiAvKiBDaGVja0Fsd2F5cyAqLywgZ2V0Q3VycmVudFNhbml0aXplcigpKTtcbiAgICAgICAgaWYgKGxDb250YWluZXJbUVVFUklFU10pIHtcbiAgICAgICAgICAgIHZpZXdUb1JlbmRlcltRVUVSSUVTXSA9IGxDb250YWluZXJbUVVFUklFU10uY3JlYXRlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVZpZXdOb2RlKHZpZXdCbG9ja0lkLCB2aWV3VG9SZW5kZXIpO1xuICAgICAgICBlbnRlclZpZXcodmlld1RvUmVuZGVyLCB2aWV3VG9SZW5kZXJbVFZJRVddLm5vZGUpO1xuICAgIH1cbiAgICBpZiAobENvbnRhaW5lcikge1xuICAgICAgICBpZiAoY3JlYXRpb25Nb2RlKSB7XG4gICAgICAgICAgICAvLyBpdCBpcyBhIG5ldyB2aWV3LCBpbnNlcnQgaXQgaW50byBjb2xsZWN0aW9uIG9mIHZpZXdzIGZvciBhIGdpdmVuIGNvbnRhaW5lclxuICAgICAgICAgICAgaW5zZXJ0Vmlldyh2aWV3VG9SZW5kZXIsIGxDb250YWluZXIsIGN1cnJlbnRWaWV3LCBsQ29udGFpbmVyW0FDVElWRV9JTkRFWF0sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBsQ29udGFpbmVyW0FDVElWRV9JTkRFWF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGdldFJlbmRlckZsYWdzKHZpZXdUb1JlbmRlcik7XG59XG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFRWaWV3IChlLmcuIHN0YXRpYyBkYXRhKSBmb3IgdGhlIGFjdGl2ZSBlbWJlZGRlZCB2aWV3LlxuICpcbiAqIEVhY2ggZW1iZWRkZWQgdmlldyBibG9jayBtdXN0IGNyZWF0ZSBvciByZXRyaWV2ZSBpdHMgb3duIFRWaWV3LiBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCB2aWV3J3NcbiAqIHN0YXRpYyBkYXRhIGZvciBhIHBhcnRpY3VsYXIgbm9kZSB3b3VsZCBvdmVyd3JpdGUgdGhlIHN0YXRpYyBkYXRhIGZvciBhIG5vZGUgaW4gdGhlIHZpZXcgYWJvdmVcbiAqIGl0IHdpdGggdGhlIHNhbWUgaW5kZXggKHNpbmNlIGl0J3MgaW4gdGhlIHNhbWUgdGVtcGxhdGUpLlxuICpcbiAqIEBwYXJhbSB2aWV3SW5kZXggVGhlIGluZGV4IG9mIHRoZSBUVmlldyBpbiBUTm9kZS50Vmlld3NcbiAqIEBwYXJhbSBjb25zdHMgVGhlIG51bWJlciBvZiBub2RlcywgbG9jYWwgcmVmcywgYW5kIHBpcGVzIGluIHRoaXMgdGVtcGxhdGVcbiAqIEBwYXJhbSB2YXJzIFRoZSBudW1iZXIgb2YgYmluZGluZ3MgYW5kIHB1cmUgZnVuY3Rpb24gYmluZGluZ3MgaW4gdGhpcyB0ZW1wbGF0ZVxuICogQHBhcmFtIGNvbnRhaW5lciBUaGUgcGFyZW50IGNvbnRhaW5lciBpbiB3aGljaCB0byBsb29rIGZvciB0aGUgdmlldydzIHN0YXRpYyBkYXRhXG4gKiBAcmV0dXJucyBUVmlld1xuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUVtYmVkZGVkVFZpZXcodmlld0luZGV4LCBjb25zdHMsIHZhcnMsIHBhcmVudCkge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlVHlwZShwYXJlbnQsIDAgLyogQ29udGFpbmVyICovKTtcbiAgICB2YXIgY29udGFpbmVyVFZpZXdzID0gcGFyZW50LnRWaWV3cztcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGVmaW5lZChjb250YWluZXJUVmlld3MsICdUVmlldyBleHBlY3RlZCcpO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbChBcnJheS5pc0FycmF5KGNvbnRhaW5lclRWaWV3cyksIHRydWUsICdUVmlld3Mgc2hvdWxkIGJlIGluIGFuIGFycmF5Jyk7XG4gICAgaWYgKHZpZXdJbmRleCA+PSBjb250YWluZXJUVmlld3MubGVuZ3RoIHx8IGNvbnRhaW5lclRWaWV3c1t2aWV3SW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyVFZpZXdzW3ZpZXdJbmRleF0gPSBjcmVhdGVUVmlldyh2aWV3SW5kZXgsIG51bGwsIGNvbnN0cywgdmFycywgdFZpZXcuZGlyZWN0aXZlUmVnaXN0cnksIHRWaWV3LnBpcGVSZWdpc3RyeSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXJUVmlld3Nbdmlld0luZGV4XTtcbn1cbi8qKiBNYXJrcyB0aGUgZW5kIG9mIGFuIGVtYmVkZGVkIHZpZXcuICovXG5mdW5jdGlvbiBlbWJlZGRlZFZpZXdFbmQoKSB7XG4gICAgdmFyIHZpZXdIb3N0ID0gdmlld0RhdGFbSE9TVF9OT0RFXTtcbiAgICByZWZyZXNoRGVzY2VuZGFudFZpZXdzKCk7XG4gICAgbGVhdmVWaWV3KHZpZXdEYXRhW1BBUkVOVF0pO1xuICAgIHByZXZpb3VzT3JQYXJlbnRUTm9kZSA9IHZpZXdIb3N0O1xuICAgIGlzUGFyZW50ID0gZmFsc2U7XG59XG4vLy8vLy8vLy8vLy8vXG4vKipcbiAqIFJlZnJlc2hlcyBjb21wb25lbnRzIGJ5IGVudGVyaW5nIHRoZSBjb21wb25lbnQgdmlldyBhbmQgcHJvY2Vzc2luZyBpdHMgYmluZGluZ3MsIHF1ZXJpZXMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYWRqdXN0ZWRFbGVtZW50SW5kZXggIEVsZW1lbnQgaW5kZXggaW4gTFZpZXdEYXRhW10gKGFkanVzdGVkIGZvciBIRUFERVJfT0ZGU0VUKVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRSZWZyZXNoKGFkanVzdGVkRWxlbWVudEluZGV4LCBwYXJlbnRGaXJzdFRlbXBsYXRlUGFzcykge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREYXRhSW5SYW5nZShhZGp1c3RlZEVsZW1lbnRJbmRleCk7XG4gICAgdmFyIGhvc3RWaWV3ID0gZ2V0Q29tcG9uZW50Vmlld0J5SW5kZXgoYWRqdXN0ZWRFbGVtZW50SW5kZXgsIHZpZXdEYXRhKTtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm9kZVR5cGUodFZpZXcuZGF0YVthZGp1c3RlZEVsZW1lbnRJbmRleF0sIDMgLyogRWxlbWVudCAqLyk7XG4gICAgLy8gT25seSBhdHRhY2hlZCBDaGVja0Fsd2F5cyBjb21wb25lbnRzIG9yIGF0dGFjaGVkLCBkaXJ0eSBPblB1c2ggY29tcG9uZW50cyBzaG91bGQgYmUgY2hlY2tlZFxuICAgIGlmICh2aWV3QXR0YWNoZWQoaG9zdFZpZXcpICYmIGhvc3RWaWV3W0ZMQUdTXSAmICgyIC8qIENoZWNrQWx3YXlzICovIHwgNCAvKiBEaXJ0eSAqLykpIHtcbiAgICAgICAgcGFyZW50Rmlyc3RUZW1wbGF0ZVBhc3MgJiYgc3luY1ZpZXdXaXRoQmx1ZXByaW50KGhvc3RWaWV3KTtcbiAgICAgICAgZGV0ZWN0Q2hhbmdlc0ludGVybmFsKGhvc3RWaWV3LCBob3N0Vmlld1tDT05URVhUXSk7XG4gICAgfVxufVxuLyoqXG4gKiBTeW5jcyBhbiBMVmlld0RhdGEgaW5zdGFuY2Ugd2l0aCBpdHMgYmx1ZXByaW50IGlmIHRoZXkgaGF2ZSBnb3R0ZW4gb3V0IG9mIHN5bmMuXG4gKlxuICogVHlwaWNhbGx5LCBibHVlcHJpbnRzIGFuZCB0aGVpciB2aWV3IGluc3RhbmNlcyBzaG91bGQgYWx3YXlzIGJlIGluIHN5bmMsIHNvIHRoZSBsb29wIGhlcmVcbiAqIHdpbGwgYmUgc2tpcHBlZC4gSG93ZXZlciwgY29uc2lkZXIgdGhpcyBjYXNlIG9mIHR3byBjb21wb25lbnRzIHNpZGUtYnktc2lkZTpcbiAqXG4gKiBBcHAgdGVtcGxhdGU6XG4gKiBgYGBcbiAqIDxjb21wPjwvY29tcD5cbiAqIDxjb21wPjwvY29tcD5cbiAqIGBgYFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd2lsbCBoYXBwZW46XG4gKiAxLiBBcHAgdGVtcGxhdGUgYmVnaW5zIHByb2Nlc3NpbmcuXG4gKiAyLiBGaXJzdCA8Y29tcD4gaXMgbWF0Y2hlZCBhcyBhIGNvbXBvbmVudCBhbmQgaXRzIExWaWV3RGF0YSBpcyBjcmVhdGVkLlxuICogMy4gU2Vjb25kIDxjb21wPiBpcyBtYXRjaGVkIGFzIGEgY29tcG9uZW50IGFuZCBpdHMgTFZpZXdEYXRhIGlzIGNyZWF0ZWQuXG4gKiA0LiBBcHAgdGVtcGxhdGUgY29tcGxldGVzIHByb2Nlc3NpbmcsIHNvIGl0J3MgdGltZSB0byBjaGVjayBjaGlsZCB0ZW1wbGF0ZXMuXG4gKiA1LiBGaXJzdCA8Y29tcD4gdGVtcGxhdGUgaXMgY2hlY2tlZC4gSXQgaGFzIGEgZGlyZWN0aXZlLCBzbyBpdHMgZGVmIGlzIHB1c2hlZCB0byBibHVlcHJpbnQuXG4gKiA2LiBTZWNvbmQgPGNvbXA+IHRlbXBsYXRlIGlzIGNoZWNrZWQuIEl0cyBibHVlcHJpbnQgaGFzIGJlZW4gdXBkYXRlZCBieSB0aGUgZmlyc3RcbiAqIDxjb21wPiB0ZW1wbGF0ZSwgYnV0IGl0cyBMVmlld0RhdGEgd2FzIGNyZWF0ZWQgYmVmb3JlIHRoaXMgdXBkYXRlLCBzbyBpdCBpcyBvdXQgb2Ygc3luYy5cbiAqXG4gKiBOb3RlIHRoYXQgZW1iZWRkZWQgdmlld3MgaW5zaWRlIG5nRm9yIGxvb3BzIHdpbGwgbmV2ZXIgYmUgb3V0IG9mIHN5bmMgYmVjYXVzZSB0aGVzZSB2aWV3c1xuICogYXJlIHByb2Nlc3NlZCBhcyBzb29uIGFzIHRoZXkgYXJlIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFZpZXcgVGhlIHZpZXcgdG8gc3luY1xuICovXG5mdW5jdGlvbiBzeW5jVmlld1dpdGhCbHVlcHJpbnQoY29tcG9uZW50Vmlldykge1xuICAgIHZhciBjb21wb25lbnRUVmlldyA9IGNvbXBvbmVudFZpZXdbVFZJRVddO1xuICAgIGZvciAodmFyIGkgPSBjb21wb25lbnRWaWV3Lmxlbmd0aDsgaSA8IGNvbXBvbmVudFRWaWV3LmJsdWVwcmludC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb21wb25lbnRWaWV3W2ldID0gY29tcG9uZW50VFZpZXcuYmx1ZXByaW50W2ldO1xuICAgIH1cbn1cbi8qKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3Igd2hldGhlciB0aGUgdmlldyBpcyBhdHRhY2hlZCAqL1xuZnVuY3Rpb24gdmlld0F0dGFjaGVkKHZpZXcpIHtcbiAgICByZXR1cm4gKHZpZXdbRkxBR1NdICYgOCAvKiBBdHRhY2hlZCAqLykgPT09IDggLyogQXR0YWNoZWQgKi87XG59XG4vKipcbiAqIEluc3RydWN0aW9uIHRvIGRpc3RyaWJ1dGUgcHJvamVjdGFibGUgbm9kZXMgYW1vbmcgPG5nLWNvbnRlbnQ+IG9jY3VycmVuY2VzIGluIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gKiBJdCB0YWtlcyBhbGwgdGhlIHNlbGVjdG9ycyBmcm9tIHRoZSBlbnRpcmUgY29tcG9uZW50J3MgdGVtcGxhdGUgYW5kIGRlY2lkZXMgd2hlcmVcbiAqIGVhY2ggcHJvamVjdGVkIG5vZGUgYmVsb25ncyAoaXQgcmUtZGlzdHJpYnV0ZXMgbm9kZXMgYW1vbmcgXCJidWNrZXRzXCIgd2hlcmUgZWFjaCBcImJ1Y2tldFwiIGlzXG4gKiBiYWNrZWQgYnkgYSBzZWxlY3RvcikuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXF1aXJlcyBDU1Mgc2VsZWN0b3JzIHRvIGJlIHByb3ZpZGVkIGluIDIgZm9ybXM6IHBhcnNlZCAoYnkgYSBjb21waWxlcikgYW5kIHRleHQsXG4gKiB1bi1wYXJzZWQgZm9ybS5cbiAqXG4gKiBUaGUgcGFyc2VkIGZvcm0gaXMgbmVlZGVkIGZvciBlZmZpY2llbnQgbWF0Y2hpbmcgb2YgYSBub2RlIGFnYWluc3QgYSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gKiBUaGUgdW4tcGFyc2VkLCB0ZXh0dWFsIGZvcm0gaXMgbmVlZGVkIGZvciBzdXBwb3J0IG9mIHRoZSBuZ1Byb2plY3RBcyBhdHRyaWJ1dGUuXG4gKlxuICogSGF2aW5nIGEgQ1NTIHNlbGVjdG9yIGluIDIgZGlmZmVyZW50IGZvcm1hdHMgaXMgbm90IGlkZWFsLCBidXQgYWx0ZXJuYXRpdmVzIGhhdmUgZXZlbiBtb3JlXG4gKiBkcmF3YmFja3M6XG4gKiAtIGhhdmluZyBvbmx5IGEgdGV4dHVhbCBmb3JtIHdvdWxkIHJlcXVpcmUgcnVudGltZSBwYXJzaW5nIG9mIENTUyBzZWxlY3RvcnM7XG4gKiAtIHdlIGNhbid0IGhhdmUgb25seSBhIHBhcnNlZCBhcyB3ZSBjYW4ndCByZS1jb25zdHJ1Y3QgdGV4dHVhbCBmb3JtIGZyb20gaXQgKGFzIGVudGVyZWQgYnkgYVxuICogdGVtcGxhdGUgYXV0aG9yKS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3JzIEEgY29sbGVjdGlvbiBvZiBwYXJzZWQgQ1NTIHNlbGVjdG9yc1xuICogQHBhcmFtIHJhd1NlbGVjdG9ycyBBIGNvbGxlY3Rpb24gb2YgQ1NTIHNlbGVjdG9ycyBpbiB0aGUgcmF3LCB1bi1wYXJzZWQgZm9ybVxuICovXG5mdW5jdGlvbiBwcm9qZWN0aW9uRGVmKHNlbGVjdG9ycywgdGV4dFNlbGVjdG9ycykge1xuICAgIHZhciBjb21wb25lbnROb2RlID0gZmluZENvbXBvbmVudFZpZXcodmlld0RhdGEpW0hPU1RfTk9ERV07XG4gICAgaWYgKCFjb21wb25lbnROb2RlLnByb2plY3Rpb24pIHtcbiAgICAgICAgdmFyIG5vT2ZOb2RlQnVja2V0cyA9IHNlbGVjdG9ycyA/IHNlbGVjdG9ycy5sZW5ndGggKyAxIDogMTtcbiAgICAgICAgdmFyIHBEYXRhID0gY29tcG9uZW50Tm9kZS5wcm9qZWN0aW9uID1cbiAgICAgICAgICAgIG5ldyBBcnJheShub09mTm9kZUJ1Y2tldHMpLmZpbGwobnVsbCk7XG4gICAgICAgIHZhciB0YWlscyA9IHBEYXRhLnNsaWNlKCk7XG4gICAgICAgIHZhciBjb21wb25lbnRDaGlsZCA9IGNvbXBvbmVudE5vZGUuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChjb21wb25lbnRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldEluZGV4ID0gc2VsZWN0b3JzID8gbWF0Y2hpbmdTZWxlY3RvckluZGV4KGNvbXBvbmVudENoaWxkLCBzZWxlY3RvcnMsIHRleHRTZWxlY3RvcnMpIDogMDtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IGNvbXBvbmVudENoaWxkLm5leHQ7XG4gICAgICAgICAgICBpZiAodGFpbHNbYnVja2V0SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdGFpbHNbYnVja2V0SW5kZXhdLm5leHQgPSBjb21wb25lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBEYXRhW2J1Y2tldEluZGV4XSA9IGNvbXBvbmVudENoaWxkO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENoaWxkLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFpbHNbYnVja2V0SW5kZXhdID0gY29tcG9uZW50Q2hpbGQ7XG4gICAgICAgICAgICBjb21wb25lbnRDaGlsZCA9IG5leHROb2RlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTdGFjayB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgcHJvamVjdGlvbiBub2RlcyBpbiBwcm9qZWN0aW9uKCkgaW5zdHJ1Y3Rpb24uXG4gKlxuICogVGhpcyBpcyBkZWxpYmVyYXRlbHkgY3JlYXRlZCBvdXRzaWRlIG9mIHByb2plY3Rpb24oKSB0byBhdm9pZCBhbGxvY2F0aW5nXG4gKiBhIG5ldyBhcnJheSBlYWNoIHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gSW5zdGVhZCB0aGUgYXJyYXkgd2lsbCBiZVxuICogcmUtdXNlZCBieSBlYWNoIGludm9jYXRpb24uIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgbm90IHJlZW50cmFudC5cbiAqL1xudmFyIHByb2plY3Rpb25Ob2RlU3RhY2skMSA9IFtdO1xuLyoqXG4gKiBJbnNlcnRzIHByZXZpb3VzbHkgcmUtZGlzdHJpYnV0ZWQgcHJvamVjdGVkIG5vZGVzLiBUaGlzIGluc3RydWN0aW9uIG11c3QgYmUgcHJlY2VkZWQgYnkgYSBjYWxsXG4gKiB0byB0aGUgcHJvamVjdGlvbkRlZiBpbnN0cnVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gbm9kZUluZGV4XG4gKiBAcGFyYW0gc2VsZWN0b3JJbmRleDpcbiAqICAgICAgICAtIDAgd2hlbiB0aGUgc2VsZWN0b3IgaXMgYCpgIChvciB1bnNwZWNpZmllZCBhcyB0aGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlKSxcbiAqICAgICAgICAtIDEgYmFzZWQgaW5kZXggb2YgdGhlIHNlbGVjdG9yIGZyb20gdGhlIHtAbGluayBwcm9qZWN0aW9uRGVmfVxuICovXG5mdW5jdGlvbiBwcm9qZWN0aW9uKG5vZGVJbmRleCwgc2VsZWN0b3JJbmRleCwgYXR0cnMpIHtcbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gdm9pZCAwKSB7IHNlbGVjdG9ySW5kZXggPSAwOyB9XG4gICAgdmFyIHRQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZU5vZGVBdEluZGV4KG5vZGVJbmRleCwgMSAvKiBQcm9qZWN0aW9uICovLCBudWxsLCBudWxsLCBhdHRycyB8fCBudWxsKTtcbiAgICAvLyBXZSBjYW4ndCB1c2Ugdmlld0RhdGFbSE9TVF9OT0RFXSBiZWNhdXNlIHByb2plY3Rpb24gbm9kZXMgY2FuIGJlIG5lc3RlZCBpbiBlbWJlZGRlZCB2aWV3cy5cbiAgICBpZiAodFByb2plY3Rpb25Ob2RlLnByb2plY3Rpb24gPT09IG51bGwpXG4gICAgICAgIHRQcm9qZWN0aW9uTm9kZS5wcm9qZWN0aW9uID0gc2VsZWN0b3JJbmRleDtcbiAgICAvLyBgPG5nLWNvbnRlbnQ+YCBoYXMgbm8gY29udGVudFxuICAgIGlzUGFyZW50ID0gZmFsc2U7XG4gICAgLy8gcmUtZGlzdHJpYnV0aW9uIG9mIHByb2plY3RhYmxlIG5vZGVzIGlzIHN0b3JlZCBvbiBhIGNvbXBvbmVudCdzIHZpZXcgbGV2ZWxcbiAgICB2YXIgY29tcG9uZW50VmlldyA9IGZpbmRDb21wb25lbnRWaWV3KHZpZXdEYXRhKTtcbiAgICB2YXIgY29tcG9uZW50Tm9kZSA9IGNvbXBvbmVudFZpZXdbSE9TVF9OT0RFXTtcbiAgICB2YXIgbm9kZVRvUHJvamVjdCA9IGNvbXBvbmVudE5vZGUucHJvamVjdGlvbltzZWxlY3RvckluZGV4XTtcbiAgICB2YXIgcHJvamVjdGVkVmlldyA9IGNvbXBvbmVudFZpZXdbUEFSRU5UXTtcbiAgICB2YXIgcHJvamVjdGlvbk5vZGVJbmRleCA9IC0xO1xuICAgIHdoaWxlIChub2RlVG9Qcm9qZWN0KSB7XG4gICAgICAgIGlmIChub2RlVG9Qcm9qZWN0LnR5cGUgPT09IDEgLyogUHJvamVjdGlvbiAqLykge1xuICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIHJlLXByb2plY3RlZCwgc28gd2UgbXVzdCBnbyB1cCB0aGUgdHJlZSB0byBnZXQgaXRzIHByb2plY3RlZCBub2Rlcy5cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9uZW50VmlldyA9IGZpbmRDb21wb25lbnRWaWV3KHByb2plY3RlZFZpZXcpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDb21wb25lbnRIb3N0ID0gY3VycmVudENvbXBvbmVudFZpZXdbSE9TVF9OT0RFXTtcbiAgICAgICAgICAgIHZhciBmaXJzdFByb2plY3RlZE5vZGUgPSBjdXJyZW50Q29tcG9uZW50SG9zdC5wcm9qZWN0aW9uW25vZGVUb1Byb2plY3QucHJvamVjdGlvbl07XG4gICAgICAgICAgICBpZiAoZmlyc3RQcm9qZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbk5vZGVTdGFjayQxWysrcHJvamVjdGlvbk5vZGVJbmRleF0gPSBub2RlVG9Qcm9qZWN0O1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25Ob2RlU3RhY2skMVsrK3Byb2plY3Rpb25Ob2RlSW5kZXhdID0gcHJvamVjdGVkVmlldztcbiAgICAgICAgICAgICAgICBub2RlVG9Qcm9qZWN0ID0gZmlyc3RQcm9qZWN0ZWROb2RlO1xuICAgICAgICAgICAgICAgIHByb2plY3RlZFZpZXcgPSBjdXJyZW50Q29tcG9uZW50Vmlld1tQQVJFTlRdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIG11c3QgYmUgc2V0IG5vdyBvciB3ZSB3b24ndCBrbm93IHRoYXQgdGhpcyBub2RlIGlzIHByb2plY3RlZFxuICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGVzIGFyZSBpbnNlcnRlZCBpbnRvIGEgY29udGFpbmVyIGxhdGVyLlxuICAgICAgICAgICAgbm9kZVRvUHJvamVjdC5mbGFncyB8PSA4MTkyIC8qIGlzUHJvamVjdGVkICovO1xuICAgICAgICAgICAgYXBwZW5kUHJvamVjdGVkTm9kZShub2RlVG9Qcm9qZWN0LCB0UHJvamVjdGlvbk5vZGUsIHZpZXdEYXRhLCBwcm9qZWN0ZWRWaWV3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgZmluaXNoZWQgd2l0aCBhIGxpc3Qgb2YgcmUtcHJvamVjdGVkIG5vZGVzLCB3ZSBuZWVkIHRvIGdldFxuICAgICAgICAvLyBiYWNrIHRvIHRoZSByb290IHByb2plY3Rpb24gbm9kZSB0aGF0IHdhcyByZS1wcm9qZWN0ZWQuXG4gICAgICAgIGlmIChub2RlVG9Qcm9qZWN0Lm5leHQgPT09IG51bGwgJiYgcHJvamVjdGVkVmlldyAhPT0gY29tcG9uZW50Vmlld1tQQVJFTlRdKSB7XG4gICAgICAgICAgICBwcm9qZWN0ZWRWaWV3ID0gcHJvamVjdGlvbk5vZGVTdGFjayQxW3Byb2plY3Rpb25Ob2RlSW5kZXgtLV07XG4gICAgICAgICAgICBub2RlVG9Qcm9qZWN0ID0gcHJvamVjdGlvbk5vZGVTdGFjayQxW3Byb2plY3Rpb25Ob2RlSW5kZXgtLV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVRvUHJvamVjdCA9IG5vZGVUb1Byb2plY3QubmV4dDtcbiAgICB9XG59XG4vKipcbiAqIEFkZHMgTFZpZXdEYXRhIG9yIExDb250YWluZXIgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCB2aWV3IHRyZWUuXG4gKlxuICogVGhpcyBzdHJ1Y3R1cmUgd2lsbCBiZSB1c2VkIHRvIHRyYXZlcnNlIHRocm91Z2ggbmVzdGVkIHZpZXdzIHRvIHJlbW92ZSBsaXN0ZW5lcnNcbiAqIGFuZCBjYWxsIG9uRGVzdHJveSBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWaWV3IFRoZSB2aWV3IHdoZXJlIExWaWV3RGF0YSBvciBMQ29udGFpbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHBhcmFtIGFkanVzdGVkSG9zdEluZGV4IEluZGV4IG9mIHRoZSB2aWV3J3MgaG9zdCBub2RlIGluIExWaWV3RGF0YVtdLCBhZGp1c3RlZCBmb3IgaGVhZGVyXG4gKiBAcGFyYW0gc3RhdGUgVGhlIExWaWV3RGF0YSBvciBMQ29udGFpbmVyIHRvIGFkZCB0byB0aGUgdmlldyB0cmVlXG4gKiBAcmV0dXJucyBUaGUgc3RhdGUgcGFzc2VkIGluXG4gKi9cbmZ1bmN0aW9uIGFkZFRvVmlld1RyZWUoY3VycmVudFZpZXcsIGFkanVzdGVkSG9zdEluZGV4LCBzdGF0ZSkge1xuICAgIGlmIChjdXJyZW50Vmlld1tUQUlMXSkge1xuICAgICAgICBjdXJyZW50Vmlld1tUQUlMXVtORVhUXSA9IHN0YXRlO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB0Vmlldy5jaGlsZEluZGV4ID0gYWRqdXN0ZWRIb3N0SW5kZXg7XG4gICAgfVxuICAgIGN1cnJlbnRWaWV3W1RBSUxdID0gc3RhdGU7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyBDaGFuZ2UgZGV0ZWN0aW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKiogSWYgbm9kZSBpcyBhbiBPblB1c2ggY29tcG9uZW50LCBtYXJrcyBpdHMgTFZpZXdEYXRhIGRpcnR5LiAqL1xuZnVuY3Rpb24gbWFya0RpcnR5SWZPblB1c2godmlld0luZGV4KSB7XG4gICAgdmFyIHZpZXcgPSBnZXRDb21wb25lbnRWaWV3QnlJbmRleCh2aWV3SW5kZXgsIHZpZXdEYXRhKTtcbiAgICBpZiAoISh2aWV3W0ZMQUdTXSAmIDIgLyogQ2hlY2tBbHdheXMgKi8pKSB7XG4gICAgICAgIHZpZXdbRkxBR1NdIHw9IDQgLyogRGlydHkgKi87XG4gICAgfVxufVxuLyoqIFdyYXBzIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggcHJldmVudERlZmF1bHQgYmVoYXZpb3IuICovXG5mdW5jdGlvbiB3cmFwTGlzdGVuZXJXaXRoUHJldmVudERlZmF1bHQobGlzdGVuZXJGbikge1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwTGlzdGVuZXJJbl9wcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lckZuKGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBsZWdhY3kgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHByZXZlbnREZWZhdWx0IChlLmcuIElFKVxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKiBNYXJrcyBjdXJyZW50IHZpZXcgYW5kIGFsbCBhbmNlc3RvcnMgZGlydHkgKi9cbmZ1bmN0aW9uIG1hcmtWaWV3RGlydHkodmlldykge1xuICAgIHZhciBjdXJyZW50VmlldyA9IHZpZXc7XG4gICAgd2hpbGUgKGN1cnJlbnRWaWV3ICYmICEoY3VycmVudFZpZXdbRkxBR1NdICYgNjQgLyogSXNSb290ICovKSkge1xuICAgICAgICBjdXJyZW50Vmlld1tGTEFHU10gfD0gNCAvKiBEaXJ0eSAqLztcbiAgICAgICAgY3VycmVudFZpZXcgPSBjdXJyZW50Vmlld1tQQVJFTlRdO1xuICAgIH1cbiAgICBjdXJyZW50Vmlld1tGTEFHU10gfD0gNCAvKiBEaXJ0eSAqLztcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGVmaW5lZChjdXJyZW50Vmlld1tDT05URVhUXSwgJ3Jvb3RDb250ZXh0IHNob3VsZCBiZSBkZWZpbmVkJyk7XG4gICAgdmFyIHJvb3RDb250ZXh0ID0gY3VycmVudFZpZXdbQ09OVEVYVF07XG4gICAgc2NoZWR1bGVUaWNrKHJvb3RDb250ZXh0LCAxIC8qIERldGVjdENoYW5nZXMgKi8pO1xufVxuLyoqXG4gKiBVc2VkIHRvIHNjaGVkdWxlIGNoYW5nZSBkZXRlY3Rpb24gb24gdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxuICpcbiAqIFVubGlrZSBgdGlja2AsIGBzY2hlZHVsZVRpY2tgIGNvYWxlc2NlcyBtdWx0aXBsZSBjYWxscyBpbnRvIG9uZSBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bi5cbiAqIEl0IGlzIHVzdWFsbHkgY2FsbGVkIGluZGlyZWN0bHkgYnkgY2FsbGluZyBgbWFya0RpcnR5YCB3aGVuIHRoZSB2aWV3IG5lZWRzIHRvIGJlXG4gKiByZS1yZW5kZXJlZC5cbiAqXG4gKiBUeXBpY2FsbHkgYHNjaGVkdWxlVGlja2AgdXNlcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0byBjb2FsZXNjZSBtdWx0aXBsZVxuICogYHNjaGVkdWxlVGlja2AgcmVxdWVzdHMuIFRoZSBzY2hlZHVsaW5nIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGluXG4gKiBgcmVuZGVyQ29tcG9uZW50YCdzIGBzY2hlZHVsZXJgIG9wdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2NoZWR1bGVUaWNrKHJvb3RDb250ZXh0LCBmbGFncykge1xuICAgIHZhciBub3RoaW5nU2NoZWR1bGVkID0gcm9vdENvbnRleHQuZmxhZ3MgPT09IDAgLyogRW1wdHkgKi87XG4gICAgcm9vdENvbnRleHQuZmxhZ3MgfD0gZmxhZ3M7XG4gICAgaWYgKG5vdGhpbmdTY2hlZHVsZWQgJiYgcm9vdENvbnRleHQuY2xlYW4gPT0gX0NMRUFOX1BST01JU0UpIHtcbiAgICAgICAgdmFyIHJlc18xO1xuICAgICAgICByb290Q29udGV4dC5jbGVhbiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXNfMSA9IHI7IH0pO1xuICAgICAgICByb290Q29udGV4dC5zY2hlZHVsZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJvb3RDb250ZXh0LmZsYWdzICYgMSAvKiBEZXRlY3RDaGFuZ2VzICovKSB7XG4gICAgICAgICAgICAgICAgcm9vdENvbnRleHQuZmxhZ3MgJj0gfjEgLyogRGV0ZWN0Q2hhbmdlcyAqLztcbiAgICAgICAgICAgICAgICB0aWNrUm9vdENvbnRleHQocm9vdENvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3RDb250ZXh0LmZsYWdzICYgMiAvKiBGbHVzaFBsYXllcnMgKi8pIHtcbiAgICAgICAgICAgICAgICByb290Q29udGV4dC5mbGFncyAmPSB+MiAvKiBGbHVzaFBsYXllcnMgKi87XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllckhhbmRsZXIgPSByb290Q29udGV4dC5wbGF5ZXJIYW5kbGVyO1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXJIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllckhhbmRsZXIuZmx1c2hQbGF5ZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdENvbnRleHQuY2xlYW4gPSBfQ0xFQU5fUFJPTUlTRTtcbiAgICAgICAgICAgIHJlc18xKG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrUm9vdENvbnRleHQocm9vdENvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3RDb250ZXh0LmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvb3RDb21wb25lbnQgPSByb290Q29udGV4dC5jb21wb25lbnRzW2ldO1xuICAgICAgICByZW5kZXJDb21wb25lbnRPclRlbXBsYXRlKHJlYWRQYXRjaGVkTFZpZXdEYXRhKHJvb3RDb21wb25lbnQpLCByb290Q29tcG9uZW50KTtcbiAgICB9XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgcGVyZm9ybSBjaGFuZ2UgZGV0ZWN0aW9uIG9uIGEgY29tcG9uZW50IChhbmQgcG9zc2libHkgaXRzIHN1Yi1jb21wb25lbnRzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBzeW5jaHJvbm91cyB3YXkgb24gYSBjb21wb25lbnQuIFRoZXJlIHNob3VsZFxuICogYmUgdmVyeSBsaXR0bGUgcmVhc29uIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSBzaW5jZSBhIHByZWZlcnJlZCB3YXkgdG8gZG8gY2hhbmdlXG4gKiBkZXRlY3Rpb24gaXMgdG8ge0BsaW5rIG1hcmtEaXJ0eX0gdGhlIGNvbXBvbmVudCBhbmQgd2FpdCBmb3IgdGhlIHNjaGVkdWxlciB0byBjYWxsIHRoaXMgbWV0aG9kXG4gKiBhdCBzb21lIGZ1dHVyZSBwb2ludCBpbiB0aW1lLiBUaGlzIGlzIGJlY2F1c2UgYSBzaW5nbGUgdXNlciBhY3Rpb24gb2Z0ZW4gcmVzdWx0cyBpbiBtYW55XG4gKiBjb21wb25lbnRzIGJlaW5nIGludmFsaWRhdGVkIGFuZCBjYWxsaW5nIGNoYW5nZSBkZXRlY3Rpb24gb24gZWFjaCBjb21wb25lbnQgc3luY2hyb25vdXNseVxuICogd291bGQgYmUgaW5lZmZpY2llbnQuIEl0IGlzIGJldHRlciB0byB3YWl0IHVudGlsIGFsbCBjb21wb25lbnRzIGFyZSBtYXJrZWQgYXMgZGlydHkgYW5kXG4gKiB0aGVuIHBlcmZvcm0gc2luZ2xlIGNoYW5nZSBkZXRlY3Rpb24gYWNyb3NzIGFsbCBvZiB0aGUgY29tcG9uZW50c1xuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB3aGljaCB0aGUgY2hhbmdlIGRldGVjdGlvbiBzaG91bGQgYmUgcGVyZm9ybWVkIG9uLlxuICovXG5mdW5jdGlvbiBkZXRlY3RDaGFuZ2VzKGNvbXBvbmVudCkge1xuICAgIGRldGVjdENoYW5nZXNJbnRlcm5hbChnZXRDb21wb25lbnRWaWV3QnlJbnN0YW5jZShjb21wb25lbnQpLCBjb21wb25lbnQpO1xufVxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHBlcmZvcm0gY2hhbmdlIGRldGVjdGlvbiBvbiBhIHJvb3QgdmlldyBhbmQgaXRzIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIGxWaWV3RGF0YSBUaGUgdmlldyB3aGljaCB0aGUgY2hhbmdlIGRldGVjdGlvbiBzaG91bGQgYmUgcGVyZm9ybWVkIG9uLlxuICovXG5mdW5jdGlvbiBkZXRlY3RDaGFuZ2VzSW5Sb290VmlldyhsVmlld0RhdGEpIHtcbiAgICB0aWNrUm9vdENvbnRleHQobFZpZXdEYXRhW0NPTlRFWFRdKTtcbn1cbi8qKlxuICogQ2hlY2tzIHRoZSBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGl0cyBjaGlsZHJlbiwgYW5kIHRocm93cyBpZiBhbnkgY2hhbmdlcyBhcmUgZGV0ZWN0ZWQuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUgdG8gdmVyaWZ5IHRoYXQgcnVubmluZyBjaGFuZ2UgZGV0ZWN0aW9uIGRvZXNuJ3RcbiAqIGludHJvZHVjZSBvdGhlciBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjaGVja05vQ2hhbmdlcyhjb21wb25lbnQpIHtcbiAgICBjaGVja05vQ2hhbmdlc01vZGUgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIGRldGVjdENoYW5nZXMoY29tcG9uZW50KTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNoZWNrTm9DaGFuZ2VzTW9kZSA9IGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIHRoZSBjaGFuZ2UgZGV0ZWN0b3Igb24gYSByb290IHZpZXcgYW5kIGl0cyBjb21wb25lbnRzLCBhbmQgdGhyb3dzIGlmIGFueSBjaGFuZ2VzIGFyZVxuICogZGV0ZWN0ZWQuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUgdG8gdmVyaWZ5IHRoYXQgcnVubmluZyBjaGFuZ2UgZGV0ZWN0aW9uIGRvZXNuJ3RcbiAqIGludHJvZHVjZSBvdGhlciBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBsVmlld0RhdGEgVGhlIHZpZXcgd2hpY2ggdGhlIGNoYW5nZSBkZXRlY3Rpb24gc2hvdWxkIGJlIGNoZWNrZWQgb24uXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTm9DaGFuZ2VzSW5Sb290VmlldyhsVmlld0RhdGEpIHtcbiAgICBjaGVja05vQ2hhbmdlc01vZGUgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIGRldGVjdENoYW5nZXNJblJvb3RWaWV3KGxWaWV3RGF0YSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjaGVja05vQ2hhbmdlc01vZGUgPSBmYWxzZTtcbiAgICB9XG59XG4vKiogQ2hlY2tzIHRoZSB2aWV3IG9mIHRoZSBjb21wb25lbnQgcHJvdmlkZWQuIERvZXMgbm90IGdhdGUgb24gZGlydHkgY2hlY2tzIG9yIGV4ZWN1dGUgZG9DaGVjay4gKi9cbmZ1bmN0aW9uIGRldGVjdENoYW5nZXNJbnRlcm5hbChob3N0VmlldywgY29tcG9uZW50KSB7XG4gICAgdmFyIGhvc3RUVmlldyA9IGhvc3RWaWV3W1RWSUVXXTtcbiAgICB2YXIgb2xkVmlldyA9IGVudGVyVmlldyhob3N0VmlldywgaG9zdFZpZXdbSE9TVF9OT0RFXSk7XG4gICAgdmFyIHRlbXBsYXRlRm4gPSBob3N0VFZpZXcudGVtcGxhdGU7XG4gICAgdmFyIHZpZXdRdWVyeSA9IGhvc3RUVmlldy52aWV3UXVlcnk7XG4gICAgdHJ5IHtcbiAgICAgICAgbmFtZXNwYWNlSFRNTCgpO1xuICAgICAgICBjcmVhdGVWaWV3UXVlcnkodmlld1F1ZXJ5LCBob3N0Vmlld1tGTEFHU10sIGNvbXBvbmVudCk7XG4gICAgICAgIHRlbXBsYXRlRm4oZ2V0UmVuZGVyRmxhZ3MoaG9zdFZpZXcpLCBjb21wb25lbnQpO1xuICAgICAgICByZWZyZXNoRGVzY2VuZGFudFZpZXdzKCk7XG4gICAgICAgIHVwZGF0ZVZpZXdRdWVyeSh2aWV3UXVlcnksIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBsZWF2ZVZpZXcob2xkVmlldyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmlld1F1ZXJ5KHZpZXdRdWVyeSwgZmxhZ3MsIGNvbXBvbmVudCkge1xuICAgIGlmICh2aWV3UXVlcnkgJiYgKGZsYWdzICYgMSAvKiBDcmVhdGlvbk1vZGUgKi8pKSB7XG4gICAgICAgIHZpZXdRdWVyeSgxIC8qIENyZWF0ZSAqLywgY29tcG9uZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVWaWV3UXVlcnkodmlld1F1ZXJ5LCBjb21wb25lbnQpIHtcbiAgICBpZiAodmlld1F1ZXJ5KSB7XG4gICAgICAgIHZpZXdRdWVyeSgyIC8qIFVwZGF0ZSAqLywgY29tcG9uZW50KTtcbiAgICB9XG59XG4vKipcbiAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBkaXJ0eSAobmVlZGluZyBjaGFuZ2UgZGV0ZWN0aW9uKS5cbiAqXG4gKiBNYXJraW5nIGEgY29tcG9uZW50IGRpcnR5IHdpbGwgc2NoZWR1bGUgYSBjaGFuZ2UgZGV0ZWN0aW9uIG9uIHRoaXNcbiAqIGNvbXBvbmVudCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuIE1hcmtpbmcgYW4gYWxyZWFkeSBkaXJ0eVxuICogY29tcG9uZW50IGFzIGRpcnR5IGlzIGEgbm9vcC4gT25seSBvbmUgb3V0c3RhbmRpbmcgY2hhbmdlIGRldGVjdGlvblxuICogY2FuIGJlIHNjaGVkdWxlZCBwZXIgY29tcG9uZW50IHRyZWUuIChUd28gY29tcG9uZW50cyBib290c3RyYXBwZWQgd2l0aFxuICogc2VwYXJhdGUgYHJlbmRlckNvbXBvbmVudGAgd2lsbCBoYXZlIHNlcGFyYXRlIHNjaGVkdWxlcnMpXG4gKlxuICogV2hlbiB0aGUgcm9vdCBjb21wb25lbnQgaXMgYm9vdHN0cmFwcGVkIHdpdGggYHJlbmRlckNvbXBvbmVudGAsIGEgc2NoZWR1bGVyXG4gKiBjYW4gYmUgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgdG8gbWFyayBhcyBkaXJ0eS5cbiAqL1xuZnVuY3Rpb24gbWFya0RpcnR5KGNvbXBvbmVudCkge1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGNvbXBvbmVudCwgJ2NvbXBvbmVudCcpO1xuICAgIG1hcmtWaWV3RGlydHkoZ2V0Q29tcG9uZW50Vmlld0J5SW5zdGFuY2UoY29tcG9uZW50KSk7XG59XG4vKiogQSBzcGVjaWFsIHZhbHVlIHdoaWNoIGRlc2lnbmF0ZXMgdGhhdCBhIHZhbHVlIGhhcyBub3QgY2hhbmdlZC4gKi9cbnZhciBOT19DSEFOR0UgPSB7fTtcbi8qKlxuICogQ3JlYXRlcyBhIHNpbmdsZSB2YWx1ZSBiaW5kaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBkaWZmXG4gKi9cbmZ1bmN0aW9uIGJpbmQodmFsdWUpIHtcbiAgICByZXR1cm4gYmluZGluZ1VwZGF0ZWQodmlld0RhdGFbQklORElOR19JTkRFWF0rKywgdmFsdWUpID8gdmFsdWUgOiBOT19DSEFOR0U7XG59XG4vKipcbiAqIENyZWF0ZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmdzIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgZXhwcmVzc2lvbnMuXG4gKlxuICogSWYgdGhlcmUgYXJlIDEgdG8gOCBleHByZXNzaW9ucyBgaW50ZXJwb2xhdGlvbjEoKWAgdG8gYGludGVycG9sYXRpb244KClgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKiBUaG9zZSBhcmUgZmFzdGVyIGJlY2F1c2UgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgYW5kIGl0ZXJhdGUgb3ZlciBpdC5cbiAqXG4gKiBgdmFsdWVzYDpcbiAqIC0gaGFzIHN0YXRpYyB0ZXh0IGF0IGV2ZW4gaW5kZXhlcyxcbiAqIC0gaGFzIGV2YWx1YXRlZCBleHByZXNzaW9ucyBhdCBvZGQgaW5kZXhlcy5cbiAqXG4gKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgY2hhbmdlcywgYE5PX0NIQU5HRWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uVih2YWx1ZXMpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TGVzc1RoYW4oMiwgdmFsdWVzLmxlbmd0aCwgJ3Nob3VsZCBoYXZlIGF0IGxlYXN0IDMgdmFsdWVzJyk7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydEVxdWFsKHZhbHVlcy5sZW5ndGggJSAyLCAxLCAnc2hvdWxkIGhhdmUgYW4gb2RkIG51bWJlciBvZiB2YWx1ZXMnKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYmluZGluZ3MgKG9kZCBpbmRleGVzKSBoYXZlIGNoYW5nZWRcbiAgICAgICAgYmluZGluZ1VwZGF0ZWQodmlld0RhdGFbQklORElOR19JTkRFWF0rKywgdmFsdWVzW2ldKSAmJiAoZGlmZmVyZW50ID0gdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgIHJldHVybiBOT19DSEFOR0U7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHRoZSB1cGRhdGVkIGNvbnRlbnRcbiAgICB2YXIgY29udGVudCA9IHZhbHVlc1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb250ZW50ICs9IHN0cmluZ2lmeSQxKHZhbHVlc1tpXSkgKyB2YWx1ZXNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnRlcnBvbGF0aW9uIGJpbmRpbmcgd2l0aCAxIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHByZWZpeCBzdGF0aWMgdmFsdWUgdXNlZCBmb3IgY29uY2F0ZW5hdGlvbiBvbmx5LlxuICogQHBhcmFtIHYwIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSBzdWZmaXggc3RhdGljIHZhbHVlIHVzZWQgZm9yIGNvbmNhdGVuYXRpb24gb25seS5cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGlvbjEocHJlZml4LCB2MCwgc3VmZml4KSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdKyssIHYwKTtcbiAgICByZXR1cm4gZGlmZmVyZW50ID8gcHJlZml4ICsgc3RyaW5naWZ5JDEodjApICsgc3VmZml4IDogTk9fQ0hBTkdFO1xufVxuLyoqIENyZWF0ZXMgYW4gaW50ZXJwb2xhdGlvbiBiaW5kaW5nIHdpdGggMiBleHByZXNzaW9ucy4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRpb24yKHByZWZpeCwgdjAsIGkwLCB2MSwgc3VmZml4KSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkMih2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdjAsIHYxKTtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSAyO1xuICAgIHJldHVybiBkaWZmZXJlbnQgPyBwcmVmaXggKyBzdHJpbmdpZnkkMSh2MCkgKyBpMCArIHN0cmluZ2lmeSQxKHYxKSArIHN1ZmZpeCA6IE5PX0NIQU5HRTtcbn1cbi8qKiBDcmVhdGVzIGFuIGludGVycG9sYXRpb24gYmluZGluZyB3aXRoIDMgZXhwcmVzc2lvbnMuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uMyhwcmVmaXgsIHYwLCBpMCwgdjEsIGkxLCB2Miwgc3VmZml4KSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkMyh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdjAsIHYxLCB2Mik7XG4gICAgdmlld0RhdGFbQklORElOR19JTkRFWF0gKz0gMztcbiAgICByZXR1cm4gZGlmZmVyZW50ID8gcHJlZml4ICsgc3RyaW5naWZ5JDEodjApICsgaTAgKyBzdHJpbmdpZnkkMSh2MSkgKyBpMSArIHN0cmluZ2lmeSQxKHYyKSArIHN1ZmZpeCA6XG4gICAgICAgIE5PX0NIQU5HRTtcbn1cbi8qKiBDcmVhdGUgYW4gaW50ZXJwb2xhdGlvbiBiaW5kaW5nIHdpdGggNCBleHByZXNzaW9ucy4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRpb240KHByZWZpeCwgdjAsIGkwLCB2MSwgaTEsIHYyLCBpMiwgdjMsIHN1ZmZpeCkge1xuICAgIHZhciBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDQodmlld0RhdGFbQklORElOR19JTkRFWF0sIHYwLCB2MSwgdjIsIHYzKTtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSA0O1xuICAgIHJldHVybiBkaWZmZXJlbnQgP1xuICAgICAgICBwcmVmaXggKyBzdHJpbmdpZnkkMSh2MCkgKyBpMCArIHN0cmluZ2lmeSQxKHYxKSArIGkxICsgc3RyaW5naWZ5JDEodjIpICsgaTIgKyBzdHJpbmdpZnkkMSh2MykgK1xuICAgICAgICAgICAgc3VmZml4IDpcbiAgICAgICAgTk9fQ0hBTkdFO1xufVxuLyoqIENyZWF0ZXMgYW4gaW50ZXJwb2xhdGlvbiBiaW5kaW5nIHdpdGggNSBleHByZXNzaW9ucy4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRpb241KHByZWZpeCwgdjAsIGkwLCB2MSwgaTEsIHYyLCBpMiwgdjMsIGkzLCB2NCwgc3VmZml4KSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkNCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdjAsIHYxLCB2MiwgdjMpO1xuICAgIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQpIHx8IGRpZmZlcmVudDtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSA1O1xuICAgIHJldHVybiBkaWZmZXJlbnQgP1xuICAgICAgICBwcmVmaXggKyBzdHJpbmdpZnkkMSh2MCkgKyBpMCArIHN0cmluZ2lmeSQxKHYxKSArIGkxICsgc3RyaW5naWZ5JDEodjIpICsgaTIgKyBzdHJpbmdpZnkkMSh2MykgKyBpMyArXG4gICAgICAgICAgICBzdHJpbmdpZnkkMSh2NCkgKyBzdWZmaXggOlxuICAgICAgICBOT19DSEFOR0U7XG59XG4vKiogQ3JlYXRlcyBhbiBpbnRlcnBvbGF0aW9uIGJpbmRpbmcgd2l0aCA2IGV4cHJlc3Npb25zLiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGlvbjYocHJlZml4LCB2MCwgaTAsIHYxLCBpMSwgdjIsIGkyLCB2MywgaTMsIHY0LCBpNCwgdjUsIHN1ZmZpeCkge1xuICAgIHZhciBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDQodmlld0RhdGFbQklORElOR19JTkRFWF0sIHYwLCB2MSwgdjIsIHYzKTtcbiAgICBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDIodmlld0RhdGFbQklORElOR19JTkRFWF0gKyA0LCB2NCwgdjUpIHx8IGRpZmZlcmVudDtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSA2O1xuICAgIHJldHVybiBkaWZmZXJlbnQgP1xuICAgICAgICBwcmVmaXggKyBzdHJpbmdpZnkkMSh2MCkgKyBpMCArIHN0cmluZ2lmeSQxKHYxKSArIGkxICsgc3RyaW5naWZ5JDEodjIpICsgaTIgKyBzdHJpbmdpZnkkMSh2MykgKyBpMyArXG4gICAgICAgICAgICBzdHJpbmdpZnkkMSh2NCkgKyBpNCArIHN0cmluZ2lmeSQxKHY1KSArIHN1ZmZpeCA6XG4gICAgICAgIE5PX0NIQU5HRTtcbn1cbi8qKiBDcmVhdGVzIGFuIGludGVycG9sYXRpb24gYmluZGluZyB3aXRoIDcgZXhwcmVzc2lvbnMuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uNyhwcmVmaXgsIHYwLCBpMCwgdjEsIGkxLCB2MiwgaTIsIHYzLCBpMywgdjQsIGk0LCB2NSwgaTUsIHY2LCBzdWZmaXgpIHtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyLCB2Myk7XG4gICAgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQzKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQsIHY1LCB2NikgfHwgZGlmZmVyZW50O1xuICAgIHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICs9IDc7XG4gICAgcmV0dXJuIGRpZmZlcmVudCA/XG4gICAgICAgIHByZWZpeCArIHN0cmluZ2lmeSQxKHYwKSArIGkwICsgc3RyaW5naWZ5JDEodjEpICsgaTEgKyBzdHJpbmdpZnkkMSh2MikgKyBpMiArIHN0cmluZ2lmeSQxKHYzKSArIGkzICtcbiAgICAgICAgICAgIHN0cmluZ2lmeSQxKHY0KSArIGk0ICsgc3RyaW5naWZ5JDEodjUpICsgaTUgKyBzdHJpbmdpZnkkMSh2NikgKyBzdWZmaXggOlxuICAgICAgICBOT19DSEFOR0U7XG59XG4vKiogQ3JlYXRlcyBhbiBpbnRlcnBvbGF0aW9uIGJpbmRpbmcgd2l0aCA4IGV4cHJlc3Npb25zLiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGlvbjgocHJlZml4LCB2MCwgaTAsIHYxLCBpMSwgdjIsIGkyLCB2MywgaTMsIHY0LCBpNCwgdjUsIGk1LCB2NiwgaTYsIHY3LCBzdWZmaXgpIHtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyLCB2Myk7XG4gICAgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQsIHY1LCB2NiwgdjcpIHx8IGRpZmZlcmVudDtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSA4O1xuICAgIHJldHVybiBkaWZmZXJlbnQgP1xuICAgICAgICBwcmVmaXggKyBzdHJpbmdpZnkkMSh2MCkgKyBpMCArIHN0cmluZ2lmeSQxKHYxKSArIGkxICsgc3RyaW5naWZ5JDEodjIpICsgaTIgKyBzdHJpbmdpZnkkMSh2MykgKyBpMyArXG4gICAgICAgICAgICBzdHJpbmdpZnkkMSh2NCkgKyBpNCArIHN0cmluZ2lmeSQxKHY1KSArIGk1ICsgc3RyaW5naWZ5JDEodjYpICsgaTYgKyBzdHJpbmdpZnkkMSh2NykgKyBzdWZmaXggOlxuICAgICAgICBOT19DSEFOR0U7XG59XG4vKiogU3RvcmUgYSB2YWx1ZSBpbiB0aGUgYGRhdGFgIGF0IGEgZ2l2ZW4gYGluZGV4YC4gKi9cbmZ1bmN0aW9uIHN0b3JlKGluZGV4LCB2YWx1ZSkge1xuICAgIC8vIFdlIGRvbid0IHN0b3JlIGFueSBzdGF0aWMgZGF0YSBmb3IgbG9jYWwgdmFyaWFibGVzLCBzbyB0aGUgZmlyc3QgdGltZVxuICAgIC8vIHdlIHNlZSB0aGUgdGVtcGxhdGUsIHdlIHNob3VsZCBzdG9yZSBhcyBudWxsIHRvIGF2b2lkIGEgc3BhcnNlIGFycmF5XG4gICAgdmFyIGFkanVzdGVkSW5kZXggPSBpbmRleCArIEhFQURFUl9PRkZTRVQ7XG4gICAgaWYgKGFkanVzdGVkSW5kZXggPj0gdFZpZXcuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdFZpZXcuZGF0YVthZGp1c3RlZEluZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIHZpZXdEYXRhW2FkanVzdGVkSW5kZXhdID0gdmFsdWU7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGxvY2FsIHJlZmVyZW5jZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRleHRWaWV3RGF0YS5cbiAqXG4gKiBJZiB0aGUgcmVmZXJlbmNlIHRvIHJldHJpZXZlIGlzIGluIGEgcGFyZW50IHZpZXcsIHRoaXMgaW5zdHJ1Y3Rpb24gaXMgdXNlZCBpbiBjb25qdW5jdGlvblxuICogd2l0aCBhIG5leHRDb250ZXh0KCkgY2FsbCwgd2hpY2ggd2Fsa3MgdXAgdGhlIHRyZWUgYW5kIHVwZGF0ZXMgdGhlIGNvbnRleHRWaWV3RGF0YSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBsb2NhbCByZWYgaW4gY29udGV4dFZpZXdEYXRhLlxuICovXG5mdW5jdGlvbiByZWZlcmVuY2UoaW5kZXgpIHtcbiAgICByZXR1cm4gbG9hZEludGVybmFsKGluZGV4LCBjb250ZXh0Vmlld0RhdGEpO1xufVxuZnVuY3Rpb24gd2Fsa1VwVmlld3MobmVzdGluZ0xldmVsLCBjdXJyZW50Vmlldykge1xuICAgIHdoaWxlIChuZXN0aW5nTGV2ZWwgPiAwKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGN1cnJlbnRWaWV3W0RFQ0xBUkFUSU9OX1ZJRVddLCAnRGVjbGFyYXRpb24gdmlldyBzaG91bGQgYmUgZGVmaW5lZCBpZiBuZXN0aW5nIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgICAgICBjdXJyZW50VmlldyA9IGN1cnJlbnRWaWV3W0RFQ0xBUkFUSU9OX1ZJRVddO1xuICAgICAgICBuZXN0aW5nTGV2ZWwtLTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRWaWV3O1xufVxuZnVuY3Rpb24gbG9hZFF1ZXJ5TGlzdChxdWVyeUxpc3RJZHgpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGVmaW5lZCh2aWV3RGF0YVtDT05URU5UX1FVRVJJRVNdLCAnQ29udGVudCBRdWVyeUxpc3QgYXJyYXkgc2hvdWxkIGJlIGRlZmluZWQgaWYgcmVhZGluZyBhIHF1ZXJ5LicpO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREYXRhSW5SYW5nZShxdWVyeUxpc3RJZHgsIHZpZXdEYXRhW0NPTlRFTlRfUVVFUklFU10pO1xuICAgIHJldHVybiB2aWV3RGF0YVtDT05URU5UX1FVRVJJRVNdW3F1ZXJ5TGlzdElkeF07XG59XG4vKiogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBjdXJyZW50IGB2aWV3RGF0YWAuICovXG5mdW5jdGlvbiBsb2FkKGluZGV4KSB7XG4gICAgcmV0dXJuIGxvYWRJbnRlcm5hbChpbmRleCwgdmlld0RhdGEpO1xufVxuLyoqIEdldHMgdGhlIGN1cnJlbnQgYmluZGluZyB2YWx1ZS4gKi9cbmZ1bmN0aW9uIGdldEJpbmRpbmcoYmluZGluZ0luZGV4KSB7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERhdGFJblJhbmdlKHZpZXdEYXRhW2JpbmRpbmdJbmRleF0pO1xuICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICBhc3NlcnROb3RFcXVhbCh2aWV3RGF0YVtiaW5kaW5nSW5kZXhdLCBOT19DSEFOR0UsICdTdG9yZWQgdmFsdWUgc2hvdWxkIG5ldmVyIGJlIE5PX0NIQU5HRS4nKTtcbiAgICByZXR1cm4gdmlld0RhdGFbYmluZGluZ0luZGV4XTtcbn1cbi8qKiBVcGRhdGVzIGJpbmRpbmcgaWYgY2hhbmdlZCwgdGhlbiByZXR1cm5zIHdoZXRoZXIgaXQgd2FzIHVwZGF0ZWQuICovXG5mdW5jdGlvbiBiaW5kaW5nVXBkYXRlZChiaW5kaW5nSW5kZXgsIHZhbHVlKSB7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydE5vdEVxdWFsKHZhbHVlLCBOT19DSEFOR0UsICdJbmNvbWluZyB2YWx1ZSBzaG91bGQgbmV2ZXIgYmUgTk9fQ0hBTkdFLicpO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRMZXNzVGhhbihiaW5kaW5nSW5kZXgsIHZpZXdEYXRhLmxlbmd0aCwgXCJTbG90IHNob3VsZCBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgdG8gTk9fQ0hBTkdFXCIpO1xuICAgIGlmICh2aWV3RGF0YVtiaW5kaW5nSW5kZXhdID09PSBOT19DSEFOR0UpIHtcbiAgICAgICAgdmlld0RhdGFbYmluZGluZ0luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0RpZmZlcmVudCh2aWV3RGF0YVtiaW5kaW5nSW5kZXhdLCB2YWx1ZSwgY2hlY2tOb0NoYW5nZXNNb2RlKSkge1xuICAgICAgICB0aHJvd0Vycm9ySWZOb0NoYW5nZXNNb2RlKGNyZWF0aW9uTW9kZSwgY2hlY2tOb0NoYW5nZXNNb2RlLCB2aWV3RGF0YVtiaW5kaW5nSW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgIHZpZXdEYXRhW2JpbmRpbmdJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKiogVXBkYXRlcyBiaW5kaW5nIGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUJpbmRpbmcoYmluZGluZ0luZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB2aWV3RGF0YVtiaW5kaW5nSW5kZXhdID0gdmFsdWU7XG59XG4vKiogVXBkYXRlcyAyIGJpbmRpbmdzIGlmIGNoYW5nZWQsIHRoZW4gcmV0dXJucyB3aGV0aGVyIGVpdGhlciB3YXMgdXBkYXRlZC4gKi9cbmZ1bmN0aW9uIGJpbmRpbmdVcGRhdGVkMihiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIpIHtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQoYmluZGluZ0luZGV4LCBleHAxKTtcbiAgICByZXR1cm4gYmluZGluZ1VwZGF0ZWQoYmluZGluZ0luZGV4ICsgMSwgZXhwMikgfHwgZGlmZmVyZW50O1xufVxuLyoqIFVwZGF0ZXMgMyBiaW5kaW5ncyBpZiBjaGFuZ2VkLCB0aGVuIHJldHVybnMgd2hldGhlciBhbnkgd2FzIHVwZGF0ZWQuICovXG5mdW5jdGlvbiBiaW5kaW5nVXBkYXRlZDMoYmluZGluZ0luZGV4LCBleHAxLCBleHAyLCBleHAzKSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkMihiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIpO1xuICAgIHJldHVybiBiaW5kaW5nVXBkYXRlZChiaW5kaW5nSW5kZXggKyAyLCBleHAzKSB8fCBkaWZmZXJlbnQ7XG59XG4vKiogVXBkYXRlcyA0IGJpbmRpbmdzIGlmIGNoYW5nZWQsIHRoZW4gcmV0dXJucyB3aGV0aGVyIGFueSB3YXMgdXBkYXRlZC4gKi9cbmZ1bmN0aW9uIGJpbmRpbmdVcGRhdGVkNChiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQpIHtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQyKGJpbmRpbmdJbmRleCwgZXhwMSwgZXhwMik7XG4gICAgcmV0dXJuIGJpbmRpbmdVcGRhdGVkMihiaW5kaW5nSW5kZXggKyAyLCBleHAzLCBleHA0KSB8fCBkaWZmZXJlbnQ7XG59XG5mdW5jdGlvbiBnZXRUVmlldygpIHtcbiAgICByZXR1cm4gdFZpZXc7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIFF1ZXJ5TGlzdCwgYXNzb2NpYXRlZCB3aXRoIGEgY29udGVudCBxdWVyeSwgZm9yIGxhdGVyIHJlZnJlc2ggKHBhcnQgb2YgYSB2aWV3XG4gKiByZWZyZXNoKS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZW50UXVlcnkocXVlcnlMaXN0KSB7XG4gICAgdmFyIHNhdmVkQ29udGVudFF1ZXJpZXNMZW5ndGggPSAodmlld0RhdGFbQ09OVEVOVF9RVUVSSUVTXSB8fCAodmlld0RhdGFbQ09OVEVOVF9RVUVSSUVTXSA9IFtdKSkucHVzaChxdWVyeUxpc3QpO1xuICAgIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB2YXIgY3VycmVudERpcmVjdGl2ZUluZGV4ID0gdmlld0RhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHRWaWV3Q29udGVudFF1ZXJpZXMgPSB0Vmlldy5jb250ZW50UXVlcmllcyB8fCAodFZpZXcuY29udGVudFF1ZXJpZXMgPSBbXSk7XG4gICAgICAgIHZhciBsYXN0U2F2ZWREaXJlY3RpdmVJbmRleCA9IHRWaWV3LmNvbnRlbnRRdWVyaWVzLmxlbmd0aCA/IHRWaWV3LmNvbnRlbnRRdWVyaWVzW3RWaWV3LmNvbnRlbnRRdWVyaWVzLmxlbmd0aCAtIDJdIDogLTE7XG4gICAgICAgIGlmIChjdXJyZW50RGlyZWN0aXZlSW5kZXggIT09IGxhc3RTYXZlZERpcmVjdGl2ZUluZGV4KSB7XG4gICAgICAgICAgICB0Vmlld0NvbnRlbnRRdWVyaWVzLnB1c2goY3VycmVudERpcmVjdGl2ZUluZGV4LCBzYXZlZENvbnRlbnRRdWVyaWVzTGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRQcmV2aW91c0lzUGFyZW50KCkge1xuICAgIGFzc2VydEVxdWFsKGlzUGFyZW50LCB0cnVlLCAncHJldmlvdXNPclBhcmVudFROb2RlIHNob3VsZCBiZSBhIHBhcmVudCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SGFzUGFyZW50KCkge1xuICAgIGFzc2VydERlZmluZWQocHJldmlvdXNPclBhcmVudFROb2RlLnBhcmVudCwgJ3ByZXZpb3VzT3JQYXJlbnRUTm9kZSBzaG91bGQgaGF2ZSBhIHBhcmVudCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGF0YUluUmFuZ2UoaW5kZXgsIGFycikge1xuICAgIGlmIChhcnIgPT0gbnVsbClcbiAgICAgICAgYXJyID0gdmlld0RhdGE7XG4gICAgYXNzZXJ0RGF0YUluUmFuZ2VJbnRlcm5hbChpbmRleCwgYXJyIHx8IHZpZXdEYXRhKTtcbn1cbnZhciBDTEVBTl9QUk9NSVNFID0gX0NMRUFOX1BST01JU0U7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFJvb3QgY29tcG9uZW50IHdpbGwgYWx3YXlzIGhhdmUgYW4gZWxlbWVudCBpbmRleCBvZiAwIGFuZCBhbiBpbmplY3RvciBzaXplIG9mIDFcbnZhciBST09UX0VYUEFORE9fSU5TVFJVQ1RJT05TID0gWzAsIDFdO1xuLyoqXG4gKiBCb290c3RyYXBzIGEgQ29tcG9uZW50IGludG8gYW4gZXhpc3RpbmcgaG9zdCBlbGVtZW50IGFuZCByZXR1cm5zIGFuIGluc3RhbmNlXG4gKiBvZiB0aGUgY29tcG9uZW50LlxuICpcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGJvb3RzdHJhcCBhIGNvbXBvbmVudCBpbnRvIHRoZSBET00gdHJlZS4gRWFjaCBpbnZvY2F0aW9uXG4gKiBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgc2VwYXJhdGUgdHJlZSBvZiBjb21wb25lbnRzLCBpbmplY3RvcnMgYW5kXG4gKiBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlcyBhbmQgbGlmZXRpbWVzLiBUbyBkeW5hbWljYWxseSBpbnNlcnQgYSBuZXcgY29tcG9uZW50XG4gKiBpbnRvIGFuIGV4aXN0aW5nIHRyZWUgc3VjaCB0aGF0IGl0IHNoYXJlcyB0aGUgc2FtZSBpbmplY3Rpb24sIGNoYW5nZSBkZXRlY3Rpb25cbiAqIGFuZCBvYmplY3QgbGlmZXRpbWUsIHVzZSB7QGxpbmsgVmlld0NvbnRhaW5lciNjcmVhdGVDb21wb25lbnR9LlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRUeXBlIENvbXBvbmVudCB0byBib290c3RyYXBcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgd2hpY2ggY29udHJvbCBib290c3RyYXBwaW5nXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnRUeXBlIC8qIFR5cGUgYXMgd29ya2Fyb3VuZCBmb3I6IE1pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80ODgxICovLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Q29tcG9uZW50VHlwZShjb21wb25lbnRUeXBlKTtcbiAgICB2YXIgcmVuZGVyZXJGYWN0b3J5ID0gb3B0cy5yZW5kZXJlckZhY3RvcnkgfHwgZG9tUmVuZGVyZXJGYWN0b3J5MztcbiAgICB2YXIgc2FuaXRpemVyID0gb3B0cy5zYW5pdGl6ZXIgfHwgbnVsbDtcbiAgICB2YXIgY29tcG9uZW50RGVmID0gZ2V0Q29tcG9uZW50RGVmKGNvbXBvbmVudFR5cGUpO1xuICAgIGlmIChjb21wb25lbnREZWYudHlwZSAhPSBjb21wb25lbnRUeXBlKVxuICAgICAgICBjb21wb25lbnREZWYudHlwZSA9IGNvbXBvbmVudFR5cGU7XG4gICAgLy8gVGhlIGZpcnN0IGluZGV4IG9mIHRoZSBmaXJzdCBzZWxlY3RvciBpcyB0aGUgdGFnIG5hbWUuXG4gICAgdmFyIGNvbXBvbmVudFRhZyA9IGNvbXBvbmVudERlZi5zZWxlY3RvcnNbMF1bMF07XG4gICAgdmFyIGhvc3RSTm9kZSA9IGxvY2F0ZUhvc3RFbGVtZW50KHJlbmRlcmVyRmFjdG9yeSwgb3B0cy5ob3N0IHx8IGNvbXBvbmVudFRhZyk7XG4gICAgdmFyIHJvb3RGbGFncyA9IGNvbXBvbmVudERlZi5vblB1c2ggPyA0IC8qIERpcnR5ICovIHwgNjQgLyogSXNSb290ICovIDpcbiAgICAgICAgMiAvKiBDaGVja0Fsd2F5cyAqLyB8IDY0IC8qIElzUm9vdCAqLztcbiAgICB2YXIgcm9vdENvbnRleHQgPSBjcmVhdGVSb290Q29udGV4dChvcHRzLnNjaGVkdWxlciB8fCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpLCBvcHRzLnBsYXllckhhbmRsZXIgfHwgbnVsbCk7XG4gICAgdmFyIHJlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKGhvc3RSTm9kZSwgY29tcG9uZW50RGVmKTtcbiAgICB2YXIgcm9vdFZpZXcgPSBjcmVhdGVMVmlld0RhdGEocmVuZGVyZXIsIGNyZWF0ZVRWaWV3KC0xLCBudWxsLCAxLCAwLCBudWxsLCBudWxsLCBudWxsKSwgcm9vdENvbnRleHQsIHJvb3RGbGFncyk7XG4gICAgcm9vdFZpZXdbSU5KRUNUT1IkMV0gPSBvcHRzLmluamVjdG9yIHx8IG51bGw7XG4gICAgdmFyIG9sZFZpZXcgPSBlbnRlclZpZXcocm9vdFZpZXcsIG51bGwpO1xuICAgIHZhciBjb21wb25lbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlbmRlcmVyRmFjdG9yeS5iZWdpbilcbiAgICAgICAgICAgIHJlbmRlcmVyRmFjdG9yeS5iZWdpbigpO1xuICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IGNyZWF0ZVJvb3RDb21wb25lbnRWaWV3KGhvc3RSTm9kZSwgY29tcG9uZW50RGVmLCByb290VmlldywgcmVuZGVyZXIsIHNhbml0aXplcik7XG4gICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVJvb3RDb21wb25lbnQoaG9zdFJOb2RlLCBjb21wb25lbnRWaWV3LCBjb21wb25lbnREZWYsIHJvb3RWaWV3LCByb290Q29udGV4dCwgb3B0cy5ob3N0RmVhdHVyZXMgfHwgbnVsbCk7XG4gICAgICAgIGV4ZWN1dGVJbml0QW5kQ29udGVudEhvb2tzKCk7XG4gICAgICAgIGRldGVjdENoYW5nZXNJbnRlcm5hbChjb21wb25lbnRWaWV3LCBjb21wb25lbnQpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgbGVhdmVWaWV3KG9sZFZpZXcpO1xuICAgICAgICBpZiAocmVuZGVyZXJGYWN0b3J5LmVuZClcbiAgICAgICAgICAgIHJlbmRlcmVyRmFjdG9yeS5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgcm9vdCBjb21wb25lbnQgdmlldyBhbmQgdGhlIHJvb3QgY29tcG9uZW50IG5vZGUuXG4gKlxuICogQHBhcmFtIHJOb2RlIFJlbmRlciBob3N0IGVsZW1lbnQuXG4gKiBAcGFyYW0gZGVmIENvbXBvbmVudERlZlxuICogQHBhcmFtIHJvb3RWaWV3IFRoZSBwYXJlbnQgdmlldyB3aGVyZSB0aGUgaG9zdCBub2RlIGlzIHN0b3JlZFxuICogQHBhcmFtIHJlbmRlcmVyIFRoZSBjdXJyZW50IHJlbmRlcmVyXG4gKiBAcGFyYW0gc2FuaXRpemVyIFRoZSBzYW5pdGl6ZXIsIGlmIHByb3ZpZGVkXG4gKlxuICogQHJldHVybnMgQ29tcG9uZW50IHZpZXcgY3JlYXRlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVSb290Q29tcG9uZW50VmlldyhyTm9kZSwgZGVmLCByb290VmlldywgcmVuZGVyZXIsIHNhbml0aXplcikge1xuICAgIHJlc2V0Q29tcG9uZW50U3RhdGUoKTtcbiAgICB2YXIgdFZpZXcgPSByb290Vmlld1tUVklFV107XG4gICAgdmFyIGNvbXBvbmVudFZpZXcgPSBjcmVhdGVMVmlld0RhdGEocmVuZGVyZXIsIGdldE9yQ3JlYXRlVFZpZXcoZGVmLnRlbXBsYXRlLCBkZWYuY29uc3RzLCBkZWYudmFycywgZGVmLmRpcmVjdGl2ZURlZnMsIGRlZi5waXBlRGVmcywgZGVmLnZpZXdRdWVyeSksIG51bGwsIGRlZi5vblB1c2ggPyA0IC8qIERpcnR5ICovIDogMiAvKiBDaGVja0Fsd2F5cyAqLywgc2FuaXRpemVyKTtcbiAgICB2YXIgdE5vZGUgPSBjcmVhdGVOb2RlQXRJbmRleCgwLCAzIC8qIEVsZW1lbnQgKi8sIHJOb2RlLCBudWxsLCBudWxsKTtcbiAgICBpZiAodFZpZXcuZmlyc3RUZW1wbGF0ZVBhc3MpIHtcbiAgICAgICAgdFZpZXcuZXhwYW5kb0luc3RydWN0aW9ucyA9IFJPT1RfRVhQQU5ET19JTlNUUlVDVElPTlMuc2xpY2UoKTtcbiAgICAgICAgaWYgKGRlZi5kaVB1YmxpYylcbiAgICAgICAgICAgIGRlZi5kaVB1YmxpYyhkZWYpO1xuICAgICAgICB0Tm9kZS5mbGFncyA9XG4gICAgICAgICAgICByb290Vmlldy5sZW5ndGggPDwgMTUgLyogRGlyZWN0aXZlU3RhcnRpbmdJbmRleFNoaWZ0ICovIHwgNDA5NiAvKiBpc0NvbXBvbmVudCAqLztcbiAgICB9XG4gICAgLy8gU3RvcmUgY29tcG9uZW50IHZpZXcgYXQgbm9kZSBpbmRleCwgd2l0aCBub2RlIGFzIHRoZSBIT1NUXG4gICAgY29tcG9uZW50Vmlld1tIT1NUXSA9IHJvb3RWaWV3W0hFQURFUl9PRkZTRVRdO1xuICAgIGNvbXBvbmVudFZpZXdbSE9TVF9OT0RFXSA9IHROb2RlO1xuICAgIHJldHVybiByb290Vmlld1tIRUFERVJfT0ZGU0VUXSA9IGNvbXBvbmVudFZpZXc7XG59XG4vKipcbiAqIENyZWF0ZXMgYSByb290IGNvbXBvbmVudCBhbmQgc2V0cyBpdCB1cCB3aXRoIGZlYXR1cmVzIGFuZCBob3N0IGJpbmRpbmdzLiBTaGFyZWQgYnlcbiAqIHJlbmRlckNvbXBvbmVudCgpIGFuZCBWaWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudCgpLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb290Q29tcG9uZW50KGhvc3RSTm9kZSwgY29tcG9uZW50VmlldywgY29tcG9uZW50RGVmLCByb290Vmlldywgcm9vdENvbnRleHQsIGhvc3RGZWF0dXJlcykge1xuICAgIC8vIENyZWF0ZSBkaXJlY3RpdmUgaW5zdGFuY2Ugd2l0aCBmYWN0b3J5KCkgYW5kIHN0b3JlIGF0IG5leHQgaW5kZXggaW4gdmlld0RhdGFcbiAgICB2YXIgY29tcG9uZW50ID0gYmFzZURpcmVjdGl2ZUNyZWF0ZShyb290Vmlldy5sZW5ndGgsIGNvbXBvbmVudERlZi5mYWN0b3J5KCksIGNvbXBvbmVudERlZiwgaG9zdFJOb2RlKTtcbiAgICByb290Q29udGV4dC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICBjb21wb25lbnRWaWV3W0NPTlRFWFRdID0gY29tcG9uZW50O1xuICAgIGhvc3RGZWF0dXJlcyAmJiBob3N0RmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkgeyByZXR1cm4gZmVhdHVyZShjb21wb25lbnQsIGNvbXBvbmVudERlZik7IH0pO1xuICAgIGlmIChyb290Vmlld1tUVklFV10uZmlyc3RUZW1wbGF0ZVBhc3MpXG4gICAgICAgIHByZWZpbGxIb3N0VmFycyhjb21wb25lbnREZWYuaG9zdFZhcnMpO1xuICAgIHNldEhvc3RCaW5kaW5ncygpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSb290Q29udGV4dChzY2hlZHVsZXIsIHBsYXllckhhbmRsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgc2NoZWR1bGVyOiBzY2hlZHVsZXIsXG4gICAgICAgIGNsZWFuOiBDTEVBTl9QUk9NSVNFLFxuICAgICAgICBwbGF5ZXJIYW5kbGVyOiBwbGF5ZXJIYW5kbGVyIHx8IG51bGwsXG4gICAgICAgIGZsYWdzOiAwIC8qIEVtcHR5ICovXG4gICAgfTtcbn1cbi8qKlxuICogVXNlZCB0byBlbmFibGUgbGlmZWN5Y2xlIGhvb2tzIG9uIHRoZSByb290IGNvbXBvbmVudC5cbiAqXG4gKiBJbmNsdWRlIHRoaXMgZmVhdHVyZSB3aGVuIGNhbGxpbmcgYHJlbmRlckNvbXBvbmVudGAgaWYgdGhlIHJvb3QgY29tcG9uZW50XG4gKiB5b3UgYXJlIHJlbmRlcmluZyBoYXMgbGlmZWN5Y2xlIGhvb2tzIGRlZmluZWQuIE90aGVyd2lzZSwgdGhlIGhvb2tzIHdvbid0XG4gKiBiZSBjYWxsZWQgcHJvcGVybHkuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHJlbmRlckNvbXBvbmVudChBcHBDb21wb25lbnQsIHtmZWF0dXJlczogW1Jvb3RMaWZlY3ljbGVIb29rc119KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBMaWZlY3ljbGVIb29rc0ZlYXR1cmUoY29tcG9uZW50LCBkZWYpIHtcbiAgICB2YXIgcm9vdFRWaWV3ID0gcmVhZFBhdGNoZWRMVmlld0RhdGEoY29tcG9uZW50KVtUVklFV107XG4gICAgdmFyIGRpckluZGV4ID0gcm9vdFRWaWV3LmRhdGEubGVuZ3RoIC0gMTtcbiAgICBxdWV1ZUluaXRIb29rcyhkaXJJbmRleCwgZGVmLm9uSW5pdCwgZGVmLmRvQ2hlY2ssIHJvb3RUVmlldyk7XG4gICAgcXVldWVMaWZlY3ljbGVIb29rcyhkaXJJbmRleCA8PCAxNSAvKiBEaXJlY3RpdmVTdGFydGluZ0luZGV4U2hpZnQgKi8gfCAxLCByb290VFZpZXcpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgcm9vdCBjb250ZXh0IGZvciBhbnkgY29tcG9uZW50IGJ5IHdhbGtpbmcgdGhlIHBhcmVudCBgTFZpZXdgIHVudGlsXG4gKiByZWFjaGluZyB0aGUgcm9vdCBgTFZpZXdgLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgYW55IGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBnZXRSb290Q29udGV4dCQxKGNvbXBvbmVudCkge1xuICAgIHZhciByb290Q29udGV4dCA9IGdldFJvb3RWaWV3KGNvbXBvbmVudClbQ09OVEVYVF07XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQocm9vdENvbnRleHQsICdyb290Q29udGV4dCcpO1xuICAgIHJldHVybiByb290Q29udGV4dDtcbn1cbi8qKlxuICogV2FpdCBvbiBjb21wb25lbnQgdW50aWwgaXQgaXMgcmVuZGVyZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYFByb21pc2VgIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gdGhlIGNvbXBvbmVudCdzXG4gKiBjaGFuZ2UgZGV0ZWN0aW9uIGlzIGV4ZWN1dGVkLiBUaGlzIGlzIGRldGVybWluZWQgYnkgZmluZGluZyB0aGUgc2NoZWR1bGVyXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIGBjb21wb25lbnRgJ3MgcmVuZGVyIHRyZWUgYW5kIHdhaXRpbmcgdW50aWwgdGhlIHNjaGVkdWxlclxuICogZmx1c2hlcy4gSWYgbm90aGluZyBpcyBzY2hlZHVsZWQsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgcmVzb2x2ZWQgcHJvbWlzZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiBhd2FpdCB3aGVuUmVuZGVyZWQobXlDb21wb25lbnQpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgdG8gd2FpdCB1cG9uXG4gKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gd2hlblJlbmRlcmVkKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBnZXRSb290Q29udGV4dCQxKGNvbXBvbmVudCkuY2xlYW47XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGRlZmluaXRpb24gaXMgYSB7QGxpbmsgQ29tcG9uZW50RGVmfSBvciBhIHtAbGluayBEaXJlY3RpdmVEZWZ9XG4gKiBAcGFyYW0gZGVmaW5pdGlvbiBUaGUgZGVmaW5pdGlvbiB0byBleGFtaW5lXG4gKi9cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RGVmKGRlZmluaXRpb24pIHtcbiAgICB2YXIgZGVmID0gZGVmaW5pdGlvbjtcbiAgICByZXR1cm4gdHlwZW9mIGRlZi50ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGdldFN1cGVyVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG59XG4vKipcbiAqIE1lcmdlcyB0aGUgZGVmaW5pdGlvbiBmcm9tIGEgc3VwZXIgY2xhc3MgdG8gYSBzdWIgY2xhc3MuXG4gKiBAcGFyYW0gZGVmaW5pdGlvbiBUaGUgZGVmaW5pdGlvbiB0aGF0IGlzIGEgU3ViQ2xhc3Mgb2YgYW5vdGhlciBkaXJlY3RpdmUgb2YgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIEluaGVyaXREZWZpbml0aW9uRmVhdHVyZShkZWZpbml0aW9uKSB7XG4gICAgdmFyIHN1cGVyVHlwZSA9IGdldFN1cGVyVHlwZShkZWZpbml0aW9uLnR5cGUpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIHN1cGVyRGVmID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDb21wb25lbnREZWYoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBnZXRDb21wb25lbnREZWYvZ2V0RGlyZWN0aXZlRGVmLiBUaGlzIGxvZ2ljIHJlbGllcyBvbiBpbmhlcml0YW5jZS5cbiAgICAgICAgICAgIHN1cGVyRGVmID0gc3VwZXJUeXBlLm5nQ29tcG9uZW50RGVmIHx8IHN1cGVyVHlwZS5uZ0RpcmVjdGl2ZURlZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdXBlclR5cGUubmdDb21wb25lbnREZWYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpcmVjdGl2ZXMgY2Fubm90IGluaGVyaXQgQ29tcG9uZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIGdldENvbXBvbmVudERlZi9nZXREaXJlY3RpdmVEZWYuIFRoaXMgbG9naWMgcmVsaWVzIG9uIGluaGVyaXRhbmNlLlxuICAgICAgICAgICAgc3VwZXJEZWYgPSBzdXBlclR5cGUubmdEaXJlY3RpdmVEZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VEZWYgPSBzdXBlclR5cGUubmdCYXNlRGVmO1xuICAgICAgICAvLyBTb21lIGZpZWxkcyBpbiB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgZW1wdHksIGlmIHRoZXJlIHdlcmUgbm8gdmFsdWVzIHRvIHB1dCBpbiB0aGVtIHRoYXRcbiAgICAgICAgLy8gd291bGQndmUganVzdGlmaWVkIG9iamVjdCBjcmVhdGlvbi4gVW53cmFwIHRoZW0gaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoYmFzZURlZiB8fCBzdXBlckRlZikge1xuICAgICAgICAgICAgdmFyIHdyaXRlYWJsZURlZiA9IGRlZmluaXRpb247XG4gICAgICAgICAgICB3cml0ZWFibGVEZWYuaW5wdXRzID0gbWF5YmVVbndyYXBFbXB0eShkZWZpbml0aW9uLmlucHV0cyk7XG4gICAgICAgICAgICB3cml0ZWFibGVEZWYuZGVjbGFyZWRJbnB1dHMgPSBtYXliZVVud3JhcEVtcHR5KGRlZmluaXRpb24uZGVjbGFyZWRJbnB1dHMpO1xuICAgICAgICAgICAgd3JpdGVhYmxlRGVmLm91dHB1dHMgPSBtYXliZVVud3JhcEVtcHR5KGRlZmluaXRpb24ub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VEZWYpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgICAgICAgICAgZmlsbFByb3BlcnRpZXMoZGVmaW5pdGlvbi5pbnB1dHMsIGJhc2VEZWYuaW5wdXRzKTtcbiAgICAgICAgICAgIGZpbGxQcm9wZXJ0aWVzKGRlZmluaXRpb24uZGVjbGFyZWRJbnB1dHMsIGJhc2VEZWYuZGVjbGFyZWRJbnB1dHMpO1xuICAgICAgICAgICAgZmlsbFByb3BlcnRpZXMoZGVmaW5pdGlvbi5vdXRwdXRzLCBiYXNlRGVmLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBlckRlZikge1xuICAgICAgICAgICAgLy8gTWVyZ2UgaG9zdEJpbmRpbmdzXG4gICAgICAgICAgICB2YXIgcHJldkhvc3RCaW5kaW5nc18xID0gZGVmaW5pdGlvbi5ob3N0QmluZGluZ3M7XG4gICAgICAgICAgICB2YXIgc3VwZXJIb3N0QmluZGluZ3NfMSA9IHN1cGVyRGVmLmhvc3RCaW5kaW5ncztcbiAgICAgICAgICAgIGlmIChzdXBlckhvc3RCaW5kaW5nc18xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZIb3N0QmluZGluZ3NfMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmhvc3RCaW5kaW5ncyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbmRleCwgZWxlbWVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlckhvc3RCaW5kaW5nc18xKGRpcmVjdGl2ZUluZGV4LCBlbGVtZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkhvc3RCaW5kaW5nc18xKGRpcmVjdGl2ZUluZGV4LCBlbGVtZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5ob3N0QmluZGluZ3MgPSBzdXBlckhvc3RCaW5kaW5nc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1lcmdlIFZpZXcgUXVlcmllc1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50RGVmKGRlZmluaXRpb24pICYmIGlzQ29tcG9uZW50RGVmKHN1cGVyRGVmKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Vmlld1F1ZXJ5XzEgPSBkZWZpbml0aW9uLnZpZXdRdWVyeTtcbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJWaWV3UXVlcnlfMSA9IHN1cGVyRGVmLnZpZXdRdWVyeTtcbiAgICAgICAgICAgICAgICBpZiAoc3VwZXJWaWV3UXVlcnlfMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlZpZXdRdWVyeV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uLnZpZXdRdWVyeSA9IGZ1bmN0aW9uIChyZiwgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXJWaWV3UXVlcnlfMShyZiwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Vmlld1F1ZXJ5XzEocmYsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi52aWV3UXVlcnkgPSBzdXBlclZpZXdRdWVyeV8xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWVyZ2UgQ29udGVudCBRdWVyaWVzXG4gICAgICAgICAgICB2YXIgcHJldkNvbnRlbnRRdWVyaWVzXzEgPSBkZWZpbml0aW9uLmNvbnRlbnRRdWVyaWVzO1xuICAgICAgICAgICAgdmFyIHN1cGVyQ29udGVudFF1ZXJpZXNfMSA9IHN1cGVyRGVmLmNvbnRlbnRRdWVyaWVzO1xuICAgICAgICAgICAgaWYgKHN1cGVyQ29udGVudFF1ZXJpZXNfMSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q29udGVudFF1ZXJpZXNfMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmNvbnRlbnRRdWVyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXJDb250ZW50UXVlcmllc18xKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q29udGVudFF1ZXJpZXNfMSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5jb250ZW50UXVlcmllcyA9IHN1cGVyQ29udGVudFF1ZXJpZXNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNZXJnZSBDb250ZW50IFF1ZXJpZXMgUmVmcmVzaFxuICAgICAgICAgICAgdmFyIHByZXZDb250ZW50UXVlcmllc1JlZnJlc2hfMSA9IGRlZmluaXRpb24uY29udGVudFF1ZXJpZXNSZWZyZXNoO1xuICAgICAgICAgICAgdmFyIHN1cGVyQ29udGVudFF1ZXJpZXNSZWZyZXNoXzEgPSBzdXBlckRlZi5jb250ZW50UXVlcmllc1JlZnJlc2g7XG4gICAgICAgICAgICBpZiAoc3VwZXJDb250ZW50UXVlcmllc1JlZnJlc2hfMSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q29udGVudFF1ZXJpZXNSZWZyZXNoXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5jb250ZW50UXVlcmllc1JlZnJlc2ggPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5kZXgsIHF1ZXJ5SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyQ29udGVudFF1ZXJpZXNSZWZyZXNoXzEoZGlyZWN0aXZlSW5kZXgsIHF1ZXJ5SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNvbnRlbnRRdWVyaWVzUmVmcmVzaF8xKGRpcmVjdGl2ZUluZGV4LCBxdWVyeUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24uY29udGVudFF1ZXJpZXNSZWZyZXNoID0gc3VwZXJDb250ZW50UXVlcmllc1JlZnJlc2hfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNZXJnZSBpbnB1dHMgYW5kIG91dHB1dHNcbiAgICAgICAgICAgIGZpbGxQcm9wZXJ0aWVzKGRlZmluaXRpb24uaW5wdXRzLCBzdXBlckRlZi5pbnB1dHMpO1xuICAgICAgICAgICAgZmlsbFByb3BlcnRpZXMoZGVmaW5pdGlvbi5kZWNsYXJlZElucHV0cywgc3VwZXJEZWYuZGVjbGFyZWRJbnB1dHMpO1xuICAgICAgICAgICAgZmlsbFByb3BlcnRpZXMoZGVmaW5pdGlvbi5vdXRwdXRzLCBzdXBlckRlZi5vdXRwdXRzKTtcbiAgICAgICAgICAgIC8vIEluaGVyaXQgaG9va3NcbiAgICAgICAgICAgIC8vIEFzc3VtZSBzdXBlciBjbGFzcyBpbmhlcml0YW5jZSBmZWF0dXJlIGhhcyBhbHJlYWR5IHJ1bi5cbiAgICAgICAgICAgIGRlZmluaXRpb24uYWZ0ZXJDb250ZW50Q2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlckNvbnRlbnRDaGVja2VkIHx8IHN1cGVyRGVmLmFmdGVyQ29udGVudENoZWNrZWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uLmFmdGVyQ29udGVudEluaXQgPSBkZWZpbml0aW9uLmFmdGVyQ29udGVudEluaXQgfHwgc3VwZXJEZWYuYWZ0ZXJDb250ZW50SW5pdDtcbiAgICAgICAgICAgIGRlZmluaXRpb24uYWZ0ZXJWaWV3Q2hlY2tlZCA9IGRlZmluaXRpb24uYWZ0ZXJWaWV3Q2hlY2tlZCB8fCBzdXBlckRlZi5hZnRlclZpZXdDaGVja2VkO1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlclZpZXdJbml0ID0gZGVmaW5pdGlvbi5hZnRlclZpZXdJbml0IHx8IHN1cGVyRGVmLmFmdGVyVmlld0luaXQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uLmRvQ2hlY2sgPSBkZWZpbml0aW9uLmRvQ2hlY2sgfHwgc3VwZXJEZWYuZG9DaGVjaztcbiAgICAgICAgICAgIGRlZmluaXRpb24ub25EZXN0cm95ID0gZGVmaW5pdGlvbi5vbkRlc3Ryb3kgfHwgc3VwZXJEZWYub25EZXN0cm95O1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5vbkluaXQgPSBkZWZpbml0aW9uLm9uSW5pdCB8fCBzdXBlckRlZi5vbkluaXQ7XG4gICAgICAgICAgICAvLyBSdW4gcGFyZW50IGZlYXR1cmVzXG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBzdXBlckRlZi5mZWF0dXJlcztcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZlYXR1cmVzXzEgPSBfX3ZhbHVlcyhmZWF0dXJlcyksIGZlYXR1cmVzXzFfMSA9IGZlYXR1cmVzXzEubmV4dCgpOyAhZmVhdHVyZXNfMV8xLmRvbmU7IGZlYXR1cmVzXzFfMSA9IGZlYXR1cmVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlICYmIGZlYXR1cmUgIT09IEluaGVyaXREZWZpbml0aW9uRmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlc18xXzEgJiYgIWZlYXR1cmVzXzFfMS5kb25lICYmIChfYSA9IGZlYXR1cmVzXzEucmV0dXJuKSkgX2EuY2FsbChmZWF0dXJlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZG9uJ3QgaGF2ZSBhIGRlZmluaXRpb24sIGNoZWNrIHRoZSB0eXBlIGZvciB0aGUgaG9va3MgYW5kIHVzZSB0aG9zZSBpZiBuZWVkIGJlXG4gICAgICAgICAgICB2YXIgc3VwZXJQcm90b3R5cGUgPSBzdXBlclR5cGUucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKHN1cGVyUHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlckNvbnRlbnRDaGVja2VkID1cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlckNvbnRlbnRDaGVja2VkIHx8IHN1cGVyUHJvdG90eXBlLmFmdGVyQ29udGVudENoZWNrZWQ7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlckNvbnRlbnRJbml0ID1cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlckNvbnRlbnRJbml0IHx8IHN1cGVyUHJvdG90eXBlLmFmdGVyQ29udGVudEluaXQ7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlclZpZXdDaGVja2VkID1cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlclZpZXdDaGVja2VkIHx8IHN1cGVyUHJvdG90eXBlLmFmdGVyVmlld0NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZnRlclZpZXdJbml0ID0gZGVmaW5pdGlvbi5hZnRlclZpZXdJbml0IHx8IHN1cGVyUHJvdG90eXBlLmFmdGVyVmlld0luaXQ7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5kb0NoZWNrID0gZGVmaW5pdGlvbi5kb0NoZWNrIHx8IHN1cGVyUHJvdG90eXBlLmRvQ2hlY2s7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5vbkRlc3Ryb3kgPSBkZWZpbml0aW9uLm9uRGVzdHJveSB8fCBzdXBlclByb3RvdHlwZS5vbkRlc3Ryb3k7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5vbkluaXQgPSBkZWZpbml0aW9uLm9uSW5pdCB8fCBzdXBlclByb3RvdHlwZS5vbkluaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJUeXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1cGVyVHlwZSk7XG4gICAgfTtcbiAgICB3aGlsZSAoc3VwZXJUeXBlKSB7XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF5YmVVbndyYXBFbXB0eSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gRU1QVFkkMSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBFTVBUWV9BUlJBWSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJJVkFURV9QUkVGSVggPSAnX19uZ09uQ2hhbmdlc18nO1xuLyoqXG4gKiBUaGUgTmdPbkNoYW5nZXNGZWF0dXJlIGRlY29yYXRlcyBhIGNvbXBvbmVudCB3aXRoIHN1cHBvcnQgZm9yIHRoZSBuZ09uQ2hhbmdlc1xuICogbGlmZWN5Y2xlIGhvb2ssIHNvIGl0IHNob3VsZCBiZSBpbmNsdWRlZCBpbiBhbnkgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50c1xuICogdGhhdCBob29rLlxuICpcbiAqIElmIHRoZSBjb21wb25lbnQgb3IgZGlyZWN0aXZlIHVzZXMgaW5oZXJpdGFuY2UsIHRoZSBOZ09uQ2hhbmdlc0ZlYXR1cmUgTVVTVFxuICogYmUgaW5jbHVkZWQgYXMgYSBmZWF0dXJlIEFGVEVSIHtAbGluayBJbmhlcml0RGVmaW5pdGlvbkZlYXR1cmV9LCBvdGhlcndpc2VcbiAqIGluaGVyaXRlZCBwcm9wZXJ0aWVzIHdpbGwgbm90IGJlIHByb3BhZ2F0ZWQgdG8gdGhlIG5nT25DaGFuZ2VzIGxpZmVjeWNsZVxuICogaG9vay5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqIGBgYFxuICogc3RhdGljIG5nQ29tcG9uZW50RGVmID0gZGVmaW5lQ29tcG9uZW50KHtcbiAqICAgLi4uXG4gKiAgIGlucHV0czoge25hbWU6ICdwdWJsaWNOYW1lJ30sXG4gKiAgIGZlYXR1cmVzOiBbTmdPbkNoYW5nZXNGZWF0dXJlXVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gTmdPbkNoYW5nZXNGZWF0dXJlKGRlZmluaXRpb24pIHtcbiAgICB2YXIgZGVjbGFyZWRUb01pbmlmaWVkSW5wdXRzID0gZGVmaW5pdGlvbi5kZWNsYXJlZElucHV0cztcbiAgICB2YXIgcHJvdG8gPSBkZWZpbml0aW9uLnR5cGUucHJvdG90eXBlO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGRlY2xhcmVkTmFtZSkge1xuICAgICAgICBpZiAoZGVjbGFyZWRUb01pbmlmaWVkSW5wdXRzLmhhc093blByb3BlcnR5KGRlY2xhcmVkTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBtaW5pZmllZEtleSA9IGRlY2xhcmVkVG9NaW5pZmllZElucHV0c1tkZWNsYXJlZE5hbWVdO1xuICAgICAgICAgICAgdmFyIHByaXZhdGVNaW5LZXlfMSA9IFBSSVZBVEVfUFJFRklYICsgbWluaWZpZWRLZXk7XG4gICAgICAgICAgICAvLyBXYWxrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gc2VlIGlmIHdlIGZpbmQgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gICAgICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4gaG9ub3Igc2V0dGVycyBhbmQgZ2V0dGVycyB0aGF0IHdlcmUgaW5oZXJpdGVkLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsUHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgY2hlY2tQcm90byA9IHByb3RvO1xuICAgICAgICAgICAgd2hpbGUgKCFvcmlnaW5hbFByb3BlcnR5ICYmIGNoZWNrUHJvdG8gJiZcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2hlY2tQcm90bykgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNoZWNrUHJvdG8sIG1pbmlmaWVkS2V5KTtcbiAgICAgICAgICAgICAgICBjaGVja1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNoZWNrUHJvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdldHRlciA9IG9yaWdpbmFsUHJvcGVydHkgJiYgb3JpZ2luYWxQcm9wZXJ0eS5nZXQ7XG4gICAgICAgICAgICB2YXIgc2V0dGVyXzEgPSBvcmlnaW5hbFByb3BlcnR5ICYmIG9yaWdpbmFsUHJvcGVydHkuc2V0O1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHByb3BlcnR5XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG1pbmlmaWVkS2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNldHRlcl8xID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1twcml2YXRlTWluS2V5XzFdOyB9KSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlQ2hhbmdlcyA9IHRoaXNbUFJJVkFURV9QUkVGSVhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUNoYW5nZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIHdoZXJlIHdlIHdpbGwgc3RvcmUgU2ltcGxlQ2hhbmdlcyBpZiB0aGVyZSBpcyBhIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFBSSVZBVEVfUFJFRklYLCB7IHZhbHVlOiBzaW1wbGVDaGFuZ2VzLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNGaXJzdENoYW5nZSA9ICF0aGlzLmhhc093blByb3BlcnR5KHByaXZhdGVNaW5LZXlfMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhbmdlID0gc2ltcGxlQ2hhbmdlc1tkZWNsYXJlZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYW5nZS5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZUNoYW5nZXNbZGVjbGFyZWROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNpbXBsZUNoYW5nZSh0aGlzW3ByaXZhdGVNaW5LZXlfMV0sIHZhbHVlLCBpc0ZpcnN0Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcGxhY2Ugd2hlcmUgdGhlIGFjdHVhbCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhbmQgbWFrZSBpdCBub24tZW51bWVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByaXZhdGVNaW5LZXlfMSwgeyB2YWx1ZTogdmFsdWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcml2YXRlTWluS2V5XzFdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRlcl8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyXzEuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBwcm9wZXJ0eSBjb25maWd1cmFibGUgaW4gZGV2IG1vZGUgdG8gYWxsb3cgb3ZlcnJpZGluZyBpbiB0ZXN0c1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogISFuZ0Rldk1vZGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBkZWNsYXJlZE5hbWUgaW4gZGVjbGFyZWRUb01pbmlmaWVkSW5wdXRzKSB7XG4gICAgICAgIF9sb29wXzEoZGVjbGFyZWROYW1lKTtcbiAgICB9XG4gICAgLy8gSWYgYW4gb25Jbml0IGhvb2sgaXMgZGVmaW5lZCwgaXQgd2lsbCBuZWVkIHRvIHdyYXAgdGhlIG5nT25DaGFuZ2VzIGNhbGxcbiAgICAvLyBzbyB0aGUgY2FsbCBvcmRlciBpcyBjaGFuZ2VzLWluaXQtY2hlY2sgaW4gY3JlYXRpb24gbW9kZS4gSW4gc3Vic2VxdWVudFxuICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24gcnVucywgb25seSB0aGUgY2hlY2sgd3JhcHBlciB3aWxsIGJlIGNhbGxlZC5cbiAgICBpZiAoZGVmaW5pdGlvbi5vbkluaXQgIT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uLm9uSW5pdCA9IG9uQ2hhbmdlc1dyYXBwZXIoZGVmaW5pdGlvbi5vbkluaXQpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uLmRvQ2hlY2sgPSBvbkNoYW5nZXNXcmFwcGVyKGRlZmluaXRpb24uZG9DaGVjayk7XG59XG5mdW5jdGlvbiBvbkNoYW5nZXNXcmFwcGVyKGRlbGVnYXRlSG9vaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaW1wbGVDaGFuZ2VzID0gdGhpc1tQUklWQVRFX1BSRUZJWF07XG4gICAgICAgIGlmIChzaW1wbGVDaGFuZ2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubmdPbkNoYW5nZXMoc2ltcGxlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0aGlzW1BSSVZBVEVfUFJFRklYXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGVnYXRlSG9vaylcbiAgICAgICAgICAgIGRlbGVnYXRlSG9vay5hcHBseSh0aGlzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoZSBudW1iZXIgb2Ygc2xvdHMgaW4gZWFjaCBibG9vbSBmaWx0ZXIgKHVzZWQgYnkgREkpLiBUaGUgbGFyZ2VyIHRoaXMgbnVtYmVyLCB0aGUgZmV3ZXJcbiAqIGRpcmVjdGl2ZXMgdGhhdCB3aWxsIHNoYXJlIHNsb3RzLCBhbmQgdGh1cywgdGhlIGZld2VyIGZhbHNlIHBvc2l0aXZlcyB3aGVuIGNoZWNraW5nIGZvclxuICogdGhlIGV4aXN0ZW5jZSBvZiBhIGRpcmVjdGl2ZS5cbiAqL1xudmFyIEJMT09NX1NJWkUgPSAyNTY7XG52YXIgQkxPT01fTUFTSyA9IEJMT09NX1NJWkUgLSAxO1xuLyoqIENvdW50ZXIgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciBkaXJlY3RpdmVzLiAqL1xudmFyIG5leHROZ0VsZW1lbnRJZCA9IDA7XG4vKipcbiAqIFJlZ2lzdGVycyB0aGlzIGRpcmVjdGl2ZSBhcyBwcmVzZW50IGluIGl0cyBub2RlJ3MgaW5qZWN0b3IgYnkgZmxpcHBpbmcgdGhlIGRpcmVjdGl2ZSdzXG4gKiBjb3JyZXNwb25kaW5nIGJpdCBpbiB0aGUgaW5qZWN0b3IncyBibG9vbSBmaWx0ZXIuXG4gKlxuICogQHBhcmFtIGluamVjdG9ySW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIGluamVjdG9yIHdoZXJlIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHJlZ2lzdGVyZWRcbiAqIEBwYXJhbSB0VmlldyBUaGUgVFZpZXcgZm9yIHRoZSBpbmplY3RvcidzIGJsb29tIGZpbHRlcnNcbiAqIEBwYXJhbSB0eXBlIFRoZSBkaXJlY3RpdmUgdG9rZW4gdG8gcmVnaXN0ZXJcbiAqL1xuZnVuY3Rpb24gYmxvb21BZGQoaW5qZWN0b3JJbmRleCwgdFZpZXcsIHR5cGUpIHtcbiAgICBpZiAodFZpZXcuZmlyc3RUZW1wbGF0ZVBhc3MpIHtcbiAgICAgICAgdmFyIGlkID0gdHlwZVtOR19FTEVNRU5UX0lEXTtcbiAgICAgICAgLy8gU2V0IGEgdW5pcXVlIElEIG9uIHRoZSBkaXJlY3RpdmUgdHlwZSwgc28gaWYgc29tZXRoaW5nIHRyaWVzIHRvIGluamVjdCB0aGUgZGlyZWN0aXZlLFxuICAgICAgICAvLyB3ZSBjYW4gZWFzaWx5IHJldHJpZXZlIHRoZSBJRCBhbmQgaGFzaCBpdCBpbnRvIHRoZSBibG9vbSBiaXQgdGhhdCBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIGlkID0gdHlwZVtOR19FTEVNRU5UX0lEXSA9IG5leHROZ0VsZW1lbnRJZCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgaGF2ZSBCTE9PTV9TSVpFICgyNTYpIHNsb3RzIGluIG91ciBibG9vbSBmaWx0ZXIgKDggYnVja2V0cyAqIDMyIGJpdHMgZWFjaCksXG4gICAgICAgIC8vIHNvIGFsbCB1bmlxdWUgSURzIG11c3QgYmUgbW9kdWxvLWVkIGludG8gYSBudW1iZXIgZnJvbSAwIC0gMjU1IHRvIGZpdCBpbnRvIHRoZSBmaWx0ZXIuXG4gICAgICAgIHZhciBibG9vbUJpdCA9IGlkICYgQkxPT01fTUFTSztcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFzayB0aGF0IHRhcmdldHMgdGhlIHNwZWNpZmljIGJpdCBhc3NvY2lhdGVkIHdpdGggdGhlIGRpcmVjdGl2ZS5cbiAgICAgICAgLy8gSlMgYml0IG9wZXJhdGlvbnMgYXJlIDMyIGJpdHMsIHNvIHRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDJeMCBhbmQgMl4zMSwgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyB0byBiaXQgcG9zaXRpb25zIDAgLSAzMSBpbiBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgICAgICB2YXIgbWFzayA9IDEgPDwgYmxvb21CaXQ7XG4gICAgICAgIC8vIFVzZSB0aGUgcmF3IGJsb29tQml0IG51bWJlciB0byBkZXRlcm1pbmUgd2hpY2ggYmxvb20gZmlsdGVyIGJ1Y2tldCB3ZSBzaG91bGQgY2hlY2tcbiAgICAgICAgLy8gZS5nOiBiZjAgPSBbMCAtIDMxXSwgYmYxID0gWzMyIC0gNjNdLCBiZjIgPSBbNjQgLSA5NV0sIGJmMyA9IFs5NiAtIDEyN10sIGV0Y1xuICAgICAgICB2YXIgYjcgPSBibG9vbUJpdCAmIDB4ODA7XG4gICAgICAgIHZhciBiNiA9IGJsb29tQml0ICYgMHg0MDtcbiAgICAgICAgdmFyIGI1ID0gYmxvb21CaXQgJiAweDIwO1xuICAgICAgICB2YXIgdERhdGEgPSB0Vmlldy5kYXRhO1xuICAgICAgICBpZiAoYjcpIHtcbiAgICAgICAgICAgIGI2ID8gKGI1ID8gKHREYXRhW2luamVjdG9ySW5kZXggKyA3XSB8PSBtYXNrKSA6ICh0RGF0YVtpbmplY3RvckluZGV4ICsgNl0gfD0gbWFzaykpIDpcbiAgICAgICAgICAgICAgICAoYjUgPyAodERhdGFbaW5qZWN0b3JJbmRleCArIDVdIHw9IG1hc2spIDogKHREYXRhW2luamVjdG9ySW5kZXggKyA0XSB8PSBtYXNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiNiA/IChiNSA/ICh0RGF0YVtpbmplY3RvckluZGV4ICsgM10gfD0gbWFzaykgOiAodERhdGFbaW5qZWN0b3JJbmRleCArIDJdIHw9IG1hc2spKSA6XG4gICAgICAgICAgICAgICAgKGI1ID8gKHREYXRhW2luamVjdG9ySW5kZXggKyAxXSB8PSBtYXNrKSA6ICh0RGF0YVtpbmplY3RvckluZGV4XSB8PSBtYXNrKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZU5vZGVJbmplY3RvcigpIHtcbiAgICByZXR1cm4gZ2V0T3JDcmVhdGVOb2RlSW5qZWN0b3JGb3JOb2RlKGdldFByZXZpb3VzT3JQYXJlbnRUTm9kZSgpLCBfZ2V0Vmlld0RhdGEoKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgKG9yIGdldHMgYW4gZXhpc3RpbmcpIGluamVjdG9yIGZvciBhIGdpdmVuIGVsZW1lbnQgb3IgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB0Tm9kZSBmb3Igd2hpY2ggYW4gaW5qZWN0b3Igc2hvdWxkIGJlIHJldHJpZXZlZCAvIGNyZWF0ZWQuXG4gKiBAcGFyYW0gaG9zdFZpZXcgVmlldyB3aGVyZSB0aGUgbm9kZSBpcyBzdG9yZWRcbiAqIEByZXR1cm5zIE5vZGUgaW5qZWN0b3JcbiAqL1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVOb2RlSW5qZWN0b3JGb3JOb2RlKHROb2RlLCBob3N0Vmlldykge1xuICAgIHZhciBleGlzdGluZ0luamVjdG9ySW5kZXggPSBnZXRJbmplY3RvckluZGV4KHROb2RlLCBob3N0Vmlldyk7XG4gICAgaWYgKGV4aXN0aW5nSW5qZWN0b3JJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5qZWN0b3JJbmRleDtcbiAgICB9XG4gICAgdmFyIHRWaWV3ID0gaG9zdFZpZXdbVFZJRVddO1xuICAgIGlmICh0Vmlldy5maXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICB0Tm9kZS5pbmplY3RvckluZGV4ID0gaG9zdFZpZXcubGVuZ3RoO1xuICAgICAgICBzZXRVcEJsb29tKHRWaWV3LmRhdGEsIHROb2RlKTsgLy8gZm91bmRhdGlvbiBmb3Igbm9kZSBibG9vbVxuICAgICAgICBzZXRVcEJsb29tKGhvc3RWaWV3LCBudWxsKTsgLy8gZm91bmRhdGlvbiBmb3IgY3VtdWxhdGl2ZSBibG9vbVxuICAgICAgICBzZXRVcEJsb29tKHRWaWV3LmJsdWVwcmludCwgbnVsbCk7XG4gICAgfVxuICAgIHZhciBwYXJlbnRMb2MgPSBnZXRQYXJlbnRJbmplY3RvckxvY2F0aW9uKHROb2RlLCBob3N0Vmlldyk7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gcGFyZW50TG9jICYgMzI3NjcgLyogSW5qZWN0b3JJbmRleE1hc2sgKi87XG4gICAgdmFyIHBhcmVudFZpZXcgPSBnZXRQYXJlbnRJbmplY3RvclZpZXcocGFyZW50TG9jLCBob3N0Vmlldyk7XG4gICAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWaWV3W1RWSUVXXS5kYXRhO1xuICAgIHZhciBpbmplY3RvckluZGV4ID0gdE5vZGUuaW5qZWN0b3JJbmRleDtcbiAgICAvLyBJZiBhIHBhcmVudCBpbmplY3RvciBjYW4ndCBiZSBmb3VuZCwgaXRzIGxvY2F0aW9uIGlzIHNldCB0byAtMS5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IG5lZWQgdG8gc2V0IHVwIGEgY3VtdWxhdGl2ZSBibG9vbVxuICAgIGlmIChwYXJlbnRMb2MgIT09IC0xKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUEFSRU5UX0lOSkVDVE9SOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBibG9vbUluZGV4ID0gcGFyZW50SW5kZXggKyBpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlcyBhIGN1bXVsYXRpdmUgYmxvb20gZmlsdGVyIHRoYXQgbWVyZ2VzIHRoZSBwYXJlbnQncyBibG9vbSBmaWx0ZXJcbiAgICAgICAgICAgIC8vIGFuZCBpdHMgb3duIGN1bXVsYXRpdmUgYmxvb20gKHdoaWNoIGNvbnRhaW5zIHRva2VucyBmb3IgYWxsIGFuY2VzdG9ycylcbiAgICAgICAgICAgIGhvc3RWaWV3W2luamVjdG9ySW5kZXggKyBpXSA9IHBhcmVudFZpZXdbYmxvb21JbmRleF0gfCBwYXJlbnREYXRhW2Jsb29tSW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhvc3RWaWV3W2luamVjdG9ySW5kZXggKyBQQVJFTlRfSU5KRUNUT1JdID0gcGFyZW50TG9jO1xuICAgIHJldHVybiBpbmplY3RvckluZGV4O1xufVxuZnVuY3Rpb24gc2V0VXBCbG9vbShhcnIsIGZvb3Rlcikge1xuICAgIGFyci5wdXNoKDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIGZvb3Rlcik7XG59XG5mdW5jdGlvbiBnZXRJbmplY3RvckluZGV4KHROb2RlLCBob3N0Vmlldykge1xuICAgIGlmICh0Tm9kZS5pbmplY3RvckluZGV4ID09PSAtMSB8fFxuICAgICAgICAvLyBJZiB0aGUgaW5qZWN0b3IgaW5kZXggaXMgdGhlIHNhbWUgYXMgaXRzIHBhcmVudCdzIGluamVjdG9yIGluZGV4LCB0aGVuIHRoZSBpbmRleCBoYXMgYmVlblxuICAgICAgICAvLyBjb3BpZWQgZG93biBmcm9tIHRoZSBwYXJlbnQgbm9kZS4gTm8gaW5qZWN0b3IgaGFzIGJlZW4gY3JlYXRlZCB5ZXQgb24gdGhpcyBub2RlLlxuICAgICAgICAodE5vZGUucGFyZW50ICYmIHROb2RlLnBhcmVudC5pbmplY3RvckluZGV4ID09PSB0Tm9kZS5pbmplY3RvckluZGV4KSB8fFxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgdGVtcGxhdGUgcGFzcywgdGhlIGluamVjdG9yIGluZGV4IG1pZ2h0IGV4aXN0IGJ1dCB0aGUgcGFyZW50IHZhbHVlc1xuICAgICAgICAvLyBtaWdodCBub3QgaGF2ZSBiZWVuIGNhbGN1bGF0ZWQgeWV0IGZvciB0aGlzIGluc3RhbmNlXG4gICAgICAgIGhvc3RWaWV3W3ROb2RlLmluamVjdG9ySW5kZXggKyBQQVJFTlRfSU5KRUNUT1JdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHROb2RlLmluamVjdG9ySW5kZXg7XG4gICAgfVxufVxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBpbmplY3Rvciwgd2l0aCBhIHZpZXcgb2Zmc2V0IGlmIGFwcGxpY2FibGUuIFVzZWQgdG8gc2V0IHRoZVxuICogcGFyZW50IGluamVjdG9yIGluaXRpYWxseS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5qZWN0b3JMb2NhdGlvbih0Tm9kZSwgdmlldykge1xuICAgIGlmICh0Tm9kZS5wYXJlbnQgJiYgdE5vZGUucGFyZW50LmluamVjdG9ySW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0Tm9kZS5wYXJlbnQuaW5qZWN0b3JJbmRleDsgLy8gdmlldyBvZmZzZXQgaXMgMFxuICAgIH1cbiAgICAvLyBGb3IgbW9zdCBjYXNlcywgdGhlIHBhcmVudCBpbmplY3RvciBpbmRleCBjYW4gYmUgZm91bmQgb24gdGhlIGhvc3Qgbm9kZSAoZS5nLiBmb3IgY29tcG9uZW50XG4gICAgLy8gb3IgY29udGFpbmVyKSwgc28gdGhpcyBsb29wIHdpbGwgYmUgc2tpcHBlZCwgYnV0IHdlIG11c3Qga2VlcCB0aGUgbG9vcCBoZXJlIHRvIHN1cHBvcnRcbiAgICAvLyB0aGUgcmFyZXIgY2FzZSBvZiBkZWVwbHkgbmVzdGVkIDxuZy10ZW1wbGF0ZT4gdGFncyBvciBpbmxpbmUgdmlld3MuXG4gICAgdmFyIGhvc3RUTm9kZSA9IHZpZXdbSE9TVF9OT0RFXTtcbiAgICB2YXIgdmlld09mZnNldCA9IDE7XG4gICAgd2hpbGUgKGhvc3RUTm9kZSAmJiBob3N0VE5vZGUuaW5qZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdmlldyA9IHZpZXdbREVDTEFSQVRJT05fVklFV107XG4gICAgICAgIGhvc3RUTm9kZSA9IHZpZXdbSE9TVF9OT0RFXTtcbiAgICAgICAgdmlld09mZnNldCsrO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdFROb2RlID9cbiAgICAgICAgaG9zdFROb2RlLmluamVjdG9ySW5kZXggfCAodmlld09mZnNldCA8PCAxNSAvKiBWaWV3T2Zmc2V0U2hpZnQgKi8pIDpcbiAgICAgICAgLTE7XG59XG4vKipcbiAqIFVud3JhcHMgYSBwYXJlbnQgaW5qZWN0b3IgbG9jYXRpb24gbnVtYmVyIHRvIGZpbmQgdGhlIHZpZXcgb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgaW5qZWN0b3IsXG4gKiB0aGVuIHdhbGtzIHVwIHRoZSBkZWNsYXJhdGlvbiB2aWV3IHRyZWUgdW50aWwgdGhlIHZpZXcgaXMgZm91bmQgdGhhdCBjb250YWlucyB0aGUgcGFyZW50XG4gKiBpbmplY3Rvci5cbiAqXG4gKiBAcGFyYW0gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSBwYXJlbnQgaW5qZWN0b3IsIHdoaWNoIGNvbnRhaW5zIHRoZSB2aWV3IG9mZnNldFxuICogQHBhcmFtIHN0YXJ0VmlldyBUaGUgTFZpZXdEYXRhIGluc3RhbmNlIGZyb20gd2hpY2ggdG8gc3RhcnQgd2Fsa2luZyB1cCB0aGUgdmlldyB0cmVlXG4gKiBAcmV0dXJucyBUaGUgTFZpZXdEYXRhIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdGhlIHBhcmVudCBpbmplY3RvclxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbmplY3RvclZpZXcobG9jYXRpb24sIHN0YXJ0Vmlldykge1xuICAgIHZhciB2aWV3T2Zmc2V0ID0gbG9jYXRpb24gPj4gMTUgLyogVmlld09mZnNldFNoaWZ0ICovO1xuICAgIHZhciBwYXJlbnRWaWV3ID0gc3RhcnRWaWV3O1xuICAgIC8vIEZvciBtb3N0IGNhc2VzLCB0aGUgcGFyZW50IGluamVjdG9yIGNhbiBiZSBmb3VuZCBvbiB0aGUgaG9zdCBub2RlIChlLmcuIGZvciBjb21wb25lbnRcbiAgICAvLyBvciBjb250YWluZXIpLCBidXQgd2UgbXVzdCBrZWVwIHRoZSBsb29wIGhlcmUgdG8gc3VwcG9ydCB0aGUgcmFyZXIgY2FzZSBvZiBkZWVwbHkgbmVzdGVkXG4gICAgLy8gPG5nLXRlbXBsYXRlPiB0YWdzIG9yIGlubGluZSB2aWV3cywgd2hlcmUgdGhlIHBhcmVudCBpbmplY3RvciBtaWdodCBsaXZlIG1hbnkgdmlld3NcbiAgICAvLyBhYm92ZSB0aGUgY2hpbGQgaW5qZWN0b3IuXG4gICAgd2hpbGUgKHZpZXdPZmZzZXQgPiAwKSB7XG4gICAgICAgIHBhcmVudFZpZXcgPSBwYXJlbnRWaWV3W0RFQ0xBUkFUSU9OX1ZJRVddO1xuICAgICAgICB2aWV3T2Zmc2V0LS07XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRWaWV3O1xufVxuLyoqXG4gKiBNYWtlcyBhIGRpcmVjdGl2ZSBwdWJsaWMgdG8gdGhlIERJIHN5c3RlbSBieSBhZGRpbmcgaXQgdG8gYW4gaW5qZWN0b3IncyBibG9vbSBmaWx0ZXIuXG4gKlxuICogQHBhcmFtIGRpIFRoZSBub2RlIGluamVjdG9yIGluIHdoaWNoIGEgZGlyZWN0aXZlIHdpbGwgYmUgYWRkZWRcbiAqIEBwYXJhbSBkZWYgVGhlIGRlZmluaXRpb24gb2YgdGhlIGRpcmVjdGl2ZSB0byBiZSBtYWRlIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkaVB1YmxpY0luSW5qZWN0b3IoaW5qZWN0b3JJbmRleCwgdmlldywgZGVmKSB7XG4gICAgYmxvb21BZGQoaW5qZWN0b3JJbmRleCwgdmlld1tUVklFV10sIGRlZi50eXBlKTtcbn1cbi8qKlxuICogTWFrZXMgYSBkaXJlY3RpdmUgcHVibGljIHRvIHRoZSBESSBzeXN0ZW0gYnkgYWRkaW5nIGl0IHRvIGFuIGluamVjdG9yJ3MgYmxvb20gZmlsdGVyLlxuICpcbiAqIEBwYXJhbSBkZWYgVGhlIGRlZmluaXRpb24gb2YgdGhlIGRpcmVjdGl2ZSB0byBiZSBtYWRlIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkaVB1YmxpYyhkZWYpIHtcbiAgICBkaVB1YmxpY0luSW5qZWN0b3IoZ2V0T3JDcmVhdGVOb2RlSW5qZWN0b3IoKSwgX2dldFZpZXdEYXRhKCksIGRlZik7XG59XG5mdW5jdGlvbiBkaXJlY3RpdmVJbmplY3QodG9rZW4sIGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAwIC8qIERlZmF1bHQgKi87IH1cbiAgICB2YXIgaG9zdFROb2RlID0gZ2V0UHJldmlvdXNPclBhcmVudFROb2RlKCk7XG4gICAgcmV0dXJuIGdldE9yQ3JlYXRlSW5qZWN0YWJsZShob3N0VE5vZGUsIF9nZXRWaWV3RGF0YSgpLCB0b2tlbiwgZmxhZ3MpO1xufVxuLyoqXG4gKiBJbmplY3Qgc3RhdGljIGF0dHJpYnV0ZSB2YWx1ZSBpbnRvIGRpcmVjdGl2ZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdpdGggYGZhY3RvcnlgIGZ1bmN0aW9ucyB3aGljaCBhcmUgZ2VuZXJhdGVkIGFzIHBhcnQgb2ZcbiAqIGBkZWZpbmVEaXJlY3RpdmVgIG9yIGBkZWZpbmVDb21wb25lbnRgLiBUaGUgbWV0aG9kIHJldHJpZXZlcyB0aGUgc3RhdGljIHZhbHVlXG4gKiBvZiBhbiBhdHRyaWJ1dGUuIChEeW5hbWljIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgc2luY2UgdGhleSBhcmUgbm90IHJlc29sdmVkXG4gKiAgYXQgdGhlIHRpbWUgb2YgaW5qZWN0aW9uIGFuZCBjYW4gY2hhbmdlIG92ZXIgdGltZS4pXG4gKlxuICogIyBFeGFtcGxlXG4gKiBHaXZlbjpcbiAqIGBgYFxuICogQENvbXBvbmVudCguLi4pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIGNvbnN0cnVjdG9yKEBBdHRyaWJ1dGUoJ3RpdGxlJykgdGl0bGU6IHN0cmluZykgeyAuLi4gfVxuICogfVxuICogYGBgXG4gKiBXaGVuIGluc3RhbnRpYXRlZCB3aXRoXG4gKiBgYGBcbiAqIDxteS1jb21wb25lbnQgdGl0bGU9XCJIZWxsb1wiPjwvbXktY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogVGhlbiBmYWN0b3J5IG1ldGhvZCBnZW5lcmF0ZWQgaXM6XG4gKiBgYGBcbiAqIE15Q29tcG9uZW50Lm5nQ29tcG9uZW50RGVmID0gZGVmaW5lQ29tcG9uZW50KHtcbiAqICAgZmFjdG9yeTogKCkgPT4gbmV3IE15Q29tcG9uZW50KGluamVjdEF0dHJpYnV0ZSgndGl0bGUnKSlcbiAqICAgLi4uXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBpbmplY3RBdHRyaWJ1dGUoYXR0ck5hbWVUb0luamVjdCkge1xuICAgIHZhciB0Tm9kZSA9IGdldFByZXZpb3VzT3JQYXJlbnRUTm9kZSgpO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnROb2RlT2ZQb3NzaWJsZVR5cGVzKHROb2RlLCAwIC8qIENvbnRhaW5lciAqLywgMyAvKiBFbGVtZW50ICovLCA0IC8qIEVsZW1lbnRDb250YWluZXIgKi8pO1xuICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHROb2RlLCAnZXhwZWN0aW5nIHROb2RlJyk7XG4gICAgdmFyIGF0dHJzID0gdE5vZGUuYXR0cnM7XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lID09PSAxIC8qIFNlbGVjdE9ubHkgKi8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT0gYXR0ck5hbWVUb0luamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gdG9rZW4gZnJvbSB0aGUgaW5qZWN0b3JzLlxuICpcbiAqIExvb2sgZm9yIHRoZSBpbmplY3RvciBwcm92aWRpbmcgdGhlIHRva2VuIGJ5IHdhbGtpbmcgdXAgdGhlIG5vZGUgaW5qZWN0b3IgdHJlZSBhbmQgdGhlblxuICogdGhlIG1vZHVsZSBpbmplY3RvciB0cmVlLlxuICpcbiAqIEBwYXJhbSBub2RlSW5qZWN0b3IgTm9kZSBpbmplY3RvciB3aGVyZSB0aGUgc2VhcmNoIHNob3VsZCBzdGFydFxuICogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiB0byBsb29rIGZvclxuICogQHBhcmFtIGZsYWdzIEluamVjdGlvbiBmbGFnc1xuICogQHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIGluamVjdG9yIG9yIGBudWxsYCB3aGVuIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUluamVjdGFibGUoaG9zdFROb2RlLCBob3N0VmlldywgdG9rZW4sIGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAwIC8qIERlZmF1bHQgKi87IH1cbiAgICB2YXIgYmxvb21IYXNoID0gYmxvb21IYXNoQml0T3JGYWN0b3J5KHRva2VuKTtcbiAgICAvLyBJZiB0aGUgSUQgc3RvcmVkIGhlcmUgaXMgYSBmdW5jdGlvbiwgdGhpcyBpcyBhIHNwZWNpYWwgb2JqZWN0IGxpa2UgRWxlbWVudFJlZiBvciBUZW1wbGF0ZVJlZlxuICAgIC8vIHNvIGp1c3QgY2FsbCB0aGUgZmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgaXQuXG4gICAgaWYgKHR5cGVvZiBibG9vbUhhc2ggPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBibG9vbUhhc2goKTtcbiAgICAvLyBJZiB0aGUgdG9rZW4gaGFzIGEgYmxvb20gaGFzaCwgdGhlbiBpdCBpcyBhIGRpcmVjdGl2ZSB0aGF0IGlzIHB1YmxpYyB0byB0aGUgaW5qZWN0aW9uIHN5c3RlbVxuICAgIC8vIChkaVB1YmxpYykgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byB0aGUgbW9kdWxlIGluamVjdG9yLlxuICAgIGlmIChibG9vbUhhc2ggIT0gbnVsbCkge1xuICAgICAgICB2YXIgc3RhcnRJbmplY3RvckluZGV4ID0gZ2V0SW5qZWN0b3JJbmRleChob3N0VE5vZGUsIGhvc3RWaWV3KTtcbiAgICAgICAgdmFyIGluamVjdG9ySW5kZXggPSBzdGFydEluamVjdG9ySW5kZXg7XG4gICAgICAgIHZhciBpbmplY3RvclZpZXcgPSBob3N0VmlldztcbiAgICAgICAgdmFyIHBhcmVudExvY2F0aW9uID0gLTE7XG4gICAgICAgIC8vIElmIHdlIHNob3VsZCBza2lwIHRoaXMgaW5qZWN0b3Igb3IgaWYgYW4gaW5qZWN0b3IgZG9lc24ndCBleGlzdCBvbiB0aGlzIG5vZGUgKGUuZy4gYWxsXG4gICAgICAgIC8vIGRpcmVjdGl2ZXMgb24gdGhpcyBub2RlIGFyZSBwcml2YXRlKSwgc3RhcnQgYnkgc2VhcmNoaW5nIHRoZSBwYXJlbnQgaW5qZWN0b3IuXG4gICAgICAgIGlmIChmbGFncyAmIDQgLyogU2tpcFNlbGYgKi8gfHwgaW5qZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhcmVudExvY2F0aW9uID0gaW5qZWN0b3JJbmRleCA9PT0gLTEgPyBnZXRQYXJlbnRJbmplY3RvckxvY2F0aW9uKGhvc3RUTm9kZSwgaG9zdFZpZXcpIDpcbiAgICAgICAgICAgICAgICBpbmplY3RvclZpZXdbaW5qZWN0b3JJbmRleCArIFBBUkVOVF9JTkpFQ1RPUl07XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90U2VhcmNoUGFyZW50KGZsYWdzLCBwYXJlbnRMb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RvckluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmplY3RvckluZGV4ID0gcGFyZW50TG9jYXRpb24gJiAzMjc2NyAvKiBJbmplY3RvckluZGV4TWFzayAqLztcbiAgICAgICAgICAgICAgICBpbmplY3RvclZpZXcgPSBnZXRQYXJlbnRJbmplY3RvclZpZXcocGFyZW50TG9jYXRpb24sIGluamVjdG9yVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluamVjdG9ySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB1cCB0aGUgaW5qZWN0b3IgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgcG90ZW50aWFsIG1hdGNoIG9yIHVudGlsIHdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vICppc24ndCogYSBtYXRjaC4gT3V0ZXIgbG9vcCBpcyBuZWNlc3NhcnkgaW4gY2FzZSB3ZSBnZXQgYSBmYWxzZSBwb3NpdGl2ZSBpbmplY3Rvci5cbiAgICAgICAgICAgIHdoaWxlIChpbmplY3RvckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IGluamVjdG9yLiBJZiBpdCBtYXRjaGVzLCBzdG9wIHNlYXJjaGluZyBmb3IgYW4gaW5qZWN0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGluamVjdG9ySGFzVG9rZW4oYmxvb21IYXNoLCBpbmplY3RvckluZGV4LCBpbmplY3RvclZpZXdbVFZJRVddLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnRMb2NhdGlvbiA9IGluamVjdG9yVmlld1tpbmplY3RvckluZGV4ICsgUEFSRU5UX0lOSkVDVE9SXTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90U2VhcmNoUGFyZW50KGZsYWdzLCBwYXJlbnRMb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3JJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFuY2VzdG9yIGJsb29tIGZpbHRlciB2YWx1ZSBoYXMgdGhlIGJpdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBkaXJlY3RpdmUsIHRyYXZlcnNlXG4gICAgICAgICAgICAgICAgLy8gdXAgdG8gZmluZCB0aGUgc3BlY2lmaWMgaW5qZWN0b3IuIElmIHRoZSBhbmNlc3RvciBibG9vbSBmaWx0ZXIgZG9lcyBub3QgaGF2ZSB0aGUgYml0LCB3ZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBhYm9ydC5cbiAgICAgICAgICAgICAgICBpZiAoaW5qZWN0b3JIYXNUb2tlbihibG9vbUhhc2gsIGluamVjdG9ySW5kZXgsIGluamVjdG9yVmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3JJbmRleCA9IHBhcmVudExvY2F0aW9uICYgMzI3NjcgLyogSW5qZWN0b3JJbmRleE1hc2sgKi87XG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9yVmlldyA9IGdldFBhcmVudEluamVjdG9yVmlldyhwYXJlbnRMb2NhdGlvbiwgaW5qZWN0b3JWaWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9ySW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm8gaW5qZWN0b3IgaXMgZm91bmQsIHdlICprbm93KiB0aGF0IHRoZXJlIGlzIG5vIGFuY2VzdG9yIGluamVjdG9yIHRoYXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAvLyB0b2tlbiwgc28gd2UgYWJvcnQuXG4gICAgICAgICAgICBpZiAoaW5qZWN0b3JJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgYW4gaW5qZWN0b3Igd2hpY2ggKm1heSogY29udGFpbiB0aGUgdG9rZW4sIHNvIHdlIHN0ZXAgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBpbmplY3RvcidzIGNvcnJlc3BvbmRpbmcgbm9kZSB0byBnZXQgdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSA9IHNlYXJjaERpcmVjdGl2ZXNPbkluamVjdG9yKGluamVjdG9ySW5kZXgsIGluamVjdG9yVmlldywgdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgKmRpZG4ndCogZmluZCB0aGUgZGlyZWN0aXZlIGZvciB0aGUgdG9rZW4gYW5kIHdlIGFyZSBzZWFyY2hpbmcgdGhlIGN1cnJlbnQgbm9kZSdzXG4gICAgICAgICAgICAvLyBpbmplY3RvciwgaXQncyBwb3NzaWJsZSB0aGUgZGlyZWN0aXZlIGlzIG9uIHRoaXMgbm9kZSBhbmQgaGFzbid0IGJlZW4gY3JlYXRlZCB5ZXQuXG4gICAgICAgICAgICBpZiAoaW5qZWN0b3JJbmRleCA9PT0gc3RhcnRJbmplY3RvckluZGV4ICYmIGhvc3RWaWV3ID09PSBpbmplY3RvclZpZXcgJiZcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBzZWFyY2hNYXRjaGVzUXVldWVkRm9yQ3JlYXRpb24odG9rZW4sIGluamVjdG9yVmlld1tUVklFV10pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBkZWYgd2Fzbid0IGZvdW5kIGFueXdoZXJlIG9uIHRoaXMgbm9kZSwgc28gaXQgd2FzIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB1cCB0aGUgdHJlZSBhbmQgY29udGludWUgc2VhcmNoaW5nLlxuICAgICAgICAgICAgaW5qZWN0b3JJbmRleCA9IHBhcmVudExvY2F0aW9uICYgMzI3NjcgLyogSW5qZWN0b3JJbmRleE1hc2sgKi87XG4gICAgICAgICAgICBpbmplY3RvclZpZXcgPSBnZXRQYXJlbnRJbmplY3RvclZpZXcocGFyZW50TG9jYXRpb24sIGluamVjdG9yVmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1vZHVsZUluamVjdG9yID0gaG9zdFZpZXdbSU5KRUNUT1IkMV07XG4gICAgdmFyIGZvcm1lckluamVjdG9yID0gc2V0Q3VycmVudEluamVjdG9yKG1vZHVsZUluamVjdG9yKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW5qZWN0KHRva2VuLCBmbGFncyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50SW5qZWN0b3IoZm9ybWVySW5qZWN0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlYXJjaE1hdGNoZXNRdWV1ZWRGb3JDcmVhdGlvbih0b2tlbiwgaG9zdFRWaWV3KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0VFZpZXcuY3VycmVudE1hdGNoZXM7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgIGlmIChkZWYudHlwZSA9PT0gdG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZURpcmVjdGl2ZShkZWYsIGkgKyAxLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlYXJjaERpcmVjdGl2ZXNPbkluamVjdG9yKGluamVjdG9ySW5kZXgsIGluamVjdG9yVmlldywgdG9rZW4pIHtcbiAgICB2YXIgdE5vZGUgPSBpbmplY3RvclZpZXdbVFZJRVddLmRhdGFbaW5qZWN0b3JJbmRleCArIFROT0RFXTtcbiAgICB2YXIgbm9kZUZsYWdzID0gdE5vZGUuZmxhZ3M7XG4gICAgdmFyIGNvdW50ID0gbm9kZUZsYWdzICYgNDA5NSAvKiBEaXJlY3RpdmVDb3VudE1hc2sgKi87XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG5vZGVGbGFncyA+PiAxNSAvKiBEaXJlY3RpdmVTdGFydGluZ0luZGV4U2hpZnQgKi87XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgICAgICB2YXIgZGVmcyA9IGluamVjdG9yVmlld1tUVklFV10uZGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVmaW5pdGlvbiBmb3IgdGhlIGRpcmVjdGl2ZSBhdCB0aGlzIGluZGV4IGFuZCwgaWYgaXQgaXMgaW5qZWN0YWJsZSAoZGlQdWJsaWMpLFxuICAgICAgICAgICAgLy8gYW5kIG1hdGNoZXMgdGhlIGdpdmVuIHRva2VuLCByZXR1cm4gdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVEZWYgPSBkZWZzW2ldO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZURlZi50eXBlID09PSB0b2tlbiAmJiBkaXJlY3RpdmVEZWYuZGlQdWJsaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0b3JWaWV3W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXQgaW4gYW4gaW5qZWN0b3IncyBibG9vbSBmaWx0ZXIgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3RcbiAqIHRoZSBkaXJlY3RpdmUgbWlnaHQgYmUgcHJvdmlkZWQgYnkgdGhlIGluamVjdG9yLlxuICpcbiAqIFdoZW4gYSBkaXJlY3RpdmUgaXMgcHVibGljLCBpdCBpcyBhZGRlZCB0byB0aGUgYmxvb20gZmlsdGVyIGFuZCBnaXZlbiBhIHVuaXF1ZSBJRCB0aGF0IGNhbiBiZVxuICogcmV0cmlldmVkIG9uIHRoZSBUeXBlLiBXaGVuIHRoZSBkaXJlY3RpdmUgaXNuJ3QgcHVibGljIG9yIHRoZSB0b2tlbiBpcyBub3QgYSBkaXJlY3RpdmUgYG51bGxgXG4gKiBpcyByZXR1cm5lZCBhcyB0aGUgbm9kZSBpbmplY3RvciBjYW4gbm90IHBvc3NpYmx5IHByb3ZpZGUgdGhhdCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gdGhlIGluamVjdGlvbiB0b2tlblxuICogQHJldHVybnMgdGhlIG1hdGNoaW5nIGJpdCB0byBjaGVjayBpbiB0aGUgYmxvb20gZmlsdGVyIG9yIGBudWxsYCBpZiB0aGUgdG9rZW4gaXMgbm90IGtub3duLlxuICovXG5mdW5jdGlvbiBibG9vbUhhc2hCaXRPckZhY3RvcnkodG9rZW4pIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGVmaW5lZCh0b2tlbiwgJ3Rva2VuIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHZhciB0b2tlbklkID0gdG9rZW5bTkdfRUxFTUVOVF9JRF07XG4gICAgcmV0dXJuIHR5cGVvZiB0b2tlbklkID09PSAnbnVtYmVyJyA/IHRva2VuSWQgJiBCTE9PTV9NQVNLIDogdG9rZW5JZDtcbn1cbmZ1bmN0aW9uIGluamVjdG9ySGFzVG9rZW4oYmxvb21IYXNoLCBpbmplY3RvckluZGV4LCBpbmplY3RvclZpZXcpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXNrIHRoYXQgdGFyZ2V0cyB0aGUgc3BlY2lmaWMgYml0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZGlyZWN0aXZlIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIC8vIEpTIGJpdCBvcGVyYXRpb25zIGFyZSAzMiBiaXRzLCBzbyB0aGlzIHdpbGwgYmUgYSBudW1iZXIgYmV0d2VlbiAyXjAgYW5kIDJeMzEsIGNvcnJlc3BvbmRpbmdcbiAgICAvLyB0byBiaXQgcG9zaXRpb25zIDAgLSAzMSBpbiBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgIHZhciBtYXNrID0gMSA8PCBibG9vbUhhc2g7XG4gICAgdmFyIGI3ID0gYmxvb21IYXNoICYgMHg4MDtcbiAgICB2YXIgYjYgPSBibG9vbUhhc2ggJiAweDQwO1xuICAgIHZhciBiNSA9IGJsb29tSGFzaCAmIDB4MjA7XG4gICAgLy8gT3VyIGJsb29tIGZpbHRlciBzaXplIGlzIDI1NiBiaXRzLCB3aGljaCBpcyBlaWdodCAzMi1iaXQgYmxvb20gZmlsdGVyIGJ1Y2tldHM6XG4gICAgLy8gYmYwID0gWzAgLSAzMV0sIGJmMSA9IFszMiAtIDYzXSwgYmYyID0gWzY0IC0gOTVdLCBiZjMgPSBbOTYgLSAxMjddLCBldGMuXG4gICAgLy8gR2V0IHRoZSBibG9vbSBmaWx0ZXIgdmFsdWUgZnJvbSB0aGUgYXBwcm9wcmlhdGUgYnVja2V0IGJhc2VkIG9uIHRoZSBkaXJlY3RpdmUncyBibG9vbUJpdC5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGI3KSB7XG4gICAgICAgIHZhbHVlID0gYjYgPyAoYjUgPyBpbmplY3RvclZpZXdbaW5qZWN0b3JJbmRleCArIDddIDogaW5qZWN0b3JWaWV3W2luamVjdG9ySW5kZXggKyA2XSkgOlxuICAgICAgICAgICAgKGI1ID8gaW5qZWN0b3JWaWV3W2luamVjdG9ySW5kZXggKyA1XSA6IGluamVjdG9yVmlld1tpbmplY3RvckluZGV4ICsgNF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBiNiA/IChiNSA/IGluamVjdG9yVmlld1tpbmplY3RvckluZGV4ICsgM10gOiBpbmplY3RvclZpZXdbaW5qZWN0b3JJbmRleCArIDJdKSA6XG4gICAgICAgICAgICAoYjUgPyBpbmplY3RvclZpZXdbaW5qZWN0b3JJbmRleCArIDFdIDogaW5qZWN0b3JWaWV3W2luamVjdG9ySW5kZXhdKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGJsb29tIGZpbHRlciB2YWx1ZSBoYXMgdGhlIGJpdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBkaXJlY3RpdmUncyBibG9vbUJpdCBmbGlwcGVkIG9uLFxuICAgIC8vIHRoaXMgaW5qZWN0b3IgaXMgYSBwb3RlbnRpYWwgbWF0Y2guXG4gICAgcmV0dXJuICEhKHZhbHVlICYgbWFzayk7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIGZsYWdzIHByZXZlbnQgcGFyZW50IGluamVjdG9yIGZyb20gYmVpbmcgc2VhcmNoZWQgZm9yIHRva2VucyAqL1xuZnVuY3Rpb24gc2hvdWxkTm90U2VhcmNoUGFyZW50KGZsYWdzLCBwYXJlbnRMb2NhdGlvbikge1xuICAgIHJldHVybiBmbGFncyAmIDIgLyogU2VsZiAqLyB8fFxuICAgICAgICAoZmxhZ3MgJiAxIC8qIEhvc3QgKi8gJiYgKHBhcmVudExvY2F0aW9uID4+IDE1IC8qIFZpZXdPZmZzZXRTaGlmdCAqLykgPiAwKTtcbn1cbnZhciBOb2RlSW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUluamVjdG9yKF90Tm9kZSwgX2hvc3RWaWV3KSB7XG4gICAgICAgIHRoaXMuX3ROb2RlID0gX3ROb2RlO1xuICAgICAgICB0aGlzLl9ob3N0VmlldyA9IF9ob3N0VmlldztcbiAgICAgICAgdGhpcy5faW5qZWN0b3JJbmRleCA9IGdldE9yQ3JlYXRlTm9kZUluamVjdG9yRm9yTm9kZShfdE5vZGUsIF9ob3N0Vmlldyk7XG4gICAgfVxuICAgIE5vZGVJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHNldEVudmlyb25tZW50KHRoaXMuX3ROb2RlLCB0aGlzLl9ob3N0Vmlldyk7XG4gICAgICAgIHJldHVybiBnZXRPckNyZWF0ZUluamVjdGFibGUodGhpcy5fdE5vZGUsIHRoaXMuX2hvc3RWaWV3LCB0b2tlbik7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZUluamVjdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGdldEZhY3RvcnlPZih0eXBlKSB7XG4gICAgdmFyIHR5cGVBbnkgPSB0eXBlO1xuICAgIHZhciBkZWYgPSBnZXRDb21wb25lbnREZWYodHlwZUFueSkgfHwgZ2V0RGlyZWN0aXZlRGVmKHR5cGVBbnkpIHx8XG4gICAgICAgIGdldFBpcGVEZWYodHlwZUFueSkgfHwgZ2V0SW5qZWN0YWJsZURlZih0eXBlQW55KSB8fCBnZXRJbmplY3RvckRlZih0eXBlQW55KTtcbiAgICBpZiAoIWRlZiB8fCBkZWYuZmFjdG9yeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmZhY3Rvcnk7XG59XG5mdW5jdGlvbiBnZXRJbmhlcml0ZWRGYWN0b3J5KHR5cGUpIHtcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgIHZhciBmYWN0b3J5ID0gZ2V0RmFjdG9yeU9mKHByb3RvKTtcbiAgICBpZiAoZmFjdG9yeSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGZhY3RvcnkgZGVmaW5lZC4gRWl0aGVyIHRoaXMgd2FzIGltcHJvcGVyIHVzYWdlIG9mIGluaGVyaXRhbmNlXG4gICAgICAgIC8vIChubyBBbmd1bGFyIGRlY29yYXRvciBvbiB0aGUgc3VwZXJjbGFzcykgb3IgdGhlcmUgaXMgbm8gY29uc3RydWN0b3IgYXQgYWxsXG4gICAgICAgIC8vIGluIHRoZSBpbmhlcml0YW5jZSBjaGFpbi4gU2luY2UgdGhlIHR3byBjYXNlcyBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCwgdGhlXG4gICAgICAgIC8vIGxhdHRlciBoYXMgdG8gYmUgYXNzdW1lZC5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiBuZXcgdCgpOyB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIGZlYXR1cmUgcHVibGlzaGVzIHRoZSBkaXJlY3RpdmUgKG9yIGNvbXBvbmVudCkgaW50byB0aGUgREkgc3lzdGVtLCBtYWtpbmcgaXQgdmlzaWJsZSB0b1xuICogb3RoZXJzIGZvciBpbmplY3Rpb24uXG4gKlxuICogQHBhcmFtIGRlZmluaXRpb25cbiAqL1xuZnVuY3Rpb24gUHVibGljRmVhdHVyZShkZWZpbml0aW9uKSB7XG4gICAgZGVmaW5pdGlvbi5kaVB1YmxpYyA9IGRpUHVibGljO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wb25lbnQgY3JlYXRlZCBieSBhIGBDb21wb25lbnRGYWN0b3J5YC5cbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlIGFuZCByZWxhdGVkIG9iamVjdHMsXG4gKiBhbmQgcHJvdmlkZXMgdGhlIG1lYW5zIG9mIGRlc3Ryb3lpbmcgdGhlIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENvbXBvbmVudFJlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRSZWYoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21wb25lbnRSZWY7XG59KCkpO1xuLyoqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDb21wb25lbnRGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9Db21wb25lbnRGYWN0b3J5RXJyb3IoY29tcG9uZW50KSB7XG4gICAgdmFyIGVycm9yID0gRXJyb3IoXCJObyBjb21wb25lbnQgZmFjdG9yeSBmb3VuZCBmb3IgXCIgKyBzdHJpbmdpZnkoY29tcG9uZW50KSArIFwiLiBEaWQgeW91IGFkZCBpdCB0byBATmdNb2R1bGUuZW50cnlDb21wb25lbnRzP1wiKTtcbiAgICBlcnJvcltFUlJPUl9DT01QT05FTlRdID0gY29tcG9uZW50O1xuICAgIHJldHVybiBlcnJvcjtcbn1cbnZhciBFUlJPUl9DT01QT05FTlQgPSAnbmdDb21wb25lbnQnO1xudmFyIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuTlVMTCA9IG5ldyBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcigpO1xuICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG59KCkpO1xudmFyIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihmYWN0b3JpZXMsIF9wYXJlbnQsIF9uZ01vZHVsZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLl9uZ01vZHVsZSA9IF9uZ01vZHVsZTtcbiAgICAgICAgdGhpcy5fZmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBmYWN0b3JpZXNbaV07XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMuc2V0KGZhY3RvcnkuY29tcG9uZW50VHlwZSwgZmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5fZmFjdG9yaWVzLmdldChjb21wb25lbnQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkgJiYgdGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gdGhpcy5fcGFyZW50LnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICAgICAgICB0aHJvdyBub0NvbXBvbmVudEZhY3RvcnlFcnJvcihjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50RmFjdG9yeUJvdW5kVG9Nb2R1bGUoZmFjdG9yeSwgdGhpcy5fbmdNb2R1bGUpO1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG59KCkpO1xudmFyIENvbXBvbmVudEZhY3RvcnlCb3VuZFRvTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRGYWN0b3J5Qm91bmRUb01vZHVsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5Qm91bmRUb01vZHVsZShmYWN0b3J5LCBuZ01vZHVsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgX3RoaXMubmdNb2R1bGUgPSBuZ01vZHVsZTtcbiAgICAgICAgX3RoaXMuc2VsZWN0b3IgPSBmYWN0b3J5LnNlbGVjdG9yO1xuICAgICAgICBfdGhpcy5jb21wb25lbnRUeXBlID0gZmFjdG9yeS5jb21wb25lbnRUeXBlO1xuICAgICAgICBfdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBmYWN0b3J5Lm5nQ29udGVudFNlbGVjdG9ycztcbiAgICAgICAgX3RoaXMuaW5wdXRzID0gZmFjdG9yeS5pbnB1dHM7XG4gICAgICAgIF90aGlzLm91dHB1dHMgPSBmYWN0b3J5Lm91dHB1dHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29tcG9uZW50RmFjdG9yeUJvdW5kVG9Nb2R1bGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlLCBuZ01vZHVsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZShpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlLCBuZ01vZHVsZSB8fCB0aGlzLm5nTW9kdWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5Qm91bmRUb01vZHVsZTtcbn0oQ29tcG9uZW50RmFjdG9yeSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgYW4gTmdNb2R1bGUgY3JlYXRlZCB2aWEgYSB7QGxpbmsgTmdNb2R1bGVGYWN0b3J5fS5cbiAqXG4gKiBgTmdNb2R1bGVSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgTmdNb2R1bGUgSW5zdGFuY2UgYXMgd2VsbCBvdGhlciBvYmplY3RzIHJlbGF0ZWQgdG8gdGhpc1xuICogTmdNb2R1bGUgSW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgTmdNb2R1bGVSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdNb2R1bGVSZWYoKSB7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZVJlZjtcbn0oKSk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5nTW9kdWxlRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZUZhY3RvcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZUZhY3Rvcnk7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVmlld1JlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3UmVmKF92aWV3LCBfY29udGV4dCwgX2NvbXBvbmVudEluZGV4KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBfY29udGV4dDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50SW5kZXggPSBfY29tcG9uZW50SW5kZXg7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90Vmlld05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZXh0ID8gdGhpcy5fY29udGV4dCA6IHRoaXMuX2xvb2tVcENvbnRleHQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWYucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl92aWV3W0ZMQUdTXSAmIDMyIC8qIERlc3Ryb3llZCAqLykgPT09IDMyIC8qIERlc3Ryb3llZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld1JlZi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdDb250YWluZXJSZWYgJiYgdmlld0F0dGFjaGVkKHRoaXMuX3ZpZXcpKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmRldGFjaCh0aGlzLl92aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdHJveUxWaWV3KHRoaXMuX3ZpZXcpO1xuICAgIH07XG4gICAgVmlld1JlZi5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHN0b3JlQ2xlYW51cEZuKHRoaXMuX3ZpZXcsIGNhbGxiYWNrKTsgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIHZpZXcgYW5kIGFsbCBvZiBpdHMgYW5jZXN0b3JzIGRpcnR5LlxuICAgICAqXG4gICAgICogSXQgYWxzbyB0cmlnZ2VycyBjaGFuZ2UgZGV0ZWN0aW9uIGJ5IGNhbGxpbmcgYHNjaGVkdWxlVGlja2AgaW50ZXJuYWxseSwgd2hpY2ggY29hbGVzY2VzXG4gICAgICogbXVsdGlwbGUgYG1hcmtGb3JDaGVja2AgY2FsbHMgdG8gaW50byBvbmUgY2hhbmdlIGRldGVjdGlvbiBydW4uXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSBhbiB7QGxpbmsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kjT25QdXNoIE9uUHVzaH0gY29tcG9uZW50IGlzXG4gICAgICogY2hlY2tlZCB3aGVuIGl0IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkIGJ1dCB0aGUgdHdvIG5vcm1hbCB0cmlnZ2VycyBoYXZlbid0IG1hcmtlZCBpdFxuICAgICAqIGRpcnR5IChpLmUuIGlucHV0cyBoYXZlbid0IGNoYW5nZWQgYW5kIGV2ZW50cyBoYXZlbid0IGZpcmVkIGluIHRoZSB2aWV3KS5cbiAgICAgKlxuICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byBhIGNoYXB0ZXIgb24gT25QdXNoIGNvbXBvbmVudHMgLS0+XG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICB0ZW1wbGF0ZTogYE51bWJlciBvZiB0aWNrczoge3tudW1iZXJPZlRpY2tzfX1gXG4gICAgICogICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICogICBudW1iZXJPZlRpY2tzID0gMDtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICogICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgKiAgICAgICB0aGlzLm51bWJlck9mVGlja3MrKztcbiAgICAgKiAgICAgICAvLyB0aGUgZm9sbG93aW5nIGlzIHJlcXVpcmVkLCBvdGhlcndpc2UgdGhlIHZpZXcgd2lsbCBub3QgYmUgdXBkYXRlZFxuICAgICAqICAgICAgIHRoaXMucmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAqICAgICB9LCAxMDAwKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgVmlld1JlZi5wcm90b3R5cGUubWFya0ZvckNoZWNrID0gZnVuY3Rpb24gKCkgeyBtYXJrVmlld0RpcnR5KHRoaXMuX3ZpZXcpOyB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaGVzIHRoZSB2aWV3IGZyb20gdGhlIGNoYW5nZSBkZXRlY3Rpb24gdHJlZS5cbiAgICAgKlxuICAgICAqIERldGFjaGVkIHZpZXdzIHdpbGwgbm90IGJlIGNoZWNrZWQgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24gcnVucyB1bnRpbCB0aGV5IGFyZVxuICAgICAqIHJlLWF0dGFjaGVkLCBldmVuIGlmIHRoZXkgYXJlIGRpcnR5LiBgZGV0YWNoYCBjYW4gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoXG4gICAgICoge0BsaW5rIENoYW5nZURldGVjdG9yUmVmI2RldGVjdENoYW5nZXMgZGV0ZWN0Q2hhbmdlc30gdG8gaW1wbGVtZW50IGxvY2FsIGNoYW5nZVxuICAgICAqIGRldGVjdGlvbiBjaGVja3MuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gYSBjaGFwdGVyIG9uIGRldGFjaC9yZWF0dGFjaC9sb2NhbCBkaWdlc3QgLS0+XG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaXZlIGRlbW8gb25jZSByZWYuZGV0ZWN0Q2hhbmdlcyBpcyBtZXJnZWQgaW50byBtYXN0ZXIgLS0+XG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVmaW5lcyBhIGNvbXBvbmVudCB3aXRoIGEgbGFyZ2UgbGlzdCBvZiByZWFkb25seSBkYXRhLlxuICAgICAqIEltYWdpbmUgdGhlIGRhdGEgY2hhbmdlcyBjb25zdGFudGx5LCBtYW55IHRpbWVzIHBlciBzZWNvbmQuIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICAgICAqIHdlIHdhbnQgdG8gY2hlY2sgYW5kIHVwZGF0ZSB0aGUgbGlzdCBldmVyeSBmaXZlIHNlY29uZHMuIFdlIGNhbiBkbyB0aGF0IGJ5IGRldGFjaGluZ1xuICAgICAqIHRoZSBjb21wb25lbnQncyBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGRvaW5nIGEgbG9jYWwgY2hlY2sgZXZlcnkgZml2ZSBzZWNvbmRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIERhdGFQcm92aWRlciB7XG4gICAgICogICAvLyBpbiBhIHJlYWwgYXBwbGljYXRpb24gdGhlIHJldHVybmVkIGRhdGEgd2lsbCBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZVxuICAgICAqICAgZ2V0IGRhdGEoKSB7XG4gICAgICogICAgIHJldHVybiBbMSwyLDMsNCw1XTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnZ2lhbnQtbGlzdCcsXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8bGkgKm5nRm9yPVwibGV0IGQgb2YgZGF0YVByb3ZpZGVyLmRhdGFcIj5EYXRhIHt7ZH19PC9saT5cbiAgICAgKiAgIGAsXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBHaWFudExpc3Qge1xuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcml2YXRlIGRhdGFQcm92aWRlcjogRGF0YVByb3ZpZGVyKSB7XG4gICAgICogICAgIHJlZi5kZXRhY2goKTtcbiAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAqICAgICAgIHRoaXMucmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgKiAgICAgfSwgNTAwMCk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgICogICBwcm92aWRlcnM6IFtEYXRhUHJvdmlkZXJdLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgPGdpYW50LWxpc3Q+PGdpYW50LWxpc3Q+XG4gICAgICogICBgLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwIHtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgVmlld1JlZi5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3W0ZMQUdTXSAmPSB+OCAvKiBBdHRhY2hlZCAqLzsgfTtcbiAgICAvKipcbiAgICAgKiBSZS1hdHRhY2hlcyBhIHZpZXcgdG8gdGhlIGNoYW5nZSBkZXRlY3Rpb24gdHJlZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmUtYXR0YWNoIHZpZXdzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRldGFjaGVkIGZyb20gdGhlIHRyZWVcbiAgICAgKiB1c2luZyB7QGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWYjZGV0YWNoIGRldGFjaH0uIFZpZXdzIGFyZSBhdHRhY2hlZCB0byB0aGUgdHJlZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIGEgY2hhcHRlciBvbiBkZXRhY2gvcmVhdHRhY2gvbG9jYWwgZGlnZXN0IC0tPlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgZGlzcGxheWluZyBgbGl2ZWAgZGF0YS4gVGhlIGNvbXBvbmVudCB3aWxsIGRldGFjaFxuICAgICAqIGl0cyBjaGFuZ2UgZGV0ZWN0b3IgZnJvbSB0aGUgbWFpbiBjaGFuZ2UgZGV0ZWN0b3IgdHJlZSB3aGVuIHRoZSBjb21wb25lbnQncyBsaXZlIHByb3BlcnR5XG4gICAgICogaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIERhdGFQcm92aWRlciB7XG4gICAgICogICBkYXRhID0gMTtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAgICogICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgKiAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEgKiAyO1xuICAgICAqICAgICB9LCA1MDApO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdsaXZlLWRhdGEnLFxuICAgICAqICAgaW5wdXRzOiBbJ2xpdmUnXSxcbiAgICAgKiAgIHRlbXBsYXRlOiAnRGF0YToge3tkYXRhUHJvdmlkZXIuZGF0YX19J1xuICAgICAqIH0pXG4gICAgICogY2xhc3MgTGl2ZURhdGEge1xuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcml2YXRlIGRhdGFQcm92aWRlcjogRGF0YVByb3ZpZGVyKSB7fVxuICAgICAqXG4gICAgICogICBzZXQgbGl2ZSh2YWx1ZSkge1xuICAgICAqICAgICBpZiAodmFsdWUpIHtcbiAgICAgKiAgICAgICB0aGlzLnJlZi5yZWF0dGFjaCgpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gICAgICogICBwcm92aWRlcnM6IFtEYXRhUHJvdmlkZXJdLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgTGl2ZSBVcGRhdGU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbKG5nTW9kZWwpXT1cImxpdmVcIj5cbiAgICAgKiAgICAgPGxpdmUtZGF0YSBbbGl2ZV09XCJsaXZlXCI+PGxpdmUtZGF0YT5cbiAgICAgKiAgIGAsXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgbGl2ZSA9IHRydWU7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFZpZXdSZWYucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3W0ZMQUdTXSB8PSA4IC8qIEF0dGFjaGVkICovOyB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgdmlldyBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYWxzbyBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGgge0BsaW5rIENoYW5nZURldGVjdG9yUmVmI2RldGFjaCBkZXRhY2h9IHRvIGltcGxlbWVudFxuICAgICAqIGxvY2FsIGNoYW5nZSBkZXRlY3Rpb24gY2hlY2tzLlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIGEgY2hhcHRlciBvbiBkZXRhY2gvcmVhdHRhY2gvbG9jYWwgZGlnZXN0IC0tPlxuICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGl2ZSBkZW1vIG9uY2UgcmVmLmRldGVjdENoYW5nZXMgaXMgbWVyZ2VkIGludG8gbWFzdGVyIC0tPlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlZmluZXMgYSBjb21wb25lbnQgd2l0aCBhIGxhcmdlIGxpc3Qgb2YgcmVhZG9ubHkgZGF0YS5cbiAgICAgKiBJbWFnaW5lLCB0aGUgZGF0YSBjaGFuZ2VzIGNvbnN0YW50bHksIG1hbnkgdGltZXMgcGVyIHNlY29uZC4gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG4gICAgICogd2Ugd2FudCB0byBjaGVjayBhbmQgdXBkYXRlIHRoZSBsaXN0IGV2ZXJ5IGZpdmUgc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIFdlIGNhbiBkbyB0aGF0IGJ5IGRldGFjaGluZyB0aGUgY29tcG9uZW50J3MgY2hhbmdlIGRldGVjdG9yIGFuZCBkb2luZyBhIGxvY2FsIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKiBjaGVjayBldmVyeSBmaXZlIHNlY29uZHMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIENoYW5nZURldGVjdG9yUmVmI2RldGFjaCBkZXRhY2h9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIFZpZXdSZWYucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlckZhY3RvcnkgPSBnZXRSZW5kZXJlckZhY3RvcnkoKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyRmFjdG9yeS5iZWdpbikge1xuICAgICAgICAgICAgcmVuZGVyZXJGYWN0b3J5LmJlZ2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0ZWN0Q2hhbmdlcyh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpZiAocmVuZGVyZXJGYWN0b3J5LmVuZCkge1xuICAgICAgICAgICAgcmVuZGVyZXJGYWN0b3J5LmVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGNoYW5nZSBkZXRlY3RvciBhbmQgaXRzIGNoaWxkcmVuLCBhbmQgdGhyb3dzIGlmIGFueSBjaGFuZ2VzIGFyZSBkZXRlY3RlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbiBkZXZlbG9wbWVudCBtb2RlIHRvIHZlcmlmeSB0aGF0IHJ1bm5pbmcgY2hhbmdlIGRldGVjdGlvbiBkb2Vzbid0XG4gICAgICogaW50cm9kdWNlIG90aGVyIGNoYW5nZXMuXG4gICAgICovXG4gICAgVmlld1JlZi5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IGNoZWNrTm9DaGFuZ2VzKHRoaXMuY29udGV4dCk7IH07XG4gICAgVmlld1JlZi5wcm90b3R5cGUuYXR0YWNoVG9WaWV3Q29udGFpbmVyUmVmID0gZnVuY3Rpb24gKHZjUmVmKSB7IHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSB2Y1JlZjsgfTtcbiAgICBWaWV3UmVmLnByb3RvdHlwZS5kZXRhY2hGcm9tQXBwUmVmID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9hcHBSZWYgPSBudWxsOyB9O1xuICAgIFZpZXdSZWYucHJvdG90eXBlLmF0dGFjaFRvQXBwUmVmID0gZnVuY3Rpb24gKGFwcFJlZikgeyB0aGlzLl9hcHBSZWYgPSBhcHBSZWY7IH07XG4gICAgVmlld1JlZi5wcm90b3R5cGUuX2xvb2tVcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0ID0gdGhpcy5fdmlld1tQQVJFTlRdW3RoaXMuX2NvbXBvbmVudEluZGV4XTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3UmVmO1xufSgpKTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBSb290Vmlld1JlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm9vdFZpZXdSZWYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vdFZpZXdSZWYoX3ZpZXcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX3ZpZXcsIG51bGwsIC0xKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJvb3RWaWV3UmVmLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyBkZXRlY3RDaGFuZ2VzSW5Sb290Vmlldyh0aGlzLl92aWV3KTsgfTtcbiAgICBSb290Vmlld1JlZi5wcm90b3R5cGUuY2hlY2tOb0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IGNoZWNrTm9DaGFuZ2VzSW5Sb290Vmlldyh0aGlzLl92aWV3KTsgfTtcbiAgICByZXR1cm4gUm9vdFZpZXdSZWY7XG59KFZpZXdSZWYpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIEVsZW1lbnRSZWYgZnJvbSB0aGUgbW9zdCByZWNlbnQgbm9kZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgRWxlbWVudFJlZiBpbnN0YW5jZSB0byB1c2VcbiAqL1xuZnVuY3Rpb24gaW5qZWN0RWxlbWVudFJlZihFbGVtZW50UmVmVG9rZW4pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudFJlZihFbGVtZW50UmVmVG9rZW4sIGdldFByZXZpb3VzT3JQYXJlbnRUTm9kZSgpLCBfZ2V0Vmlld0RhdGEoKSk7XG59XG52YXIgUjNFbGVtZW50UmVmO1xuLyoqXG4gKiBDcmVhdGVzIGFuIEVsZW1lbnRSZWYgZ2l2ZW4gYSBub2RlLlxuICpcbiAqIEBwYXJhbSBFbGVtZW50UmVmVG9rZW4gVGhlIEVsZW1lbnRSZWYgdHlwZVxuICogQHBhcmFtIHROb2RlIFRoZSBub2RlIGZvciB3aGljaCB5b3UnZCBsaWtlIGFuIEVsZW1lbnRSZWZcbiAqIEBwYXJhbSB2aWV3IFRoZSB2aWV3IHRvIHdoaWNoIHRoZSBub2RlIGJlbG9uZ3NcbiAqIEByZXR1cm5zIFRoZSBFbGVtZW50UmVmIGluc3RhbmNlIHRvIHVzZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50UmVmKEVsZW1lbnRSZWZUb2tlbiwgdE5vZGUsIHZpZXcpIHtcbiAgICBpZiAoIVIzRWxlbWVudFJlZikge1xuICAgICAgICAvLyBUT0RPOiBGaXggY2xhc3MgbmFtZSwgc2hvdWxkIGJlIEVsZW1lbnRSZWYsIGJ1dCB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgcm9sbHVwIGJ1Z1xuICAgICAgICBSM0VsZW1lbnRSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoRWxlbWVudFJlZl8sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBFbGVtZW50UmVmXygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFJlZl87XG4gICAgICAgIH0oRWxlbWVudFJlZlRva2VuKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUjNFbGVtZW50UmVmKGdldE5hdGl2ZUJ5VE5vZGUodE5vZGUsIHZpZXcpKTtcbn1cbnZhciBSM1RlbXBsYXRlUmVmO1xuLyoqXG4gKiBDcmVhdGVzIGEgVGVtcGxhdGVSZWYgZ2l2ZW4gYSBub2RlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBUZW1wbGF0ZVJlZiBpbnN0YW5jZSB0byB1c2VcbiAqL1xuZnVuY3Rpb24gaW5qZWN0VGVtcGxhdGVSZWYoVGVtcGxhdGVSZWZUb2tlbiwgRWxlbWVudFJlZlRva2VuKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRlbXBsYXRlUmVmKFRlbXBsYXRlUmVmVG9rZW4sIEVsZW1lbnRSZWZUb2tlbiwgZ2V0UHJldmlvdXNPclBhcmVudFROb2RlKCksIF9nZXRWaWV3RGF0YSgpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFRlbXBsYXRlUmVmIGFuZCBzdG9yZXMgaXQgb24gdGhlIGluamVjdG9yLlxuICpcbiAqIEBwYXJhbSBUZW1wbGF0ZVJlZlRva2VuIFRoZSBUZW1wbGF0ZVJlZiB0eXBlXG4gKiBAcGFyYW0gRWxlbWVudFJlZlRva2VuIFRoZSBFbGVtZW50UmVmIHR5cGVcbiAqIEBwYXJhbSBob3N0VE5vZGUgVGhlIG5vZGUgdGhhdCBpcyByZXF1ZXN0aW5nIGEgVGVtcGxhdGVSZWZcbiAqIEBwYXJhbSBob3N0VmlldyBUaGUgdmlldyB0byB3aGljaCB0aGUgbm9kZSBiZWxvbmdzXG4gKiBAcmV0dXJucyBUaGUgVGVtcGxhdGVSZWYgaW5zdGFuY2UgdG8gdXNlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlUmVmKFRlbXBsYXRlUmVmVG9rZW4sIEVsZW1lbnRSZWZUb2tlbiwgaG9zdFROb2RlLCBob3N0Vmlldykge1xuICAgIGlmICghUjNUZW1wbGF0ZVJlZikge1xuICAgICAgICAvLyBUT0RPOiBGaXggY2xhc3MgbmFtZSwgc2hvdWxkIGJlIFRlbXBsYXRlUmVmLCBidXQgdGhlcmUgYXBwZWFycyB0byBiZSBhIHJvbGx1cCBidWdcbiAgICAgICAgUjNUZW1wbGF0ZVJlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZVJlZl8sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZVJlZl8oX2RlY2xhcmF0aW9uUGFyZW50VmlldywgZWxlbWVudFJlZiwgX3RWaWV3LCBfcmVuZGVyZXIsIF9xdWVyaWVzLCBfaW5qZWN0b3JJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RlY2xhcmF0aW9uUGFyZW50VmlldyA9IF9kZWNsYXJhdGlvblBhcmVudFZpZXc7XG4gICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RWaWV3ID0gX3RWaWV3O1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcXVlcmllcyA9IF9xdWVyaWVzO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmplY3RvckluZGV4ID0gX2luamVjdG9ySW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVGVtcGxhdGVSZWZfLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAoY29udGV4dCwgY29udGFpbmVyJCQxLCBob3N0VE5vZGUsIGhvc3RWaWV3LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsVmlldyA9IGNyZWF0ZUVtYmVkZGVkVmlld0FuZE5vZGUodGhpcy5fdFZpZXcsIGNvbnRleHQsIHRoaXMuX2RlY2xhcmF0aW9uUGFyZW50VmlldywgdGhpcy5fcmVuZGVyZXIsIHRoaXMuX3F1ZXJpZXMsIHRoaXMuX2luamVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIkJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VmlldyhsVmlldywgY29udGFpbmVyJCQxLCBob3N0VmlldywgaW5kZXgsIGhvc3RUTm9kZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlckVtYmVkZGVkVGVtcGxhdGUobFZpZXcsIHRoaXMuX3RWaWV3LCBjb250ZXh0LCAxIC8qIENyZWF0ZSAqLyk7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdSZWYgPSBuZXcgVmlld1JlZihsVmlldywgY29udGV4dCwgLTEpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuX3RWaWV3Tm9kZSA9IGxWaWV3W0hPU1RfTk9ERV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlUmVmXztcbiAgICAgICAgfShUZW1wbGF0ZVJlZlRva2VuKSk7XG4gICAgfVxuICAgIHZhciBob3N0Q29udGFpbmVyID0gaG9zdFZpZXdbaG9zdFROb2RlLmluZGV4XTtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm9kZVR5cGUoaG9zdFROb2RlLCAwIC8qIENvbnRhaW5lciAqLyk7XG4gICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQoaG9zdFROb2RlLnRWaWV3cywgJ1RWaWV3IG11c3QgYmUgYWxsb2NhdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBSM1RlbXBsYXRlUmVmKGhvc3RWaWV3LCBjcmVhdGVFbGVtZW50UmVmKEVsZW1lbnRSZWZUb2tlbiwgaG9zdFROb2RlLCBob3N0VmlldyksIGhvc3RUTm9kZS50Vmlld3MsIGdldFJlbmRlcmVyKCksIGhvc3RDb250YWluZXJbUVVFUklFU10sIGhvc3RUTm9kZS5pbmplY3RvckluZGV4KTtcbn1cbnZhciBSM1ZpZXdDb250YWluZXJSZWY7XG4vKipcbiAqIENyZWF0ZXMgYSBWaWV3Q29udGFpbmVyUmVmIGFuZCBzdG9yZXMgaXQgb24gdGhlIGluamVjdG9yLiBPciwgaWYgdGhlIFZpZXdDb250YWluZXJSZWZcbiAqIGFscmVhZHkgZXhpc3RzLCByZXRyaWV2ZXMgdGhlIGV4aXN0aW5nIFZpZXdDb250YWluZXJSZWYuXG4gKlxuICogQHJldHVybnMgVGhlIFZpZXdDb250YWluZXJSZWYgaW5zdGFuY2UgdG8gdXNlXG4gKi9cbmZ1bmN0aW9uIGluamVjdFZpZXdDb250YWluZXJSZWYoVmlld0NvbnRhaW5lclJlZlRva2VuLCBFbGVtZW50UmVmVG9rZW4pIHtcbiAgICB2YXIgcHJldmlvdXNUTm9kZSA9IGdldFByZXZpb3VzT3JQYXJlbnRUTm9kZSgpO1xuICAgIHJldHVybiBjcmVhdGVDb250YWluZXJSZWYoVmlld0NvbnRhaW5lclJlZlRva2VuLCBFbGVtZW50UmVmVG9rZW4sIHByZXZpb3VzVE5vZGUsIF9nZXRWaWV3RGF0YSgpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFZpZXdDb250YWluZXJSZWYgYW5kIHN0b3JlcyBpdCBvbiB0aGUgaW5qZWN0b3IuXG4gKlxuICogQHBhcmFtIFZpZXdDb250YWluZXJSZWZUb2tlbiBUaGUgVmlld0NvbnRhaW5lclJlZiB0eXBlXG4gKiBAcGFyYW0gRWxlbWVudFJlZlRva2VuIFRoZSBFbGVtZW50UmVmIHR5cGVcbiAqIEBwYXJhbSBob3N0VE5vZGUgVGhlIG5vZGUgdGhhdCBpcyByZXF1ZXN0aW5nIGEgVmlld0NvbnRhaW5lclJlZlxuICogQHBhcmFtIGhvc3RWaWV3IFRoZSB2aWV3IHRvIHdoaWNoIHRoZSBub2RlIGJlbG9uZ3NcbiAqIEByZXR1cm5zIFRoZSBWaWV3Q29udGFpbmVyUmVmIGluc3RhbmNlIHRvIHVzZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXJSZWYoVmlld0NvbnRhaW5lclJlZlRva2VuLCBFbGVtZW50UmVmVG9rZW4sIGhvc3RUTm9kZSwgaG9zdFZpZXcpIHtcbiAgICBpZiAoIVIzVmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICAvLyBUT0RPOiBGaXggY2xhc3MgbmFtZSwgc2hvdWxkIGJlIFZpZXdDb250YWluZXJSZWYsIGJ1dCB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgcm9sbHVwIGJ1Z1xuICAgICAgICBSM1ZpZXdDb250YWluZXJSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoVmlld0NvbnRhaW5lclJlZl8sIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBWaWV3Q29udGFpbmVyUmVmXyhfbENvbnRhaW5lciwgX2hvc3RUTm9kZSwgX2hvc3RWaWV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBfdGhpcy5fbENvbnRhaW5lciA9IF9sQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIF90aGlzLl9ob3N0VE5vZGUgPSBfaG9zdFROb2RlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9ob3N0VmlldyA9IF9ob3N0VmlldztcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlld1JlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudFJlZihFbGVtZW50UmVmVG9rZW4sIHRoaXMuX2hvc3RUTm9kZSwgdGhpcy5faG9zdFZpZXcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTm9kZUluamVjdG9yKHRoaXMuX2hvc3RUTm9kZSwgdGhpcy5faG9zdFZpZXcpOyB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwicGFyZW50SW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCBObyByZXBsYWNlbWVudCAqL1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50TG9jYXRpb24gPSBnZXRQYXJlbnRJbmplY3RvckxvY2F0aW9uKHRoaXMuX2hvc3RUTm9kZSwgdGhpcy5faG9zdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50VmlldyA9IGdldFBhcmVudEluamVjdG9yVmlldyhwYXJlbnRMb2NhdGlvbiwgdGhpcy5faG9zdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5kZXggPSBwYXJlbnRMb2NhdGlvbiAmIDMyNzY3IC8qIEluamVjdG9ySW5kZXhNYXNrICovO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50VE5vZGUgPSBwYXJlbnRWaWV3W1RWSUVXXS5kYXRhW3BhcmVudEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudExvY2F0aW9uID09PSAtMSA/IG5ldyBOdWxsSW5qZWN0b3IoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm9kZUluamVjdG9yKHBhcmVudFROb2RlLCBwYXJlbnRWaWV3KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fbENvbnRhaW5lcltWSUVXU10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl92aWV3UmVmc1tpbmRleF0gfHwgbnVsbDsgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xDb250YWluZXJbVklFV1NdLmxlbmd0aDsgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKHRlbXBsYXRlUmVmLCBjb250ZXh0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZElkeCA9IHRoaXMuX2FkanVzdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgdmlld1JlZiA9IHRlbXBsYXRlUmVmXG4gICAgICAgICAgICAgICAgICAgIC5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCB8fCB7fSwgdGhpcy5fbENvbnRhaW5lciwgdGhpcy5faG9zdFROb2RlLCB0aGlzLl9ob3N0VmlldywgYWRqdXN0ZWRJZHgpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuYXR0YWNoVG9WaWV3Q29udGFpbmVyUmVmKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdSZWZzLnNwbGljZShhZGp1c3RlZElkeCwgMCwgdmlld1JlZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5LCBpbmRleCwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIG5nTW9kdWxlUmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGluamVjdG9yIHx8IHRoaXMucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFuZ01vZHVsZVJlZiAmJiBjb250ZXh0SW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmdNb2R1bGVSZWYgPSBjb250ZXh0SW5qZWN0b3IuZ2V0KE5nTW9kdWxlUmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKGNvbnRleHRJbmplY3RvciwgcHJvamVjdGFibGVOb2RlcywgdW5kZWZpbmVkLCBuZ01vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoY29tcG9uZW50UmVmLmhvc3RWaWV3LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZpZXdSZWYsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGluc2VydCBhIGRlc3Ryb3llZCBWaWV3IGluIGEgVmlld0NvbnRhaW5lciEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxWaWV3ID0gdmlld1JlZi5fdmlldztcbiAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRJZHggPSB0aGlzLl9hZGp1c3RJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0VmlldyhsVmlldywgdGhpcy5fbENvbnRhaW5lciwgdGhpcy5faG9zdFZpZXcsIGFkanVzdGVkSWR4LCB0aGlzLl9ob3N0VE5vZGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVOb2RlID0gZ2V0QmVmb3JlTm9kZUZvclZpZXcoYWRqdXN0ZWRJZHgsIHRoaXMuX2xDb250YWluZXJbVklFV1NdLCB0aGlzLl9sQ29udGFpbmVyW05BVElWRV0pO1xuICAgICAgICAgICAgICAgIGFkZFJlbW92ZVZpZXdGcm9tQ29udGFpbmVyKGxWaWV3LCB0cnVlLCBiZWZvcmVOb2RlKTtcbiAgICAgICAgICAgICAgICB2aWV3UmVmLmF0dGFjaFRvVmlld0NvbnRhaW5lclJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UmVmcy5zcGxpY2UoYWRqdXN0ZWRJZHgsIDAsIHZpZXdSZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3UmVmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIG5ld0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKHZpZXdSZWYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydCh2aWV3UmVmLCB0aGlzLl9hZGp1c3RJbmRleChuZXdJbmRleCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3UmVmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHZpZXdSZWYpIHsgcmV0dXJuIHRoaXMuX3ZpZXdSZWZzLmluZGV4T2Yodmlld1JlZik7IH07XG4gICAgICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkSWR4ID0gdGhpcy5fYWRqdXN0SW5kZXgoaW5kZXgsIC0xKTtcbiAgICAgICAgICAgICAgICByZW1vdmVWaWV3KHRoaXMuX2xDb250YWluZXIsIHRoaXMuX2hvc3RUTm9kZSwgYWRqdXN0ZWRJZHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdSZWZzLnNwbGljZShhZGp1c3RlZElkeCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBhZGp1c3RlZElkeCA9IHRoaXMuX2FkanVzdEluZGV4KGluZGV4LCAtMSk7XG4gICAgICAgICAgICAgICAgZGV0YWNoVmlldyh0aGlzLl9sQ29udGFpbmVyLCBhZGp1c3RlZElkeCwgISF0aGlzLl9ob3N0VE5vZGUuZGV0YWNoZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3UmVmcy5zcGxpY2UoYWRqdXN0ZWRJZHgsIDEpWzBdIHx8IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLl9hZGp1c3RJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnQgPT09IHZvaWQgMCkgeyBzaGlmdCA9IDA7IH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbENvbnRhaW5lcltWSUVXU10ubGVuZ3RoICsgc2hpZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0R3JlYXRlclRoYW4oaW5kZXgsIC0xLCAnaW5kZXggbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAvLyArMSBiZWNhdXNlIGl0J3MgbGVnYWwgdG8gaW5zZXJ0IGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydExlc3NUaGFuKGluZGV4LCB0aGlzLl9sQ29udGFpbmVyW1ZJRVdTXS5sZW5ndGggKyAxICsgc2hpZnQsICdpbmRleCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWZfO1xuICAgICAgICB9KFZpZXdDb250YWluZXJSZWZUb2tlbikpO1xuICAgIH1cbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Tm9kZU9mUG9zc2libGVUeXBlcyhob3N0VE5vZGUsIDAgLyogQ29udGFpbmVyICovLCAzIC8qIEVsZW1lbnQgKi8sIDQgLyogRWxlbWVudENvbnRhaW5lciAqLyk7XG4gICAgdmFyIGxDb250YWluZXI7XG4gICAgdmFyIHNsb3RWYWx1ZSA9IGhvc3RWaWV3W2hvc3RUTm9kZS5pbmRleF07XG4gICAgaWYgKGlzTENvbnRhaW5lcihzbG90VmFsdWUpKSB7XG4gICAgICAgIC8vIElmIHRoZSBob3N0IGlzIGEgY29udGFpbmVyLCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBMQ29udGFpbmVyXG4gICAgICAgIGxDb250YWluZXIgPSBzbG90VmFsdWU7XG4gICAgICAgIGxDb250YWluZXJbQUNUSVZFX0lOREVYXSA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSBob3N0Vmlld1tSRU5ERVJFUl0uY3JlYXRlQ29tbWVudChuZ0Rldk1vZGUgPyAnY29udGFpbmVyJyA6ICcnKTtcbiAgICAgICAgbmdEZXZNb2RlICYmIG5nRGV2TW9kZS5yZW5kZXJlckNyZWF0ZUNvbW1lbnQrKztcbiAgICAgICAgaG9zdFZpZXdbaG9zdFROb2RlLmluZGV4XSA9IGxDb250YWluZXIgPVxuICAgICAgICAgICAgY3JlYXRlTENvbnRhaW5lcihzbG90VmFsdWUsIGhvc3RUTm9kZSwgaG9zdFZpZXcsIGNvbW1lbnQsIHRydWUpO1xuICAgICAgICBhcHBlbmRDaGlsZChjb21tZW50LCBob3N0VE5vZGUsIGhvc3RWaWV3KTtcbiAgICAgICAgYWRkVG9WaWV3VHJlZShob3N0VmlldywgaG9zdFROb2RlLmluZGV4LCBsQ29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSM1ZpZXdDb250YWluZXJSZWYobENvbnRhaW5lciwgaG9zdFROb2RlLCBob3N0Vmlldyk7XG59XG4vKiogUmV0dXJucyBhIENoYW5nZURldGVjdG9yUmVmIChhLmsuYS4gYSBWaWV3UmVmKSAqL1xuZnVuY3Rpb24gaW5qZWN0Q2hhbmdlRGV0ZWN0b3JSZWYoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZpZXdSZWYoZ2V0UHJldmlvdXNPclBhcmVudFROb2RlKCksIF9nZXRWaWV3RGF0YSgpLCBudWxsKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFZpZXdSZWYgYW5kIHN0b3JlcyBpdCBvbiB0aGUgaW5qZWN0b3IgYXMgQ2hhbmdlRGV0ZWN0b3JSZWYgKHB1YmxpYyBhbGlhcykuXG4gKlxuICogQHBhcmFtIGhvc3RUTm9kZSBUaGUgbm9kZSB0aGF0IGlzIHJlcXVlc3RpbmcgYSBDaGFuZ2VEZXRlY3RvclJlZlxuICogQHBhcmFtIGhvc3RWaWV3IFRoZSB2aWV3IHRvIHdoaWNoIHRoZSBub2RlIGJlbG9uZ3NcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IGZvciB0aGlzIGNoYW5nZSBkZXRlY3RvciByZWZcbiAqIEByZXR1cm5zIFRoZSBDaGFuZ2VEZXRlY3RvclJlZiB0byB1c2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmlld1JlZihob3N0VE5vZGUsIGhvc3RWaWV3LCBjb250ZXh0KSB7XG4gICAgaWYgKGlzQ29tcG9uZW50KGhvc3RUTm9kZSkpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudEluZGV4ID0gaG9zdFROb2RlLmZsYWdzID4+IDE1IC8qIERpcmVjdGl2ZVN0YXJ0aW5nSW5kZXhTaGlmdCAqLztcbiAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSBnZXRDb21wb25lbnRWaWV3QnlJbmRleChob3N0VE5vZGUuaW5kZXgsIGhvc3RWaWV3KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UmVmKGNvbXBvbmVudFZpZXcsIGNvbnRleHQsIGNvbXBvbmVudEluZGV4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG9zdFROb2RlLnR5cGUgPT09IDMgLyogRWxlbWVudCAqLykge1xuICAgICAgICB2YXIgaG9zdENvbXBvbmVudFZpZXcgPSBmaW5kQ29tcG9uZW50Vmlldyhob3N0Vmlldyk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1JlZihob3N0Q29tcG9uZW50VmlldywgaG9zdENvbXBvbmVudFZpZXdbQ09OVEVYVF0sIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVJlbmRlcmVyMih2aWV3KSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdmlld1tSRU5ERVJFUl07XG4gICAgaWYgKGlzUHJvY2VkdXJhbFJlbmRlcmVyKHJlbmRlcmVyKSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbmplY3QgUmVuZGVyZXIyIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHVzZXMgUmVuZGVyZXIzIScpO1xuICAgIH1cbn1cbi8qKiBSZXR1cm5zIGEgUmVuZGVyZXIyIChvciB0aHJvd3Mgd2hlbiBhcHBsaWNhdGlvbiB3YXMgYm9vdHN0cmFwcGVkIHdpdGggUmVuZGVyZXIzKSAqL1xuZnVuY3Rpb24gaW5qZWN0UmVuZGVyZXIyKCkge1xuICAgIHJldHVybiBnZXRPckNyZWF0ZVJlbmRlcmVyMihfZ2V0Vmlld0RhdGEoKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSM19FTEVNRU5UX1JFRl9GQUNUT1JZID0gaW5qZWN0RWxlbWVudFJlZjtcbnZhciBSM19URU1QTEFURV9SRUZfRkFDVE9SWSA9IGluamVjdFRlbXBsYXRlUmVmO1xudmFyIFIzX0NIQU5HRV9ERVRFQ1RPUl9SRUZfRkFDVE9SWSA9IGluamVjdENoYW5nZURldGVjdG9yUmVmO1xudmFyIFIzX1ZJRVdfQ09OVEFJTkVSX1JFRl9GQUNUT1JZID0gaW5qZWN0Vmlld0NvbnRhaW5lclJlZjtcbnZhciBSM19SRU5ERVJFUjJfRkFDVE9SWSA9IGluamVjdFJlbmRlcmVyMjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9vcEZhY3RvcnkoKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRva2Vuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbn1cbnZhciBSM19FTEVNRU5UX1JFRl9GQUNUT1JZX19QT1NUX05HQ0NfXyA9IFIzX0VMRU1FTlRfUkVGX0ZBQ1RPUlk7XG52YXIgUjNfVEVNUExBVEVfUkVGX0ZBQ1RPUllfX1BPU1RfTkdDQ19fID0gUjNfVEVNUExBVEVfUkVGX0ZBQ1RPUlk7XG52YXIgUjNfQ0hBTkdFX0RFVEVDVE9SX1JFRl9GQUNUT1JZX19QT1NUX05HQ0NfXyA9IFIzX0NIQU5HRV9ERVRFQ1RPUl9SRUZfRkFDVE9SWTtcbnZhciBSM19WSUVXX0NPTlRBSU5FUl9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18gPSBSM19WSUVXX0NPTlRBSU5FUl9SRUZfRkFDVE9SWTtcbnZhciBSM19SRU5ERVJFUjJfRkFDVE9SWV9fUE9TVF9OR0NDX18gPSBSM19SRU5ERVJFUjJfRkFDVE9SWTtcbnZhciBSM19FTEVNRU5UX1JFRl9GQUNUT1JZX19QUkVfTkdDQ19fID0gbm9vcEZhY3Rvcnk7XG52YXIgUjNfVEVNUExBVEVfUkVGX0ZBQ1RPUllfX1BSRV9OR0NDX18gPSBub29wRmFjdG9yeTtcbnZhciBSM19DSEFOR0VfREVURUNUT1JfUkVGX0ZBQ1RPUllfX1BSRV9OR0NDX18gPSBub29wRmFjdG9yeTtcbnZhciBSM19WSUVXX0NPTlRBSU5FUl9SRUZfRkFDVE9SWV9fUFJFX05HQ0NfXyA9IG5vb3BGYWN0b3J5O1xudmFyIFIzX1JFTkRFUkVSMl9GQUNUT1JZX19QUkVfTkdDQ19fID0gbm9vcEZhY3Rvcnk7XG52YXIgUjNfRUxFTUVOVF9SRUZfRkFDVE9SWSQxID0gUjNfRUxFTUVOVF9SRUZfRkFDVE9SWV9fUFJFX05HQ0NfXztcbnZhciBSM19URU1QTEFURV9SRUZfRkFDVE9SWSQxID0gUjNfVEVNUExBVEVfUkVGX0ZBQ1RPUllfX1BSRV9OR0NDX187XG52YXIgUjNfQ0hBTkdFX0RFVEVDVE9SX1JFRl9GQUNUT1JZJDEgPSBSM19DSEFOR0VfREVURUNUT1JfUkVGX0ZBQ1RPUllfX1BSRV9OR0NDX187XG52YXIgUjNfVklFV19DT05UQUlORVJfUkVGX0ZBQ1RPUlkkMSA9IFIzX1ZJRVdfQ09OVEFJTkVSX1JFRl9GQUNUT1JZX19QUkVfTkdDQ19fO1xudmFyIFIzX1JFTkRFUkVSMl9GQUNUT1JZJDEgPSBSM19SRU5ERVJFUjJfRkFDVE9SWV9fUFJFX05HQ0NfXztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGEgbmF0aXZlIGVsZW1lbnQgaW5zaWRlIG9mIGEgVmlldy5cbiAqXG4gKiBBbiBgRWxlbWVudFJlZmAgaXMgYmFja2VkIGJ5IGEgcmVuZGVyLXNwZWNpZmljIGVsZW1lbnQuIEluIHRoZSBicm93c2VyLCB0aGlzIGlzIHVzdWFsbHkgYSBET01cbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlY3VyaXR5IFBlcm1pdHRpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgRE9NIGNhbiBtYWtlIHlvdXIgYXBwbGljYXRpb24gbW9yZSB2dWxuZXJhYmxlIHRvXG4gKiBYU1MgYXR0YWNrcy4gQ2FyZWZ1bGx5IHJldmlldyBhbnkgdXNlIG9mIGBFbGVtZW50UmVmYCBpbiB5b3VyIGNvZGUuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZVxuICogW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG4vLyBOb3RlOiBXZSBkb24ndCBleHBvc2UgdGhpbmdzIGxpa2UgYEluamVjdG9yYCwgYFZpZXdDb250YWluZXJgLCAuLi4gaGVyZSxcbi8vIGkuZS4gdXNlcnMgaGF2ZSB0byBhc2sgZm9yIHdoYXQgdGhleSBuZWVkLiBXaXRoIHRoYXQsIHdlIGNhbiBidWlsZCBiZXR0ZXIgYW5hbHlzaXMgdG9vbHNcbi8vIGFuZCBjb3VsZCBkbyBiZXR0ZXIgY29kZWdlbiBpbiB0aGUgZnV0dXJlLlxudmFyIEVsZW1lbnRSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudFJlZihuYXRpdmVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFbGVtZW50UmVmLl9fTkdfRUxFTUVOVF9JRF9fID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUjNfRUxFTUVOVF9SRUZfRkFDVE9SWSQxKEVsZW1lbnRSZWYpOyB9O1xuICAgIHJldHVybiBFbGVtZW50UmVmO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYFJlbmRlcmVyVHlwZTJgIChhbmQgYFJlbmRlcmVyMmApIGluc3RlYWQuXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZW5kZXJDb21wb25lbnRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlckNvbXBvbmVudFR5cGUoaWQsIHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgdGhpcy5zbG90Q291bnQgPSBzbG90Q291bnQ7XG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gUmVuZGVyQ29tcG9uZW50VHlwZTtcbn0oKSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIERlYnVnIGluZm8gaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGluIHRoZSB2aWV3IGVuZ2luZSBub3cuXG4gKi9cbnZhciBSZW5kZXJEZWJ1Z0luZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyRGVidWdJbmZvKCkge1xuICAgIH1cbiAgICByZXR1cm4gUmVuZGVyRGVidWdJbmZvO1xufSgpKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgUmVuZGVyZXIyYCBpbnN0ZWFkLlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oKSk7XG52YXIgUmVuZGVyZXIySW50ZXJjZXB0b3IgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1JlbmRlcmVyMkludGVyY2VwdG9yJyk7XG4vKipcbiAqIEluamVjdGFibGUgc2VydmljZSB0aGF0IHByb3ZpZGVzIGEgbG93LWxldmVsIGludGVyZmFjZSBmb3IgbW9kaWZ5aW5nIHRoZSBVSS5cbiAqXG4gKiBVc2UgdGhpcyBzZXJ2aWNlIHRvIGJ5cGFzcyBBbmd1bGFyJ3MgdGVtcGxhdGluZyBhbmQgbWFrZSBjdXN0b20gVUkgY2hhbmdlcyB0aGF0IGNhbid0IGJlXG4gKiBleHByZXNzZWQgZGVjbGFyYXRpdmVseS4gRm9yIGV4YW1wbGUgaWYgeW91IG5lZWQgdG8gc2V0IGEgcHJvcGVydHkgb3IgYW4gYXR0cmlidXRlIHdob3NlIG5hbWUgaXNcbiAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rIFJlbmRlcmVyI3NldEVsZW1lbnRQcm9wZXJ0eSBzZXRFbGVtZW50UHJvcGVydHl9IG9yXG4gKiB7QGxpbmsgUmVuZGVyZXIjc2V0RWxlbWVudEF0dHJpYnV0ZSBzZXRFbGVtZW50QXR0cmlidXRlfSByZXNwZWN0aXZlbHkuXG4gKlxuICogSWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gcmVuZGVyZXIsIHlvdSBtdXN0IGltcGxlbWVudCB0aGlzIGludGVyZmFjZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBSZW5kZXJlciBpbXBsZW1lbnRhdGlvbiBpcyBgRG9tUmVuZGVyZXJgLiBBbHNvIGF2YWlsYWJsZSBpcyBgV2ViV29ya2VyUmVuZGVyZXJgLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgUmVuZGVyZXJGYWN0b3J5MmAgaW5zdGVhZC5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvb3RSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb290UmVuZGVyZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBSb290UmVuZGVyZXI7XG59KCkpO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIGN1c3RvbSByZW5kZXJlciB0aGF0IGltcGxlbWVudHMgdGhlIGBSZW5kZXJlcjJgIGJhc2UgY2xhc3MuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVuZGVyZXJGYWN0b3J5MiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlckZhY3RvcnkyKCkge1xuICAgIH1cbiAgICByZXR1cm4gUmVuZGVyZXJGYWN0b3J5Mjtcbn0oKSk7XG4vKipcbiAqIEZsYWdzIGZvciByZW5kZXJlci1zcGVjaWZpYyBzdHlsZSBtb2RpZmllcnMuXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZW5kZXJlclN0eWxlRmxhZ3MyO1xuKGZ1bmN0aW9uIChSZW5kZXJlclN0eWxlRmxhZ3MyKSB7XG4gICAgLyoqXG4gICAgICogTWFya3MgYSBzdHlsZSBhcyBpbXBvcnRhbnQuXG4gICAgICovXG4gICAgUmVuZGVyZXJTdHlsZUZsYWdzMltSZW5kZXJlclN0eWxlRmxhZ3MyW1wiSW1wb3J0YW50XCJdID0gMV0gPSBcIkltcG9ydGFudFwiO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgc3R5bGUgYXMgdXNpbmcgZGFzaCBjYXNlIG5hbWluZyAodGhpcy1pcy1kYXNoLWNhc2UpLlxuICAgICAqL1xuICAgIFJlbmRlcmVyU3R5bGVGbGFnczJbUmVuZGVyZXJTdHlsZUZsYWdzMltcIkRhc2hDYXNlXCJdID0gMl0gPSBcIkRhc2hDYXNlXCI7XG59KShSZW5kZXJlclN0eWxlRmxhZ3MyIHx8IChSZW5kZXJlclN0eWxlRmxhZ3MyID0ge30pKTtcbi8qKlxuICogRXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyB0byBpbXBsZW1lbnQgY3VzdG9tIHJlbmRlcmluZy4gQnkgZGVmYXVsdCwgQW5ndWxhclxuICogcmVuZGVycyBhIHRlbXBsYXRlIGludG8gRE9NLiBZb3UgY2FuIHVzZSBjdXN0b20gcmVuZGVyaW5nIHRvIGludGVyY2VwdFxuICogcmVuZGVyaW5nIGNhbGxzLCBvciB0byByZW5kZXIgdG8gc29tZXRoaW5nIG90aGVyIHRoYW4gRE9NLlxuICpcbiAqIENyZWF0ZSB5b3VyIGN1c3RvbSByZW5kZXJlciB1c2luZyBgUmVuZGVyZXJGYWN0b3J5MmAuXG4gKlxuICogVXNlIGEgY3VzdG9tIHJlbmRlcmVyIHRvIGJ5cGFzcyBBbmd1bGFyJ3MgdGVtcGxhdGluZyBhbmRcbiAqIG1ha2UgY3VzdG9tIFVJIGNoYW5nZXMgdGhhdCBjYW4ndCBiZSBleHByZXNzZWQgZGVjbGFyYXRpdmVseS5cbiAqIEZvciBleGFtcGxlIGlmIHlvdSBuZWVkIHRvIHNldCBhIHByb3BlcnR5IG9yIGFuIGF0dHJpYnV0ZSB3aG9zZSBuYW1lIGlzXG4gKiBub3Qgc3RhdGljYWxseSBrbm93biwgdXNlIHRoZSBgc2V0UHJvcGVydHkoKWAgb3JcbiAqIGBzZXRBdHRyaWJ1dGUoKWAgbWV0aG9kLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJlbmRlcmVyMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcjIoKSB7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZW5kZXJlcjIuX19OR19FTEVNRU5UX0lEX18gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBSM19SRU5ERVJFUjJfRkFDVE9SWSQxKCk7IH07XG4gICAgcmV0dXJuIFJlbmRlcmVyMjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJCQxLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciQkMSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIkJDEucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0Q29tcG9uZW50VHlwZShjb21wb25lbnQpO1xuICAgICAgICB2YXIgY29tcG9uZW50RGVmID0gZ2V0Q29tcG9uZW50RGVmKGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50RmFjdG9yeSQxKGNvbXBvbmVudERlZik7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJCQxO1xufShDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKTtcbmZ1bmN0aW9uIHRvUmVmQXJyYXkobWFwKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgbm9uTWluaWZpZWQgaW4gbWFwKSB7XG4gICAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkobm9uTWluaWZpZWQpKSB7XG4gICAgICAgICAgICB2YXIgbWluaWZpZWQgPSBtYXBbbm9uTWluaWZpZWRdO1xuICAgICAgICAgICAgYXJyYXkucHVzaCh7IHByb3BOYW1lOiBtaW5pZmllZCwgdGVtcGxhdGVOYW1lOiBub25NaW5pZmllZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIERlZmF1bHQge0BsaW5rIFJvb3RDb250ZXh0fSBmb3IgYWxsIGNvbXBvbmVudHMgcmVuZGVyZWQgd2l0aCB7QGxpbmsgcmVuZGVyQ29tcG9uZW50fS5cbiAqL1xudmFyIFJPT1RfQ09OVEVYVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignUk9PVF9DT05URVhUX1RPS0VOJywgeyBwcm92aWRlZEluOiAncm9vdCcsIGZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJvb3RDb250ZXh0KGluamVjdChTQ0hFRFVMRVIpKTsgfSB9KTtcbi8qKlxuICogQSBjaGFuZ2UgZGV0ZWN0aW9uIHNjaGVkdWxlciB0b2tlbiBmb3Ige0BsaW5rIFJvb3RDb250ZXh0fS4gVGhpcyB0b2tlbiBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB1c2VkXG4gKiBmb3IgdGhlIGRlZmF1bHQgYFJvb3RDb250ZXh0YCBmb3VuZCBpbiB0aGUge0BsaW5rIFJPT1RfQ09OVEVYVH0gdG9rZW4uXG4gKi9cbnZhciBTQ0hFRFVMRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1NDSEVEVUxFUl9UT0tFTicsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlUmFmID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIHJldHVybiB1c2VSYWYgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogc2V0VGltZW91dDtcbiAgICB9LFxufSk7XG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCB0byB3cmFwIHRoZSBgUmVuZGVyZXJGYWN0b3J5MmAuXG4gKiBVc2VkIGluIHRlc3RzIHRvIGNoYW5nZSB0aGUgYFJlbmRlcmVyRmFjdG9yeTJgIGludG8gYSBgRGVidWdSZW5kZXJlckZhY3RvcnkyYC5cbiAqL1xudmFyIFdSQVBfUkVOREVSRVJfRkFDVE9SWTIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1dSQVBfUkVOREVSRVJfRkFDVE9SWTInKTtcbi8qKlxuICogUmVuZGVyMyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgdmlld0VuZ2luZV9Db21wb25lbnRGYWN0b3J5fS5cbiAqL1xudmFyIENvbXBvbmVudEZhY3RvcnkkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcG9uZW50RmFjdG9yeSQkMSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5JCQxKGNvbXBvbmVudERlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb21wb25lbnREZWYgPSBjb21wb25lbnREZWY7XG4gICAgICAgIF90aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnREZWYudHlwZTtcbiAgICAgICAgX3RoaXMuc2VsZWN0b3IgPSBjb21wb25lbnREZWYuc2VsZWN0b3JzWzBdWzBdO1xuICAgICAgICBfdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50RmFjdG9yeSQkMS5wcm90b3R5cGUsIFwiaW5wdXRzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9SZWZBcnJheSh0aGlzLmNvbXBvbmVudERlZi5pbnB1dHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50RmFjdG9yeSQkMS5wcm90b3R5cGUsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvUmVmQXJyYXkodGhpcy5jb21wb25lbnREZWYub3V0cHV0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbXBvbmVudEZhY3RvcnkkJDEucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlLCBuZ01vZHVsZSkge1xuICAgICAgICB2YXIgaXNJbnRlcm5hbFJvb3RWaWV3ID0gcm9vdFNlbGVjdG9yT3JOb2RlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZW5kZXJlckZhY3Rvcnk7XG4gICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZ01vZHVsZS5pbmplY3Rvci5nZXQoV1JBUF9SRU5ERVJFUl9GQUNUT1JZMiwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pO1xuICAgICAgICAgICAgcmVuZGVyZXJGYWN0b3J5ID0gd3JhcHBlcihuZ01vZHVsZS5pbmplY3Rvci5nZXQoUmVuZGVyZXJGYWN0b3J5MikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZXJGYWN0b3J5ID0gZG9tUmVuZGVyZXJGYWN0b3J5MztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9zdFJOb2RlID0gaXNJbnRlcm5hbFJvb3RWaWV3ID9cbiAgICAgICAgICAgIGVsZW1lbnRDcmVhdGUodGhpcy5zZWxlY3RvciwgcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIHRoaXMuY29tcG9uZW50RGVmKSkgOlxuICAgICAgICAgICAgbG9jYXRlSG9zdEVsZW1lbnQocmVuZGVyZXJGYWN0b3J5LCByb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAvLyBUaGUgZmlyc3QgaW5kZXggb2YgdGhlIGZpcnN0IHNlbGVjdG9yIGlzIHRoZSB0YWcgbmFtZS5cbiAgICAgICAgdmFyIGNvbXBvbmVudFRhZyA9IHRoaXMuY29tcG9uZW50RGVmLnNlbGVjdG9yc1swXVswXTtcbiAgICAgICAgdmFyIHJvb3RGbGFncyA9IHRoaXMuY29tcG9uZW50RGVmLm9uUHVzaCA/IDQgLyogRGlydHkgKi8gfCA2NCAvKiBJc1Jvb3QgKi8gOlxuICAgICAgICAgICAgMiAvKiBDaGVja0Fsd2F5cyAqLyB8IDY0IC8qIElzUm9vdCAqLztcbiAgICAgICAgdmFyIHJvb3RDb250ZXh0ID0gbmdNb2R1bGUgJiYgIWlzSW50ZXJuYWxSb290VmlldyA/XG4gICAgICAgICAgICBuZ01vZHVsZS5pbmplY3Rvci5nZXQoUk9PVF9DT05URVhUKSA6XG4gICAgICAgICAgICBjcmVhdGVSb290Q29udGV4dChyZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKGhvc3RSTm9kZSwgdGhpcy5jb21wb25lbnREZWYpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHJvb3Qgdmlldy4gVXNlcyBlbXB0eSBUVmlldyBhbmQgQ29udGVudFRlbXBsYXRlLlxuICAgICAgICB2YXIgcm9vdFZpZXcgPSBjcmVhdGVMVmlld0RhdGEocmVuZGVyZXIsIGNyZWF0ZVRWaWV3KC0xLCBudWxsLCAxLCAwLCBudWxsLCBudWxsLCBudWxsKSwgcm9vdENvbnRleHQsIHJvb3RGbGFncyk7XG4gICAgICAgIHJvb3RWaWV3W0lOSkVDVE9SJDFdID0gbmdNb2R1bGUgJiYgbmdNb2R1bGUuaW5qZWN0b3IgfHwgbnVsbDtcbiAgICAgICAgLy8gcm9vdFZpZXcgaXMgdGhlIHBhcmVudCB3aGVuIGJvb3RzdHJhcHBpbmdcbiAgICAgICAgdmFyIG9sZFZpZXcgPSBlbnRlclZpZXcocm9vdFZpZXcsIG51bGwpO1xuICAgICAgICB2YXIgY29tcG9uZW50O1xuICAgICAgICB2YXIgdEVsZW1lbnROb2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyRmFjdG9yeS5iZWdpbilcbiAgICAgICAgICAgICAgICByZW5kZXJlckZhY3RvcnkuYmVnaW4oKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRWaWV3ID0gY3JlYXRlUm9vdENvbXBvbmVudFZpZXcoaG9zdFJOb2RlLCB0aGlzLmNvbXBvbmVudERlZiwgcm9vdFZpZXcsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIHRFbGVtZW50Tm9kZSA9IGdldFROb2RlKDAsIHJvb3RWaWV3KTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgYXJyYXlzIG9mIG5hdGl2ZSBub2RlcyBpbnRvIGEgc3RydWN0dXJlIHRoYXQgY2FuIGJlIGNvbnN1bWVkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gcHJvamVjdGlvbiBpbnN0cnVjdGlvbi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCB0aGUgcmVwcm9qZWN0aW9uIG9mIHRoZXNlIG5vZGVzLlxuICAgICAgICAgICAgaWYgKHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uJCQxID0gdEVsZW1lbnROb2RlLnByb2plY3Rpb24gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2plY3RhYmxlTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVMaXN0ID0gcHJvamVjdGFibGVOb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0VE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNUTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZUxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEJsdWVwcmludEZvck5ld05vZGUocm9vdFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHROb2RlID0gY3JlYXRlTm9kZUF0SW5kZXgoKytpbmRleCwgMyAvKiBFbGVtZW50ICovLCBub2RlTGlzdFtqXSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ROb2RlID8gKHByZXZpb3VzVE5vZGUubmV4dCA9IHROb2RlKSA6IChmaXJzdFROb2RlID0gdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUTm9kZSA9IHROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb24kJDEucHVzaChmaXJzdFROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgTGlmZWN5Y2xlSG9va3NGZWF0dXJlIGFuZCBvdGhlciBob3N0IGZlYXR1cmVzIGJlIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlZCBoZXJlP1xuICAgICAgICAgICAgLy8gQW5ndWxhciA1IHJlZmVyZW5jZTogaHR0cHM6Ly9zdGFja2JsaXR6LmNvbS9lZGl0L2xpZmVjeWNsZS1ob29rcy12Y3JlZlxuICAgICAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlUm9vdENvbXBvbmVudChob3N0Uk5vZGUsIGNvbXBvbmVudFZpZXcsIHRoaXMuY29tcG9uZW50RGVmLCByb290Vmlldywgcm9vdENvbnRleHQsIFtMaWZlY3ljbGVIb29rc0ZlYXR1cmVdKTtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHRlbXBsYXRlIGluIGNyZWF0aW9uIG1vZGUgb25seSwgYW5kIHRoZW4gdHVybiBvZmYgdGhlIENyZWF0aW9uTW9kZSBmbGFnXG4gICAgICAgICAgICByZW5kZXJFbWJlZGRlZFRlbXBsYXRlKGNvbXBvbmVudFZpZXcsIGNvbXBvbmVudFZpZXdbVFZJRVddLCBjb21wb25lbnQsIDEgLyogQ3JlYXRlICovKTtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdbRkxBR1NdICY9IH4xIC8qIENyZWF0aW9uTW9kZSAqLztcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGVudGVyVmlldyhvbGRWaWV3LCBudWxsKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlckZhY3RvcnkuZW5kKVxuICAgICAgICAgICAgICAgIHJlbmRlcmVyRmFjdG9yeS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gbmV3IENvbXBvbmVudFJlZiQxKHRoaXMuY29tcG9uZW50VHlwZSwgY29tcG9uZW50LCByb290VmlldywgaW5qZWN0b3IsIGNyZWF0ZUVsZW1lbnRSZWYoRWxlbWVudFJlZiwgdEVsZW1lbnROb2RlLCByb290VmlldykpO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbFJvb3RWaWV3KSB7XG4gICAgICAgICAgICAvLyBUaGUgaG9zdCBlbGVtZW50IG9mIHRoZSBpbnRlcm5hbCByb290IHZpZXcgaXMgYXR0YWNoZWQgdG8gdGhlIGNvbXBvbmVudCdzIGhvc3QgdmlldyBub2RlXG4gICAgICAgICAgICBjb21wb25lbnRSZWYuaG9zdFZpZXcuX3RWaWV3Tm9kZS5jaGlsZCA9IHRFbGVtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnkkJDE7XG59KENvbXBvbmVudEZhY3RvcnkpKTtcbnZhciBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBuZXcgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJDEoKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIENvbXBvbmVudCBjcmVhdGVkIHZpYSBhIHtAbGluayBDb21wb25lbnRGYWN0b3J5fS5cbiAqXG4gKiBgQ29tcG9uZW50UmVmYCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIENvbXBvbmVudCBJbnN0YW5jZSBhcyB3ZWxsIG90aGVyIG9iamVjdHMgcmVsYXRlZCB0byB0aGlzXG4gKiBDb21wb25lbnQgSW5zdGFuY2UgYW5kIGFsbG93cyB5b3UgdG8gZGVzdHJveSB0aGUgQ29tcG9uZW50IEluc3RhbmNlIHZpYSB0aGUge0BsaW5rICNkZXN0cm95fVxuICogbWV0aG9kLlxuICpcbiAqL1xudmFyIENvbXBvbmVudFJlZiQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRSZWYkJDEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmJCQxKGNvbXBvbmVudFR5cGUsIGluc3RhbmNlLCByb290VmlldywgaW5qZWN0b3IsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLmRlc3Ryb3lDYnMgPSBbXTtcbiAgICAgICAgX3RoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgX3RoaXMuaG9zdFZpZXcgPSBfdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IG5ldyBSb290Vmlld1JlZihyb290Vmlldyk7XG4gICAgICAgIF90aGlzLmhvc3RWaWV3Ll90Vmlld05vZGUgPSBjcmVhdGVWaWV3Tm9kZSgtMSwgcm9vdFZpZXcpO1xuICAgICAgICBfdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICBfdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21wb25lbnRSZWYkJDEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHRoaXMuZGVzdHJveUNicywgJ05nTW9kdWxlIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUNicy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIHRoaXMuZGVzdHJveUNicyA9IG51bGw7XG4gICAgfTtcbiAgICBDb21wb25lbnRSZWYkJDEucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0RGVmaW5lZCh0aGlzLmRlc3Ryb3lDYnMsICdOZ01vZHVsZSBhbHJlYWR5IGRlc3Ryb3llZCcpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lDYnMucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50UmVmJCQxO1xufShDb21wb25lbnRSZWYpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIGkxOG5UYWdSZWdleCA9IC97XFwkKFtefV0rKX0vZztcbi8qKlxuICogVGFrZXMgYSB0cmFuc2xhdGlvbiBzdHJpbmcsIHRoZSBpbml0aWFsIGxpc3Qgb2YgcGxhY2Vob2xkZXJzIChlbGVtZW50cyBhbmQgZXhwcmVzc2lvbnMpIGFuZCB0aGVcbiAqIGluZGV4ZXMgb2YgdGhlaXIgY29ycmVzcG9uZGluZyBleHByZXNzaW9uIG5vZGVzIHRvIHJldHVybiBhIGxpc3Qgb2YgaW5zdHJ1Y3Rpb25zIGZvciBlYWNoXG4gKiB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBCZWNhdXNlIGVtYmVkZGVkIHRlbXBsYXRlcyBoYXZlIGRpZmZlcmVudCBpbmRleGVzIGZvciBlYWNoIHBsYWNlaG9sZGVyLCBlYWNoIHBhcmFtZXRlciAoZXhjZXB0XG4gKiB0aGUgdHJhbnNsYXRpb24pIGlzIGFuIGFycmF5LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGEgZGlmZmVyZW50IHRlbXBsYXRlLCBieSBvcmRlciBvZlxuICogYXBwZWFyYW5jZS5cbiAqXG4gKiBAcGFyYW0gdHJhbnNsYXRpb24gQSB0cmFuc2xhdGlvbiBzdHJpbmcgd2hlcmUgcGxhY2Vob2xkZXJzIGFyZSByZXByZXNlbnRlZCBieSBgeyRuYW1lfWBcbiAqIEBwYXJhbSBlbGVtZW50cyBBbiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaCB0ZW1wbGF0ZSwgdGhlIG1hcHMgb2YgZWxlbWVudCBwbGFjZWhvbGRlcnMgYW5kXG4gKiB0aGVpciBpbmRleGVzLlxuICogQHBhcmFtIGV4cHJlc3Npb25zIEFuIGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoIHRlbXBsYXRlLCB0aGUgbWFwcyBvZiBleHByZXNzaW9uIHBsYWNlaG9sZGVyc1xuICogYW5kIHRoZWlyIGluZGV4ZXMuXG4gKiBAcGFyYW0gdGVtcGxhdGVSb290cyBBbiBhcnJheSBvZiB0ZW1wbGF0ZSByb290cyB3aG9zZSBjb250ZW50IHNob3VsZCBiZSBpZ25vcmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlaXIgcGFyZW50IHRlbXBsYXRlLlxuICogQHBhcmFtIGxhc3RDaGlsZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgaTE4biBub2RlLiBVc2VkIHdoZW4gdGhlIGkxOG4gYmxvY2sgaXNcbiAqIGFuIG5nLWNvbnRhaW5lci5cbiAqXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHVzZWQgdG8gdHJhbnNsYXRlIGVhY2ggdGVtcGxhdGUuXG4gKi9cbmZ1bmN0aW9uIGkxOG5NYXBwaW5nKHRyYW5zbGF0aW9uLCBlbGVtZW50cywgZXhwcmVzc2lvbnMsIHRlbXBsYXRlUm9vdHMsIGxhc3RDaGlsZEluZGV4KSB7XG4gICAgdmFyIHRyYW5zbGF0aW9uUGFydHMgPSB0cmFuc2xhdGlvbi5zcGxpdChpMThuVGFnUmVnZXgpO1xuICAgIHZhciBuYlRlbXBsYXRlcyA9IHRlbXBsYXRlUm9vdHMgPyB0ZW1wbGF0ZVJvb3RzLmxlbmd0aCArIDEgOiAxO1xuICAgIHZhciBpbnN0cnVjdGlvbnMgPSAobmV3IEFycmF5KG5iVGVtcGxhdGVzKSkuZmlsbCh1bmRlZmluZWQpO1xuICAgIGdlbmVyYXRlTWFwcGluZ0luc3RydWN0aW9ucygwLCAwLCB0cmFuc2xhdGlvblBhcnRzLCBpbnN0cnVjdGlvbnMsIGVsZW1lbnRzLCBleHByZXNzaW9ucywgdGVtcGxhdGVSb290cywgbGFzdENoaWxkSW5kZXgpO1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG59XG4vKipcbiAqIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmVhZHMgdGhlIHRyYW5zbGF0aW9uIHBhcnRzIGFuZCBnZW5lcmF0ZXMgYSBzZXQgb2YgaW5zdHJ1Y3Rpb25zIGZvciBlYWNoXG4gKiB0ZW1wbGF0ZS5cbiAqXG4gKiBTZWUgYGkxOG5NYXBwaW5nKClgIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHRtcGxJbmRleCBUaGUgb3JkZXIgb2YgYXBwZWFyYW5jZSBvZiB0aGUgdGVtcGxhdGUuXG4gKiAwIGZvciB0aGUgcm9vdCB0ZW1wbGF0ZSwgZm9sbG93aW5nIGluZGV4ZXMgbWF0Y2ggdGhlIG9yZGVyIGluIGB0ZW1wbGF0ZVJvb3RzYC5cbiAqIEBwYXJhbSBwYXJ0SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gYHRyYW5zbGF0aW9uUGFydHNgLlxuICogQHBhcmFtIHRyYW5zbGF0aW9uUGFydHMgVGhlIHRyYW5zbGF0aW9uIHN0cmluZyBzcGxpdCBpbnRvIGFuIGFycmF5IG9mIHBsYWNlaG9sZGVycyBhbmQgdGV4dFxuICogZWxlbWVudHMuXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIFRoZSBjdXJyZW50IGxpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSBlbGVtZW50cyBBbiBhcnJheSBjb250YWluaW5nLCBmb3IgZWFjaCB0ZW1wbGF0ZSwgdGhlIG1hcHMgb2YgZWxlbWVudCBwbGFjZWhvbGRlcnMgYW5kXG4gKiB0aGVpciBpbmRleGVzLlxuICogQHBhcmFtIGV4cHJlc3Npb25zIEFuIGFycmF5IGNvbnRhaW5pbmcsIGZvciBlYWNoIHRlbXBsYXRlLCB0aGUgbWFwcyBvZiBleHByZXNzaW9uIHBsYWNlaG9sZGVyc1xuICogYW5kIHRoZWlyIGluZGV4ZXMuXG4gKiBAcGFyYW0gdGVtcGxhdGVSb290cyBBbiBhcnJheSBvZiB0ZW1wbGF0ZSByb290cyB3aG9zZSBjb250ZW50IHNob3VsZCBiZSBpZ25vcmVkIHdoZW5cbiAqIGdlbmVyYXRpbmcgdGhlIGluc3RydWN0aW9ucyBmb3IgdGhlaXIgcGFyZW50IHRlbXBsYXRlLlxuICogQHBhcmFtIGxhc3RDaGlsZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgaTE4biBub2RlLiBVc2VkIHdoZW4gdGhlIGkxOG4gYmxvY2sgaXNcbiAqIGFuIG5nLWNvbnRhaW5lci5cbiAqXG4gKiBAcmV0dXJucyB0aGUgY3VycmVudCBpbmRleCBpbiBgdHJhbnNsYXRpb25QYXJ0c2BcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVNYXBwaW5nSW5zdHJ1Y3Rpb25zKHRtcGxJbmRleCwgcGFydEluZGV4LCB0cmFuc2xhdGlvblBhcnRzLCBpbnN0cnVjdGlvbnMsIGVsZW1lbnRzLCBleHByZXNzaW9ucywgdGVtcGxhdGVSb290cywgbGFzdENoaWxkSW5kZXgpIHtcbiAgICB2YXIgdG1wbEluc3RydWN0aW9ucyA9IFtdO1xuICAgIHZhciBwaFZpc2l0ZWQgPSBbXTtcbiAgICB2YXIgb3BlbmVkVGFnQ291bnQgPSAwO1xuICAgIHZhciBtYXhJbmRleCA9IDA7XG4gICAgdmFyIGN1cnJlbnRFbGVtZW50cyA9IGVsZW1lbnRzICYmIGVsZW1lbnRzW3RtcGxJbmRleF0gPyBlbGVtZW50c1t0bXBsSW5kZXhdIDogbnVsbDtcbiAgICB2YXIgY3VycmVudEV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMgJiYgZXhwcmVzc2lvbnNbdG1wbEluZGV4XSA/IGV4cHJlc3Npb25zW3RtcGxJbmRleF0gOiBudWxsO1xuICAgIGluc3RydWN0aW9uc1t0bXBsSW5kZXhdID0gdG1wbEluc3RydWN0aW9ucztcbiAgICBmb3IgKDsgcGFydEluZGV4IDwgdHJhbnNsYXRpb25QYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBjYW4gZWl0aGVyIGJlIHRleHQgb3IgdGhlIG5hbWUgb2YgYSBwbGFjZWhvbGRlciAoZWxlbWVudC90ZW1wbGF0ZSByb290L2V4cHJlc3Npb24pXG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zbGF0aW9uUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgLy8gT2RkIGluZGV4ZXMgYXJlIHBsYWNlaG9sZGVyc1xuICAgICAgICBpZiAocGFydEluZGV4ICYgMSkge1xuICAgICAgICAgICAgdmFyIHBoSW5kZXggPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRzICYmIGN1cnJlbnRFbGVtZW50c1t2YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBoSW5kZXggPSBjdXJyZW50RWxlbWVudHNbdmFsdWVdO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwbGFjZWhvbGRlciByZXByZXNlbnRzIGEgRE9NIGVsZW1lbnQsIGFkZCBhbiBpbnN0cnVjdGlvbiB0byBtb3ZlIGl0XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUm9vdEluZGV4ID0gdGVtcGxhdGVSb290cyA/IHRlbXBsYXRlUm9vdHMuaW5kZXhPZih2YWx1ZSkgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVSb290SW5kZXggIT09IC0xICYmICh0ZW1wbGF0ZVJvb3RJbmRleCArIDEpICE9PSB0bXBsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHRlbXBsYXRlIHJvb3QsIGl0IGhhcyBubyBjbG9zaW5nIHRhZywgbm90IHRyZWF0aW5nIGl0IGFzIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdG1wbEluc3RydWN0aW9ucy5wdXNoKHBoSW5kZXggfCAtMjE0NzQ4MzY0OCAvKiBUZW1wbGF0ZVJvb3QgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wbEluc3RydWN0aW9ucy5wdXNoKHBoSW5kZXggfCAxMDczNzQxODI0IC8qIEVsZW1lbnQgKi8pO1xuICAgICAgICAgICAgICAgICAgICBvcGVuZWRUYWdDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwaFZpc2l0ZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RXhwcmVzc2lvbnMgJiYgY3VycmVudEV4cHJlc3Npb25zW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGhJbmRleCA9IGN1cnJlbnRFeHByZXNzaW9uc1t2YWx1ZV07XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBsYWNlaG9sZGVyIHJlcHJlc2VudHMgYW4gZXhwcmVzc2lvbiwgYWRkIGFuIGluc3RydWN0aW9uIHRvIG1vdmUgaXRcbiAgICAgICAgICAgICAgICB0bXBsSW5zdHJ1Y3Rpb25zLnB1c2gocGhJbmRleCB8IDE2MTA2MTI3MzYgLyogRXhwcmVzc2lvbiAqLyk7XG4gICAgICAgICAgICAgICAgcGhWaXNpdGVkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBjbG9zaW5nIHRhZ1xuICAgICAgICAgICAgICAgIHRtcGxJbnN0cnVjdGlvbnMucHVzaCgtMTA3Mzc0MTgyNCAvKiBDbG9zZU5vZGUgKi8pO1xuICAgICAgICAgICAgICAgIGlmICh0bXBsSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lZFRhZ0NvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgcmVhY2hlZCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoaXMgdGVtcGxhdGUsIGV4aXQgdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lZFRhZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaEluZGV4ICE9PSB1bmRlZmluZWQgJiYgcGhJbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBwaEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlUm9vdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VG1wbEluZGV4ID0gdGVtcGxhdGVSb290cy5pbmRleE9mKHZhbHVlKSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RtcGxJbmRleCAhPT0gMCAmJiBuZXdUbXBsSW5kZXggIT09IHRtcGxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggPSBnZW5lcmF0ZU1hcHBpbmdJbnN0cnVjdGlvbnMobmV3VG1wbEluZGV4LCBwYXJ0SW5kZXgsIHRyYW5zbGF0aW9uUGFydHMsIGluc3RydWN0aW9ucywgZWxlbWVudHMsIGV4cHJlc3Npb25zLCB0ZW1wbGF0ZVJvb3RzLCBsYXN0Q2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgbm9uLWVtcHR5IHN0cmluZywgY3JlYXRlIGEgdGV4dCBub2RlXG4gICAgICAgICAgICB0bXBsSW5zdHJ1Y3Rpb25zLnB1c2goNTM2ODcwOTEyIC8qIFRleHQgKi8sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgaW5zdHJ1Y3Rpb25zIHRvIHJlbW92ZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgdXNlZCBpbiB0aGUgdHJhbnNsYXRpb25cbiAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHRtcGxFbGVtZW50cyA9IGVsZW1lbnRzW3RtcGxJbmRleF07XG4gICAgICAgIGlmICh0bXBsRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBwaEtleXMgPSBPYmplY3Qua2V5cyh0bXBsRWxlbWVudHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGggPSBwaEtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBoVmlzaXRlZC5pbmRleE9mKHBoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdG1wbEVsZW1lbnRzW3BoXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFuIGluc3RydWN0aW9uIHRvIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB0bXBsSW5zdHJ1Y3Rpb25zLnB1c2goaW5kZXggfCAtNTM2ODcwOTEyIC8qIFJlbW92ZU5vZGUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiBtYXhJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgaW5zdHJ1Y3Rpb25zIHRvIHJlbW92ZSBleHByZXNzaW9ucyB0aGF0IGFyZSBub3QgdXNlZCBpbiB0aGUgdHJhbnNsYXRpb25cbiAgICBpZiAoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIHRtcGxFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25zW3RtcGxJbmRleF07XG4gICAgICAgIGlmICh0bXBsRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBwaEtleXMgPSBPYmplY3Qua2V5cyh0bXBsRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGggPSBwaEtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBoVmlzaXRlZC5pbmRleE9mKHBoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdG1wbEV4cHJlc3Npb25zW3BoXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TGVzc1RoYW4oaW5kZXgudG9TdHJpbmcoMikubGVuZ3RoLCAyOCwgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgdG9vIGJpZyBhbmQgd2lsbCBvdmVyZmxvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW4gaW5zdHJ1Y3Rpb24gdG8gcmVtb3ZlIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHRtcGxJbnN0cnVjdGlvbnMucHVzaChpbmRleCB8IC01MzY4NzA5MTIgLyogUmVtb3ZlTm9kZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0bXBsSW5kZXggPT09IDAgJiYgdHlwZW9mIGxhc3RDaGlsZEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBwYXJlbnQgaXMgYW4gbmctY29udGFpbmVyIGFuZCBpdCBoYXMgbW9yZSBjaGlsZHJlbiBhZnRlciB0aGUgdHJhbnNsYXRpb24gdGhhdCB3ZVxuICAgICAgICAvLyBuZWVkIHRvIGFwcGVuZCB0byBrZWVwIHRoZSBvcmRlciBvZiB0aGUgRE9NIG5vZGVzIGNvcnJlY3RcbiAgICAgICAgZm9yICh2YXIgaSA9IG1heEluZGV4ICsgMTsgaSA8PSBsYXN0Q2hpbGRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmdEZXZNb2RlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TGVzc1RoYW4oaS50b1N0cmluZygyKS5sZW5ndGgsIDI4LCBcIkluZGV4IFwiICsgaSArIFwiIGlzIHRvbyBiaWcgYW5kIHdpbGwgb3ZlcmZsb3dcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXBsSW5zdHJ1Y3Rpb25zLnB1c2goaSB8IC0xNjEwNjEyNzM2IC8qIEFueSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRJbmRleDtcbn1cbmZ1bmN0aW9uIGFwcGVuZEkxOG5Ob2RlKHROb2RlLCBwYXJlbnRUTm9kZSwgcHJldmlvdXNUTm9kZSkge1xuICAgIGlmIChuZ0Rldk1vZGUpIHtcbiAgICAgICAgbmdEZXZNb2RlLnJlbmRlcmVyTW92ZU5vZGUrKztcbiAgICB9XG4gICAgdmFyIHZpZXdEYXRhID0gX2dldFZpZXdEYXRhKCk7XG4gICAgLy8gT24gZmlyc3QgcGFzcywgcmUtb3JnYW5pemUgbm9kZSB0cmVlIHRvIHB1dCB0aGlzIG5vZGUgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAgdmFyIGZpcnN0VGVtcGxhdGVQYXNzID0gdmlld0RhdGFbVFZJRVddLmZpcnN0VGVtcGxhdGVQYXNzO1xuICAgIGlmIChmaXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICBpZiAocHJldmlvdXNUTm9kZSA9PT0gcGFyZW50VE5vZGUgJiYgdE5vZGUgIT09IHBhcmVudFROb2RlLmNoaWxkKSB7XG4gICAgICAgICAgICB0Tm9kZS5uZXh0ID0gcGFyZW50VE5vZGUuY2hpbGQ7XG4gICAgICAgICAgICBwYXJlbnRUTm9kZS5jaGlsZCA9IHROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzVE5vZGUgIT09IHBhcmVudFROb2RlICYmIHROb2RlICE9PSBwcmV2aW91c1ROb2RlLm5leHQpIHtcbiAgICAgICAgICAgIHROb2RlLm5leHQgPSBwcmV2aW91c1ROb2RlLm5leHQ7XG4gICAgICAgICAgICBwcmV2aW91c1ROb2RlLm5leHQgPSB0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHROb2RlLm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRUTm9kZSAhPT0gdmlld0RhdGFbSE9TVF9OT0RFXSkge1xuICAgICAgICAgICAgdE5vZGUucGFyZW50ID0gcGFyZW50VE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQoZ2V0TmF0aXZlQnlUTm9kZSh0Tm9kZSwgdmlld0RhdGEpLCB0Tm9kZSwgdmlld0RhdGEpO1xuICAgIHZhciBzbG90VmFsdWUgPSB2aWV3RGF0YVt0Tm9kZS5pbmRleF07XG4gICAgaWYgKHROb2RlLnR5cGUgIT09IDAgLyogQ29udGFpbmVyICovICYmIGlzTENvbnRhaW5lcihzbG90VmFsdWUpKSB7XG4gICAgICAgIC8vIE5vZGVzIHRoYXQgaW5qZWN0IFZpZXdDb250YWluZXJSZWYgYWxzbyBoYXZlIGEgY29tbWVudCBub2RlIHRoYXQgc2hvdWxkIGJlIG1vdmVkXG4gICAgICAgIGFwcGVuZENoaWxkKHNsb3RWYWx1ZVtOQVRJVkVdLCB0Tm9kZSwgdmlld0RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdE5vZGU7XG59XG5mdW5jdGlvbiBpMThuQXR0cmlidXRlKGluZGV4LCBhdHRycykge1xuICAgIC8vIHBsYWNlaG9sZGVyIGZvciBpMThuQXR0cmlidXRlIGZ1bmN0aW9uXG59XG5mdW5jdGlvbiBpMThuRXhwKGV4cHJlc3Npb24pIHtcbiAgICAvLyBwbGFjZWhvbGRlciBmb3IgaTE4bkV4cCBmdW5jdGlvblxufVxuZnVuY3Rpb24gaTE4blN0YXJ0KGluZGV4LCBtZXNzYWdlLCBzdWJUZW1wbGF0ZUluZGV4KSB7XG4gICAgaWYgKHN1YlRlbXBsYXRlSW5kZXggPT09IHZvaWQgMCkgeyBzdWJUZW1wbGF0ZUluZGV4ID0gMDsgfVxuICAgIC8vIHBsYWNlaG9sZGVyIGZvciBpMThuRXhwIGZ1bmN0aW9uXG59XG5mdW5jdGlvbiBpMThuRW5kKCkge1xuICAgIC8vIHBsYWNlaG9sZGVyIGZvciBpMThuRW5kIGZ1bmN0aW9uXG59XG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBpbnN0cnVjdGlvbnMgZ2VuZXJhdGVkIGJ5IGBpMThuTWFwcGluZygpYCB0byB0cmFuc2Zvcm0gdGhlIHRlbXBsYXRlIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBzdGFydEluZGV4IEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IHRvIHRyYW5zbGF0ZSAoZm9yIGluc3RhbmNlIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGVcbiAqIGVsZW1lbnQgd2l0aCB0aGUgaTE4biBhdHRyaWJ1dGUpLlxuICogQHBhcmFtIGluc3RydWN0aW9ucyBUaGUgbGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYXBwbHkgb24gdGhlIGN1cnJlbnQgdmlldy5cbiAqL1xuZnVuY3Rpb24gaTE4bkFwcGx5KHN0YXJ0SW5kZXgsIGluc3RydWN0aW9ucykge1xuICAgIHZhciB2aWV3RGF0YSA9IF9nZXRWaWV3RGF0YSgpO1xuICAgIGlmIChuZ0Rldk1vZGUpIHtcbiAgICAgICAgYXNzZXJ0RXF1YWwodmlld0RhdGFbQklORElOR19JTkRFWF0sIHZpZXdEYXRhW1RWSUVXXS5iaW5kaW5nU3RhcnRJbmRleCwgJ2kxOG5BcHBseSBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhbnkgYmluZGluZycpO1xuICAgIH1cbiAgICBpZiAoIWluc3RydWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IGdldFJlbmRlcmVyKCk7XG4gICAgdmFyIHN0YXJ0VE5vZGUgPSBnZXRUTm9kZShzdGFydEluZGV4LCB2aWV3RGF0YSk7XG4gICAgdmFyIGxvY2FsUGFyZW50VE5vZGUgPSBzdGFydFROb2RlLnBhcmVudCB8fCB2aWV3RGF0YVtIT1NUX05PREVdO1xuICAgIHZhciBsb2NhbFByZXZpb3VzVE5vZGUgPSBsb2NhbFBhcmVudFROb2RlO1xuICAgIHJlc2V0Q29tcG9uZW50U3RhdGUoKTsgLy8gV2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIHRyZWUgd2l0aCB0aGUgd3JvbmcgcHJldmlvdXMgbm9kZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgc3dpdGNoIChpbnN0cnVjdGlvbiAmIC01MzY4NzA5MTIgLyogSW5zdHJ1Y3Rpb25NYXNrICovKSB7XG4gICAgICAgICAgICBjYXNlIDEwNzM3NDE4MjQgLyogRWxlbWVudCAqLzpcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFROb2RlID0gZ2V0VE5vZGUoaW5zdHJ1Y3Rpb24gJiA1MzY4NzA5MTEgLyogSW5kZXhNYXNrICovLCB2aWV3RGF0YSk7XG4gICAgICAgICAgICAgICAgbG9jYWxQcmV2aW91c1ROb2RlID0gYXBwZW5kSTE4bk5vZGUoZWxlbWVudFROb2RlLCBsb2NhbFBhcmVudFROb2RlLCBsb2NhbFByZXZpb3VzVE5vZGUpO1xuICAgICAgICAgICAgICAgIGxvY2FsUGFyZW50VE5vZGUgPSBlbGVtZW50VE5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2MTA2MTI3MzYgLyogRXhwcmVzc2lvbiAqLzpcbiAgICAgICAgICAgIGNhc2UgLTIxNDc0ODM2NDggLyogVGVtcGxhdGVSb290ICovOlxuICAgICAgICAgICAgY2FzZSAtMTYxMDYxMjczNiAvKiBBbnkgKi86XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGluc3RydWN0aW9uICYgNTM2ODcwOTExIC8qIEluZGV4TWFzayAqLztcbiAgICAgICAgICAgICAgICBsb2NhbFByZXZpb3VzVE5vZGUgPVxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRJMThuTm9kZShnZXRUTm9kZShub2RlSW5kZXgsIHZpZXdEYXRhKSwgbG9jYWxQYXJlbnRUTm9kZSwgbG9jYWxQcmV2aW91c1ROb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTM2ODcwOTEyIC8qIFRleHQgKi86XG4gICAgICAgICAgICAgICAgaWYgKG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBuZ0Rldk1vZGUucmVuZGVyZXJDcmVhdGVUZXh0Tm9kZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnN0cnVjdGlvbnNbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFJOb2RlID0gY3JlYXRlVGV4dE5vZGUodmFsdWUsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHRvIG9ubHkgY3JlYXRlIGEgYFJOb2RlYCB0aGVuIHByb2plY3Rpb25zIHdvbid0IG1vdmUgdGhlIHRleHQuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRleHQgbm9kZSBhdCB0aGUgY3VycmVudCBlbmQgb2Ygdmlld0RhdGEuIE11c3Qgc3VidHJhY3QgaGVhZGVyIG9mZnNldCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlTm9kZUF0SW5kZXggdGFrZXMgYSByYXcgaW5kZXggKG5vdCBhZGp1c3RlZCBieSBoZWFkZXIgb2Zmc2V0KS5cbiAgICAgICAgICAgICAgICBhZGp1c3RCbHVlcHJpbnRGb3JOZXdOb2RlKHZpZXdEYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFROb2RlID0gY3JlYXRlTm9kZUF0SW5kZXgodmlld0RhdGEubGVuZ3RoIC0gMSAtIEhFQURFUl9PRkZTRVQsIDMgLyogRWxlbWVudCAqLywgdGV4dFJOb2RlLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBsb2NhbFByZXZpb3VzVE5vZGUgPSBhcHBlbmRJMThuTm9kZSh0ZXh0VE5vZGUsIGxvY2FsUGFyZW50VE5vZGUsIGxvY2FsUHJldmlvdXNUTm9kZSk7XG4gICAgICAgICAgICAgICAgcmVzZXRDb21wb25lbnRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAtMTA3Mzc0MTgyNCAvKiBDbG9zZU5vZGUgKi86XG4gICAgICAgICAgICAgICAgbG9jYWxQcmV2aW91c1ROb2RlID0gbG9jYWxQYXJlbnRUTm9kZTtcbiAgICAgICAgICAgICAgICBsb2NhbFBhcmVudFROb2RlID0gbG9jYWxQYXJlbnRUTm9kZS5wYXJlbnQgfHwgdmlld0RhdGFbSE9TVF9OT0RFXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgLTUzNjg3MDkxMiAvKiBSZW1vdmVOb2RlICovOlxuICAgICAgICAgICAgICAgIGlmIChuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmdEZXZNb2RlLnJlbmRlcmVyUmVtb3ZlTm9kZSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSBpbnN0cnVjdGlvbiAmIDUzNjg3MDkxMSAvKiBJbmRleE1hc2sgKi87XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRFbGVtZW50ID0gZ2V0TmF0aXZlQnlJbmRleChyZW1vdmVJbmRleCwgdmlld0RhdGEpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkVE5vZGUgPSBnZXRUTm9kZShyZW1vdmVJbmRleCwgdmlld0RhdGEpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkKHJlbW92ZWRUTm9kZSwgcmVtb3ZlZEVsZW1lbnQgfHwgbnVsbCwgdmlld0RhdGEpO1xuICAgICAgICAgICAgICAgIHZhciBzbG90VmFsdWUgPSBsb2FkKHJlbW92ZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMQ29udGFpbmVyKHNsb3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxDb250YWluZXIgPSBzbG90VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkVE5vZGUudHlwZSAhPT0gMCAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkKHJlbW92ZWRUTm9kZSwgbENvbnRhaW5lcltOQVRJVkVdIHx8IG51bGwsIHZpZXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkVE5vZGUuZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsQ29udGFpbmVyW1JFTkRFUl9QQVJFTlRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRha2VzIGEgdHJhbnNsYXRpb24gc3RyaW5nIGFuZCB0aGUgaW5pdGlhbCBsaXN0IG9mIGV4cHJlc3Npb25zIGFuZCByZXR1cm5zIGEgbGlzdCBvZiBpbnN0cnVjdGlvbnNcbiAqIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHRyYW5zbGF0ZSBhbiBhdHRyaWJ1dGUuXG4gKiBFdmVuIGluZGV4ZXMgY29udGFpbiBzdGF0aWMgc3RyaW5ncywgd2hpbGUgb2RkIGluZGV4ZXMgY29udGFpbiB0aGUgaW5kZXggb2YgdGhlIGV4cHJlc3Npb24gd2hvc2VcbiAqIHZhbHVlIHdpbGwgYmUgY29uY2F0ZW5hdGVkIGludG8gdGhlIGZpbmFsIHRyYW5zbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpMThuRXhwTWFwcGluZyh0cmFuc2xhdGlvbiwgcGxhY2Vob2xkZXJzKSB7XG4gICAgdmFyIHN0YXRpY1RleHQgPSB0cmFuc2xhdGlvbi5zcGxpdChpMThuVGFnUmVnZXgpO1xuICAgIC8vIG9kZCBpbmRleGVzIGFyZSBwbGFjZWhvbGRlcnNcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YXRpY1RleHQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgc3RhdGljVGV4dFtpXSA9IHBsYWNlaG9sZGVyc1tzdGF0aWNUZXh0W2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRpY1RleHQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgb2YgYW4gZXhwcmVzc2lvbiBoYXMgY2hhbmdlZCBhbmQgcmVwbGFjZXMgaXQgYnkgaXRzIHZhbHVlIGluIGEgdHJhbnNsYXRpb24sXG4gKiBvciByZXR1cm5zIE5PX0NIQU5HRS5cbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIEEgbGlzdCBvZiBpbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNsYXRlIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB2MCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmcgd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBjaGFuZ2VzLCBgTk9fQ0hBTkdFYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGkxOG5JbnRlcnBvbGF0aW9uMShpbnN0cnVjdGlvbnMsIHYwKSB7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkKF9nZXRWaWV3RGF0YSgpW0JJTkRJTkdfSU5ERVhdKyssIHYwKTtcbiAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICAgIH1cbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gT2RkIGluZGV4ZXMgYXJlIGJpbmRpbmdzXG4gICAgICAgIGlmIChpICYgMSkge1xuICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeSQxKHYwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZXMgb2YgdXAgdG8gMiBleHByZXNzaW9ucyBoYXZlIGNoYW5nZWQgYW5kIHJlcGxhY2VzIHRoZW0gYnkgdGhlaXIgdmFsdWVzIGluIGFcbiAqIHRyYW5zbGF0aW9uLCBvciByZXR1cm5zIE5PX0NIQU5HRS5cbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIEEgbGlzdCBvZiBpbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNsYXRlIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB2MCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjEgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgY2hhbmdlcywgYE5PX0NIQU5HRWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpMThuSW50ZXJwb2xhdGlvbjIoaW5zdHJ1Y3Rpb25zLCB2MCwgdjEpIHtcbiAgICB2YXIgdmlld0RhdGEgPSBfZ2V0Vmlld0RhdGEoKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQyKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEpO1xuICAgIHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICs9IDI7XG4gICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgICB9XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE9kZCBpbmRleGVzIGFyZSBiaW5kaW5nc1xuICAgICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYml0c1xuICAgICAgICAgICAgdmFyIGlkeCA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBiMSA9IGlkeCAmIDE7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFyZ3VtZW50IHZ4IHdoZXJlIHggPSBpZHhcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGIxID8gdjEgOiB2MDtcbiAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnkkMSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWVzIG9mIHVwIHRvIDMgZXhwcmVzc2lvbnMgaGF2ZSBjaGFuZ2VkIGFuZCByZXBsYWNlcyB0aGVtIGJ5IHRoZWlyIHZhbHVlcyBpbiBhXG4gKiB0cmFuc2xhdGlvbiwgb3IgcmV0dXJucyBOT19DSEFOR0UuXG4gKlxuICogQHBhcmFtIGluc3RydWN0aW9ucyBBIGxpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHRyYW5zbGF0ZSBhbiBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdjAgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYxIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MiB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmcgd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBjaGFuZ2VzLCBgTk9fQ0hBTkdFYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGkxOG5JbnRlcnBvbGF0aW9uMyhpbnN0cnVjdGlvbnMsIHYwLCB2MSwgdjIpIHtcbiAgICB2YXIgdmlld0RhdGEgPSBfZ2V0Vmlld0RhdGEoKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQzKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyKTtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSAzO1xuICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgIHJldHVybiBOT19DSEFOR0U7XG4gICAgfVxuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBPZGQgaW5kZXhlcyBhcmUgYmluZGluZ3NcbiAgICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGJpdHNcbiAgICAgICAgICAgIHZhciBpZHggPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgYjIgPSBpZHggJiAyO1xuICAgICAgICAgICAgdmFyIGIxID0gaWR4ICYgMTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYXJndW1lbnQgdnggd2hlcmUgeCA9IGlkeFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYjIgPyB2MiA6IChiMSA/IHYxIDogdjApO1xuICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeSQxKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZXMgb2YgdXAgdG8gNCBleHByZXNzaW9ucyBoYXZlIGNoYW5nZWQgYW5kIHJlcGxhY2VzIHRoZW0gYnkgdGhlaXIgdmFsdWVzIGluIGFcbiAqIHRyYW5zbGF0aW9uLCBvciByZXR1cm5zIE5PX0NIQU5HRS5cbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIEEgbGlzdCBvZiBpbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNsYXRlIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB2MCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjEgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYyIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MyB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmcgd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBjaGFuZ2VzLCBgTk9fQ0hBTkdFYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGkxOG5JbnRlcnBvbGF0aW9uNChpbnN0cnVjdGlvbnMsIHYwLCB2MSwgdjIsIHYzKSB7XG4gICAgdmFyIHZpZXdEYXRhID0gX2dldFZpZXdEYXRhKCk7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkNCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSwgdjAsIHYxLCB2MiwgdjMpO1xuICAgIHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICs9IDQ7XG4gICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgICB9XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE9kZCBpbmRleGVzIGFyZSBiaW5kaW5nc1xuICAgICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYml0c1xuICAgICAgICAgICAgdmFyIGlkeCA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBiMiA9IGlkeCAmIDI7XG4gICAgICAgICAgICB2YXIgYjEgPSBpZHggJiAxO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhcmd1bWVudCB2eCB3aGVyZSB4ID0gaWR4XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBiMiA/IChiMSA/IHYzIDogdjIpIDogKGIxID8gdjEgOiB2MCk7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5JDEodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlcyBvZiB1cCB0byA1IGV4cHJlc3Npb25zIGhhdmUgY2hhbmdlZCBhbmQgcmVwbGFjZXMgdGhlbSBieSB0aGVpciB2YWx1ZXMgaW4gYVxuICogdHJhbnNsYXRpb24sIG9yIHJldHVybnMgTk9fQ0hBTkdFLlxuICpcbiAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgQSBsaXN0IG9mIGluc3RydWN0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2xhdGUgYW4gYXR0cmlidXRlLlxuICogQHBhcmFtIHYwIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MSB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjIgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYzIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2NCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmcgd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBjaGFuZ2VzLCBgTk9fQ0hBTkdFYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGkxOG5JbnRlcnBvbGF0aW9uNShpbnN0cnVjdGlvbnMsIHYwLCB2MSwgdjIsIHYzLCB2NCkge1xuICAgIHZhciB2aWV3RGF0YSA9IF9nZXRWaWV3RGF0YSgpO1xuICAgIHZhciBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDQodmlld0RhdGFbQklORElOR19JTkRFWF0sIHYwLCB2MSwgdjIsIHYzKTtcbiAgICBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArIDQsIHY0KSB8fCBkaWZmZXJlbnQ7XG4gICAgdmlld0RhdGFbQklORElOR19JTkRFWF0gKz0gNTtcbiAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICAgIH1cbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gT2RkIGluZGV4ZXMgYXJlIGJpbmRpbmdzXG4gICAgICAgIGlmIChpICYgMSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBiaXRzXG4gICAgICAgICAgICB2YXIgaWR4ID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGI0ID0gaWR4ICYgNDtcbiAgICAgICAgICAgIHZhciBiMiA9IGlkeCAmIDI7XG4gICAgICAgICAgICB2YXIgYjEgPSBpZHggJiAxO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhcmd1bWVudCB2eCB3aGVyZSB4ID0gaWR4XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBiNCA/IHY0IDogKGIyID8gKGIxID8gdjMgOiB2MikgOiAoYjEgPyB2MSA6IHYwKSk7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5JDEodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlcyBvZiB1cCB0byA2IGV4cHJlc3Npb25zIGhhdmUgY2hhbmdlZCBhbmQgcmVwbGFjZXMgdGhlbSBieSB0aGVpciB2YWx1ZXMgaW4gYVxuICogdHJhbnNsYXRpb24sIG9yIHJldHVybnMgTk9fQ0hBTkdFLlxuICpcbiAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgQSBsaXN0IG9mIGluc3RydWN0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2xhdGUgYW4gYXR0cmlidXRlLlxuICogQHBhcmFtIHYwIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MSB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjIgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYzIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2NCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjUgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgY2hhbmdlcywgYE5PX0NIQU5HRWAgb3RoZXJ3aXNlLlxuICovIGZ1bmN0aW9uIGkxOG5JbnRlcnBvbGF0aW9uNihpbnN0cnVjdGlvbnMsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUpIHtcbiAgICB2YXIgdmlld0RhdGEgPSBfZ2V0Vmlld0RhdGEoKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyLCB2Myk7XG4gICAgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQyKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQsIHY1KSB8fCBkaWZmZXJlbnQ7XG4gICAgdmlld0RhdGFbQklORElOR19JTkRFWF0gKz0gNjtcbiAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICAgIH1cbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gT2RkIGluZGV4ZXMgYXJlIGJpbmRpbmdzXG4gICAgICAgIGlmIChpICYgMSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBiaXRzXG4gICAgICAgICAgICB2YXIgaWR4ID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGI0ID0gaWR4ICYgNDtcbiAgICAgICAgICAgIHZhciBiMiA9IGlkeCAmIDI7XG4gICAgICAgICAgICB2YXIgYjEgPSBpZHggJiAxO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBhcmd1bWVudCB2eCB3aGVyZSB4ID0gaWR4XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBiNCA/IChiMSA/IHY1IDogdjQpIDogKGIyID8gKGIxID8gdjMgOiB2MikgOiAoYjEgPyB2MSA6IHYwKSk7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5JDEodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlcyBvZiB1cCB0byA3IGV4cHJlc3Npb25zIGhhdmUgY2hhbmdlZCBhbmQgcmVwbGFjZXMgdGhlbSBieSB0aGVpciB2YWx1ZXMgaW4gYVxuICogdHJhbnNsYXRpb24sIG9yIHJldHVybnMgTk9fQ0hBTkdFLlxuICpcbiAqIEBwYXJhbSBpbnN0cnVjdGlvbnMgQSBsaXN0IG9mIGluc3RydWN0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCB0byB0cmFuc2xhdGUgYW4gYXR0cmlidXRlLlxuICogQHBhcmFtIHYwIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MSB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjIgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYzIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2NCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjUgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHY2IHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZyB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIGNoYW5nZXMsIGBOT19DSEFOR0VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaTE4bkludGVycG9sYXRpb243KGluc3RydWN0aW9ucywgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYpIHtcbiAgICB2YXIgdmlld0RhdGEgPSBfZ2V0Vmlld0RhdGEoKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyLCB2Myk7XG4gICAgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQzKHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQsIHY1LCB2NikgfHwgZGlmZmVyZW50O1xuICAgIHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICs9IDc7XG4gICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgICB9XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE9kZCBpbmRleGVzIGFyZSBiaW5kaW5nc1xuICAgICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYml0c1xuICAgICAgICAgICAgdmFyIGlkeCA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBiNCA9IGlkeCAmIDQ7XG4gICAgICAgICAgICB2YXIgYjIgPSBpZHggJiAyO1xuICAgICAgICAgICAgdmFyIGIxID0gaWR4ICYgMTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgYXJndW1lbnQgdnggd2hlcmUgeCA9IGlkeFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYjQgPyAoYjIgPyB2NiA6IChiMSA/IHY1IDogdjQpKSA6IChiMiA/IChiMSA/IHYzIDogdjIpIDogKGIxID8gdjEgOiB2MCkpO1xuICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeSQxKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB2YWx1ZXMgb2YgdXAgdG8gOCBleHByZXNzaW9ucyBoYXZlIGNoYW5nZWQgYW5kIHJlcGxhY2VzIHRoZW0gYnkgdGhlaXIgdmFsdWVzIGluIGFcbiAqIHRyYW5zbGF0aW9uLCBvciByZXR1cm5zIE5PX0NIQU5HRS5cbiAqXG4gKiBAcGFyYW0gaW5zdHJ1Y3Rpb25zIEEgbGlzdCBvZiBpbnN0cnVjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNsYXRlIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB2MCB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjEgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHYyIHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2MyB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjQgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICogQHBhcmFtIHY1IHZhbHVlIGNoZWNrZWQgZm9yIGNoYW5nZS5cbiAqIEBwYXJhbSB2NiB2YWx1ZSBjaGVja2VkIGZvciBjaGFuZ2UuXG4gKiBAcGFyYW0gdjcgdmFsdWUgY2hlY2tlZCBmb3IgY2hhbmdlLlxuICpcbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgY2hhbmdlcywgYE5PX0NIQU5HRWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpMThuSW50ZXJwb2xhdGlvbjgoaW5zdHJ1Y3Rpb25zLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcpIHtcbiAgICB2YXIgdmlld0RhdGEgPSBfZ2V0Vmlld0RhdGEoKTtcbiAgICB2YXIgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdLCB2MCwgdjEsIHYyLCB2Myk7XG4gICAgZGlmZmVyZW50ID0gYmluZGluZ1VwZGF0ZWQ0KHZpZXdEYXRhW0JJTkRJTkdfSU5ERVhdICsgNCwgdjQsIHY1LCB2NiwgdjcpIHx8IGRpZmZlcmVudDtcbiAgICB2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSArPSA4O1xuICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgIHJldHVybiBOT19DSEFOR0U7XG4gICAgfVxuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBPZGQgaW5kZXhlcyBhcmUgYmluZGluZ3NcbiAgICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGJpdHNcbiAgICAgICAgICAgIHZhciBpZHggPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgYjQgPSBpZHggJiA0O1xuICAgICAgICAgICAgdmFyIGIyID0gaWR4ICYgMjtcbiAgICAgICAgICAgIHZhciBiMSA9IGlkeCAmIDE7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFyZ3VtZW50IHZ4IHdoZXJlIHggPSBpZHhcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGI0ID8gKGIyID8gKGIxID8gdjcgOiB2NikgOiAoYjEgPyB2NSA6IHY0KSkgOiAoYjIgPyAoYjEgPyB2MyA6IHYyKSA6IChiMSA/IHYxIDogdjApKTtcbiAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnkkMSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENyZWF0ZSBhIHRyYW5zbGF0ZWQgaW50ZXJwb2xhdGlvbiBiaW5kaW5nIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgZXhwcmVzc2lvbnMuXG4gKlxuICogSWYgdGhlcmUgYXJlIDEgdG8gOCBleHByZXNzaW9ucyB0aGVuIGBpMThuSW50ZXJwb2xhdGlvbigpYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLiBJdCBpcyBmYXN0ZXJcbiAqIGJlY2F1c2UgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgYW5kIGl0ZXJhdGUgb3ZlciBpdC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZyB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIGNoYW5nZXMsIGBOT19DSEFOR0VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaTE4bkludGVycG9sYXRpb25WKGluc3RydWN0aW9ucywgdmFsdWVzKSB7XG4gICAgdmFyIHZpZXdEYXRhID0gX2dldFZpZXdEYXRhKCk7XG4gICAgdmFyIGRpZmZlcmVudCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGJpbmRpbmdzIGhhdmUgY2hhbmdlZFxuICAgICAgICBiaW5kaW5nVXBkYXRlZCh2aWV3RGF0YVtCSU5ESU5HX0lOREVYXSsrLCB2YWx1ZXNbaV0pICYmIChkaWZmZXJlbnQgPSB0cnVlKTtcbiAgICB9XG4gICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5PX0NIQU5HRTtcbiAgICB9XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE9kZCBpbmRleGVzIGFyZSBwbGFjZWhvbGRlcnNcbiAgICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5JDEodmFsdWVzW2luc3RydWN0aW9uc1tpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVybmFsIHRva2VuIHdob3NlIHByZXNlbmNlIGluIGFuIGluamVjdG9yIGluZGljYXRlcyB0aGF0IHRoZSBpbmplY3RvciBzaG91bGQgdHJlYXQgaXRzZWxmXG4gKiBhcyBhIHJvb3Qgc2NvcGVkIGluamVjdG9yIHdoZW4gcHJvY2Vzc2luZyByZXF1ZXN0cyBmb3IgdW5rbm93biB0b2tlbnMgd2hpY2ggbWF5IGluZGljYXRlXG4gKiB0aGV5IGFyZSBwcm92aWRlZCBpbiB0aGUgcm9vdCBzY29wZS5cbiAqL1xudmFyIEFQUF9ST09UID0gbmV3IEluamVjdGlvblRva2VuKCdUaGUgcHJlc2VuY2Ugb2YgdGhpcyB0b2tlbiBtYXJrcyBhbiBpbmplY3RvciBhcyBiZWluZyB0aGUgcm9vdCBpbmplY3Rvci4nKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBNYXJrZXIgd2hpY2ggaW5kaWNhdGVzIHRoYXQgYSB2YWx1ZSBoYXMgbm90IHlldCBiZWVuIGNyZWF0ZWQgZnJvbSB0aGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqL1xudmFyIE5PVF9ZRVQgPSB7fTtcbi8qKlxuICogTWFya2VyIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBhIHRva2VuIGlzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIGNhbGxlZC5cbiAqXG4gKiBJZiB0aGUgaW5qZWN0b3IgaXMgYXNrZWQgdG8gaW5qZWN0IGEgdG9rZW4gd2l0aCBpdHMgdmFsdWUgc2V0IHRvIENJUkNVTEFSLCB0aGF0IGluZGljYXRlc1xuICogaW5qZWN0aW9uIG9mIGEgZGVwZW5kZW5jeSBoYXMgcmVjdXJzaXZlbHkgYXR0ZW1wdGVkIHRvIGluamVjdCB0aGUgb3JpZ2luYWwgdG9rZW4sIGFuZCB0aGVyZSBpc1xuICogYSBjaXJjdWxhciBkZXBlbmRlbmN5IGFtb25nIHRoZSBwcm92aWRlcnMuXG4gKi9cbnZhciBDSVJDVUxBUiQyID0ge307XG52YXIgRU1QVFlfQVJSQVkkMSA9IFtdO1xuLyoqXG4gKiBBIGxhemlseSBpbml0aWFsaXplZCBOdWxsSW5qZWN0b3IuXG4gKi9cbnZhciBOVUxMX0lOSkVDVE9SJDIgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXROdWxsSW5qZWN0b3IoKSB7XG4gICAgaWYgKE5VTExfSU5KRUNUT1IkMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE5VTExfSU5KRUNUT1IkMiA9IG5ldyBOdWxsSW5qZWN0b3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfSU5KRUNUT1IkMjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBJbmplY3RvcmAgd2hpY2ggaXMgY29uZmlndXJlZCB1c2luZyBhIGBkZWZUeXBlYCBvZiBgSW5qZWN0b3JUeXBlPGFueT5gcy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluamVjdG9yKGRlZlR5cGUsIHBhcmVudCwgYWRkaXRpb25hbFByb3ZpZGVycykge1xuICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgaWYgKGFkZGl0aW9uYWxQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsUHJvdmlkZXJzID0gbnVsbDsgfVxuICAgIHBhcmVudCA9IHBhcmVudCB8fCBnZXROdWxsSW5qZWN0b3IoKTtcbiAgICByZXR1cm4gbmV3IFIzSW5qZWN0b3IoZGVmVHlwZSwgYWRkaXRpb25hbFByb3ZpZGVycywgcGFyZW50KTtcbn1cbnZhciBSM0luamVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFIzSW5qZWN0b3IoZGVmLCBhZGRpdGlvbmFsUHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgdG9rZW5zIHRvIHJlY29yZHMgd2hpY2ggY29udGFpbiB0aGUgaW5zdGFuY2VzIG9mIHRob3NlIHRva2Vucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2l0aXZlIHNldCBvZiBgSW5qZWN0b3JUeXBlYHMgd2hpY2ggZGVmaW5lIHRoaXMgaW5qZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluamVjdG9yRGVmVHlwZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgb2YgdmFsdWVzIGluc3RhbnRpYXRlZCBieSB0aGlzIGluamVjdG9yIHdoaWNoIGNvbnRhaW4gYG5nT25EZXN0cm95YCBsaWZlY3ljbGUgaG9va3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRGVzdHJveSA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgaW5qZWN0b3Igd2FzIHByZXZpb3VzbHkgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gU3RhcnQgb2ZmIGJ5IGNyZWF0aW5nIFJlY29yZHMgZm9yIGV2ZXJ5IHByb3ZpZGVyIGRlY2xhcmVkIGluIGV2ZXJ5IEluamVjdG9yVHlwZVxuICAgICAgICAvLyBpbmNsdWRlZCB0cmFuc2l0aXZlbHkgaW4gYGRlZmAuXG4gICAgICAgIGRlZXBGb3JFYWNoKFtkZWZdLCBmdW5jdGlvbiAoaW5qZWN0b3JEZWYpIHsgcmV0dXJuIF90aGlzLnByb2Nlc3NJbmplY3RvclR5cGUoaW5qZWN0b3JEZWYsIG5ldyBTZXQoKSk7IH0pO1xuICAgICAgICBhZGRpdGlvbmFsUHJvdmlkZXJzICYmXG4gICAgICAgICAgICBkZWVwRm9yRWFjaChhZGRpdGlvbmFsUHJvdmlkZXJzLCBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLnByb2Nlc3NQcm92aWRlcihwcm92aWRlcik7IH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIElOSkVDVE9SIHRva2VuIHByb3ZpZGVzIHRoaXMgaW5qZWN0b3IuXG4gICAgICAgIHRoaXMucmVjb3Jkcy5zZXQoSU5KRUNUT1IsIG1ha2VSZWNvcmQodW5kZWZpbmVkLCB0aGlzKSk7XG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRoaXMgaW5qZWN0b3IgaGFzIHRoZSBBUFBfUk9PVF9TQ09QRSB0b2tlbiBhbmQgdGh1cyBzaG91bGQgcHJvdmlkZVxuICAgICAgICAvLyBhbnkgaW5qZWN0YWJsZSBzY29wZWQgdG8gQVBQX1JPT1RfU0NPUEUuXG4gICAgICAgIHRoaXMuaXNSb290SW5qZWN0b3IgPSB0aGlzLnJlY29yZHMuaGFzKEFQUF9ST09UKTtcbiAgICAgICAgLy8gRWFnZXJseSBpbnN0YW50aWF0ZSB0aGUgSW5qZWN0b3JUeXBlIGNsYXNzZXMgdGhlbXNlbHZlcy5cbiAgICAgICAgdGhpcy5pbmplY3RvckRlZlR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGRlZlR5cGUpIHsgcmV0dXJuIF90aGlzLmdldChkZWZUeXBlKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGluamVjdG9yIGFuZCByZWxlYXNlIHJlZmVyZW5jZXMgdG8gZXZlcnkgaW5zdGFuY2Ugb3IgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqXG4gICAgICogQWxzbyBjYWxscyB0aGUgYE9uRGVzdHJveWAgbGlmZWN5Y2xlIGhvb2tzIG9mIGV2ZXJ5IGluc3RhbmNlIHRoYXQgd2FzIGNyZWF0ZWQgZm9yIHdoaWNoIGFcbiAgICAgKiBob29rIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBSM0luamVjdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFzc2VydE5vdERlc3Ryb3llZCgpO1xuICAgICAgICAvLyBTZXQgZGVzdHJveWVkID0gdHJ1ZSBmaXJzdCwgaW4gY2FzZSBsaWZlY3ljbGUgaG9va3MgcmUtZW50ZXIgZGVzdHJveSgpLlxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYWxsIGFsbCB0aGUgbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAgICAgICAgdGhpcy5vbkRlc3Ryb3kuZm9yRWFjaChmdW5jdGlvbiAoc2VydmljZSkgeyByZXR1cm4gc2VydmljZS5uZ09uRGVzdHJveSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFJlbGVhc2UgYWxsIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICB0aGlzLnJlY29yZHMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMub25EZXN0cm95LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmluamVjdG9yRGVmVHlwZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUjNJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlLCBmbGFncykge1xuICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAwIC8qIERlZmF1bHQgKi87IH1cbiAgICAgICAgdGhpcy5hc3NlcnROb3REZXN0cm95ZWQoKTtcbiAgICAgICAgLy8gU2V0IHRoZSBpbmplY3Rpb24gY29udGV4dC5cbiAgICAgICAgdmFyIHByZXZpb3VzSW5qZWN0b3IgPSBzZXRDdXJyZW50SW5qZWN0b3IodGhpcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIFNraXBTZWxmIGZsYWcuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIDQgLyogU2tpcFNlbGYgKi8pKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcFNlbGYgaXNuJ3Qgc2V0LCBjaGVjayBpZiB0aGUgcmVjb3JkIGJlbG9uZ3MgdG8gdGhpcyBpbmplY3Rvci5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldCh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZCwgYnV0IG1heWJlIHRoZSB0b2tlbiBpcyBzY29wZWQgdG8gdGhpcyBpbmplY3Rvci4gTG9vayBmb3IgYW4gbmdJbmplY3RhYmxlRGVmXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggYSBzY29wZSBtYXRjaGluZyB0aGlzIGluamVjdG9yLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gY291bGRCZUluamVjdGFibGVUeXBlKHRva2VuKSAmJiBnZXRJbmplY3RhYmxlRGVmKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZiAmJiB0aGlzLmluamVjdGFibGVEZWZJblNjb3BlKGRlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIG5nSW5qZWN0YWJsZURlZiBhbmQgaXQncyBzY29wZWQgdG8gdGhpcyBpbmplY3Rvci4gUHJldGVuZCBhcyBpZiBpdCB3YXMgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGFsb25nLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gaW5qZWN0YWJsZURlZlJlY29yZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZHMuc2V0KHRva2VuLCByZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGEgcmVjb3JkIHdhcyBmb3VuZCwgZ2V0IHRoZSBpbnN0YW5jZSBmb3IgaXQgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHlkcmF0ZSh0b2tlbiwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIG5leHQgaW5qZWN0b3IgYmFzZWQgb24gdGhlIFNlbGYgZmxhZyAtIGlmIHNlbGYgaXMgc2V0LCB0aGUgbmV4dCBpbmplY3RvciBpc1xuICAgICAgICAgICAgLy8gdGhlIE51bGxJbmplY3Rvciwgb3RoZXJ3aXNlIGl0J3MgdGhlIHBhcmVudC5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gIShmbGFncyAmIDIgLyogU2VsZiAqLykgPyB0aGlzLnBhcmVudCA6IGdldE51bGxJbmplY3RvcigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBMYXN0bHksIGNsZWFuIHVwIHRoZSBzdGF0ZSBieSByZXN0b3JpbmcgdGhlIHByZXZpb3VzIGluamVjdG9yLlxuICAgICAgICAgICAgc2V0Q3VycmVudEluamVjdG9yKHByZXZpb3VzSW5qZWN0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSM0luamVjdG9yLnByb3RvdHlwZS5hc3NlcnROb3REZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmplY3RvciBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGBJbmplY3RvclR5cGVgIG9yIGBJbmplY3RvckRlZlR5cGVXaXRoUHJvdmlkZXJzYCBhbmQgYWxsIG9mIGl0cyB0cmFuc2l0aXZlIHByb3ZpZGVyc1xuICAgICAqIHRvIHRoaXMgaW5qZWN0b3IuXG4gICAgICovXG4gICAgUjNJbmplY3Rvci5wcm90b3R5cGUucHJvY2Vzc0luamVjdG9yVHlwZSA9IGZ1bmN0aW9uIChkZWZPcldyYXBwZWREZWYsIHBhcmVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZGVmT3JXcmFwcGVkRGVmID0gcmVzb2x2ZUZvcndhcmRSZWYoZGVmT3JXcmFwcGVkRGVmKTtcbiAgICAgICAgLy8gRWl0aGVyIHRoZSBkZWZPcldyYXBwZWREZWYgaXMgYW4gSW5qZWN0b3JUeXBlICh3aXRoIG5nSW5qZWN0b3JEZWYpIG9yIGFuXG4gICAgICAgIC8vIEluamVjdG9yRGVmVHlwZVdpdGhQcm92aWRlcnMgKGFrYSBNb2R1bGVXaXRoUHJvdmlkZXJzKS4gRGV0ZWN0aW5nIGVpdGhlciBpcyBhIG1lZ2Ftb3JwaGljXG4gICAgICAgIC8vIHJlYWQsIHNvIGNhcmUgaXMgdGFrZW4gdG8gb25seSBkbyB0aGUgcmVhZCBvbmNlLlxuICAgICAgICAvLyBGaXJzdCBhdHRlbXB0IHRvIHJlYWQgdGhlIG5nSW5qZWN0b3JEZWYuXG4gICAgICAgIHZhciBkZWYgPSBnZXRJbmplY3RvckRlZihkZWZPcldyYXBwZWREZWYpO1xuICAgICAgICAvLyBJZiB0aGF0J3Mgbm90IHByZXNlbnQsIHRoZW4gYXR0ZW1wdCB0byByZWFkIG5nTW9kdWxlIGZyb20gdGhlIEluamVjdG9yRGVmVHlwZVdpdGhQcm92aWRlcnMuXG4gICAgICAgIHZhciBuZ01vZHVsZSA9IChkZWYgPT0gbnVsbCkgJiYgZGVmT3JXcmFwcGVkRGVmLm5nTW9kdWxlIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBJbmplY3RvclR5cGUuIEluIHRoZSBjYXNlIHdoZXJlIGBkZWZPcldyYXBwZWREZWZgIGlzIGFuIGBJbmplY3RvclR5cGVgLFxuICAgICAgICAvLyB0aGVuIHRoaXMgaXMgZWFzeS4gSW4gdGhlIGNhc2Ugb2YgYW4gSW5qZWN0b3JEZWZUeXBlV2l0aFByb3ZpZGVycywgdGhlbiB0aGUgZGVmaW5pdGlvbiB0eXBlXG4gICAgICAgIC8vIGlzIHRoZSBgbmdNb2R1bGVgLlxuICAgICAgICB2YXIgZGVmVHlwZSA9IChuZ01vZHVsZSA9PT0gdW5kZWZpbmVkKSA/IGRlZk9yV3JhcHBlZERlZiA6IG5nTW9kdWxlO1xuICAgICAgICAvLyBJZiBkZWZPcldyYXBwZWRUeXBlIHdhcyBhbiBJbmplY3RvckRlZlR5cGVXaXRoUHJvdmlkZXJzLCB0aGVuIC5wcm92aWRlcnMgbWF5IGhvbGQgc29tZVxuICAgICAgICAvLyBleHRyYSBwcm92aWRlcnMuXG4gICAgICAgIHZhciBwcm92aWRlcnMgPSAobmdNb2R1bGUgIT09IHVuZGVmaW5lZCkgJiYgZGVmT3JXcmFwcGVkRGVmLnByb3ZpZGVycyB8fFxuICAgICAgICAgICAgRU1QVFlfQVJSQVkkMTtcbiAgICAgICAgLy8gRmluYWxseSwgaWYgZGVmT3JXcmFwcGVkVHlwZSB3YXMgYW4gYEluamVjdG9yRGVmVHlwZVdpdGhQcm92aWRlcnNgLCB0aGVuIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gYEluamVjdG9yRGVmYCBpcyBvbiBpdHMgYG5nTW9kdWxlYC5cbiAgICAgICAgaWYgKG5nTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZiA9IGdldEluamVjdG9yRGVmKG5nTW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBkZWZpbml0aW9uIHdhcyBmb3VuZCwgaXQgbWlnaHQgYmUgZnJvbSBleHBvcnRzLiBSZW1vdmUgaXQuXG4gICAgICAgIGlmIChkZWYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmIChwYXJlbnRzLmhhcyhkZWZUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgZGVwZW5kZW5jeTogdHlwZSBcIiArIHN0cmluZ2lmeShkZWZUeXBlKSArIFwiIGVuZHMgdXAgaW1wb3J0aW5nIGl0c2VsZi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhY2sgdGhlIEluamVjdG9yVHlwZSBhbmQgYWRkIGEgcHJvdmlkZXIgZm9yIGl0LlxuICAgICAgICB0aGlzLmluamVjdG9yRGVmVHlwZXMuYWRkKGRlZlR5cGUpO1xuICAgICAgICB0aGlzLnJlY29yZHMuc2V0KGRlZlR5cGUsIG1ha2VSZWNvcmQoZGVmLmZhY3RvcnkpKTtcbiAgICAgICAgLy8gQWRkIHByb3ZpZGVycyBpbiB0aGUgc2FtZSB3YXkgdGhhdCBATmdNb2R1bGUgcmVzb2x1dGlvbiBkaWQ6XG4gICAgICAgIC8vIEZpcnN0LCBpbmNsdWRlIHByb3ZpZGVycyBmcm9tIGFueSBpbXBvcnRzLlxuICAgICAgICBpZiAoZGVmLmltcG9ydHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQmVmb3JlIHByb2Nlc3NpbmcgZGVmVHlwZSdzIGltcG9ydHMsIGFkZCBpdCB0byB0aGUgc2V0IG9mIHBhcmVudHMuIFRoaXMgd2F5LCBpZiBpdCBlbmRzXG4gICAgICAgICAgICAvLyB1cCBkZWVwbHkgaW1wb3J0aW5nIGl0c2VsZiwgdGhpcyBjYW4gYmUgZGV0ZWN0ZWQuXG4gICAgICAgICAgICBwYXJlbnRzLmFkZChkZWZUeXBlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVlcEZvckVhY2goZGVmLmltcG9ydHMsIGZ1bmN0aW9uIChpbXBvcnRlZCkgeyByZXR1cm4gX3RoaXMucHJvY2Vzc0luamVjdG9yVHlwZShpbXBvcnRlZCwgcGFyZW50cyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHBhcmVudHMgc2V0IHdoZW4gZmluaXNoZWQuXG4gICAgICAgICAgICAgICAgcGFyZW50cy5kZWxldGUoZGVmVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmV4dCwgaW5jbHVkZSBwcm92aWRlcnMgbGlzdGVkIG9uIHRoZSBkZWZpbml0aW9uIGl0c2VsZi5cbiAgICAgICAgaWYgKGRlZi5wcm92aWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVlcEZvckVhY2goZGVmLnByb3ZpZGVycywgZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5wcm9jZXNzUHJvdmlkZXIocHJvdmlkZXIpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5LCBpbmNsdWRlIHByb3ZpZGVycyBmcm9tIGFuIEluamVjdG9yRGVmVHlwZVdpdGhQcm92aWRlcnMgaWYgdGhlcmUgd2FzIG9uZS5cbiAgICAgICAgZGVlcEZvckVhY2gocHJvdmlkZXJzLCBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLnByb2Nlc3NQcm92aWRlcihwcm92aWRlcik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGBTaW5nbGVQcm92aWRlcmAgYW5kIGFkZCBpdC5cbiAgICAgKi9cbiAgICBSM0luamVjdG9yLnByb3RvdHlwZS5wcm9jZXNzUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB0b2tlbiBmcm9tIHRoZSBwcm92aWRlci4gRWl0aGVyIGl0J3MgaXRzIG93biB0b2tlbiwgb3IgaGFzIGEge3Byb3ZpZGU6IC4uLn1cbiAgICAgICAgLy8gcHJvcGVydHkuXG4gICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICB2YXIgdG9rZW4gPSBpc1R5cGVQcm92aWRlcihwcm92aWRlcikgPyBwcm92aWRlciA6IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnByb3ZpZGUpO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBgUmVjb3JkYCBmb3IgdGhlIHByb3ZpZGVyLlxuICAgICAgICB2YXIgcmVjb3JkID0gcHJvdmlkZXJUb1JlY29yZChwcm92aWRlcik7XG4gICAgICAgIGlmICghaXNUeXBlUHJvdmlkZXIocHJvdmlkZXIpICYmIHByb3ZpZGVyLm11bHRpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJvdmlkZXIgaW5kaWNhdGVzIHRoYXQgaXQncyBhIG11bHRpLXByb3ZpZGVyLCBwcm9jZXNzIGl0IHNwZWNpYWxseS5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIHdoZXRoZXIgaXQncyBiZWVuIGRlZmluZWQgYWxyZWFkeS5cbiAgICAgICAgICAgIHZhciBtdWx0aVJlY29yZF8xID0gdGhpcy5yZWNvcmRzLmdldCh0b2tlbik7XG4gICAgICAgICAgICBpZiAobXVsdGlSZWNvcmRfMSkge1xuICAgICAgICAgICAgICAgIC8vIEl0IGhhcy4gVGhyb3cgYSBuaWNlIGVycm9yIGlmXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpUmVjb3JkXzEubXVsdGkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXhlZCBtdWx0aS1wcm92aWRlciBmb3IgXCIgKyB0b2tlbiArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlY29yZF8xID0gbWFrZVJlY29yZCh1bmRlZmluZWQsIE5PVF9ZRVQsIHRydWUpO1xuICAgICAgICAgICAgICAgIG11bHRpUmVjb3JkXzEuZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluamVjdEFyZ3MobXVsdGlSZWNvcmRfMS5tdWx0aSk7IH07XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzLnNldCh0b2tlbiwgbXVsdGlSZWNvcmRfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgbXVsdGlSZWNvcmRfMS5tdWx0aS5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMucmVjb3Jkcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLm11bHRpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXhlZCBtdWx0aS1wcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY29yZHMuc2V0KHRva2VuLCByZWNvcmQpO1xuICAgIH07XG4gICAgUjNJbmplY3Rvci5wcm90b3R5cGUuaHlkcmF0ZSA9IGZ1bmN0aW9uICh0b2tlbiwgcmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQudmFsdWUgPT09IENJUkNVTEFSJDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIGRlcCBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWNvcmQudmFsdWUgPT09IE5PVF9ZRVQpIHtcbiAgICAgICAgICAgIHJlY29yZC52YWx1ZSA9IENJUkNVTEFSJDI7XG4gICAgICAgICAgICByZWNvcmQudmFsdWUgPSByZWNvcmQuZmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVjb3JkLnZhbHVlID09PSAnb2JqZWN0JyAmJiByZWNvcmQudmFsdWUgJiYgaGFzT25EZXN0cm95KHJlY29yZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25EZXN0cm95LmFkZChyZWNvcmQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQudmFsdWU7XG4gICAgfTtcbiAgICBSM0luamVjdG9yLnByb3RvdHlwZS5pbmplY3RhYmxlRGVmSW5TY29wZSA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgaWYgKCFkZWYucHJvdmlkZWRJbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWYucHJvdmlkZWRJbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYucHJvdmlkZWRJbiA9PT0gJ2FueScgfHwgKGRlZi5wcm92aWRlZEluID09PSAncm9vdCcgJiYgdGhpcy5pc1Jvb3RJbmplY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3RvckRlZlR5cGVzLmhhcyhkZWYucHJvdmlkZWRJbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSM0luamVjdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGluamVjdGFibGVEZWZSZWNvcmQodG9rZW4pIHtcbiAgICB2YXIgaW5qZWN0YWJsZURlZiA9IGdldEluamVjdGFibGVEZWYodG9rZW4pO1xuICAgIGlmIChpbmplY3RhYmxlRGVmID09PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIEluamVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBcIiArIHN0cmluZ2lmeSh0b2tlbikgKyBcIiBpcyBtaXNzaW5nIGFuIG5nSW5qZWN0YWJsZURlZiBkZWZpbml0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IHRoZXJlIHNob3VsZCBwcm9iYWJseSBiZSBhIHN0cmljdCBtb2RlIHdoaWNoIHRocm93cyBoZXJlIGluc3RlYWQgb2YgYXNzdW1pbmcgYVxuICAgICAgICAvLyBuby1hcmdzIGNvbnN0cnVjdG9yLlxuICAgICAgICByZXR1cm4gbWFrZVJlY29yZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgdG9rZW4oKTsgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlUmVjb3JkKGluamVjdGFibGVEZWYuZmFjdG9yeSk7XG59XG5mdW5jdGlvbiBwcm92aWRlclRvUmVjb3JkKHByb3ZpZGVyKSB7XG4gICAgdmFyIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgIHZhciB2YWx1ZSA9IE5PVF9ZRVQ7XG4gICAgdmFyIGZhY3RvcnkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzVHlwZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICByZXR1cm4gaW5qZWN0YWJsZURlZlJlY29yZChwcm92aWRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnByb3ZpZGUpO1xuICAgICAgICBpZiAoaXNWYWx1ZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0V4aXN0aW5nUHJvdmlkZXIocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5qZWN0KHByb3ZpZGVyLnVzZUV4aXN0aW5nKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ZhY3RvcnlQcm92aWRlcihwcm92aWRlcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlci51c2VGYWN0b3J5LmFwcGx5KHByb3ZpZGVyLCBfX3NwcmVhZChpbmplY3RBcmdzKHByb3ZpZGVyLmRlcHMgfHwgW10pKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NSZWZfMSA9IHByb3ZpZGVyLnVzZUNsYXNzIHx8IHRva2VuO1xuICAgICAgICAgICAgaWYgKGhhc0RlcHMocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAoKGNsYXNzUmVmXzEpLmJpbmQuYXBwbHkoKGNsYXNzUmVmXzEpLCBfX3NwcmVhZChbdm9pZCAwXSwgaW5qZWN0QXJncyhwcm92aWRlci5kZXBzKSkpKSgpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluamVjdGFibGVEZWZSZWNvcmQoY2xhc3NSZWZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ha2VSZWNvcmQoZmFjdG9yeSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gbWFrZVJlY29yZChmYWN0b3J5LCB2YWx1ZSwgbXVsdGkpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IE5PVF9ZRVQ7IH1cbiAgICBpZiAobXVsdGkgPT09IHZvaWQgMCkgeyBtdWx0aSA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmFjdG9yeTogZmFjdG9yeSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtdWx0aTogbXVsdGkgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVlcEZvckVhY2goaW5wdXQsIGZuKSB7XG4gICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gZGVlcEZvckVhY2godmFsdWUsIGZuKSA6IGZuKHZhbHVlKTsgfSk7XG59XG5mdW5jdGlvbiBpc1ZhbHVlUHJvdmlkZXIodmFsdWUpIHtcbiAgICByZXR1cm4gVVNFX1ZBTFVFIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNFeGlzdGluZ1Byb3ZpZGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUudXNlRXhpc3Rpbmc7XG59XG5mdW5jdGlvbiBpc0ZhY3RvcnlQcm92aWRlcih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLnVzZUZhY3Rvcnk7XG59XG5mdW5jdGlvbiBpc1R5cGVQcm92aWRlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBoYXNEZXBzKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUuZGVwcztcbn1cbmZ1bmN0aW9uIGhhc09uRGVzdHJveSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUubmdPbkRlc3Ryb3kgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLm5nT25EZXN0cm95ID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gY291bGRCZUluamVjdGFibGVUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlIGluc3RhbmNlb2YgSW5qZWN0aW9uVG9rZW4pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09NUE9ORU5UX0ZBQ1RPUllfUkVTT0xWRVIgPSB7XG4gICAgcHJvdmlkZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIkMSgpOyB9LFxuICAgIGRlcHM6IFtdLFxufTtcbnZhciBOZ01vZHVsZVJlZiQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ01vZHVsZVJlZiQkMSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZiQkMShuZ01vZHVsZVR5cGUsIHBhcmVudEluamVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICBfdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5kZXN0cm95Q2JzID0gW107XG4gICAgICAgIHZhciBuZ01vZHVsZURlZiA9IGdldE5nTW9kdWxlRGVmKG5nTW9kdWxlVHlwZSk7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKG5nTW9kdWxlRGVmLCBcIk5nTW9kdWxlICdcIiArIHN0cmluZ2lmeShuZ01vZHVsZVR5cGUpICsgXCInIGlzIG5vdCBhIHN1YnR5cGUgb2YgJ05nTW9kdWxlVHlwZScuXCIpO1xuICAgICAgICBfdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50cyA9IG5nTW9kdWxlRGVmLmJvb3RzdHJhcDtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxQcm92aWRlcnMgPSBbXG4gICAgICAgICAgICBDT01QT05FTlRfRkFDVE9SWV9SRVNPTFZFUiwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5nTW9kdWxlUmVmLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBfdGhpcyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgX3RoaXMuaW5qZWN0b3IgPSBjcmVhdGVJbmplY3RvcihuZ01vZHVsZVR5cGUsIHBhcmVudEluamVjdG9yLCBhZGRpdGlvbmFsUHJvdmlkZXJzKTtcbiAgICAgICAgX3RoaXMuaW5zdGFuY2UgPSBfdGhpcy5pbmplY3Rvci5nZXQobmdNb2R1bGVUeXBlKTtcbiAgICAgICAgX3RoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gbmV3IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciQxKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmdNb2R1bGVSZWYkJDEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHRoaXMuZGVzdHJveUNicywgJ05nTW9kdWxlIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUNicy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIHRoaXMuZGVzdHJveUNicyA9IG51bGw7XG4gICAgfTtcbiAgICBOZ01vZHVsZVJlZiQkMS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKHRoaXMuZGVzdHJveUNicywgJ05nTW9kdWxlIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICAgIHRoaXMuZGVzdHJveUNicy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZVJlZiQkMTtcbn0oTmdNb2R1bGVSZWYpKTtcbnZhciBOZ01vZHVsZUZhY3RvcnkkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmdNb2R1bGVGYWN0b3J5JCQxLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlRmFjdG9yeSQkMShtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vZHVsZVR5cGUgPSBtb2R1bGVUeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5nTW9kdWxlRmFjdG9yeSQkMS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudEluamVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVSZWYkMSh0aGlzLm1vZHVsZVR5cGUsIHBhcmVudEluamVjdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZUZhY3RvcnkkJDE7XG59KE5nTW9kdWxlRmFjdG9yeSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEJpbmRpbmdzIGZvciBwdXJlIGZ1bmN0aW9ucyBhcmUgc3RvcmVkIGFmdGVyIHJlZ3VsYXIgYmluZGluZ3MuXG4gKlxuICogfC0tLS0tLWNvbnN0cy0tLS0tLXwtLS0tLS0tLS12YXJzLS0tLS0tLS0tfCAgICAgICAgICAgICAgICAgfC0tLS0tIGhvc3RWYXJzIChkaXIxKSAtLS0tLS18XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHwgbm9kZXMvcmVmcy9waXBlcyB8IGJpbmRpbmdzIHwgZm4gc2xvdHMgIHwgaW5qZWN0b3IgfCBkaXIxIHwgaG9zdCBiaW5kaW5ncyB8IGhvc3Qgc2xvdHMgfFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgICAgICAgICAgICBeXG4gKiAgICAgIFRWaWV3LmJpbmRpbmdTdGFydEluZGV4ICAgICAgVFZpZXcuZXhwYW5kb1N0YXJ0SW5kZXhcbiAqXG4gKiBQdXJlIGZ1bmN0aW9uIGluc3RydWN0aW9ucyBhcmUgZ2l2ZW4gYW4gb2Zmc2V0IGZyb20gdGhlIGJpbmRpbmcgcm9vdC4gQWRkaW5nIHRoZSBvZmZzZXQgdG8gdGhlXG4gKiBiaW5kaW5nIHJvb3QgZ2l2ZXMgdGhlIGZpcnN0IGluZGV4IHdoZXJlIHRoZSBiaW5kaW5ncyBhcmUgc3RvcmVkLiBJbiBjb21wb25lbnQgdmlld3MsIHRoZSBiaW5kaW5nXG4gKiByb290IGlzIHRoZSBiaW5kaW5nU3RhcnRJbmRleC4gSW4gaG9zdCBiaW5kaW5ncywgdGhlIGJpbmRpbmcgcm9vdCBpcyB0aGUgZXhwYW5kb1N0YXJ0SW5kZXggK1xuICogYW55IGRpcmVjdGl2ZSBpbnN0YW5jZXMgKyBhbnkgaG9zdFZhcnMgaW4gZGlyZWN0aXZlcyBldmFsdWF0ZWQgYmVmb3JlIGl0LlxuICpcbiAqIFNlZSBWSUVXX0RBVEEubWQgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG9zdCBiaW5kaW5nIHJlc29sdXRpb24uXG4gKi9cbi8qKlxuICogSWYgdGhlIHZhbHVlIGhhc24ndCBiZWVuIHNhdmVkLCBjYWxscyB0aGUgcHVyZSBmdW5jdGlvbiB0byBzdG9yZSBhbmQgcmV0dXJuIHRoZVxuICogdmFsdWUuIElmIGl0IGhhcyBiZWVuIHNhdmVkLCByZXR1cm5zIHRoZSBzYXZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc2xvdE9mZnNldCB0aGUgb2Zmc2V0IGZyb20gYmluZGluZyByb290IHRvIHRoZSByZXNlcnZlZCBzbG90XG4gKiBAcGFyYW0gcHVyZUZuIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlXG4gKiBAcGFyYW0gdGhpc0FyZyBPcHRpb25hbCBjYWxsaW5nIGNvbnRleHQgb2YgcHVyZUZuXG4gKiBAcmV0dXJucyB2YWx1ZVxuICovXG5mdW5jdGlvbiBwdXJlRnVuY3Rpb24wKHNsb3RPZmZzZXQsIHB1cmVGbiwgdGhpc0FyZykge1xuICAgIC8vIFRPRE8oa2FyYSk6IHVzZSBiaW5kaW5nUm9vdCBpbnN0ZWFkIG9mIGJpbmRpbmdTdGFydEluZGV4IHdoZW4gaW1wbGVtZW50aW5nIGhvc3QgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ0luZGV4ID0gZ2V0QmluZGluZ1Jvb3QoKSArIHNsb3RPZmZzZXQ7XG4gICAgcmV0dXJuIGdldENyZWF0aW9uTW9kZSgpID9cbiAgICAgICAgdXBkYXRlQmluZGluZyhiaW5kaW5nSW5kZXgsIHRoaXNBcmcgPyBwdXJlRm4uY2FsbCh0aGlzQXJnKSA6IHB1cmVGbigpKSA6XG4gICAgICAgIGdldEJpbmRpbmcoYmluZGluZ0luZGV4KTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gdXBkYXRlZCB2YWx1ZVxuICogQHBhcmFtIGV4cCBVcGRhdGVkIGV4cHJlc3Npb24gdmFsdWVcbiAqIEBwYXJhbSB0aGlzQXJnIE9wdGlvbmFsIGNhbGxpbmcgY29udGV4dCBvZiBwdXJlRm5cbiAqIEByZXR1cm5zIFVwZGF0ZWQgb3IgY2FjaGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHB1cmVGdW5jdGlvbjEoc2xvdE9mZnNldCwgcHVyZUZuLCBleHAsIHRoaXNBcmcpIHtcbiAgICAvLyBUT0RPKGthcmEpOiB1c2UgYmluZGluZ1Jvb3QgaW5zdGVhZCBvZiBiaW5kaW5nU3RhcnRJbmRleCB3aGVuIGltcGxlbWVudGluZyBob3N0IGJpbmRpbmdzXG4gICAgdmFyIGJpbmRpbmdJbmRleCA9IGdldEJpbmRpbmdSb290KCkgKyBzbG90T2Zmc2V0O1xuICAgIHJldHVybiBiaW5kaW5nVXBkYXRlZChiaW5kaW5nSW5kZXgsIGV4cCkgP1xuICAgICAgICB1cGRhdGVCaW5kaW5nKGJpbmRpbmdJbmRleCArIDEsIHRoaXNBcmcgPyBwdXJlRm4uY2FsbCh0aGlzQXJnLCBleHApIDogcHVyZUZuKGV4cCkpIDpcbiAgICAgICAgZ2V0QmluZGluZyhiaW5kaW5nSW5kZXggKyAxKTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIGFueSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgbm8gdmFsdWVzIGhhdmUgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGblxuICogQHBhcmFtIGV4cDFcbiAqIEBwYXJhbSBleHAyXG4gKiBAcGFyYW0gdGhpc0FyZyBPcHRpb25hbCBjYWxsaW5nIGNvbnRleHQgb2YgcHVyZUZuXG4gKiBAcmV0dXJucyBVcGRhdGVkIG9yIGNhY2hlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwdXJlRnVuY3Rpb24yKHNsb3RPZmZzZXQsIHB1cmVGbiwgZXhwMSwgZXhwMiwgdGhpc0FyZykge1xuICAgIC8vIFRPRE8oa2FyYSk6IHVzZSBiaW5kaW5nUm9vdCBpbnN0ZWFkIG9mIGJpbmRpbmdTdGFydEluZGV4IHdoZW4gaW1wbGVtZW50aW5nIGhvc3QgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ0luZGV4ID0gZ2V0QmluZGluZ1Jvb3QoKSArIHNsb3RPZmZzZXQ7XG4gICAgcmV0dXJuIGJpbmRpbmdVcGRhdGVkMihiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIpID9cbiAgICAgICAgdXBkYXRlQmluZGluZyhiaW5kaW5nSW5kZXggKyAyLCB0aGlzQXJnID8gcHVyZUZuLmNhbGwodGhpc0FyZywgZXhwMSwgZXhwMikgOiBwdXJlRm4oZXhwMSwgZXhwMikpIDpcbiAgICAgICAgZ2V0QmluZGluZyhiaW5kaW5nSW5kZXggKyAyKTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIGFueSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgbm8gdmFsdWVzIGhhdmUgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGblxuICogQHBhcmFtIGV4cDFcbiAqIEBwYXJhbSBleHAyXG4gKiBAcGFyYW0gZXhwM1xuICogQHBhcmFtIHRoaXNBcmcgT3B0aW9uYWwgY2FsbGluZyBjb250ZXh0IG9mIHB1cmVGblxuICogQHJldHVybnMgVXBkYXRlZCBvciBjYWNoZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uMyhzbG90T2Zmc2V0LCBwdXJlRm4sIGV4cDEsIGV4cDIsIGV4cDMsIHRoaXNBcmcpIHtcbiAgICAvLyBUT0RPKGthcmEpOiB1c2UgYmluZGluZ1Jvb3QgaW5zdGVhZCBvZiBiaW5kaW5nU3RhcnRJbmRleCB3aGVuIGltcGxlbWVudGluZyBob3N0IGJpbmRpbmdzXG4gICAgdmFyIGJpbmRpbmdJbmRleCA9IGdldEJpbmRpbmdSb290KCkgKyBzbG90T2Zmc2V0O1xuICAgIHJldHVybiBiaW5kaW5nVXBkYXRlZDMoYmluZGluZ0luZGV4LCBleHAxLCBleHAyLCBleHAzKSA/XG4gICAgICAgIHVwZGF0ZUJpbmRpbmcoYmluZGluZ0luZGV4ICsgMywgdGhpc0FyZyA/IHB1cmVGbi5jYWxsKHRoaXNBcmcsIGV4cDEsIGV4cDIsIGV4cDMpIDogcHVyZUZuKGV4cDEsIGV4cDIsIGV4cDMpKSA6XG4gICAgICAgIGdldEJpbmRpbmcoYmluZGluZ0luZGV4ICsgMyk7XG59XG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiBhbnkgcHJvdmlkZWQgZXhwIGhhcyBjaGFuZ2VkLCBjYWxscyB0aGUgcHVyZSBmdW5jdGlvbiB0byByZXR1cm5cbiAqIGFuIHVwZGF0ZWQgdmFsdWUuIE9yIGlmIG5vIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHJldHVybnMgY2FjaGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzbG90T2Zmc2V0IHRoZSBvZmZzZXQgZnJvbSBiaW5kaW5nIHJvb3QgdG8gdGhlIHJlc2VydmVkIHNsb3RcbiAqIEBwYXJhbSBwdXJlRm5cbiAqIEBwYXJhbSBleHAxXG4gKiBAcGFyYW0gZXhwMlxuICogQHBhcmFtIGV4cDNcbiAqIEBwYXJhbSBleHA0XG4gKiBAcGFyYW0gdGhpc0FyZyBPcHRpb25hbCBjYWxsaW5nIGNvbnRleHQgb2YgcHVyZUZuXG4gKiBAcmV0dXJucyBVcGRhdGVkIG9yIGNhY2hlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwdXJlRnVuY3Rpb240KHNsb3RPZmZzZXQsIHB1cmVGbiwgZXhwMSwgZXhwMiwgZXhwMywgZXhwNCwgdGhpc0FyZykge1xuICAgIC8vIFRPRE8oa2FyYSk6IHVzZSBiaW5kaW5nUm9vdCBpbnN0ZWFkIG9mIGJpbmRpbmdTdGFydEluZGV4IHdoZW4gaW1wbGVtZW50aW5nIGhvc3QgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ0luZGV4ID0gZ2V0QmluZGluZ1Jvb3QoKSArIHNsb3RPZmZzZXQ7XG4gICAgcmV0dXJuIGJpbmRpbmdVcGRhdGVkNChiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQpID9cbiAgICAgICAgdXBkYXRlQmluZGluZyhiaW5kaW5nSW5kZXggKyA0LCB0aGlzQXJnID8gcHVyZUZuLmNhbGwodGhpc0FyZywgZXhwMSwgZXhwMiwgZXhwMywgZXhwNCkgOiBwdXJlRm4oZXhwMSwgZXhwMiwgZXhwMywgZXhwNCkpIDpcbiAgICAgICAgZ2V0QmluZGluZyhiaW5kaW5nSW5kZXggKyA0KTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIGFueSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgbm8gdmFsdWVzIGhhdmUgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGblxuICogQHBhcmFtIGV4cDFcbiAqIEBwYXJhbSBleHAyXG4gKiBAcGFyYW0gZXhwM1xuICogQHBhcmFtIGV4cDRcbiAqIEBwYXJhbSBleHA1XG4gKiBAcGFyYW0gdGhpc0FyZyBPcHRpb25hbCBjYWxsaW5nIGNvbnRleHQgb2YgcHVyZUZuXG4gKiBAcmV0dXJucyBVcGRhdGVkIG9yIGNhY2hlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwdXJlRnVuY3Rpb241KHNsb3RPZmZzZXQsIHB1cmVGbiwgZXhwMSwgZXhwMiwgZXhwMywgZXhwNCwgZXhwNSwgdGhpc0FyZykge1xuICAgIC8vIFRPRE8oa2FyYSk6IHVzZSBiaW5kaW5nUm9vdCBpbnN0ZWFkIG9mIGJpbmRpbmdTdGFydEluZGV4IHdoZW4gaW1wbGVtZW50aW5nIGhvc3QgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ0luZGV4ID0gZ2V0QmluZGluZ1Jvb3QoKSArIHNsb3RPZmZzZXQ7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkNChiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQpO1xuICAgIHJldHVybiBiaW5kaW5nVXBkYXRlZChiaW5kaW5nSW5kZXggKyA0LCBleHA1KSB8fCBkaWZmZXJlbnQgP1xuICAgICAgICB1cGRhdGVCaW5kaW5nKGJpbmRpbmdJbmRleCArIDUsIHRoaXNBcmcgPyBwdXJlRm4uY2FsbCh0aGlzQXJnLCBleHAxLCBleHAyLCBleHAzLCBleHA0LCBleHA1KSA6XG4gICAgICAgICAgICBwdXJlRm4oZXhwMSwgZXhwMiwgZXhwMywgZXhwNCwgZXhwNSkpIDpcbiAgICAgICAgZ2V0QmluZGluZyhiaW5kaW5nSW5kZXggKyA1KTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIGFueSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgbm8gdmFsdWVzIGhhdmUgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGblxuICogQHBhcmFtIGV4cDFcbiAqIEBwYXJhbSBleHAyXG4gKiBAcGFyYW0gZXhwM1xuICogQHBhcmFtIGV4cDRcbiAqIEBwYXJhbSBleHA1XG4gKiBAcGFyYW0gZXhwNlxuICogQHBhcmFtIHRoaXNBcmcgT3B0aW9uYWwgY2FsbGluZyBjb250ZXh0IG9mIHB1cmVGblxuICogQHJldHVybnMgVXBkYXRlZCBvciBjYWNoZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uNihzbG90T2Zmc2V0LCBwdXJlRm4sIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQsIGV4cDUsIGV4cDYsIHRoaXNBcmcpIHtcbiAgICAvLyBUT0RPKGthcmEpOiB1c2UgYmluZGluZ1Jvb3QgaW5zdGVhZCBvZiBiaW5kaW5nU3RhcnRJbmRleCB3aGVuIGltcGxlbWVudGluZyBob3N0IGJpbmRpbmdzXG4gICAgdmFyIGJpbmRpbmdJbmRleCA9IGdldEJpbmRpbmdSb290KCkgKyBzbG90T2Zmc2V0O1xuICAgIHZhciBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDQoYmluZGluZ0luZGV4LCBleHAxLCBleHAyLCBleHAzLCBleHA0KTtcbiAgICByZXR1cm4gYmluZGluZ1VwZGF0ZWQyKGJpbmRpbmdJbmRleCArIDQsIGV4cDUsIGV4cDYpIHx8IGRpZmZlcmVudCA/XG4gICAgICAgIHVwZGF0ZUJpbmRpbmcoYmluZGluZ0luZGV4ICsgNiwgdGhpc0FyZyA/IHB1cmVGbi5jYWxsKHRoaXNBcmcsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQsIGV4cDUsIGV4cDYpIDpcbiAgICAgICAgICAgIHB1cmVGbihleHAxLCBleHAyLCBleHAzLCBleHA0LCBleHA1LCBleHA2KSkgOlxuICAgICAgICBnZXRCaW5kaW5nKGJpbmRpbmdJbmRleCArIDYpO1xufVxuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgYW55IHByb3ZpZGVkIGV4cCBoYXMgY2hhbmdlZCwgY2FsbHMgdGhlIHB1cmUgZnVuY3Rpb24gdG8gcmV0dXJuXG4gKiBhbiB1cGRhdGVkIHZhbHVlLiBPciBpZiBubyB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCByZXR1cm5zIGNhY2hlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc2xvdE9mZnNldCB0aGUgb2Zmc2V0IGZyb20gYmluZGluZyByb290IHRvIHRoZSByZXNlcnZlZCBzbG90XG4gKiBAcGFyYW0gcHVyZUZuXG4gKiBAcGFyYW0gZXhwMVxuICogQHBhcmFtIGV4cDJcbiAqIEBwYXJhbSBleHAzXG4gKiBAcGFyYW0gZXhwNFxuICogQHBhcmFtIGV4cDVcbiAqIEBwYXJhbSBleHA2XG4gKiBAcGFyYW0gZXhwN1xuICogQHBhcmFtIHRoaXNBcmcgT3B0aW9uYWwgY2FsbGluZyBjb250ZXh0IG9mIHB1cmVGblxuICogQHJldHVybnMgVXBkYXRlZCBvciBjYWNoZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uNyhzbG90T2Zmc2V0LCBwdXJlRm4sIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQsIGV4cDUsIGV4cDYsIGV4cDcsIHRoaXNBcmcpIHtcbiAgICAvLyBUT0RPKGthcmEpOiB1c2UgYmluZGluZ1Jvb3QgaW5zdGVhZCBvZiBiaW5kaW5nU3RhcnRJbmRleCB3aGVuIGltcGxlbWVudGluZyBob3N0IGJpbmRpbmdzXG4gICAgdmFyIGJpbmRpbmdJbmRleCA9IGdldEJpbmRpbmdSb290KCkgKyBzbG90T2Zmc2V0O1xuICAgIHZhciBkaWZmZXJlbnQgPSBiaW5kaW5nVXBkYXRlZDQoYmluZGluZ0luZGV4LCBleHAxLCBleHAyLCBleHAzLCBleHA0KTtcbiAgICByZXR1cm4gYmluZGluZ1VwZGF0ZWQzKGJpbmRpbmdJbmRleCArIDQsIGV4cDUsIGV4cDYsIGV4cDcpIHx8IGRpZmZlcmVudCA/XG4gICAgICAgIHVwZGF0ZUJpbmRpbmcoYmluZGluZ0luZGV4ICsgNywgdGhpc0FyZyA/XG4gICAgICAgICAgICBwdXJlRm4uY2FsbCh0aGlzQXJnLCBleHAxLCBleHAyLCBleHAzLCBleHA0LCBleHA1LCBleHA2LCBleHA3KSA6XG4gICAgICAgICAgICBwdXJlRm4oZXhwMSwgZXhwMiwgZXhwMywgZXhwNCwgZXhwNSwgZXhwNiwgZXhwNykpIDpcbiAgICAgICAgZ2V0QmluZGluZyhiaW5kaW5nSW5kZXggKyA3KTtcbn1cbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIGFueSBwcm92aWRlZCBleHAgaGFzIGNoYW5nZWQsIGNhbGxzIHRoZSBwdXJlIGZ1bmN0aW9uIHRvIHJldHVyblxuICogYW4gdXBkYXRlZCB2YWx1ZS4gT3IgaWYgbm8gdmFsdWVzIGhhdmUgY2hhbmdlZCwgcmV0dXJucyBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBmcm9tIGJpbmRpbmcgcm9vdCB0byB0aGUgcmVzZXJ2ZWQgc2xvdFxuICogQHBhcmFtIHB1cmVGblxuICogQHBhcmFtIGV4cDFcbiAqIEBwYXJhbSBleHAyXG4gKiBAcGFyYW0gZXhwM1xuICogQHBhcmFtIGV4cDRcbiAqIEBwYXJhbSBleHA1XG4gKiBAcGFyYW0gZXhwNlxuICogQHBhcmFtIGV4cDdcbiAqIEBwYXJhbSBleHA4XG4gKiBAcGFyYW0gdGhpc0FyZyBPcHRpb25hbCBjYWxsaW5nIGNvbnRleHQgb2YgcHVyZUZuXG4gKiBAcmV0dXJucyBVcGRhdGVkIG9yIGNhY2hlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwdXJlRnVuY3Rpb244KHNsb3RPZmZzZXQsIHB1cmVGbiwgZXhwMSwgZXhwMiwgZXhwMywgZXhwNCwgZXhwNSwgZXhwNiwgZXhwNywgZXhwOCwgdGhpc0FyZykge1xuICAgIC8vIFRPRE8oa2FyYSk6IHVzZSBiaW5kaW5nUm9vdCBpbnN0ZWFkIG9mIGJpbmRpbmdTdGFydEluZGV4IHdoZW4gaW1wbGVtZW50aW5nIGhvc3QgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ0luZGV4ID0gZ2V0QmluZGluZ1Jvb3QoKSArIHNsb3RPZmZzZXQ7XG4gICAgdmFyIGRpZmZlcmVudCA9IGJpbmRpbmdVcGRhdGVkNChiaW5kaW5nSW5kZXgsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQpO1xuICAgIHJldHVybiBiaW5kaW5nVXBkYXRlZDQoYmluZGluZ0luZGV4ICsgNCwgZXhwNSwgZXhwNiwgZXhwNywgZXhwOCkgfHwgZGlmZmVyZW50ID9cbiAgICAgICAgdXBkYXRlQmluZGluZyhiaW5kaW5nSW5kZXggKyA4LCB0aGlzQXJnID9cbiAgICAgICAgICAgIHB1cmVGbi5jYWxsKHRoaXNBcmcsIGV4cDEsIGV4cDIsIGV4cDMsIGV4cDQsIGV4cDUsIGV4cDYsIGV4cDcsIGV4cDgpIDpcbiAgICAgICAgICAgIHB1cmVGbihleHAxLCBleHAyLCBleHAzLCBleHA0LCBleHA1LCBleHA2LCBleHA3LCBleHA4KSkgOlxuICAgICAgICBnZXRCaW5kaW5nKGJpbmRpbmdJbmRleCArIDgpO1xufVxuLyoqXG4gKiBwdXJlRnVuY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjYW4gc3VwcG9ydCBhbnkgbnVtYmVyIG9mIGJpbmRpbmdzLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBvZiBhbnkgcHJvdmlkZWQgZXhwIGhhcyBjaGFuZ2VkLCBjYWxscyB0aGUgcHVyZSBmdW5jdGlvbiB0byByZXR1cm5cbiAqIGFuIHVwZGF0ZWQgdmFsdWUuIE9yIGlmIG5vIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHJldHVybnMgY2FjaGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBzbG90T2Zmc2V0IHRoZSBvZmZzZXQgZnJvbSBiaW5kaW5nIHJvb3QgdG8gdGhlIHJlc2VydmVkIHNsb3RcbiAqIEBwYXJhbSBwdXJlRm4gQSBwdXJlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYmluZGluZyB2YWx1ZXMgYW5kIGJ1aWxkcyBhbiBvYmplY3Qgb3IgYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhvc2UgdmFsdWVzLlxuICogQHBhcmFtIGV4cHMgQW4gYXJyYXkgb2YgYmluZGluZyB2YWx1ZXNcbiAqIEBwYXJhbSB0aGlzQXJnIE9wdGlvbmFsIGNhbGxpbmcgY29udGV4dCBvZiBwdXJlRm5cbiAqIEByZXR1cm5zIFVwZGF0ZWQgb3IgY2FjaGVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHB1cmVGdW5jdGlvblYoc2xvdE9mZnNldCwgcHVyZUZuLCBleHBzLCB0aGlzQXJnKSB7XG4gICAgLy8gVE9ETyhrYXJhKTogdXNlIGJpbmRpbmdSb290IGluc3RlYWQgb2YgYmluZGluZ1N0YXJ0SW5kZXggd2hlbiBpbXBsZW1lbnRpbmcgaG9zdCBiaW5kaW5nc1xuICAgIHZhciBiaW5kaW5nSW5kZXggPSBnZXRCaW5kaW5nUm9vdCgpICsgc2xvdE9mZnNldDtcbiAgICB2YXIgZGlmZmVyZW50ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJpbmRpbmdVcGRhdGVkKGJpbmRpbmdJbmRleCsrLCBleHBzW2ldKSAmJiAoZGlmZmVyZW50ID0gdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbnQgPyB1cGRhdGVCaW5kaW5nKGJpbmRpbmdJbmRleCwgcHVyZUZuLmFwcGx5KHRoaXNBcmcsIGV4cHMpKSA6XG4gICAgICAgIGdldEJpbmRpbmcoYmluZGluZ0luZGV4KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSBwaXBlLlxuICpcbiAqIEBwYXJhbSBpbmRleCBQaXBlIGluZGV4IHdoZXJlIHRoZSBwaXBlIHdpbGwgYmUgc3RvcmVkLlxuICogQHBhcmFtIHBpcGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBwaXBlXG4gKiBAcmV0dXJucyBUIHRoZSBpbnN0YW5jZSBvZiB0aGUgcGlwZS5cbiAqL1xuZnVuY3Rpb24gcGlwZShpbmRleCwgcGlwZU5hbWUpIHtcbiAgICB2YXIgdFZpZXcgPSBnZXRUVmlldygpO1xuICAgIHZhciBwaXBlRGVmO1xuICAgIHZhciBhZGp1c3RlZEluZGV4ID0gaW5kZXggKyBIRUFERVJfT0ZGU0VUO1xuICAgIGlmICh0Vmlldy5maXJzdFRlbXBsYXRlUGFzcykge1xuICAgICAgICBwaXBlRGVmID0gZ2V0UGlwZURlZiQxKHBpcGVOYW1lLCB0Vmlldy5waXBlUmVnaXN0cnkpO1xuICAgICAgICB0Vmlldy5kYXRhW2FkanVzdGVkSW5kZXhdID0gcGlwZURlZjtcbiAgICAgICAgaWYgKHBpcGVEZWYub25EZXN0cm95KSB7XG4gICAgICAgICAgICAodFZpZXcucGlwZURlc3Ryb3lIb29rcyB8fCAodFZpZXcucGlwZURlc3Ryb3lIb29rcyA9IFtdKSkucHVzaChhZGp1c3RlZEluZGV4LCBwaXBlRGVmLm9uRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBpcGVEZWYgPSB0Vmlldy5kYXRhW2FkanVzdGVkSW5kZXhdO1xuICAgIH1cbiAgICB2YXIgcGlwZUluc3RhbmNlID0gcGlwZURlZi5mYWN0b3J5KCk7XG4gICAgc3RvcmUoaW5kZXgsIHBpcGVJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHBpcGVJbnN0YW5jZTtcbn1cbi8qKlxuICogU2VhcmNoZXMgdGhlIHBpcGUgcmVnaXN0cnkgZm9yIGEgcGlwZSB3aXRoIHRoZSBnaXZlbiBuYW1lLiBJZiBvbmUgaXMgZm91bmQsXG4gKiByZXR1cm5zIHRoZSBwaXBlLiBPdGhlcndpc2UsIGFuIGVycm9yIGlzIHRocm93biBiZWNhdXNlIHRoZSBwaXBlIGNhbm5vdCBiZSByZXNvbHZlZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHBpcGUgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHJlZ2lzdHJ5IEZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcGlwZXNcbiAqIEByZXR1cm5zIE1hdGNoaW5nIFBpcGVEZWZcbiAqL1xuZnVuY3Rpb24gZ2V0UGlwZURlZiQxKG5hbWUsIHJlZ2lzdHJ5KSB7XG4gICAgaWYgKHJlZ2lzdHJ5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaXBlRGVmID0gcmVnaXN0cnlbaV07XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gcGlwZURlZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpcGVEZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGlwZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBub3QgZm91bmQhXCIpO1xufVxuLyoqXG4gKiBJbnZva2VzIGEgcGlwZSB3aXRoIDEgYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgaW5zdHJ1Y3Rpb24gYWN0cyBhcyBhIGd1YXJkIHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0gaW52b2tpbmdcbiAqIHRoZSBwaXBlIG9ubHkgd2hlbiBhbiBpbnB1dCB0byB0aGUgcGlwZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBpbmRleCBQaXBlIGluZGV4IHdoZXJlIHRoZSBwaXBlIHdhcyBzdG9yZWQgb24gY3JlYXRpb24uXG4gKiBAcGFyYW0gc2xvdE9mZnNldCB0aGUgb2Zmc2V0IGluIHRoZSByZXNlcnZlZCBzbG90IHNwYWNlXG4gKiBAcGFyYW0gdjEgMXN0IGFyZ3VtZW50IHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0uXG4gKi9cbmZ1bmN0aW9uIHBpcGVCaW5kMShpbmRleCwgc2xvdE9mZnNldCwgdjEpIHtcbiAgICB2YXIgcGlwZUluc3RhbmNlID0gbG9hZChpbmRleCk7XG4gICAgcmV0dXJuIGlzUHVyZShpbmRleCkgPyBwdXJlRnVuY3Rpb24xKHNsb3RPZmZzZXQsIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0sIHYxLCBwaXBlSW5zdGFuY2UpIDpcbiAgICAgICAgcGlwZUluc3RhbmNlLnRyYW5zZm9ybSh2MSk7XG59XG4vKipcbiAqIEludm9rZXMgYSBwaXBlIHdpdGggMiBhcmd1bWVudHMuXG4gKlxuICogVGhpcyBpbnN0cnVjdGlvbiBhY3RzIGFzIGEgZ3VhcmQgdG8ge0BsaW5rIFBpcGVUcmFuc2Zvcm0jdHJhbnNmb3JtfSBpbnZva2luZ1xuICogdGhlIHBpcGUgb25seSB3aGVuIGFuIGlucHV0IHRvIHRoZSBwaXBlIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIGluZGV4IFBpcGUgaW5kZXggd2hlcmUgdGhlIHBpcGUgd2FzIHN0b3JlZCBvbiBjcmVhdGlvbi5cbiAqIEBwYXJhbSBzbG90T2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIHJlc2VydmVkIHNsb3Qgc3BhY2VcbiAqIEBwYXJhbSB2MSAxc3QgYXJndW1lbnQgdG8ge0BsaW5rIFBpcGVUcmFuc2Zvcm0jdHJhbnNmb3JtfS5cbiAqIEBwYXJhbSB2MiAybmQgYXJndW1lbnQgdG8ge0BsaW5rIFBpcGVUcmFuc2Zvcm0jdHJhbnNmb3JtfS5cbiAqL1xuZnVuY3Rpb24gcGlwZUJpbmQyKGluZGV4LCBzbG90T2Zmc2V0LCB2MSwgdjIpIHtcbiAgICB2YXIgcGlwZUluc3RhbmNlID0gbG9hZChpbmRleCk7XG4gICAgcmV0dXJuIGlzUHVyZShpbmRleCkgPyBwdXJlRnVuY3Rpb24yKHNsb3RPZmZzZXQsIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0sIHYxLCB2MiwgcGlwZUluc3RhbmNlKSA6XG4gICAgICAgIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0odjEsIHYyKTtcbn1cbi8qKlxuICogSW52b2tlcyBhIHBpcGUgd2l0aCAzIGFyZ3VtZW50cy5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGFjdHMgYXMgYSBndWFyZCB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19IGludm9raW5nXG4gKiB0aGUgcGlwZSBvbmx5IHdoZW4gYW4gaW5wdXQgdG8gdGhlIHBpcGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gaW5kZXggUGlwZSBpbmRleCB3aGVyZSB0aGUgcGlwZSB3YXMgc3RvcmVkIG9uIGNyZWF0aW9uLlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgcmVzZXJ2ZWQgc2xvdCBzcGFjZVxuICogQHBhcmFtIHYxIDFzdCBhcmd1bWVudCB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19LlxuICogQHBhcmFtIHYyIDJuZCBhcmd1bWVudCB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19LlxuICogQHBhcmFtIHYzIDRyZCBhcmd1bWVudCB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19LlxuICovXG5mdW5jdGlvbiBwaXBlQmluZDMoaW5kZXgsIHNsb3RPZmZzZXQsIHYxLCB2MiwgdjMpIHtcbiAgICB2YXIgcGlwZUluc3RhbmNlID0gbG9hZChpbmRleCk7XG4gICAgcmV0dXJuIGlzUHVyZShpbmRleCkgP1xuICAgICAgICBwdXJlRnVuY3Rpb24zKHNsb3RPZmZzZXQsIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0sIHYxLCB2MiwgdjMsIHBpcGVJbnN0YW5jZSkgOlxuICAgICAgICBwaXBlSW5zdGFuY2UudHJhbnNmb3JtKHYxLCB2MiwgdjMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGEgcGlwZSB3aXRoIDQgYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgaW5zdHJ1Y3Rpb24gYWN0cyBhcyBhIGd1YXJkIHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0gaW52b2tpbmdcbiAqIHRoZSBwaXBlIG9ubHkgd2hlbiBhbiBpbnB1dCB0byB0aGUgcGlwZSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSBpbmRleCBQaXBlIGluZGV4IHdoZXJlIHRoZSBwaXBlIHdhcyBzdG9yZWQgb24gY3JlYXRpb24uXG4gKiBAcGFyYW0gc2xvdE9mZnNldCB0aGUgb2Zmc2V0IGluIHRoZSByZXNlcnZlZCBzbG90IHNwYWNlXG4gKiBAcGFyYW0gdjEgMXN0IGFyZ3VtZW50IHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0uXG4gKiBAcGFyYW0gdjIgMm5kIGFyZ3VtZW50IHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0uXG4gKiBAcGFyYW0gdjMgM3JkIGFyZ3VtZW50IHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0uXG4gKiBAcGFyYW0gdjQgNHRoIGFyZ3VtZW50IHRvIHtAbGluayBQaXBlVHJhbnNmb3JtI3RyYW5zZm9ybX0uXG4gKi9cbmZ1bmN0aW9uIHBpcGVCaW5kNChpbmRleCwgc2xvdE9mZnNldCwgdjEsIHYyLCB2MywgdjQpIHtcbiAgICB2YXIgcGlwZUluc3RhbmNlID0gbG9hZChpbmRleCk7XG4gICAgcmV0dXJuIGlzUHVyZShpbmRleCkgP1xuICAgICAgICBwdXJlRnVuY3Rpb240KHNsb3RPZmZzZXQsIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0sIHYxLCB2MiwgdjMsIHY0LCBwaXBlSW5zdGFuY2UpIDpcbiAgICAgICAgcGlwZUluc3RhbmNlLnRyYW5zZm9ybSh2MSwgdjIsIHYzLCB2NCk7XG59XG4vKipcbiAqIEludm9rZXMgYSBwaXBlIHdpdGggdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAqXG4gKiBUaGlzIGluc3RydWN0aW9uIGFjdHMgYXMgYSBndWFyZCB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19IGludm9raW5nXG4gKiB0aGUgcGlwZSBvbmx5IHdoZW4gYW4gaW5wdXQgdG8gdGhlIHBpcGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0gaW5kZXggUGlwZSBpbmRleCB3aGVyZSB0aGUgcGlwZSB3YXMgc3RvcmVkIG9uIGNyZWF0aW9uLlxuICogQHBhcmFtIHNsb3RPZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgcmVzZXJ2ZWQgc2xvdCBzcGFjZVxuICogQHBhcmFtIHZhbHVlcyBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB7QGxpbmsgUGlwZVRyYW5zZm9ybSN0cmFuc2Zvcm19IG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gcGlwZUJpbmRWKGluZGV4LCBzbG90T2Zmc2V0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcGlwZUluc3RhbmNlID0gbG9hZChpbmRleCk7XG4gICAgcmV0dXJuIGlzUHVyZShpbmRleCkgPyBwdXJlRnVuY3Rpb25WKHNsb3RPZmZzZXQsIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0sIHZhbHVlcywgcGlwZUluc3RhbmNlKSA6XG4gICAgICAgIHBpcGVJbnN0YW5jZS50cmFuc2Zvcm0uYXBwbHkocGlwZUluc3RhbmNlLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gaXNQdXJlKGluZGV4KSB7XG4gICAgcmV0dXJuIGdldFRWaWV3KCkuZGF0YVtpbmRleCArIEhFQURFUl9PRkZTRVRdLnB1cmU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVXNlIGluIGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gZXZlbnRzIHN5bmNocm9ub3VzbHlcbiAqIG9yIGFzeW5jaHJvbm91c2x5LCBhbmQgcmVnaXN0ZXIgaGFuZGxlcnMgZm9yIHRob3NlIGV2ZW50cyBieSBzdWJzY3JpYmluZ1xuICogdG8gYW4gaW5zdGFuY2UuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGEgY29tcG9uZW50IGRlZmluZXMgdHdvIG91dHB1dCBwcm9wZXJ0aWVzXG4gKiB0aGF0IGNyZWF0ZSBldmVudCBlbWl0dGVycy4gV2hlbiB0aGUgdGl0bGUgaXMgY2xpY2tlZCwgdGhlIGVtaXR0ZXJcbiAqIGVtaXRzIGFuIG9wZW4gb3IgY2xvc2UgZXZlbnQgdG8gdG9nZ2xlIHRoZSBjdXJyZW50IHZpc2liaWxpdHkgc3RhdGUuXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICd6aXBweScsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxuICogICAgIDxkaXYgKGNsaWNrKT1cInRvZ2dsZSgpXCI+VG9nZ2xlPC9kaXY+XG4gKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gKiAgICAgPC9kaXY+XG4gKiAgPC9kaXY+YH0pXG4gKiBleHBvcnQgY2xhc3MgWmlwcHkge1xuICogICB2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICogICBAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICpcbiAqICAgdG9nZ2xlKCkge1xuICogICAgIHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7XG4gKiAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIHRoaXMuY2xvc2UuZW1pdChudWxsKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFjY2VzcyB0aGUgZXZlbnQgb2JqZWN0IHdpdGggdGhlIGAkZXZlbnRgIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgb3V0cHV0IGV2ZW50XG4gKiBoYW5kbGVyOlxuICpcbiAqIGBgYFxuICogPHppcHB5IChvcGVuKT1cIm9uT3BlbigkZXZlbnQpXCIgKGNsb3NlKT1cIm9uQ2xvc2UoJGV2ZW50KVwiPjwvemlwcHk+XG4gKiBgYGBcbiAqXG4gKiAjIyMgTm90ZXNcbiAqXG4gKiBVc2VzIFJ4Lk9ic2VydmFibGUgYnV0IHByb3ZpZGVzIGFuIGFkYXB0ZXIgdG8gbWFrZSBpdCB3b3JrIGFzIHNwZWNpZmllZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gKlxuICogT25jZSBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlYyBpcyBhdmFpbGFibGUsIHN3aXRjaCB0byBpdC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50RW1pdHRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgdGhhdCBjYW5cbiAgICAgKiBkZWxpdmVyIGV2ZW50cyBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzQXN5bmMgV2hlbiB0cnVlLCBkZWxpdmVyIGV2ZW50cyBhc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihpc0FzeW5jKSB7XG4gICAgICAgIGlmIChpc0FzeW5jID09PSB2b2lkIDApIHsgaXNBc3luYyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgY29udGFpbmluZyBhIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZW1pdC5cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHsgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgZXZlbnRzIGVtaXR0ZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yT3JOZXh0IFdoZW4gc3VwcGxpZWQsIGEgY3VzdG9tIGhhbmRsZXIgZm9yIGVtaXR0ZWQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBlcnJvciBXaGVuIHN1cHBsaWVkLCBhIGN1c3RvbSBoYW5kbGVyIGZvciBhbiBlcnJvciBub3RpZmljYXRpb25cbiAgICAgKiBmcm9tIHRoaXMgZW1pdHRlci5cbiAgICAgKiBAcGFyYW0gY29tcGxldGUgV2hlbiBzdXBwbGllZCwgYSBjdXN0b20gaGFuZGxlciBmb3IgYSBjb21wbGV0aW9uXG4gICAgICogbm90aWZpY2F0aW9uIGZyb20gdGhpcyBlbWl0dGVyLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXJGbjtcbiAgICAgICAgdmFyIGVycm9yRm4gPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGxldGUoKTsgfSk7IH0gOiBmdW5jdGlvbiAoKSB7IGNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpbmsgPSBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgZ2VuZXJhdG9yT3JOZXh0LmFkZChzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KFN1YmplY3QpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVtYmVkZGVkIHRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgZW1iZWRkZWQgdmlld3MuXG4gKiBUbyBpbnN0YW50aWF0ZSBlbWJlZGRlZCB2aWV3cyBiYXNlZCBvbiBhIHRlbXBsYXRlLCB1c2UgdGhlIGBWaWV3Q29udGFpbmVyUmVmYFxuICogbWV0aG9kIGBjcmVhdGVFbWJlZGRlZFZpZXcoKWAuXG4gKlxuICogQWNjZXNzIGEgYFRlbXBsYXRlUmVmYCBpbnN0YW5jZSBieSBwbGFjaW5nIGEgZGlyZWN0aXZlIG9uIGFuIGA8bmctdGVtcGxhdGU+YFxuICogZWxlbWVudCAob3IgZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKS4gVGhlIGBUZW1wbGF0ZVJlZmAgZm9yIHRoZSBlbWJlZGRlZCB2aWV3XG4gKiBpcyBpbmplY3RlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlyZWN0aXZlLFxuICogdXNpbmcgdGhlIGBUZW1wbGF0ZVJlZmAgdG9rZW4uXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBhIGBRdWVyeWAgdG8gZmluZCBhIGBUZW1wbGF0ZVJlZmAgYXNzb2NpYXRlZCB3aXRoXG4gKiBhIGNvbXBvbmVudCBvciBhIGRpcmVjdGl2ZS5cbiAqXG4gKiBAc2VlIGBWaWV3Q29udGFpbmVyUmVmYFxuICogQHNlZSBbTmF2aWdhdGUgdGhlIENvbXBvbmVudCBUcmVlIHdpdGggREldKGd1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uLW5hdnRyZWUpXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVGVtcGxhdGVSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVSZWYoKSB7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBUZW1wbGF0ZVJlZi5fX05HX0VMRU1FTlRfSURfXyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFIzX1RFTVBMQVRFX1JFRl9GQUNUT1JZJDEoVGVtcGxhdGVSZWYsIEVsZW1lbnRSZWYpOyB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVJlZjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTFF1ZXJpZXNfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExRdWVyaWVzXyhwYXJlbnQsIHNoYWxsb3csIGRlZXApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuc2hhbGxvdyA9IHNoYWxsb3c7XG4gICAgICAgIHRoaXMuZGVlcCA9IGRlZXA7XG4gICAgfVxuICAgIExRdWVyaWVzXy5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAocXVlcnlMaXN0LCBwcmVkaWNhdGUsIGRlc2NlbmQsIHJlYWQpIHtcbiAgICAgICAgaWYgKGRlc2NlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVlcCA9IGNyZWF0ZVF1ZXJ5KHRoaXMuZGVlcCwgcXVlcnlMaXN0LCBwcmVkaWNhdGUsIHJlYWQgIT0gbnVsbCA/IHJlYWQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hhbGxvdyA9IGNyZWF0ZVF1ZXJ5KHRoaXMuc2hhbGxvdywgcXVlcnlMaXN0LCBwcmVkaWNhdGUsIHJlYWQgIT0gbnVsbCA/IHJlYWQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTFF1ZXJpZXNfLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBMUXVlcmllc18odGhpcywgbnVsbCwgdGhpcy5kZWVwKTsgfTtcbiAgICBMUXVlcmllc18ucHJvdG90eXBlLmNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNoYWxsb3dSZXN1bHRzID0gY29weVF1ZXJpZXNUb0NvbnRhaW5lcih0aGlzLnNoYWxsb3cpO1xuICAgICAgICB2YXIgZGVlcFJlc3VsdHMgPSBjb3B5UXVlcmllc1RvQ29udGFpbmVyKHRoaXMuZGVlcCk7XG4gICAgICAgIHJldHVybiBzaGFsbG93UmVzdWx0cyB8fCBkZWVwUmVzdWx0cyA/IG5ldyBMUXVlcmllc18odGhpcywgc2hhbGxvd1Jlc3VsdHMsIGRlZXBSZXN1bHRzKSA6IG51bGw7XG4gICAgfTtcbiAgICBMUXVlcmllc18ucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaGFsbG93UmVzdWx0cyA9IGNvcHlRdWVyaWVzVG9WaWV3KHRoaXMuc2hhbGxvdyk7XG4gICAgICAgIHZhciBkZWVwUmVzdWx0cyA9IGNvcHlRdWVyaWVzVG9WaWV3KHRoaXMuZGVlcCk7XG4gICAgICAgIHJldHVybiBzaGFsbG93UmVzdWx0cyB8fCBkZWVwUmVzdWx0cyA/IG5ldyBMUXVlcmllc18odGhpcywgc2hhbGxvd1Jlc3VsdHMsIGRlZXBSZXN1bHRzKSA6IG51bGw7XG4gICAgfTtcbiAgICBMUXVlcmllc18ucHJvdG90eXBlLmluc2VydFZpZXcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaW5zZXJ0VmlldyQxKGluZGV4LCB0aGlzLnNoYWxsb3cpO1xuICAgICAgICBpbnNlcnRWaWV3JDEoaW5kZXgsIHRoaXMuZGVlcCk7XG4gICAgfTtcbiAgICBMUXVlcmllc18ucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAodE5vZGUpIHtcbiAgICAgICAgYWRkKHRoaXMuZGVlcCwgdE5vZGUpO1xuICAgICAgICBpZiAoaXNDb250ZW50UXVlcnlIb3N0KHROb2RlKSkge1xuICAgICAgICAgICAgYWRkKHRoaXMuc2hhbGxvdywgdE5vZGUpO1xuICAgICAgICAgICAgaWYgKHROb2RlLnBhcmVudCAmJiBpc0NvbnRlbnRRdWVyeUhvc3QodE5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIGEgY29udGVudCBxdWVyeSBhbmQgcGFyZW50IGFsc28gaGFzIGEgY29udGVudCBxdWVyeVxuICAgICAgICAgICAgICAgIC8vIGJvdGggcXVlcmllcyBuZWVkIHRvIGNoZWNrIHRoaXMgbm9kZSBmb3Igc2hhbGxvdyBtYXRjaGVzXG4gICAgICAgICAgICAgICAgYWRkKHRoaXMucGFyZW50LnNoYWxsb3csIHROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpc1Jvb3ROb2RlT2ZRdWVyeSh0Tm9kZSkgJiYgYWRkKHRoaXMuc2hhbGxvdywgdE5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExRdWVyaWVzXy5wcm90b3R5cGUucmVtb3ZlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVmlldyQxKHRoaXMuc2hhbGxvdyk7XG4gICAgICAgIHJlbW92ZVZpZXckMSh0aGlzLmRlZXApO1xuICAgIH07XG4gICAgcmV0dXJuIExRdWVyaWVzXztcbn0oKSk7XG5mdW5jdGlvbiBpc1Jvb3ROb2RlT2ZRdWVyeSh0Tm9kZSkge1xuICAgIHJldHVybiB0Tm9kZS5wYXJlbnQgPT09IG51bGwgfHwgaXNDb250ZW50UXVlcnlIb3N0KHROb2RlLnBhcmVudCk7XG59XG5mdW5jdGlvbiBjb3B5UXVlcmllc1RvQ29udGFpbmVyKHF1ZXJ5KSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgd2hpbGUgKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBjb250YWluZXJWYWx1ZXMgPSBbXTsgLy8gcHJlcGFyZSByb29tIGZvciB2aWV3c1xuICAgICAgICBxdWVyeS52YWx1ZXMucHVzaChjb250YWluZXJWYWx1ZXMpO1xuICAgICAgICB2YXIgY2xvbmVkUXVlcnkgPSB7XG4gICAgICAgICAgICBuZXh0OiByZXN1bHQsXG4gICAgICAgICAgICBsaXN0OiBxdWVyeS5saXN0LFxuICAgICAgICAgICAgcHJlZGljYXRlOiBxdWVyeS5wcmVkaWNhdGUsXG4gICAgICAgICAgICB2YWx1ZXM6IGNvbnRhaW5lclZhbHVlcyxcbiAgICAgICAgICAgIGNvbnRhaW5lclZhbHVlczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQgPSBjbG9uZWRRdWVyeTtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29weVF1ZXJpZXNUb1ZpZXcocXVlcnkpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB3aGlsZSAocXVlcnkpIHtcbiAgICAgICAgdmFyIGNsb25lZFF1ZXJ5ID0ge1xuICAgICAgICAgICAgbmV4dDogcmVzdWx0LFxuICAgICAgICAgICAgbGlzdDogcXVlcnkubGlzdCxcbiAgICAgICAgICAgIHByZWRpY2F0ZTogcXVlcnkucHJlZGljYXRlLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNvbnRhaW5lclZhbHVlczogcXVlcnkudmFsdWVzXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdCA9IGNsb25lZFF1ZXJ5O1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpbnNlcnRWaWV3JDEoaW5kZXgsIHF1ZXJ5KSB7XG4gICAgd2hpbGUgKHF1ZXJ5KSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgYXNzZXJ0RGVmaW5lZChxdWVyeS5jb250YWluZXJWYWx1ZXMsICdWaWV3IHF1ZXJpZXMgbmVlZCB0byBoYXZlIGEgcG9pbnRlciB0byBjb250YWluZXIgdmFsdWVzLicpO1xuICAgICAgICBxdWVyeS5jb250YWluZXJWYWx1ZXMuc3BsaWNlKGluZGV4LCAwLCBxdWVyeS52YWx1ZXMpO1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVmlldyQxKHF1ZXJ5KSB7XG4gICAgd2hpbGUgKHF1ZXJ5KSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgYXNzZXJ0RGVmaW5lZChxdWVyeS5jb250YWluZXJWYWx1ZXMsICdWaWV3IHF1ZXJpZXMgbmVlZCB0byBoYXZlIGEgcG9pbnRlciB0byBjb250YWluZXIgdmFsdWVzLicpO1xuICAgICAgICB2YXIgY29udGFpbmVyVmFsdWVzID0gcXVlcnkuY29udGFpbmVyVmFsdWVzO1xuICAgICAgICB2YXIgdmlld1ZhbHVlc0lkeCA9IGNvbnRhaW5lclZhbHVlcy5pbmRleE9mKHF1ZXJ5LnZhbHVlcyk7XG4gICAgICAgIHZhciByZW1vdmVkID0gY29udGFpbmVyVmFsdWVzLnNwbGljZSh2aWV3VmFsdWVzSWR4LCAxKTtcbiAgICAgICAgLy8gbWFyayBhIHF1ZXJ5IGFzIGRpcnR5IG9ubHkgd2hlbiByZW1vdmVkIHZpZXcgaGFkIG1hdGNoaW5nIG1vZGVzXG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnRFcXVhbChyZW1vdmVkLmxlbmd0aCwgMSwgJ3JlbW92ZWQubGVuZ3RoJyk7XG4gICAgICAgIGlmIChyZW1vdmVkWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVlcnkubGlzdC5zZXREaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkubmV4dDtcbiAgICB9XG59XG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgbG9jYWwgbmFtZXMgZm9yIGEgZ2l2ZW4gbm9kZSBhbmQgcmV0dXJucyBkaXJlY3RpdmUgaW5kZXhcbiAqIChvciAtMSBpZiBhIGxvY2FsIG5hbWUgcG9pbnRzIHRvIGFuIGVsZW1lbnQpLlxuICpcbiAqIEBwYXJhbSB0Tm9kZSBzdGF0aWMgZGF0YSBvZiBhIG5vZGUgdG8gY2hlY2tcbiAqIEBwYXJhbSBzZWxlY3RvciBzZWxlY3RvciB0byBtYXRjaFxuICogQHJldHVybnMgZGlyZWN0aXZlIGluZGV4LCAtMSBvciBudWxsIGlmIGEgc2VsZWN0b3IgZGlkbid0IG1hdGNoIGFueSBvZiB0aGUgbG9jYWwgbmFtZXNcbiAqL1xuZnVuY3Rpb24gZ2V0SWR4T2ZNYXRjaGluZ1NlbGVjdG9yKHROb2RlLCBzZWxlY3Rvcikge1xuICAgIHZhciBsb2NhbE5hbWVzID0gdE5vZGUubG9jYWxOYW1lcztcbiAgICBpZiAobG9jYWxOYW1lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsTmFtZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbE5hbWVzW2ldID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbE5hbWVzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhbGwgdGhlIGRpcmVjdGl2ZXMgZm9yIGEgbm9kZSBhbmQgcmV0dXJucyBpbmRleCBvZiBhIGRpcmVjdGl2ZSBmb3IgYSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB0Tm9kZSBUTm9kZSBvbiB3aGljaCBkaXJlY3RpdmVzIGFyZSBwcmVzZW50LlxuICogQHBhcmFtIGN1cnJlbnRWaWV3IFRoZSB2aWV3IHdlIGFyZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICogQHBhcmFtIHR5cGUgVHlwZSBvZiBhIGRpcmVjdGl2ZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIEluZGV4IG9mIGEgZm91bmQgZGlyZWN0aXZlIG9yIG51bGwgd2hlbiBub25lIGZvdW5kLlxuICovXG5mdW5jdGlvbiBnZXRJZHhPZk1hdGNoaW5nRGlyZWN0aXZlKHROb2RlLCBjdXJyZW50VmlldywgdHlwZSkge1xuICAgIHZhciBkZWZzID0gY3VycmVudFZpZXdbVFZJRVddLmRhdGE7XG4gICAgaWYgKGRlZnMpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gdE5vZGUuZmxhZ3M7XG4gICAgICAgIHZhciBjb3VudCA9IGZsYWdzICYgNDA5NSAvKiBEaXJlY3RpdmVDb3VudE1hc2sgKi87XG4gICAgICAgIHZhciBzdGFydCA9IGZsYWdzID4+IDE1IC8qIERpcmVjdGl2ZVN0YXJ0aW5nSW5kZXhTaGlmdCAqLztcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgICAgIGlmIChkZWYudHlwZSA9PT0gdHlwZSAmJiBkZWYuZGlQdWJsaWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFRPRE86IFwicmVhZFwiIHNob3VsZCBiZSBhbiBBYnN0cmFjdFR5cGUgKEZXLTQ4NilcbmZ1bmN0aW9uIHF1ZXJ5UmVhZCh0Tm9kZSwgY3VycmVudFZpZXcsIHJlYWQpIHtcbiAgICB2YXIgZmFjdG9yeUZuID0gcmVhZFtOR19FTEVNRU5UX0lEXTtcbiAgICBpZiAodHlwZW9mIGZhY3RvcnlGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFjdG9yeUZuKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbWF0Y2hpbmdJZHggPSBnZXRJZHhPZk1hdGNoaW5nRGlyZWN0aXZlKHROb2RlLCBjdXJyZW50VmlldywgcmVhZCk7XG4gICAgICAgIGlmIChtYXRjaGluZ0lkeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWaWV3W21hdGNoaW5nSWR4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmVhZEJ5VE5vZGVUeXBlKHROb2RlLCBjdXJyZW50Vmlldykge1xuICAgIGlmICh0Tm9kZS50eXBlID09PSAzIC8qIEVsZW1lbnQgKi8gfHwgdE5vZGUudHlwZSA9PT0gNCAvKiBFbGVtZW50Q29udGFpbmVyICovKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50UmVmKEVsZW1lbnRSZWYsIHROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgfVxuICAgIGlmICh0Tm9kZS50eXBlID09PSAwIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICByZXR1cm4gY3JlYXRlVGVtcGxhdGVSZWYoVGVtcGxhdGVSZWYsIEVsZW1lbnRSZWYsIHROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYWRkKHF1ZXJ5LCB0Tm9kZSkge1xuICAgIHZhciBjdXJyZW50VmlldyA9IF9nZXRWaWV3RGF0YSgpO1xuICAgIHdoaWxlIChxdWVyeSkge1xuICAgICAgICB2YXIgcHJlZGljYXRlID0gcXVlcnkucHJlZGljYXRlO1xuICAgICAgICB2YXIgdHlwZSA9IHByZWRpY2F0ZS50eXBlO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgLy8gaWYgcmVhZCB0b2tlbiBhbmQgLyBvciBzdHJhdGVneSBpcyBub3Qgc3BlY2lmaWVkLCB1c2UgdHlwZSBhcyByZWFkIHRva2VuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcXVlcnlSZWFkKHROb2RlLCBjdXJyZW50VmlldywgcHJlZGljYXRlLnJlYWQgfHwgdHlwZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkTWF0Y2gocXVlcnksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBwcmVkaWNhdGUuc2VsZWN0b3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUlkeCA9IGdldElkeE9mTWF0Y2hpbmdTZWxlY3Rvcih0Tm9kZSwgc2VsZWN0b3JbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVJZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUucmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcXVlcnlSZWFkKHROb2RlLCBjdXJyZW50VmlldywgcHJlZGljYXRlLnJlYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZUlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudFZpZXdbZGlyZWN0aXZlSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHJlYWQgdG9rZW4gYW5kIC8gb3Igc3RyYXRlZ3kgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaXQgdXNpbmcgYXBwcm9wcmlhdGUgdE5vZGUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHF1ZXJ5UmVhZEJ5VE5vZGVUeXBlKHROb2RlLCBjdXJyZW50Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTWF0Y2gocXVlcnksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkgPSBxdWVyeS5uZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZE1hdGNoKHF1ZXJ5LCBtYXRjaGluZ1ZhbHVlKSB7XG4gICAgcXVlcnkudmFsdWVzLnB1c2gobWF0Y2hpbmdWYWx1ZSk7XG4gICAgcXVlcnkubGlzdC5zZXREaXJ0eSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlKHByZWRpY2F0ZSwgcmVhZCkge1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcmVkaWNhdGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGlzQXJyYXkgPyBudWxsIDogcHJlZGljYXRlLFxuICAgICAgICBzZWxlY3RvcjogaXNBcnJheSA/IHByZWRpY2F0ZSA6IG51bGwsXG4gICAgICAgIHJlYWQ6IHJlYWRcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUXVlcnkocHJldmlvdXMsIHF1ZXJ5TGlzdCwgcHJlZGljYXRlLCByZWFkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogcHJldmlvdXMsXG4gICAgICAgIGxpc3Q6IHF1ZXJ5TGlzdCxcbiAgICAgICAgcHJlZGljYXRlOiBjcmVhdGVQcmVkaWNhdGUocHJlZGljYXRlLCByZWFkKSxcbiAgICAgICAgdmFsdWVzOiBxdWVyeUxpc3QuX3ZhbHVlc1RyZWUsXG4gICAgICAgIGNvbnRhaW5lclZhbHVlczogbnVsbFxuICAgIH07XG59XG52YXIgUXVlcnlMaXN0XyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeUxpc3RfKCkge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl92YWx1ZXNUcmVlID0gW107XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3RfLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3RfLnByb3RvdHlwZSwgXCJmaXJzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdF8ucHJvdG90eXBlLCBcImxhc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZWVcbiAgICAgKiBbQXJyYXkubWFwXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApXG4gICAgICovXG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl92YWx1ZXMubWFwKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBTZWVcbiAgICAgKiBbQXJyYXkuZmlsdGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpXG4gICAgICovXG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuZmlsdGVyKGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZVxuICAgICAqIFtBcnJheS5maW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kKVxuICAgICAqL1xuICAgIFF1ZXJ5TGlzdF8ucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5maW5kKGZuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZVxuICAgICAqIFtBcnJheS5yZWR1Y2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSlcbiAgICAgKi9cbiAgICBRdWVyeUxpc3RfLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5yZWR1Y2UoZm4sIGluaXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogW0FycmF5LmZvckVhY2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2gpXG4gICAgICovXG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl92YWx1ZXMuZm9yRWFjaChmbik7IH07XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogW0FycmF5LnNvbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWUpXG4gICAgICovXG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLnNvbWUoZm4pO1xuICAgIH07XG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlcy5zbGljZSgwKTsgfTtcbiAgICBRdWVyeUxpc3RfLnByb3RvdHlwZVtnZXRTeW1ib2xJdGVyYXRvcigpXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tnZXRTeW1ib2xJdGVyYXRvcigpXSgpOyB9O1xuICAgIFF1ZXJ5TGlzdF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzLnRvU3RyaW5nKCk7IH07XG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IGZsYXR0ZW4ocmVzKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNoYW5nZXMuZW1pdCh0aGlzKTsgfTtcbiAgICBRdWVyeUxpc3RfLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXJ0eSA9IHRydWU7IH07XG4gICAgUXVlcnlMaXN0Xy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXJ5TGlzdF87XG59KCkpO1xudmFyIFF1ZXJ5TGlzdCA9IFF1ZXJ5TGlzdF87XG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBRdWVyeUxpc3QuXG4gKlxuICogQHBhcmFtIG1lbW9yeUluZGV4IFRoZSBpbmRleCBpbiBtZW1vcnkgd2hlcmUgdGhlIFF1ZXJ5TGlzdCBzaG91bGQgYmUgc2F2ZWQuIElmIG51bGwsXG4gKiB0aGlzIGlzIGlzIGEgY29udGVudCBxdWVyeSBhbmQgdGhlIFF1ZXJ5TGlzdCB3aWxsIGJlIHNhdmVkIGxhdGVyIHRocm91Z2ggZGlyZWN0aXZlQ3JlYXRlLlxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgdHlwZSBmb3Igd2hpY2ggdGhlIHF1ZXJ5IHdpbGwgc2VhcmNoXG4gKiBAcGFyYW0gZGVzY2VuZCBXaGV0aGVyIG9yIG5vdCB0byBkZXNjZW5kIGludG8gY2hpbGRyZW5cbiAqIEBwYXJhbSByZWFkIFdoYXQgdG8gc2F2ZSBpbiB0aGUgcXVlcnlcbiAqIEByZXR1cm5zIFF1ZXJ5TGlzdDxUPlxuICovXG5mdW5jdGlvbiBxdWVyeShtZW1vcnlJbmRleCwgcHJlZGljYXRlLCBkZXNjZW5kLCBcbi8vIFRPRE86IFwicmVhZFwiIHNob3VsZCBiZSBhbiBBYnN0cmFjdFR5cGUgKEZXLTQ4NilcbnJlYWQpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0UHJldmlvdXNJc1BhcmVudCgpO1xuICAgIHZhciBxdWVyeUxpc3QgPSBuZXcgUXVlcnlMaXN0KCk7XG4gICAgdmFyIHF1ZXJpZXMgPSBnZXRPckNyZWF0ZUN1cnJlbnRRdWVyaWVzKExRdWVyaWVzXyk7XG4gICAgcXVlcmllcy50cmFjayhxdWVyeUxpc3QsIHByZWRpY2F0ZSwgZGVzY2VuZCwgcmVhZCk7XG4gICAgc3RvcmVDbGVhbnVwV2l0aENvbnRleHQobnVsbCwgcXVlcnlMaXN0LCBxdWVyeUxpc3QuZGVzdHJveSk7XG4gICAgaWYgKG1lbW9yeUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc3RvcmUobWVtb3J5SW5kZXgsIHF1ZXJ5TGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUxpc3Q7XG59XG4vKipcbiAqIFJlZnJlc2hlcyBhIHF1ZXJ5IGJ5IGNvbWJpbmluZyBtYXRjaGVzIGZyb20gYWxsIGFjdGl2ZSB2aWV3cyBhbmQgcmVtb3ZpbmcgbWF0Y2hlcyBmcm9tIGRlbGV0ZWRcbiAqIHZpZXdzLlxuICogUmV0dXJucyB0cnVlIGlmIGEgcXVlcnkgZ290IGRpcnR5IGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5UmVmcmVzaChxdWVyeUxpc3QpIHtcbiAgICB2YXIgcXVlcnlMaXN0SW1wbCA9IHF1ZXJ5TGlzdDtcbiAgICBpZiAocXVlcnlMaXN0LmRpcnR5KSB7XG4gICAgICAgIHF1ZXJ5TGlzdC5yZXNldChxdWVyeUxpc3RJbXBsLl92YWx1ZXNUcmVlKTtcbiAgICAgICAgcXVlcnlMaXN0Lm5vdGlmeU9uQ2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJldHJpZXZlcyBgVGVtcGxhdGVSZWZgIGluc3RhbmNlIGZyb20gYEluamVjdG9yYCB3aGVuIGEgbG9jYWwgcmVmZXJlbmNlIGlzIHBsYWNlZCBvbiB0aGVcbiAqIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVJlZkV4dHJhY3Rvcih0Tm9kZSwgY3VycmVudFZpZXcpIHtcbiAgICByZXR1cm4gY3JlYXRlVGVtcGxhdGVSZWYoVGVtcGxhdGVSZWYsIEVsZW1lbnRSZWYsIHROb2RlLCBjdXJyZW50Vmlldyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJSQU5EID0gJ19fU0FOSVRJWkVSX1RSVVNURURfQlJBTkRfXyc7XG5mdW5jdGlvbiBhbGxvd1Nhbml0aXphdGlvbkJ5cGFzcyh2YWx1ZSwgdHlwZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgJiYgdmFsdWVbQlJBTkRdID09PSB0eXBlKSA/IHRydWUgOiBmYWxzZTtcbn1cbi8qKlxuICogTWFyayBgaHRtbGAgc3RyaW5nIGFzIHRydXN0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3cmFwcyB0aGUgdHJ1c3RlZCBzdHJpbmcgaW4gYFN0cmluZ2AgYW5kIGJyYW5kcyBpdCBpbiBhIHdheSB3aGljaCBtYWtlcyBpdFxuICogcmVjb2duaXphYmxlIHRvIHtAbGluayBodG1sU2FuaXRpemVyfSB0byBiZSB0cnVzdGVkIGltcGxpY2l0bHkuXG4gKlxuICogQHBhcmFtIHRydXN0ZWRIdG1sIGBodG1sYCBzdHJpbmcgd2hpY2ggbmVlZHMgdG8gYmUgaW1wbGljaXRseSB0cnVzdGVkLlxuICogQHJldHVybnMgYSBgaHRtbGAgYFN0cmluZ2Agd2hpY2ggaGFzIGJlZW4gYnJhbmRlZCB0byBiZSBpbXBsaWNpdGx5IHRydXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0SHRtbCh0cnVzdGVkSHRtbCkge1xuICAgIHJldHVybiBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFN0cmluZyh0cnVzdGVkSHRtbCwgXCJIdG1sXCIgLyogSHRtbCAqLyk7XG59XG4vKipcbiAqIE1hcmsgYHN0eWxlYCBzdHJpbmcgYXMgdHJ1c3RlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdyYXBzIHRoZSB0cnVzdGVkIHN0cmluZyBpbiBgU3RyaW5nYCBhbmQgYnJhbmRzIGl0IGluIGEgd2F5IHdoaWNoIG1ha2VzIGl0XG4gKiByZWNvZ25pemFibGUgdG8ge0BsaW5rIHN0eWxlU2FuaXRpemVyfSB0byBiZSB0cnVzdGVkIGltcGxpY2l0bHkuXG4gKlxuICogQHBhcmFtIHRydXN0ZWRTdHlsZSBgc3R5bGVgIHN0cmluZyB3aGljaCBuZWVkcyB0byBiZSBpbXBsaWNpdGx5IHRydXN0ZWQuXG4gKiBAcmV0dXJucyBhIGBzdHlsZWAgYFN0cmluZ2Agd2hpY2ggaGFzIGJlZW4gYnJhbmRlZCB0byBiZSBpbXBsaWNpdGx5IHRydXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0U3R5bGUodHJ1c3RlZFN0eWxlKSB7XG4gICAgcmV0dXJuIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0U3RyaW5nKHRydXN0ZWRTdHlsZSwgXCJTdHlsZVwiIC8qIFN0eWxlICovKTtcbn1cbi8qKlxuICogTWFyayBgc2NyaXB0YCBzdHJpbmcgYXMgdHJ1c3RlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdyYXBzIHRoZSB0cnVzdGVkIHN0cmluZyBpbiBgU3RyaW5nYCBhbmQgYnJhbmRzIGl0IGluIGEgd2F5IHdoaWNoIG1ha2VzIGl0XG4gKiByZWNvZ25pemFibGUgdG8ge0BsaW5rIHNjcmlwdFNhbml0aXplcn0gdG8gYmUgdHJ1c3RlZCBpbXBsaWNpdGx5LlxuICpcbiAqIEBwYXJhbSB0cnVzdGVkU2NyaXB0IGBzY3JpcHRgIHN0cmluZyB3aGljaCBuZWVkcyB0byBiZSBpbXBsaWNpdGx5IHRydXN0ZWQuXG4gKiBAcmV0dXJucyBhIGBzY3JpcHRgIGBTdHJpbmdgIHdoaWNoIGhhcyBiZWVuIGJyYW5kZWQgdG8gYmUgaW1wbGljaXRseSB0cnVzdGVkLlxuICovXG5mdW5jdGlvbiBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFNjcmlwdCh0cnVzdGVkU2NyaXB0KSB7XG4gICAgcmV0dXJuIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0U3RyaW5nKHRydXN0ZWRTY3JpcHQsIFwiU2NyaXB0XCIgLyogU2NyaXB0ICovKTtcbn1cbi8qKlxuICogTWFyayBgdXJsYCBzdHJpbmcgYXMgdHJ1c3RlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdyYXBzIHRoZSB0cnVzdGVkIHN0cmluZyBpbiBgU3RyaW5nYCBhbmQgYnJhbmRzIGl0IGluIGEgd2F5IHdoaWNoIG1ha2VzIGl0XG4gKiByZWNvZ25pemFibGUgdG8ge0BsaW5rIHVybFNhbml0aXplcn0gdG8gYmUgdHJ1c3RlZCBpbXBsaWNpdGx5LlxuICpcbiAqIEBwYXJhbSB0cnVzdGVkVXJsIGB1cmxgIHN0cmluZyB3aGljaCBuZWVkcyB0byBiZSBpbXBsaWNpdGx5IHRydXN0ZWQuXG4gKiBAcmV0dXJucyBhIGB1cmxgIGBTdHJpbmdgIHdoaWNoIGhhcyBiZWVuIGJyYW5kZWQgdG8gYmUgaW1wbGljaXRseSB0cnVzdGVkLlxuICovXG5mdW5jdGlvbiBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFVybCh0cnVzdGVkVXJsKSB7XG4gICAgcmV0dXJuIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0U3RyaW5nKHRydXN0ZWRVcmwsIFwiVXJsXCIgLyogVXJsICovKTtcbn1cbi8qKlxuICogTWFyayBgdXJsYCBzdHJpbmcgYXMgdHJ1c3RlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdyYXBzIHRoZSB0cnVzdGVkIHN0cmluZyBpbiBgU3RyaW5nYCBhbmQgYnJhbmRzIGl0IGluIGEgd2F5IHdoaWNoIG1ha2VzIGl0XG4gKiByZWNvZ25pemFibGUgdG8ge0BsaW5rIHJlc291cmNlVXJsU2FuaXRpemVyfSB0byBiZSB0cnVzdGVkIGltcGxpY2l0bHkuXG4gKlxuICogQHBhcmFtIHRydXN0ZWRSZXNvdXJjZVVybCBgdXJsYCBzdHJpbmcgd2hpY2ggbmVlZHMgdG8gYmUgaW1wbGljaXRseSB0cnVzdGVkLlxuICogQHJldHVybnMgYSBgdXJsYCBgU3RyaW5nYCB3aGljaCBoYXMgYmVlbiBicmFuZGVkIHRvIGJlIGltcGxpY2l0bHkgdHJ1c3RlZC5cbiAqL1xuZnVuY3Rpb24gYnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RSZXNvdXJjZVVybCh0cnVzdGVkUmVzb3VyY2VVcmwpIHtcbiAgICByZXR1cm4gYnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTdHJpbmcodHJ1c3RlZFJlc291cmNlVXJsLCBcIlJlc291cmNlVXJsXCIgLyogUmVzb3VyY2VVcmwgKi8pO1xufVxuZnVuY3Rpb24gYnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTdHJpbmcodHJ1c3RlZFN0cmluZywgbW9kZSkge1xuICAgIHZhciB0cnVzdGVkID0gbmV3IFN0cmluZyh0cnVzdGVkU3RyaW5nKTtcbiAgICB0cnVzdGVkW0JSQU5EXSA9IG1vZGU7XG4gICAgcmV0dXJuIHRydXN0ZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgdG8gY29udHJvbCBpZiB0aGUgZGVmYXVsdCByZW5kZXJpbmcgcGlwZWxpbmUgc2hvdWxkIGJlIGBWaWV3RW5naW5lYCBvciBgSXZ5YC5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gcnVuIGFuZCBkZWJ1ZyB0ZXN0cyB3aXRoIGVpdGhlciBJdnkgb3IgVmlldyBFbmdpbmUgKGxlZ2FjeSksXG4gKiBwbGVhc2Ugc2VlIFtCQVpFTC5tZF0oLi9kb2NzL0JBWkVMLm1kKS5cbiAqL1xudmFyIF9kZXZNb2RlID0gdHJ1ZTtcbnZhciBfcnVuTW9kZUxvY2tlZCA9IGZhbHNlO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgQW5ndWxhciBpcyBpbiBkZXZlbG9wbWVudCBtb2RlLiBBZnRlciBjYWxsZWQgb25jZSxcbiAqIHRoZSB2YWx1ZSBpcyBsb2NrZWQgYW5kIHdvbid0IGNoYW5nZSBhbnkgbW9yZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRydWUsIHVubGVzcyBhIHVzZXIgY2FsbHMgYGVuYWJsZVByb2RNb2RlYCBiZWZvcmUgY2FsbGluZyB0aGlzLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gaXNEZXZNb2RlKCkge1xuICAgIF9ydW5Nb2RlTG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Rldk1vZGU7XG59XG4vKipcbiAqIERpc2FibGUgQW5ndWxhcidzIGRldmVsb3BtZW50IG1vZGUsIHdoaWNoIHR1cm5zIG9mZiBhc3NlcnRpb25zIGFuZCBvdGhlclxuICogY2hlY2tzIHdpdGhpbiB0aGUgZnJhbWV3b3JrLlxuICpcbiAqIE9uZSBpbXBvcnRhbnQgYXNzZXJ0aW9uIHRoaXMgZGlzYWJsZXMgdmVyaWZpZXMgdGhhdCBhIGNoYW5nZSBkZXRlY3Rpb24gcGFzc1xuICogZG9lcyBub3QgcmVzdWx0IGluIGFkZGl0aW9uYWwgY2hhbmdlcyB0byBhbnkgYmluZGluZ3MgKGFsc28ga25vd24gYXNcbiAqIHVuaWRpcmVjdGlvbmFsIGRhdGEgZmxvdykuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICBpZiAoX3J1bk1vZGVMb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5hYmxlIHByb2QgbW9kZSBhZnRlciBwbGF0Zm9ybSBzZXR1cC4nKTtcbiAgICB9XG4gICAgX2Rldk1vZGUgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBpcyB1c2VkIHRvIGdldCBob2xkIG9mIGFuIGluZXJ0IHRyZWUgb2YgRE9NIGVsZW1lbnRzIGNvbnRhaW5pbmcgZGlydHkgSFRNTFxuICogdGhhdCBuZWVkcyBzYW5pdGl6aW5nLlxuICogRGVwZW5kaW5nIHVwb24gYnJvd3NlciBzdXBwb3J0IHdlIG11c3QgdXNlIG9uZSBvZiB0aHJlZSBzdHJhdGVnaWVzIGZvciBkb2luZyB0aGlzLlxuICogU3VwcG9ydDogU2FmYXJpIDEwLnggLT4gWEhSIHN0cmF0ZWd5XG4gKiBTdXBwb3J0OiBGaXJlZm94IC0+IERvbVBhcnNlciBzdHJhdGVneVxuICogRGVmYXVsdDogSW5lcnREb2N1bWVudCBzdHJhdGVneVxuICovXG52YXIgSW5lcnRCb2R5SGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZXJ0Qm9keUhlbHBlcihkZWZhdWx0RG9jKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdERvYyA9IGRlZmF1bHREb2M7XG4gICAgICAgIHRoaXMuaW5lcnREb2N1bWVudCA9IHRoaXMuZGVmYXVsdERvYy5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3Nhbml0aXphdGlvbi1pbmVydCcpO1xuICAgICAgICB0aGlzLmluZXJ0Qm9keUVsZW1lbnQgPSB0aGlzLmluZXJ0RG9jdW1lbnQuYm9keTtcbiAgICAgICAgaWYgKHRoaXMuaW5lcnRCb2R5RWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1c3VhbGx5IHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBib2R5IGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50LCBidXQgSUUgZG9lc24ndCBoYXZlIGFueSwgc29cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIG9uZS5cbiAgICAgICAgICAgIHZhciBpbmVydEh0bWwgPSB0aGlzLmluZXJ0RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHRtbCcpO1xuICAgICAgICAgICAgdGhpcy5pbmVydERvY3VtZW50LmFwcGVuZENoaWxkKGluZXJ0SHRtbCk7XG4gICAgICAgICAgICB0aGlzLmluZXJ0Qm9keUVsZW1lbnQgPSB0aGlzLmluZXJ0RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgICAgICAgICAgaW5lcnRIdG1sLmFwcGVuZENoaWxkKHRoaXMuaW5lcnRCb2R5RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmVydEJvZHlFbGVtZW50LmlubmVySFRNTCA9ICc8c3ZnPjxnIG9ubG9hZD1cInRoaXMucGFyZW50Tm9kZS5yZW1vdmUoKVwiPjwvZz48L3N2Zz4nO1xuICAgICAgICBpZiAodGhpcy5pbmVydEJvZHlFbGVtZW50LnF1ZXJ5U2VsZWN0b3IgJiYgIXRoaXMuaW5lcnRCb2R5RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzdmcnKSkge1xuICAgICAgICAgICAgLy8gV2UganVzdCBoaXQgdGhlIFNhZmFyaSAxMC4xIGJ1ZyAtIHdoaWNoIGFsbG93cyBKUyB0byBydW4gaW5zaWRlIHRoZSBTVkcgRyBlbGVtZW50XG4gICAgICAgICAgICAvLyBzbyB1c2UgdGhlIFhIUiBzdHJhdGVneS5cbiAgICAgICAgICAgIHRoaXMuZ2V0SW5lcnRCb2R5RWxlbWVudCA9IHRoaXMuZ2V0SW5lcnRCb2R5RWxlbWVudF9YSFI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmVydEJvZHlFbGVtZW50LmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPHN2Zz48cD48c3R5bGU+PGltZyBzcmM9XCI8L3N0eWxlPjxpbWcgc3JjPXggb25lcnJvcj1hbGVydCgxKS8vXCI+JztcbiAgICAgICAgaWYgKHRoaXMuaW5lcnRCb2R5RWxlbWVudC5xdWVyeVNlbGVjdG9yICYmIHRoaXMuaW5lcnRCb2R5RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdzdmcgaW1nJykpIHtcbiAgICAgICAgICAgIC8vIFdlIGp1c3QgaGl0IHRoZSBGaXJlZm94IGJ1ZyAtIHdoaWNoIHByZXZlbnRzIHRoZSBpbm5lciBpbWcgSlMgZnJvbSBiZWluZyBzYW5pdGl6ZWRcbiAgICAgICAgICAgIC8vIHNvIHVzZSB0aGUgRE9NUGFyc2VyIHN0cmF0ZWd5LCBpZiBpdCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgdGhlbiB3ZSBhcmUgbm90IGluIEZpcmVmb3ggKFNlcnZlci9XZWJXb3JrZXI/KSBzbyB3ZVxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkZWZhdWx0IHN0cmF0ZWd5IGJlbG93LlxuICAgICAgICAgICAgaWYgKGlzRE9NUGFyc2VyQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEluZXJ0Qm9keUVsZW1lbnQgPSB0aGlzLmdldEluZXJ0Qm9keUVsZW1lbnRfRE9NUGFyc2VyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb25lIG9mIHRoZSBidWdzIHdlcmUgaGl0IHNvIGl0IGlzIHNhZmUgZm9yIHVzIHRvIHVzZSB0aGUgZGVmYXVsdCBJbmVydERvY3VtZW50IHN0cmF0ZWd5XG4gICAgICAgIHRoaXMuZ2V0SW5lcnRCb2R5RWxlbWVudCA9IHRoaXMuZ2V0SW5lcnRCb2R5RWxlbWVudF9JbmVydERvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgWEhSIHRvIGNyZWF0ZSBhbmQgZmlsbCBhbiBpbmVydCBib2R5IGVsZW1lbnQgKG9uIFNhZmFyaSAxMC4xKVxuICAgICAqIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvYTk5MmQzYTc1MDMxY2I4YmIwMzJlNWVhODM5OWJhOTcyYmRmOWE2NS9zcmMvcHVyaWZ5LmpzI0w0MzktTDQ0OVxuICAgICAqL1xuICAgIEluZXJ0Qm9keUhlbHBlci5wcm90b3R5cGUuZ2V0SW5lcnRCb2R5RWxlbWVudF9YSFIgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlc2UgZXh0cmEgZWxlbWVudHMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgaXMgcGFyc2VkIGFzIGV4cGVjdGVkXG4gICAgICAgIC8vIGUuZy4gbGVhZGluZyB3aGl0ZXNwYWNlIGlzIG1haW50YWluZWQgYW5kIHRhZ3MgbGlrZSBgPG1ldGE+YCBkbyBub3QgZ2V0IGhvaXN0ZWQgdG8gdGhlXG4gICAgICAgIC8vIGA8aGVhZD5gIHRhZy5cbiAgICAgICAgaHRtbCA9ICc8Ym9keT48cmVtb3ZlPjwvcmVtb3ZlPicgKyBodG1sICsgJzwvYm9keT4nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaHRtbCA9IGVuY29kZVVSSShodG1sKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2RvY3VtZW50JztcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsICdkYXRhOnRleHQvaHRtbDtjaGFyc2V0PXV0Zi04LCcgKyBodG1sLCBmYWxzZSk7XG4gICAgICAgIHhoci5zZW5kKHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBib2R5ID0geGhyLnJlc3BvbnNlLmJvZHk7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgRE9NUGFyc2VyIHRvIGNyZWF0ZSBhbmQgZmlsbCBhbiBpbmVydCBib2R5IGVsZW1lbnQgKG9uIEZpcmVmb3gpXG4gICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L3JlbGVhc2VzL3RhZy8wLjYuN1xuICAgICAqXG4gICAgICovXG4gICAgSW5lcnRCb2R5SGVscGVyLnByb3RvdHlwZS5nZXRJbmVydEJvZHlFbGVtZW50X0RPTVBhcnNlciA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGVzZSBleHRyYSBlbGVtZW50cyB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBpcyBwYXJzZWQgYXMgZXhwZWN0ZWRcbiAgICAgICAgLy8gZS5nLiBsZWFkaW5nIHdoaXRlc3BhY2UgaXMgbWFpbnRhaW5lZCBhbmQgdGFncyBsaWtlIGA8bWV0YT5gIGRvIG5vdCBnZXQgaG9pc3RlZCB0byB0aGVcbiAgICAgICAgLy8gYDxoZWFkPmAgdGFnLlxuICAgICAgICBodG1sID0gJzxib2R5PjxyZW1vdmU+PC9yZW1vdmU+JyArIGh0bWwgKyAnPC9ib2R5Pic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyB3aW5kb3dcbiAgICAgICAgICAgICAgICAuRE9NUGFyc2VyKClcbiAgICAgICAgICAgICAgICAucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKVxuICAgICAgICAgICAgICAgIC5ib2R5O1xuICAgICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgYW4gSFRNTDUgYHRlbXBsYXRlYCBlbGVtZW50LCBpZiBzdXBwb3J0ZWQsIG9yIGFuIGluZXJ0IGJvZHkgZWxlbWVudCBjcmVhdGVkIHZpYVxuICAgICAqIGBjcmVhdGVIdG1sRG9jdW1lbnRgIHRvIGNyZWF0ZSBhbmQgZmlsbCBhbiBpbmVydCBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IHNhbmUgc3RyYXRlZ3kgdG8gdXNlIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHJlcXVpcmUgb25lIG9mIHRoZSBzcGVjaWFsaXNlZFxuICAgICAqIHN0cmF0ZWdpZXMgYWJvdmUuXG4gICAgICovXG4gICAgSW5lcnRCb2R5SGVscGVyLnByb3RvdHlwZS5nZXRJbmVydEJvZHlFbGVtZW50X0luZXJ0RG9jdW1lbnQgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAvLyBQcmVmZXIgdXNpbmcgPHRlbXBsYXRlPiBlbGVtZW50IGlmIHN1cHBvcnRlZC5cbiAgICAgICAgdmFyIHRlbXBsYXRlRWwgPSB0aGlzLmluZXJ0RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKCdjb250ZW50JyBpbiB0ZW1wbGF0ZUVsKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVFbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOS0xMSBvbmx5XG4gICAgICAgIC8vIHN0cmlwIGN1c3RvbS1uYW1lc3BhY2VkIGF0dHJpYnV0ZXMgb24gSUU8PTExXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHREb2MuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlwQ3VzdG9tTnNBdHRycyh0aGlzLmluZXJ0Qm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZXJ0Qm9keUVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIElFOS0xMSBjb21lcyBhY3Jvc3MgYW4gdW5rbm93biBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBlLmcuICd4bGluazpmb28nIGl0IGFkZHMgJ3htbG5zOm5zMSdcbiAgICAgKiBhdHRyaWJ1dGUgdG8gZGVjbGFyZSBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy5cbiAgICAgKiAnbnMxOnhsaW5rOmZvbycpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2RcbiAgICAgKiBzdHJpcHMgdGhlbSBhbGwuXG4gICAgICovXG4gICAgSW5lcnRCb2R5SGVscGVyLnByb3RvdHlwZS5zdHJpcEN1c3RvbU5zQXR0cnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGVsQXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuICAgICAgICAvLyBsb29wIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiBzdXBwb3J0IHJlbW92YWxzLlxuICAgICAgICBmb3IgKHZhciBpID0gZWxBdHRycy5sZW5ndGggLSAxOyAwIDwgaTsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmliID0gZWxBdHRycy5pdGVtKGkpO1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0cmliLm5hbWU7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICd4bWxuczpuczEnIHx8IGF0dHJOYW1lLmluZGV4T2YoJ25zMTonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaXBDdXN0b21Oc0F0dHJzKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmVydEJvZHlIZWxwZXI7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBET01QYXJzZXIgZXhpc3RzIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAqIFRoZSB0cnktY2F0Y2ggaXMgYmVjYXVzZSwgb24gc29tZSBicm93c2VycywgdHJ5aW5nIHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5XG4gKiBvbiB3aW5kb3cgY2FuIGFjdHVhbGx5IHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBzdXBwcmVzcyB7dXNlbGVzc0NvZGV9XG4gKi9cbmZ1bmN0aW9uIGlzRE9NUGFyc2VyQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIXdpbmRvdy5ET01QYXJzZXI7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxuICpcbiAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgYSBzdWJzZXQgb2YgVVJMcyB0aGF0IHdpbGwgbm90IGNhdXNlIHNjcmlwdFxuICogZXhlY3V0aW9uIGlmIHVzZWQgaW4gVVJMIGNvbnRleHQgd2l0aGluIGEgSFRNTCBkb2N1bWVudC4gU3BlY2lmaWNhbGx5LCB0aGlzXG4gKiByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hlcyBpZiAoY29tbWVudCBmcm9tIGhlcmUgb24gYW5kIHJlZ2V4IGNvcGllZCBmcm9tXG4gKiBTb3kncyBFc2NhcGluZ0NvbnZlbnRpb25zKTpcbiAqICgxKSBFaXRoZXIgYSBwcm90b2NvbCBpbiBhIHdoaXRlbGlzdCAoaHR0cCwgaHR0cHMsIG1haWx0byBvciBmdHApLlxuICogKDIpIG9yIG5vIHByb3RvY29sLiAgQSBwcm90b2NvbCBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgY29sb24uIFRoZSBiZWxvd1xuICogICAgIGFsbG93cyB0aGF0IGJ5IGFsbG93aW5nIGNvbG9ucyBvbmx5IGFmdGVyIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBbLz8jXS5cbiAqICAgICBBIGNvbG9uIGFmdGVyIGEgaGFzaCAoIykgbXVzdCBiZSBpbiB0aGUgZnJhZ21lbnQuXG4gKiAgICAgT3RoZXJ3aXNlLCBhIGNvbG9uIGFmdGVyIGEgKD8pIG11c3QgYmUgaW4gYSBxdWVyeS5cbiAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBzaW5nbGUgc29saWR1cyAoLykgbXVzdCBiZSBpbiBhIHBhdGguXG4gKiAgICAgT3RoZXJ3aXNlLCBhIGNvbG9uIGFmdGVyIGEgZG91YmxlIHNvbGlkdXMgKC8vKSBtdXN0IGJlIGluIHRoZSBhdXRob3JpdHlcbiAqICAgICAoYmVmb3JlIHBvcnQpLlxuICpcbiAqIFRoZSBwYXR0ZXJuIGRpc2FsbG93cyAmLCB1c2VkIGluIEhUTUwgZW50aXR5IGRlY2xhcmF0aW9ucyBiZWZvcmVcbiAqIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBpbiBbLz8jXS4gVGhpcyBkaXNhbGxvd3MgSFRNTCBlbnRpdGllcyB1c2VkIGluIHRoZVxuICogcHJvdG9jb2wgbmFtZSwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiwgZS5nLiBcImgmIzExNjt0cFwiIGZvciBcImh0dHBcIi5cbiAqIEl0IGFsc28gZGlzYWxsb3dzIEhUTUwgZW50aXRpZXMgaW4gdGhlIGZpcnN0IHBhdGggcGFydCBvZiBhIHJlbGF0aXZlIHBhdGgsXG4gKiBlLmcuIFwiZm9vJmx0O2Jhci9iYXpcIi4gIE91ciBleGlzdGluZyBlc2NhcGluZyBmdW5jdGlvbnMgc2hvdWxkIG5vdCBwcm9kdWNlXG4gKiB0aGF0LiBNb3JlIGltcG9ydGFudGx5LCBpdCBkaXNhbGxvd3MgbWFza2luZyBvZiBhIGNvbG9uLFxuICogZS5nLiBcImphdmFzY3JpcHQmIzU4Oy4uLlwiLlxuICpcbiAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICovXG52YXIgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGUpOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvZ2k7XG4vKiogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuICovXG52YXIgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFthLXowLTkrXFwvXSs9KiQvaTtcbmZ1bmN0aW9uIF9zYW5pdGl6ZVVybCh1cmwpIHtcbiAgICB1cmwgPSBTdHJpbmcodXJsKTtcbiAgICBpZiAodXJsLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IHVybC5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogc2FuaXRpemluZyB1bnNhZmUgVVJMIHZhbHVlIFwiICsgdXJsICsgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gJ3Vuc2FmZTonICsgdXJsO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTcmNzZXQoc3Jjc2V0KSB7XG4gICAgc3Jjc2V0ID0gU3RyaW5nKHNyY3NldCk7XG4gICAgcmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoc3Jjc2V0KSB7IHJldHVybiBfc2FuaXRpemVVcmwoc3Jjc2V0LnRyaW0oKSk7IH0pLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHRhZ1NldCh0YWdzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGFncy5zcGxpdCgnLCcpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHJlc1t0XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBtZXJnZSQxKCkge1xuICAgIHZhciBzZXRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc2V0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZV8yLCBfYTtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgc2V0c18xID0gX192YWx1ZXMoc2V0cyksIHNldHNfMV8xID0gc2V0c18xLm5leHQoKTsgIXNldHNfMV8xLmRvbmU7IHNldHNfMV8xID0gc2V0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBzZXRzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChzLmhhc093blByb3BlcnR5KHYpKVxuICAgICAgICAgICAgICAgICAgICByZXNbdl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2V0c18xXzEgJiYgIXNldHNfMV8xLmRvbmUgJiYgKF9hID0gc2V0c18xLnJldHVybikpIF9hLmNhbGwoc2V0c18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBHb29kIHNvdXJjZSBvZiBpbmZvIGFib3V0IGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzXG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjc2VtYW50aWNzXG4vLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcbi8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xudmFyIFZPSURfRUxFTUVOVFMgPSB0YWdTZXQoJ2FyZWEsYnIsY29sLGhyLGltZyx3YnInKTtcbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlbiAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjb3B0aW9uYWwtdGFnc1xudmFyIE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMgPSB0YWdTZXQoJ2NvbGdyb3VwLGRkLGR0LGxpLHAsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHInKTtcbnZhciBPUFRJT05BTF9FTkRfVEFHX0lOTElORV9FTEVNRU5UUyA9IHRhZ1NldCgncnAscnQnKTtcbnZhciBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTID0gbWVyZ2UkMShPUFRJT05BTF9FTkRfVEFHX0lOTElORV9FTEVNRU5UUywgT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUyk7XG4vLyBTYWZlIEJsb2NrIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBCTE9DS19FTEVNRU5UUyA9IG1lcmdlJDEoT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUywgdGFnU2V0KCdhZGRyZXNzLGFydGljbGUsJyArXG4gICAgJ2FzaWRlLGJsb2NrcXVvdGUsY2FwdGlvbixjZW50ZXIsZGVsLGRldGFpbHMsZGlhbG9nLGRpcixkaXYsZGwsZmlndXJlLGZpZ2NhcHRpb24sZm9vdGVyLGgxLGgyLGgzLGg0LGg1LCcgK1xuICAgICdoNixoZWFkZXIsaGdyb3VwLGhyLGlucyxtYWluLG1hcCxtZW51LG5hdixvbCxwcmUsc2VjdGlvbixzdW1tYXJ5LHRhYmxlLHVsJykpO1xuLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBJTkxJTkVfRUxFTUVOVFMgPSBtZXJnZSQxKE9QVElPTkFMX0VORF9UQUdfSU5MSU5FX0VMRU1FTlRTLCB0YWdTZXQoJ2EsYWJicixhY3JvbnltLGF1ZGlvLGIsJyArXG4gICAgJ2JkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxwaWN0dXJlLHEscnVieSxycCxydCxzLCcgK1xuICAgICdzYW1wLHNtYWxsLHNvdXJjZSxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0aW1lLHRyYWNrLHR0LHUsdmFyLHZpZGVvJykpO1xudmFyIFZBTElEX0VMRU1FTlRTID0gbWVyZ2UkMShWT0lEX0VMRU1FTlRTLCBCTE9DS19FTEVNRU5UUywgSU5MSU5FX0VMRU1FTlRTLCBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTKTtcbi8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIGhyZWYgYW5kIGhlbmNlIG5lZWQgdG8gYmUgc2FuaXRpemVkXG52YXIgVVJJX0FUVFJTID0gdGFnU2V0KCdiYWNrZ3JvdW5kLGNpdGUsaHJlZixpdGVtdHlwZSxsb25nZGVzYyxwb3N0ZXIsc3JjLHhsaW5rOmhyZWYnKTtcbi8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIHNwZWNpYWwgaHJlZiBzZXQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbnZhciBTUkNTRVRfQVRUUlMgPSB0YWdTZXQoJ3NyY3NldCcpO1xudmFyIEhUTUxfQVRUUlMgPSB0YWdTZXQoJ2FiYnIsYWNjZXNza2V5LGFsaWduLGFsdCxhdXRvcGxheSxheGlzLGJnY29sb3IsYm9yZGVyLGNlbGxwYWRkaW5nLGNlbGxzcGFjaW5nLGNsYXNzLGNsZWFyLGNvbG9yLGNvbHMsY29sc3BhbiwnICtcbiAgICAnY29tcGFjdCxjb250cm9scyxjb29yZHMsZGF0ZXRpbWUsZGVmYXVsdCxkaXIsZG93bmxvYWQsZmFjZSxoZWFkZXJzLGhlaWdodCxoaWRkZW4saHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICdpc21hcCxpdGVtc2NvcGUsaXRlbXByb3Asa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvb3AsbWVkaWEsbXV0ZWQsbm9ocmVmLG5vd3JhcCxvcGVuLHByZWxvYWQscmVsLHJldixyb2xlLHJvd3Mscm93c3BhbixydWxlcywnICtcbiAgICAnc2NvcGUsc2Nyb2xsaW5nLHNoYXBlLHNpemUsc2l6ZXMsc3BhbixzcmNsYW5nLHN0YXJ0LHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCwnICtcbiAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuLy8gTkI6IFRoaXMgY3VycmVudGx5IGNvbnNjaW91c2x5IGRvZXNuJ3Qgc3VwcG9ydCBTVkcuIFNWRyBzYW5pdGl6YXRpb24gaGFzIGhhZCBzZXZlcmFsIHNlY3VyaXR5XG4vLyBpc3N1ZXMgaW4gdGhlIHBhc3QsIHNvIGl0IHNlZW1zIHNhZmVyIHRvIGxlYXZlIGl0IG91dCBpZiBwb3NzaWJsZS4gSWYgc3VwcG9ydCBmb3IgYmluZGluZyBTVkcgdmlhXG4vLyBpbm5lckhUTUwgaXMgcmVxdWlyZWQsIFNWRyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhZGRlZCBoZXJlLlxuLy8gTkI6IFNhbml0aXphdGlvbiBkb2VzIG5vdCBhbGxvdyA8Zm9ybT4gZWxlbWVudHMgb3Igb3RoZXIgYWN0aXZlIGVsZW1lbnRzICg8YnV0dG9uPiBldGMpLiBUaG9zZVxuLy8gY2FuIGJlIHNhbml0aXplZCwgYnV0IHRoZXkgaW5jcmVhc2Ugc2VjdXJpdHkgc3VyZmFjZSBhcmVhIHdpdGhvdXQgYSBsZWdpdGltYXRlIHVzZSBjYXNlLCBzbyB0aGV5XG4vLyBhcmUgbGVmdCBvdXQgaGVyZS5cbnZhciBWQUxJRF9BVFRSUyA9IG1lcmdlJDEoVVJJX0FUVFJTLCBTUkNTRVRfQVRUUlMsIEhUTUxfQVRUUlMpO1xuLyoqXG4gKiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgc2VyaWFsaXplcyBhIERPTSBmcmFnbWVudCwgc3RyaXBwaW5nIG91dCBhbnkgdW5zYWZlIGVsZW1lbnRzIGFuZCB1bnNhZmVcbiAqIGF0dHJpYnV0ZXMuXG4gKi9cbnZhciBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyKCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHRyYWNrIGlmIHNvbWV0aGluZyB3YXMgc3RyaXBwZWQsIHRvIGF2b2lkIGFjY2lkZW50YWxseSB3YXJuaW5nIG9mIHNhbml0aXphdGlvbiBqdXN0XG4gICAgICAgIC8vIGJlY2F1c2UgY2hhcmFjdGVycyB3ZXJlIHJlLWVuY29kZWQuXG4gICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgfVxuICAgIFNhbml0aXppbmdIdG1sU2VyaWFsaXplci5wcm90b3R5cGUuc2FuaXRpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCB1c2UgYSBUcmVlV2Fsa2VyLCBhcyBpdCBoYXMgdG8gcnVuIG9uIEFuZ3VsYXIncyB2YXJpb3VzIERPTSBhZGFwdGVycy5cbiAgICAgICAgLy8gSG93ZXZlciB0aGlzIGNvZGUgbmV2ZXIgYWNjZXNzZXMgcHJvcGVydGllcyBvZmYgb2YgYGRvY3VtZW50YCBiZWZvcmUgZGVsZXRpbmcgaXRzIGNvbnRlbnRzXG4gICAgICAgIC8vIGFnYWluLCBzbyBpdCBzaG91bGRuJ3QgYmUgdnVsbmVyYWJsZSB0byBET00gY2xvYmJlcmluZy5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEVsZW1lbnQoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhcnMoY3VycmVudC5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbm9uLWVsZW1lbnQsIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBMZWF2aW5nIHRoZSBlbGVtZW50LiBXYWxrIHVwIGFuZCB0byB0aGUgcmlnaHQsIGNsb3NpbmcgdGFncyBhcyB3ZSBnby5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRFbGVtZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuY2hlY2tDbG9iYmVyZWRFbGVtZW50KGN1cnJlbnQsIGN1cnJlbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuY2hlY2tDbG9iYmVyZWRFbGVtZW50KGN1cnJlbnQsIGN1cnJlbnQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLmpvaW4oJycpO1xuICAgIH07XG4gICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zdGFydEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFWQUxJRF9FTEVNRU5UUy5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmLnB1c2goJzwnKTtcbiAgICAgICAgdGhpcy5idWYucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgdmFyIGVsQXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsQXR0ciA9IGVsQXR0cnMuaXRlbShpKTtcbiAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGVsQXR0ci5uYW1lO1xuICAgICAgICAgICAgdmFyIGxvd2VyID0gYXR0ck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghVkFMSURfQVRUUlMuaGFzT3duUHJvcGVydHkobG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZWxBdHRyLnZhbHVlO1xuICAgICAgICAgICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBTcGVjaWFsIGNhc2UgaW1hZ2UgVVJJcyBmb3IgZGF0YTppbWFnZS8uLi5cbiAgICAgICAgICAgIGlmIChVUklfQVRUUlNbbG93ZXJdKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3Nhbml0aXplVXJsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChTUkNTRVRfQVRUUlNbbG93ZXJdKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gc2FuaXRpemVTcmNzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnICcsIGF0dHJOYW1lLCAnPVwiJywgZW5jb2RlRW50aXRpZXModmFsdWUpLCAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc+Jyk7XG4gICAgfTtcbiAgICBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIucHJvdG90eXBlLmVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGN1cnJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFZBTElEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpICYmICFWT0lEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc8LycpO1xuICAgICAgICAgICAgdGhpcy5idWYucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJz4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5jaGFycyA9IGZ1bmN0aW9uIChjaGFycykgeyB0aGlzLmJ1Zi5wdXNoKGVuY29kZUVudGl0aWVzKGNoYXJzKSk7IH07XG4gICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5jaGVja0Nsb2JiZXJlZEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbmV4dE5vZGUpIHtcbiAgICAgICAgaWYgKG5leHROb2RlICYmXG4gICAgICAgICAgICAobm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0Tm9kZSkgJlxuICAgICAgICAgICAgICAgIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSA9PT0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzYW5pdGl6ZSBodG1sIGJlY2F1c2UgdGhlIGVsZW1lbnQgaXMgY2xvYmJlcmVkOiBcIiArIG5vZGUub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyO1xufSgpKTtcbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIFNVUlJPR0FURV9QQUlSX1JFR0VYUCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG4vLyAhIHRvIH4gaXMgdGhlIEFTQ0lJIHJhbmdlLlxudmFyIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+IHwhXSkvZztcbi8qKlxuICogRXNjYXBlcyBhbGwgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnMsIHNvIHRoYXQgdGhlXG4gKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAqIGVsZW1lbnQgdGV4dC5cbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVFbnRpdGllcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHZhciBoaSA9IG1hdGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBsb3cgPSBtYXRjaC5jaGFyQ29kZUF0KDEpO1xuICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgfSlcbiAgICAgICAgLnJlcGxhY2UoTk9OX0FMUEhBTlVNRVJJQ19SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gJyYjJyArIG1hdGNoLmNoYXJDb2RlQXQoMCkgKyAnOyc7IH0pXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cbnZhciBpbmVydEJvZHlIZWxwZXI7XG4vKipcbiAqIFNhbml0aXplcyB0aGUgZ2l2ZW4gdW5zYWZlLCB1bnRydXN0ZWQgSFRNTCBmcmFnbWVudCwgYW5kIHJldHVybnMgSFRNTCB0ZXh0IHRoYXQgaXMgc2FmZSB0byBhZGQgdG9cbiAqIHRoZSBET00gaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICovXG5mdW5jdGlvbiBfc2FuaXRpemVIdG1sKGRlZmF1bHREb2MsIHVuc2FmZUh0bWxJbnB1dCkge1xuICAgIHZhciBpbmVydEJvZHlFbGVtZW50ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBpbmVydEJvZHlIZWxwZXIgPSBpbmVydEJvZHlIZWxwZXIgfHwgbmV3IEluZXJ0Qm9keUhlbHBlcihkZWZhdWx0RG9jKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHVuc2FmZUh0bWwgaXMgYWN0dWFsbHkgYSBzdHJpbmcgKFR5cGVTY3JpcHQgdHlwZXMgYXJlIG5vdCBlbmZvcmNlZCBhdCBydW50aW1lKS5cbiAgICAgICAgdmFyIHVuc2FmZUh0bWwgPSB1bnNhZmVIdG1sSW5wdXQgPyBTdHJpbmcodW5zYWZlSHRtbElucHV0KSA6ICcnO1xuICAgICAgICBpbmVydEJvZHlFbGVtZW50ID0gaW5lcnRCb2R5SGVscGVyLmdldEluZXJ0Qm9keUVsZW1lbnQodW5zYWZlSHRtbCk7XG4gICAgICAgIC8vIG1YU1MgcHJvdGVjdGlvbi4gUmVwZWF0ZWRseSBwYXJzZSB0aGUgZG9jdW1lbnQgdG8gbWFrZSBzdXJlIGl0IHN0YWJpbGl6ZXMsIHNvIHRoYXQgYSBicm93c2VyXG4gICAgICAgIC8vIHRyeWluZyB0byBhdXRvLWNvcnJlY3QgaW5jb3JyZWN0IEhUTUwgY2Fubm90IGNhdXNlIGZvcm1lcmx5IGluZXJ0IEhUTUwgdG8gYmVjb21lIGRhbmdlcm91cy5cbiAgICAgICAgdmFyIG1YU1NBdHRlbXB0cyA9IDU7XG4gICAgICAgIHZhciBwYXJzZWRIdG1sID0gdW5zYWZlSHRtbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG1YU1NBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhbml0aXplIGh0bWwgYmVjYXVzZSB0aGUgaW5wdXQgaXMgdW5zdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1YU1NBdHRlbXB0cy0tO1xuICAgICAgICAgICAgdW5zYWZlSHRtbCA9IHBhcnNlZEh0bWw7XG4gICAgICAgICAgICBwYXJzZWRIdG1sID0gaW5lcnRCb2R5RWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICBpbmVydEJvZHlFbGVtZW50ID0gaW5lcnRCb2R5SGVscGVyLmdldEluZXJ0Qm9keUVsZW1lbnQodW5zYWZlSHRtbCk7XG4gICAgICAgIH0gd2hpbGUgKHVuc2FmZUh0bWwgIT09IHBhcnNlZEh0bWwpO1xuICAgICAgICB2YXIgc2FuaXRpemVyID0gbmV3IFNhbml0aXppbmdIdG1sU2VyaWFsaXplcigpO1xuICAgICAgICB2YXIgc2FmZUh0bWwgPSBzYW5pdGl6ZXIuc2FuaXRpemVDaGlsZHJlbihnZXRUZW1wbGF0ZUNvbnRlbnQoaW5lcnRCb2R5RWxlbWVudCkgfHwgaW5lcnRCb2R5RWxlbWVudCk7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiBzYW5pdGl6ZXIuc2FuaXRpemVkU29tZXRoaW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IHNhbml0aXppbmcgSFRNTCBzdHJpcHBlZCBzb21lIGNvbnRlbnQgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYWZlSHRtbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIEluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZywgY2xlYXIgb3V0IGluZXJ0RWxlbWVudCB0byByZXNldCB0aGUgZW50aXJlIERPTSBzdHJ1Y3R1cmUuXG4gICAgICAgIGlmIChpbmVydEJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBnZXRUZW1wbGF0ZUNvbnRlbnQoaW5lcnRCb2R5RWxlbWVudCkgfHwgaW5lcnRCb2R5RWxlbWVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRfMS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50XzEucmVtb3ZlQ2hpbGQocGFyZW50XzEuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUNvbnRlbnQoZWwpIHtcbiAgICByZXR1cm4gJ2NvbnRlbnQnIGluIGVsIC8qKiBNaWNyb3NvZnQvVHlwZVNjcmlwdCMyMTUxNyAqLyAmJiBpc1RlbXBsYXRlRWxlbWVudChlbCkgP1xuICAgICAgICBlbC5jb250ZW50IDpcbiAgICAgICAgbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVGVtcGxhdGVFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbC5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIFNlY3VyaXR5Q29udGV4dCBtYXJrcyBhIGxvY2F0aW9uIHRoYXQgaGFzIGRhbmdlcm91cyBzZWN1cml0eSBpbXBsaWNhdGlvbnMsIGUuZy4gYSBET00gcHJvcGVydHlcbiAqIGxpa2UgYGlubmVySFRNTGAgdGhhdCBjb3VsZCBjYXVzZSBDcm9zcyBTaXRlIFNjcmlwdGluZyAoWFNTKSBzZWN1cml0eSBidWdzIHdoZW4gaW1wcm9wZXJseVxuICogaGFuZGxlZC5cbiAqXG4gKiBTZWUgRG9tU2FuaXRpemVyIGZvciBtb3JlIGRldGFpbHMgb24gc2VjdXJpdHkgaW4gQW5ndWxhciBhcHBsaWNhdGlvbnMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgU2VjdXJpdHlDb250ZXh0O1xuKGZ1bmN0aW9uIChTZWN1cml0eUNvbnRleHQpIHtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIkhUTUxcIl0gPSAxXSA9IFwiSFRNTFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTVFlMRVwiXSA9IDJdID0gXCJTVFlMRVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlVSTFwiXSA9IDRdID0gXCJVUkxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiUkVTT1VSQ0VfVVJMXCJdID0gNV0gPSBcIlJFU09VUkNFX1VSTFwiO1xufSkoU2VjdXJpdHlDb250ZXh0IHx8IChTZWN1cml0eUNvbnRleHQgPSB7fSkpO1xuLyoqXG4gKiBTYW5pdGl6ZXIgaXMgdXNlZCBieSB0aGUgdmlld3MgdG8gc2FuaXRpemUgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBTYW5pdGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FuaXRpemVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gU2FuaXRpemVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIHNhZmUgc3R5bGUgdmFsdWVzLlxuICpcbiAqIFF1b3RlcyAoXCIgYW5kICcpIGFyZSBhbGxvd2VkLCBidXQgYSBjaGVjayBtdXN0IGJlIGRvbmUgZWxzZXdoZXJlIHRvIGVuc3VyZSB0aGV5J3JlIGJhbGFuY2VkLlxuICpcbiAqICcsJyBhbGxvd3MgbXVsdGlwbGUgdmFsdWVzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBzYW1lIHByb3BlcnR5IChlLmcuIGJhY2tncm91bmQtYXR0YWNobWVudCBvclxuICogZm9udC1mYW1pbHkpIGFuZCBoZW5jZSBjb3VsZCBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgdG8gZ2V0IGluamVjdGVkLCBidXQgdGhhdCBzaG91bGQgcG9zZSBubyByaXNrXG4gKiBvZiBYU1MuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24gY2hlY2tzIG9ubHkgZm9yIFhTUyBzYWZldHksIG5vdCBmb3IgQ1NTIHZhbGlkaXR5LlxuICpcbiAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LCBhbmQgYXVnbWVudGVkIGZvclxuICogdHJhbnNmb3JtYXRpb24gdmFsdWVzLlxuICovXG52YXIgVkFMVUVTID0gJ1stLC5cIlxcJyVfISMgYS16QS1aMC05XSsnO1xudmFyIFRSQU5TRk9STUFUSU9OX0ZOUyA9ICcoPzptYXRyaXh8dHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3fHBlcnNwZWN0aXZlKSg/Olh8WXwzZCk/JztcbnZhciBDT0xPUl9GTlMgPSAnKD86cmdifGhzbClhPyc7XG52YXIgR1JBRElFTlRTID0gJyg/OnJlcGVhdGluZy0pPyg/OmxpbmVhcnxyYWRpYWwpLWdyYWRpZW50JztcbnZhciBDU1MzX0ZOUyA9ICcoPzpjYWxjfGF0dHIpJztcbnZhciBGTl9BUkdTID0gJ1xcXFwoWy0wLTkuJSwgI2EtekEtWl0rXFxcXCknO1xudmFyIFNBRkVfU1RZTEVfVkFMVUUgPSBuZXcgUmVnRXhwKFwiXihcIiArIFZBTFVFUyArIFwifFwiICtcbiAgICAoXCIoPzpcIiArIFRSQU5TRk9STUFUSU9OX0ZOUyArIFwifFwiICsgQ09MT1JfRk5TICsgXCJ8XCIgKyBHUkFESUVOVFMgKyBcInxcIiArIENTUzNfRk5TICsgXCIpXCIpICtcbiAgICAoRk5fQVJHUyArIFwiKSRcIiksICdnJyk7XG4vKipcbiAqIE1hdGNoZXMgYSBgdXJsKC4uLilgIHZhbHVlIHdpdGggYW4gYXJiaXRyYXJ5IGFyZ3VtZW50IGFzIGxvbmcgYXMgaXQgZG9lc1xuICogbm90IGNvbnRhaW4gcGFyZW50aGVzZXMuXG4gKlxuICogVGhlIFVSTCB2YWx1ZSBzdGlsbCBuZWVkcyB0byBiZSBzYW5pdGl6ZWQgc2VwYXJhdGVseS5cbiAqXG4gKiBgdXJsKC4uLilgIHZhbHVlcyBhcmUgYSB2ZXJ5IGNvbW1vbiB1c2UgY2FzZSwgZS5nLiBmb3IgYGJhY2tncm91bmQtaW1hZ2VgLiBXaXRoIGNhcmVmdWxseSBjcmFmdGVkXG4gKiBDU1Mgc3R5bGUgcnVsZXMsIGl0IGlzIHBvc3NpYmxlIHRvIGNvbnN0cnVjdCBhbiBpbmZvcm1hdGlvbiBsZWFrIHdpdGggYHVybGAgdmFsdWVzIGluIENTUywgZS5nLlxuICogYnkgb2JzZXJ2aW5nIHdoZXRoZXIgc2Nyb2xsIGJhcnMgYXJlIGRpc3BsYXllZCwgb3IgY2hhcmFjdGVyIHJhbmdlcyB1c2VkIGJ5IGEgZm9udCBmYWNlXG4gKiBkZWZpbml0aW9uLlxuICpcbiAqIEFuZ3VsYXIgb25seSBhbGxvd3MgYmluZGluZyBDU1MgdmFsdWVzIChhcyBvcHBvc2VkIHRvIGVudGlyZSBDU1MgcnVsZXMpLCBzbyBpdCBpcyB1bmxpa2VseSB0aGF0XG4gKiBiaW5kaW5nIGEgVVJMIHZhbHVlIHdpdGhvdXQgZnVydGhlciBjb29wZXJhdGlvbiBmcm9tIHRoZSBwYWdlIHdpbGwgY2F1c2UgYW4gaW5mb3JtYXRpb24gbGVhaywgYW5kXG4gKiBpZiBzbywgaXQgaXMganVzdCBhIGxlYWssIG5vdCBhIGZ1bGwgYmxvd24gWFNTIHZ1bG5lcmFiaWxpdHkuXG4gKlxuICogR2l2ZW4gdGhlIGNvbW1vbiB1c2UgY2FzZSwgbG93IGxpa2VsaWhvb2Qgb2YgYXR0YWNrIHZlY3RvciwgYW5kIGxvdyBpbXBhY3Qgb2YgYW4gYXR0YWNrLCB0aGlzXG4gKiBjb2RlIGlzIHBlcm1pc3NpdmUgYW5kIGFsbG93cyBVUkxzIHRoYXQgc2FuaXRpemUgb3RoZXJ3aXNlLlxuICovXG52YXIgVVJMX1JFID0gL151cmxcXCgoW14pXSspXFwpJC87XG4vKipcbiAqIENoZWNrcyB0aGF0IHF1b3RlcyAoXCIgYW5kICcpIGFyZSBwcm9wZXJseSBiYWxhbmNlZCBpbnNpZGUgYSBzdHJpbmcuIEFzc3VtZXNcbiAqIHRoYXQgbmVpdGhlciBlc2NhcGUgKFxcKSBub3IgYW55IG90aGVyIGNoYXJhY3RlciB0aGF0IGNvdWxkIHJlc3VsdCBpblxuICogYnJlYWtpbmcgb3V0IG9mIGEgc3RyaW5nIHBhcnNpbmcgY29udGV4dCBhcmUgYWxsb3dlZDtcbiAqIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jc3RyaW5nLXRva2VuLWRpYWdyYW0uXG4gKlxuICogVGhpcyBjb2RlIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICovXG5mdW5jdGlvbiBoYXNCYWxhbmNlZFF1b3Rlcyh2YWx1ZSkge1xuICAgIHZhciBvdXRzaWRlU2luZ2xlID0gdHJ1ZTtcbiAgICB2YXIgb3V0c2lkZURvdWJsZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHZhbHVlLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGMgPT09ICdcXCcnICYmIG91dHNpZGVEb3VibGUpIHtcbiAgICAgICAgICAgIG91dHNpZGVTaW5nbGUgPSAhb3V0c2lkZVNpbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSAnXCInICYmIG91dHNpZGVTaW5nbGUpIHtcbiAgICAgICAgICAgIG91dHNpZGVEb3VibGUgPSAhb3V0c2lkZURvdWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0c2lkZVNpbmdsZSAmJiBvdXRzaWRlRG91YmxlO1xufVxuLyoqXG4gKiBTYW5pdGl6ZXMgdGhlIGdpdmVuIHVudHJ1c3RlZCBDU1Mgc3R5bGUgcHJvcGVydHkgdmFsdWUgKGkuZS4gbm90IGFuIGVudGlyZSBvYmplY3QsIGp1c3QgYSBzaW5nbGVcbiAqIHZhbHVlKSBhbmQgcmV0dXJucyBhIHZhbHVlIHRoYXQgaXMgc2FmZSB0byB1c2UgaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICovXG5mdW5jdGlvbiBfc2FuaXRpemVTdHlsZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKS50cmltKCk7IC8vIE1ha2Ugc3VyZSBpdCdzIGFjdHVhbGx5IGEgc3RyaW5nLlxuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiAnJztcbiAgICAvLyBTaW5nbGUgdXJsKC4uLikgdmFsdWVzIGFyZSBzdXBwb3J0ZWQsIGJ1dCBvbmx5IGZvciBVUkxzIHRoYXQgc2FuaXRpemUgY2xlYW5seS4gU2VlIGFib3ZlIGZvclxuICAgIC8vIHJlYXNvbmluZyBiZWhpbmQgdGhpcy5cbiAgICB2YXIgdXJsTWF0Y2ggPSB2YWx1ZS5tYXRjaChVUkxfUkUpO1xuICAgIGlmICgodXJsTWF0Y2ggJiYgX3Nhbml0aXplVXJsKHVybE1hdGNoWzFdKSA9PT0gdXJsTWF0Y2hbMV0pIHx8XG4gICAgICAgIHZhbHVlLm1hdGNoKFNBRkVfU1RZTEVfVkFMVUUpICYmIGhhc0JhbGFuY2VkUXVvdGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7IC8vIFNhZmUgc3R5bGUgdmFsdWVzLlxuICAgIH1cbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogc2FuaXRpemluZyB1bnNhZmUgc3R5bGUgdmFsdWUgXCIgKyB2YWx1ZSArIFwiIChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKS5cIik7XG4gICAgfVxuICAgIHJldHVybiAndW5zYWZlJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBgaHRtbGAgc2FuaXRpemVyIHdoaWNoIGNvbnZlcnRzIHVudHJ1c3RlZCBgaHRtbGAgKipzdHJpbmcqKiBpbnRvIHRydXN0ZWQgc3RyaW5nIGJ5IHJlbW92aW5nXG4gKiBkYW5nZXJvdXMgY29udGVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhlIGBodG1sYCBhbmQgbG9jYXRlcyBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY29udGVudCAoc3VjaCBhcyB1cmxzIGFuZFxuICogamF2YXNjcmlwdCkgYW5kIHJlbW92ZXMgaXQuXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gbWFyayBhIHN0cmluZyBhcyB0cnVzdGVkIGJ5IGNhbGxpbmcge0BsaW5rIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0SHRtbH0uXG4gKlxuICogQHBhcmFtIHVuc2FmZUh0bWwgdW50cnVzdGVkIGBodG1sYCwgdHlwaWNhbGx5IGZyb20gdGhlIHVzZXIuXG4gKiBAcmV0dXJucyBgaHRtbGAgc3RyaW5nIHdoaWNoIGlzIHNhZmUgdG8gZGlzcGxheSB0byB1c2VyLCBiZWNhdXNlIGFsbCBvZiB0aGUgZGFuZ2Vyb3VzIGphdmFzY3JpcHRcbiAqIGFuZCB1cmxzIGhhdmUgYmVlbiByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCkge1xuICAgIHZhciBzID0gZ2V0Q3VycmVudFNhbml0aXplcigpO1xuICAgIGlmIChzKSB7XG4gICAgICAgIHJldHVybiBzLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5IVE1MLCB1bnNhZmVIdG1sKSB8fCAnJztcbiAgICB9XG4gICAgaWYgKGFsbG93U2FuaXRpemF0aW9uQnlwYXNzKHVuc2FmZUh0bWwsIFwiSHRtbFwiIC8qIEh0bWwgKi8pKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVIdG1sLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2FuaXRpemVIdG1sKGRvY3VtZW50LCBzdHJpbmdpZnkkMSh1bnNhZmVIdG1sKSk7XG59XG4vKipcbiAqIEEgYHN0eWxlYCBzYW5pdGl6ZXIgd2hpY2ggY29udmVydHMgdW50cnVzdGVkIGBzdHlsZWAgKipzdHJpbmcqKiBpbnRvIHRydXN0ZWQgc3RyaW5nIGJ5IHJlbW92aW5nXG4gKiBkYW5nZXJvdXMgY29udGVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhlIGBzdHlsZWAgYW5kIGxvY2F0ZXMgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNvbnRlbnQgKHN1Y2ggYXMgdXJscyBhbmRcbiAqIGphdmFzY3JpcHQpIGFuZCByZW1vdmVzIGl0LlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIG1hcmsgYSBzdHJpbmcgYXMgdHJ1c3RlZCBieSBjYWxsaW5nIHtAbGluayBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFN0eWxlfS5cbiAqXG4gKiBAcGFyYW0gdW5zYWZlU3R5bGUgdW50cnVzdGVkIGBzdHlsZWAsIHR5cGljYWxseSBmcm9tIHRoZSB1c2VyLlxuICogQHJldHVybnMgYHN0eWxlYCBzdHJpbmcgd2hpY2ggaXMgc2FmZSB0byBiaW5kIHRvIHRoZSBgc3R5bGVgIHByb3BlcnRpZXMsIGJlY2F1c2UgYWxsIG9mIHRoZVxuICogZGFuZ2Vyb3VzIGphdmFzY3JpcHQgYW5kIHVybHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplU3R5bGUodW5zYWZlU3R5bGUpIHtcbiAgICB2YXIgcyA9IGdldEN1cnJlbnRTYW5pdGl6ZXIoKTtcbiAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcy5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuU1RZTEUsIHVuc2FmZVN0eWxlKSB8fCAnJztcbiAgICB9XG4gICAgaWYgKGFsbG93U2FuaXRpemF0aW9uQnlwYXNzKHVuc2FmZVN0eWxlLCBcIlN0eWxlXCIgLyogU3R5bGUgKi8pKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVTdHlsZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Nhbml0aXplU3R5bGUoc3RyaW5naWZ5JDEodW5zYWZlU3R5bGUpKTtcbn1cbi8qKlxuICogQSBgdXJsYCBzYW5pdGl6ZXIgd2hpY2ggY29udmVydHMgdW50cnVzdGVkIGB1cmxgICoqc3RyaW5nKiogaW50byB0cnVzdGVkIHN0cmluZyBieSByZW1vdmluZ1xuICogZGFuZ2Vyb3VzXG4gKiBjb250ZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIHBhcnNlcyB0aGUgYHVybGAgYW5kIGxvY2F0ZXMgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGNvbnRlbnQgKHN1Y2ggYXMgamF2YXNjcmlwdCkgYW5kXG4gKiByZW1vdmVzIGl0LlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIG1hcmsgYSBzdHJpbmcgYXMgdHJ1c3RlZCBieSBjYWxsaW5nIHtAbGluayBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFVybH0uXG4gKlxuICogQHBhcmFtIHVuc2FmZVVybCB1bnRydXN0ZWQgYHVybGAsIHR5cGljYWxseSBmcm9tIHRoZSB1c2VyLlxuICogQHJldHVybnMgYHVybGAgc3RyaW5nIHdoaWNoIGlzIHNhZmUgdG8gYmluZCB0byB0aGUgYHNyY2AgcHJvcGVydGllcyBzdWNoIGFzIGA8aW1nIHNyYz5gLCBiZWNhdXNlXG4gKiBhbGwgb2YgdGhlIGRhbmdlcm91cyBqYXZhc2NyaXB0IGhhcyBiZWVuIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplVXJsKHVuc2FmZVVybCkge1xuICAgIHZhciBzID0gZ2V0Q3VycmVudFNhbml0aXplcigpO1xuICAgIGlmIChzKSB7XG4gICAgICAgIHJldHVybiBzLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5VUkwsIHVuc2FmZVVybCkgfHwgJyc7XG4gICAgfVxuICAgIGlmIChhbGxvd1Nhbml0aXphdGlvbkJ5cGFzcyh1bnNhZmVVcmwsIFwiVXJsXCIgLyogVXJsICovKSkge1xuICAgICAgICByZXR1cm4gdW5zYWZlVXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2FuaXRpemVVcmwoc3RyaW5naWZ5JDEodW5zYWZlVXJsKSk7XG59XG4vKipcbiAqIEEgYHVybGAgc2FuaXRpemVyIHdoaWNoIG9ubHkgbGV0cyB0cnVzdGVkIGB1cmxgcyB0aHJvdWdoLlxuICpcbiAqIFRoaXMgcGFzc2VzIG9ubHkgYHVybGBzIG1hcmtlZCB0cnVzdGVkIGJ5IGNhbGxpbmcge0BsaW5rIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0UmVzb3VyY2VVcmx9LlxuICpcbiAqIEBwYXJhbSB1bnNhZmVSZXNvdXJjZVVybCB1bnRydXN0ZWQgYHVybGAsIHR5cGljYWxseSBmcm9tIHRoZSB1c2VyLlxuICogQHJldHVybnMgYHVybGAgc3RyaW5nIHdoaWNoIGlzIHNhZmUgdG8gYmluZCB0byB0aGUgYHNyY2AgcHJvcGVydGllcyBzdWNoIGFzIGA8aW1nIHNyYz5gLCBiZWNhdXNlXG4gKiBvbmx5IHRydXN0ZWQgYHVybGBzIGhhdmUgYmVlbiBhbGxvd2VkIHRvIHBhc3MuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplUmVzb3VyY2VVcmwodW5zYWZlUmVzb3VyY2VVcmwpIHtcbiAgICB2YXIgcyA9IGdldEN1cnJlbnRTYW5pdGl6ZXIoKTtcbiAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcy5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCB1bnNhZmVSZXNvdXJjZVVybCkgfHwgJyc7XG4gICAgfVxuICAgIGlmIChhbGxvd1Nhbml0aXphdGlvbkJ5cGFzcyh1bnNhZmVSZXNvdXJjZVVybCwgXCJSZXNvdXJjZVVybFwiIC8qIFJlc291cmNlVXJsICovKSkge1xuICAgICAgICByZXR1cm4gdW5zYWZlUmVzb3VyY2VVcmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmUgdmFsdWUgdXNlZCBpbiBhIHJlc291cmNlIFVSTCBjb250ZXh0IChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKScpO1xufVxuLyoqXG4gKiBBIGBzY3JpcHRgIHNhbml0aXplciB3aGljaCBvbmx5IGxldHMgdHJ1c3RlZCBqYXZhc2NyaXB0IHRocm91Z2guXG4gKlxuICogVGhpcyBwYXNzZXMgb25seSBgc2NyaXB0YHMgbWFya2VkIHRydXN0ZWQgYnkgY2FsbGluZyB7QGxpbmsgYnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTY3JpcHR9LlxuICpcbiAqIEBwYXJhbSB1bnNhZmVTY3JpcHQgdW50cnVzdGVkIGBzY3JpcHRgLCB0eXBpY2FsbHkgZnJvbSB0aGUgdXNlci5cbiAqIEByZXR1cm5zIGB1cmxgIHN0cmluZyB3aGljaCBpcyBzYWZlIHRvIGJpbmQgdG8gdGhlIGA8c2NyaXB0PmAgZWxlbWVudCBzdWNoIGFzIGA8aW1nIHNyYz5gLFxuICogYmVjYXVzZSBvbmx5IHRydXN0ZWQgYHNjcmlwdHNgcyBoYXZlIGJlZW4gYWxsb3dlZCB0byBwYXNzLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZVNjcmlwdCh1bnNhZmVTY3JpcHQpIHtcbiAgICB2YXIgcyA9IGdldEN1cnJlbnRTYW5pdGl6ZXIoKTtcbiAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcy5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuU0NSSVBULCB1bnNhZmVTY3JpcHQpIHx8ICcnO1xuICAgIH1cbiAgICBpZiAoYWxsb3dTYW5pdGl6YXRpb25CeXBhc3ModW5zYWZlU2NyaXB0LCBcIlNjcmlwdFwiIC8qIFNjcmlwdCAqLykpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVNjcmlwdC50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgc2NyaXB0IGNvbnRleHQnKTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgc3R5bGUgc2FuaXRpemVyIHdpbGwgaGFuZGxlIHNhbml0aXphdGlvbiBmb3Igc3R5bGUgcHJvcGVydGllcyBieVxuICogc2FuaXRpemluZyBhbnkgQ1NTIHByb3BlcnR5IHRoYXQgY2FuIGluY2x1ZGUgYSBgdXJsYCB2YWx1ZSAodXN1YWxseSBpbWFnZS1iYXNlZCBwcm9wZXJ0aWVzKVxuICovXG52YXIgZGVmYXVsdFN0eWxlU2FuaXRpemVyID0gZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHByb3AgPT09ICdiYWNrZ3JvdW5kLWltYWdlJyB8fCBwcm9wID09PSAnYmFja2dyb3VuZCcgfHwgcHJvcCA9PT0gJ2JvcmRlci1pbWFnZScgfHxcbiAgICAgICAgICAgIHByb3AgPT09ICdmaWx0ZXInIHx8IHByb3AgPT09ICdmaWx0ZXInIHx8IHByb3AgPT09ICdsaXN0LXN0eWxlJyB8fFxuICAgICAgICAgICAgcHJvcCA9PT0gJ2xpc3Qtc3R5bGUtaW1hZ2UnO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpemVTdHlsZSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgbWFwcGluZyBvZiB0aGUgQGFuZ3VsYXIvY29yZSBBUEkgc3VyZmFjZSB1c2VkIGluIGdlbmVyYXRlZCBleHByZXNzaW9ucyB0byB0aGUgYWN0dWFsIHN5bWJvbHMuXG4gKlxuICogVGhpcyBzaG91bGQgYmUga2VwdCB1cCB0byBkYXRlIHdpdGggdGhlIHB1YmxpYyBleHBvcnRzIG9mIEBhbmd1bGFyL2NvcmUuXG4gKi9cbnZhciBhbmd1bGFyQ29yZUVudiA9IHtcbiAgICAnybVkZWZpbmVCYXNlJzogZGVmaW5lQmFzZSxcbiAgICAnybVkZWZpbmVDb21wb25lbnQnOiBkZWZpbmVDb21wb25lbnQsXG4gICAgJ8m1ZGVmaW5lRGlyZWN0aXZlJzogZGVmaW5lRGlyZWN0aXZlLFxuICAgICdkZWZpbmVJbmplY3RhYmxlJzogZGVmaW5lSW5qZWN0YWJsZSxcbiAgICAnZGVmaW5lSW5qZWN0b3InOiBkZWZpbmVJbmplY3RvcixcbiAgICAnybVkZWZpbmVOZ01vZHVsZSc6IGRlZmluZU5nTW9kdWxlLFxuICAgICfJtWRlZmluZVBpcGUnOiBkZWZpbmVQaXBlLFxuICAgICfJtWRpcmVjdGl2ZUluamVjdCc6IGRpcmVjdGl2ZUluamVjdCxcbiAgICAnybVnZXRGYWN0b3J5T2YnOiBnZXRGYWN0b3J5T2YsXG4gICAgJ8m1Z2V0SW5oZXJpdGVkRmFjdG9yeSc6IGdldEluaGVyaXRlZEZhY3RvcnksXG4gICAgJ2luamVjdCc6IGluamVjdCxcbiAgICAnybVpbmplY3RBdHRyaWJ1dGUnOiBpbmplY3RBdHRyaWJ1dGUsXG4gICAgJ8m1dGVtcGxhdGVSZWZFeHRyYWN0b3InOiB0ZW1wbGF0ZVJlZkV4dHJhY3RvcixcbiAgICAnybVOZ09uQ2hhbmdlc0ZlYXR1cmUnOiBOZ09uQ2hhbmdlc0ZlYXR1cmUsXG4gICAgJ8m1UHVibGljRmVhdHVyZSc6IFB1YmxpY0ZlYXR1cmUsXG4gICAgJ8m1SW5oZXJpdERlZmluaXRpb25GZWF0dXJlJzogSW5oZXJpdERlZmluaXRpb25GZWF0dXJlLFxuICAgICfJtWVsZW1lbnRBdHRyaWJ1dGUnOiBlbGVtZW50QXR0cmlidXRlLFxuICAgICfJtWJpbmQnOiBiaW5kLFxuICAgICfJtWNvbnRhaW5lcic6IGNvbnRhaW5lcixcbiAgICAnybVuZXh0Q29udGV4dCc6IG5leHRDb250ZXh0LFxuICAgICfJtWNvbnRhaW5lclJlZnJlc2hTdGFydCc6IGNvbnRhaW5lclJlZnJlc2hTdGFydCxcbiAgICAnybVjb250YWluZXJSZWZyZXNoRW5kJzogY29udGFpbmVyUmVmcmVzaEVuZCxcbiAgICAnybVsb2FkUXVlcnlMaXN0JzogbG9hZFF1ZXJ5TGlzdCxcbiAgICAnybVuYW1lc3BhY2VIVE1MJzogbmFtZXNwYWNlSFRNTCxcbiAgICAnybVuYW1lc3BhY2VNYXRoTUwnOiBuYW1lc3BhY2VNYXRoTUwsXG4gICAgJ8m1bmFtZXNwYWNlU1ZHJzogbmFtZXNwYWNlU1ZHLFxuICAgICfJtWVuYWJsZUJpbmRpbmdzJzogZW5hYmxlQmluZGluZ3MsXG4gICAgJ8m1ZGlzYWJsZUJpbmRpbmdzJzogZGlzYWJsZUJpbmRpbmdzLFxuICAgICfJtWVsZW1lbnRTdGFydCc6IGVsZW1lbnRTdGFydCxcbiAgICAnybVlbGVtZW50RW5kJzogZWxlbWVudEVuZCxcbiAgICAnybVlbGVtZW50JzogZWxlbWVudCxcbiAgICAnybVFQyc6IGVsZW1lbnRDb250YWluZXJTdGFydCxcbiAgICAnybVlQyc6IGVsZW1lbnRDb250YWluZXJFbmQsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uMCc6IHB1cmVGdW5jdGlvbjAsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uMSc6IHB1cmVGdW5jdGlvbjEsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uMic6IHB1cmVGdW5jdGlvbjIsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uMyc6IHB1cmVGdW5jdGlvbjMsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uNCc6IHB1cmVGdW5jdGlvbjQsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uNSc6IHB1cmVGdW5jdGlvbjUsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uNic6IHB1cmVGdW5jdGlvbjYsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uNyc6IHB1cmVGdW5jdGlvbjcsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uOCc6IHB1cmVGdW5jdGlvbjgsXG4gICAgJ8m1cHVyZUZ1bmN0aW9uVic6IHB1cmVGdW5jdGlvblYsXG4gICAgJ8m1Z2V0Q3VycmVudFZpZXcnOiBnZXRDdXJyZW50VmlldyxcbiAgICAnybVyZXN0b3JlVmlldyc6IHJlc3RvcmVWaWV3LFxuICAgICfJtWludGVycG9sYXRpb24xJzogaW50ZXJwb2xhdGlvbjEsXG4gICAgJ8m1aW50ZXJwb2xhdGlvbjInOiBpbnRlcnBvbGF0aW9uMixcbiAgICAnybVpbnRlcnBvbGF0aW9uMyc6IGludGVycG9sYXRpb24zLFxuICAgICfJtWludGVycG9sYXRpb240JzogaW50ZXJwb2xhdGlvbjQsXG4gICAgJ8m1aW50ZXJwb2xhdGlvbjUnOiBpbnRlcnBvbGF0aW9uNSxcbiAgICAnybVpbnRlcnBvbGF0aW9uNic6IGludGVycG9sYXRpb242LFxuICAgICfJtWludGVycG9sYXRpb243JzogaW50ZXJwb2xhdGlvbjcsXG4gICAgJ8m1aW50ZXJwb2xhdGlvbjgnOiBpbnRlcnBvbGF0aW9uOCxcbiAgICAnybVpbnRlcnBvbGF0aW9uVic6IGludGVycG9sYXRpb25WLFxuICAgICfJtWVsZW1lbnRDbGFzc1Byb3AnOiBlbGVtZW50Q2xhc3NQcm9wLFxuICAgICfJtWxpc3RlbmVyJzogbGlzdGVuZXIsXG4gICAgJ8m1bG9hZCc6IGxvYWQsXG4gICAgJ8m1cHJvamVjdGlvbic6IHByb2plY3Rpb24sXG4gICAgJ8m1ZWxlbWVudFByb3BlcnR5JzogZWxlbWVudFByb3BlcnR5LFxuICAgICfJtXBpcGVCaW5kMSc6IHBpcGVCaW5kMSxcbiAgICAnybVwaXBlQmluZDInOiBwaXBlQmluZDIsXG4gICAgJ8m1cGlwZUJpbmQzJzogcGlwZUJpbmQzLFxuICAgICfJtXBpcGVCaW5kNCc6IHBpcGVCaW5kNCxcbiAgICAnybVwaXBlQmluZFYnOiBwaXBlQmluZFYsXG4gICAgJ8m1cHJvamVjdGlvbkRlZic6IHByb2plY3Rpb25EZWYsXG4gICAgJ8m1cGlwZSc6IHBpcGUsXG4gICAgJ8m1cXVlcnknOiBxdWVyeSxcbiAgICAnybVxdWVyeVJlZnJlc2gnOiBxdWVyeVJlZnJlc2gsXG4gICAgJ8m1cmVnaXN0ZXJDb250ZW50UXVlcnknOiByZWdpc3RlckNvbnRlbnRRdWVyeSxcbiAgICAnybVyZWZlcmVuY2UnOiByZWZlcmVuY2UsXG4gICAgJ8m1ZWxlbWVudFN0eWxpbmcnOiBlbGVtZW50U3R5bGluZyxcbiAgICAnybVlbGVtZW50U3R5bGluZ01hcCc6IGVsZW1lbnRTdHlsaW5nTWFwLFxuICAgICfJtWVsZW1lbnRTdHlsZVByb3AnOiBlbGVtZW50U3R5bGVQcm9wLFxuICAgICfJtWVsZW1lbnRTdHlsaW5nQXBwbHknOiBlbGVtZW50U3R5bGluZ0FwcGx5LFxuICAgICfJtXRlbXBsYXRlJzogdGVtcGxhdGUsXG4gICAgJ8m1dGV4dCc6IHRleHQsXG4gICAgJ8m1dGV4dEJpbmRpbmcnOiB0ZXh0QmluZGluZyxcbiAgICAnybVlbWJlZGRlZFZpZXdTdGFydCc6IGVtYmVkZGVkVmlld1N0YXJ0LFxuICAgICfJtWVtYmVkZGVkVmlld0VuZCc6IGVtYmVkZGVkVmlld0VuZCxcbiAgICAnybVpMThuQXR0cmlidXRlJzogaTE4bkF0dHJpYnV0ZSxcbiAgICAnybVpMThuRXhwJzogaTE4bkV4cCxcbiAgICAnybVpMThuU3RhcnQnOiBpMThuU3RhcnQsXG4gICAgJ8m1aTE4bkVuZCc6IGkxOG5FbmQsXG4gICAgJ8m1aTE4bkFwcGx5JzogaTE4bkFwcGx5LFxuICAgICfJtXNhbml0aXplSHRtbCc6IHNhbml0aXplSHRtbCxcbiAgICAnybVzYW5pdGl6ZVN0eWxlJzogc2FuaXRpemVTdHlsZSxcbiAgICAnybVkZWZhdWx0U3R5bGVTYW5pdGl6ZXInOiBkZWZhdWx0U3R5bGVTYW5pdGl6ZXIsXG4gICAgJ8m1c2FuaXRpemVSZXNvdXJjZVVybCc6IHNhbml0aXplUmVzb3VyY2VVcmwsXG4gICAgJ8m1c2FuaXRpemVTY3JpcHQnOiBzYW5pdGl6ZVNjcmlwdCxcbiAgICAnybVzYW5pdGl6ZVVybCc6IHNhbml0aXplVXJsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX3JlZmxlY3QgPSBudWxsO1xuZnVuY3Rpb24gZ2V0UmVmbGVjdCgpIHtcbiAgICByZXR1cm4gKF9yZWZsZWN0ID0gX3JlZmxlY3QgfHwgbmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKSk7XG59XG5mdW5jdGlvbiByZWZsZWN0RGVwZW5kZW5jaWVzKHR5cGUpIHtcbiAgICByZXR1cm4gY29udmVydERlcGVuZGVuY2llcyhnZXRSZWZsZWN0KCkucGFyYW1ldGVycyh0eXBlKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGVwZW5kZW5jaWVzKGRlcHMpIHtcbiAgICB2YXIgY29tcGlsZXIgPSBnZXRDb21waWxlckZhY2FkZSgpO1xuICAgIHJldHVybiBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiByZWZsZWN0RGVwZW5kZW5jeShjb21waWxlciwgZGVwKTsgfSk7XG59XG5mdW5jdGlvbiByZWZsZWN0RGVwZW5kZW5jeShjb21waWxlciwgZGVwKSB7XG4gICAgdmFyIG1ldGEgPSB7XG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICBob3N0OiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXNvbHZlZDogY29tcGlsZXIuUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLlRva2VuLFxuICAgICAgICBzZWxmOiBmYWxzZSxcbiAgICAgICAgc2tpcFNlbGY6IGZhbHNlLFxuICAgIH07XG4gICAgZnVuY3Rpb24gc2V0VG9rZW5BbmRSZXNvbHZlZFR5cGUodG9rZW4pIHtcbiAgICAgICAgbWV0YS5yZXNvbHZlZCA9IGNvbXBpbGVyLlIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5Ub2tlbjtcbiAgICAgICAgbWV0YS50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXApKSB7XG4gICAgICAgIGlmIChkZXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcGVuZGVuY3kgYXJyYXkgbXVzdCBoYXZlIGFyZ3VtZW50cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRlcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gZGVwW2pdO1xuICAgICAgICAgICAgaWYgKHBhcmFtIGluc3RhbmNlb2YgT3B0aW9uYWwgfHwgcGFyYW0uX19wcm90b19fLm5nTWV0YWRhdGFOYW1lID09PSAnT3B0aW9uYWwnKSB7XG4gICAgICAgICAgICAgICAgbWV0YS5vcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIFNraXBTZWxmIHx8IHBhcmFtLl9fcHJvdG9fXy5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NraXBTZWxmJykge1xuICAgICAgICAgICAgICAgIG1ldGEuc2tpcFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBTZWxmIHx8IHBhcmFtLl9fcHJvdG9fXy5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NlbGYnKSB7XG4gICAgICAgICAgICAgICAgbWV0YS5zZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgSG9zdCB8fCBwYXJhbS5fX3Byb3RvX18ubmdNZXRhZGF0YU5hbWUgPT09ICdIb3N0Jykge1xuICAgICAgICAgICAgICAgIG1ldGEuaG9zdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgICAgIG1ldGEudG9rZW4gPSBwYXJhbS50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmF0dHJpYnV0ZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUgbmFtZSBtdXN0IGJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRhLnRva2VuID0gcGFyYW0uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICBtZXRhLnJlc29sdmVkID0gY29tcGlsZXIuUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkF0dHJpYnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRva2VuQW5kUmVzb2x2ZWRUeXBlKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0VG9rZW5BbmRSZXNvbHZlZFR5cGUoZGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFTVBUWV9BUlJBWSQyID0gW107XG4vKipcbiAqIENvbXBpbGVzIGEgbW9kdWxlIGluIEpJVCBtb2RlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXV0b21hdGljYWxseSBnZXRzIGNhbGxlZCB3aGVuIGEgY2xhc3MgaGFzIGEgYEBOZ01vZHVsZWAgZGVjb3JhdG9yLlxuICovXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGUobW9kdWxlVHlwZSwgbmdNb2R1bGUpIHtcbiAgICBjb21waWxlTmdNb2R1bGVEZWZzKG1vZHVsZVR5cGUsIG5nTW9kdWxlKTtcbiAgICBzZXRTY29wZU9uRGVjbGFyZWRDb21wb25lbnRzKG1vZHVsZVR5cGUsIG5nTW9kdWxlKTtcbn1cbi8qKlxuICogQ29tcGlsZXMgYW5kIGFkZHMgdGhlIGBuZ01vZHVsZURlZmAgYW5kIGBuZ0luamVjdG9yRGVmYCBwcm9wZXJ0aWVzIHRvIHRoZSBtb2R1bGUgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVOZ01vZHVsZURlZnMobW9kdWxlVHlwZSwgbmdNb2R1bGUpIHtcbiAgICB2YXIgZGVjbGFyYXRpb25zID0gZmxhdHRlbiQxKG5nTW9kdWxlLmRlY2xhcmF0aW9ucyB8fCBFTVBUWV9BUlJBWSQyKTtcbiAgICB2YXIgbmdNb2R1bGVEZWYgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGVUeXBlLCBOR19NT0RVTEVfREVGLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobmdNb2R1bGVEZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZURlZiA9IGdldENvbXBpbGVyRmFjYWRlKCkuY29tcGlsZU5nTW9kdWxlKGFuZ3VsYXJDb3JlRW52LCBcIm5nOi8vXCIgKyBtb2R1bGVUeXBlLm5hbWUgKyBcIi9uZ01vZHVsZURlZi5qc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1vZHVsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGJvb3RzdHJhcDogZmxhdHRlbiQxKG5nTW9kdWxlLmJvb3RzdHJhcCB8fCBFTVBUWV9BUlJBWSQyKSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IGZsYXR0ZW4kMShuZ01vZHVsZS5pbXBvcnRzIHx8IEVNUFRZX0FSUkFZJDIpLm1hcChleHBhbmRNb2R1bGVXaXRoUHJvdmlkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogZmxhdHRlbiQxKG5nTW9kdWxlLmV4cG9ydHMgfHwgRU1QVFlfQVJSQVkkMikubWFwKGV4cGFuZE1vZHVsZVdpdGhQcm92aWRlcnMpLFxuICAgICAgICAgICAgICAgICAgICBlbWl0SW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5nTW9kdWxlRGVmO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5nSW5qZWN0b3JEZWYgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGVUeXBlLCBOR19JTkpFQ1RPUl9ERUYsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobmdJbmplY3RvckRlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGVUeXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1vZHVsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IHJlZmxlY3REZXBlbmRlbmNpZXMobW9kdWxlVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogbmdNb2R1bGUucHJvdmlkZXJzIHx8IEVNUFRZX0FSUkFZJDIsXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kdWxlLmltcG9ydHMgfHwgRU1QVFlfQVJSQVkkMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kdWxlLmV4cG9ydHMgfHwgRU1QVFlfQVJSQVkkMixcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5nSW5qZWN0b3JEZWYgPSBnZXRDb21waWxlckZhY2FkZSgpLmNvbXBpbGVJbmplY3Rvcihhbmd1bGFyQ29yZUVudiwgXCJuZzovL1wiICsgbW9kdWxlVHlwZS5uYW1lICsgXCIvbmdJbmplY3RvckRlZi5qc1wiLCBtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZ0luamVjdG9yRGVmO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYWtlIHRoZSBwcm9wZXJ0eSBjb25maWd1cmFibGUgaW4gZGV2IG1vZGUgdG8gYWxsb3cgb3ZlcnJpZGluZyBpbiB0ZXN0c1xuICAgICAgICBjb25maWd1cmFibGU6ICEhbmdEZXZNb2RlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTb21lIGRlY2xhcmVkIGNvbXBvbmVudHMgbWF5IGJlIGNvbXBpbGVkIGFzeW5jaHJvbm91c2x5LCBhbmQgdGh1cyBtYXkgbm90IGhhdmUgdGhlaXJcbiAqIG5nQ29tcG9uZW50RGVmIHNldCB5ZXQuIElmIHRoaXMgaXMgdGhlIGNhc2UsIHRoZW4gYSByZWZlcmVuY2UgdG8gdGhlIG1vZHVsZSBpcyB3cml0dGVuIGludG9cbiAqIHRoZSBgbmdTZWxlY3RvclNjb3BlYCBwcm9wZXJ0eSBvZiB0aGUgZGVjbGFyZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gc2V0U2NvcGVPbkRlY2xhcmVkQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBuZ01vZHVsZSkge1xuICAgIHZhciBkZWNsYXJhdGlvbnMgPSBmbGF0dGVuJDEobmdNb2R1bGUuZGVjbGFyYXRpb25zIHx8IEVNUFRZX0FSUkFZJDIpO1xuICAgIHZhciB0cmFuc2l0aXZlU2NvcGVzID0gdHJhbnNpdGl2ZVNjb3Blc0Zvcihtb2R1bGVUeXBlKTtcbiAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmhhc093blByb3BlcnR5KE5HX0NPTVBPTkVOVF9ERUYpKSB7XG4gICAgICAgICAgICAvLyBBbiBgbmdDb21wb25lbnREZWZgIGZpZWxkIGV4aXN0cyAtIGdvIGFoZWFkIGFuZCBwYXRjaCB0aGUgY29tcG9uZW50IGRpcmVjdGx5LlxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudERlZiA9IGdldENvbXBvbmVudERlZihjb21wb25lbnQpO1xuICAgICAgICAgICAgcGF0Y2hDb21wb25lbnREZWZXaXRoU2NvcGUoY29tcG9uZW50RGVmLCB0cmFuc2l0aXZlU2NvcGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGVjbGFyYXRpb24uaGFzT3duUHJvcGVydHkoTkdfRElSRUNUSVZFX0RFRikgJiYgIWRlY2xhcmF0aW9uLmhhc093blByb3BlcnR5KE5HX1BJUEVfREVGKSkge1xuICAgICAgICAgICAgLy8gU2V0IGBuZ1NlbGVjdG9yU2NvcGVgIGZvciBmdXR1cmUgcmVmZXJlbmNlIHdoZW4gdGhlIGNvbXBvbmVudCBjb21waWxhdGlvbiBmaW5pc2hlcy5cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLm5nU2VsZWN0b3JTY29wZSA9IG1vZHVsZVR5cGU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUGF0Y2ggdGhlIGRlZmluaXRpb24gb2YgYSBjb21wb25lbnQgd2l0aCBkaXJlY3RpdmVzIGFuZCBwaXBlcyBmcm9tIHRoZSBjb21waWxhdGlvbiBzY29wZSBvZlxuICogYSBnaXZlbiBtb2R1bGUuXG4gKi9cbmZ1bmN0aW9uIHBhdGNoQ29tcG9uZW50RGVmV2l0aFNjb3BlKGNvbXBvbmVudERlZiwgdHJhbnNpdGl2ZVNjb3Blcykge1xuICAgIGNvbXBvbmVudERlZi5kaXJlY3RpdmVEZWZzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0cmFuc2l0aXZlU2NvcGVzLmNvbXBpbGF0aW9uLmRpcmVjdGl2ZXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZ2V0RGlyZWN0aXZlRGVmKGRpcikgfHwgZ2V0Q29tcG9uZW50RGVmKGRpcik7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gISFkZWY7IH0pOyB9O1xuICAgIGNvbXBvbmVudERlZi5waXBlRGVmcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odHJhbnNpdGl2ZVNjb3Blcy5jb21waWxhdGlvbi5waXBlcykubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBnZXRQaXBlRGVmKHBpcGUpOyB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBwYWlyIG9mIHRyYW5zaXRpdmUgc2NvcGVzIChjb21waWxhdGlvbiBzY29wZSBhbmQgZXhwb3J0ZWQgc2NvcGUpIGZvciBhIGdpdmVuIG1vZHVsZS5cbiAqXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBtZW1vaXplZCBhbmQgdGhlIHJlc3VsdCBpcyBjYWNoZWQgb24gdGhlIG1vZHVsZSdzIGRlZmluaXRpb24uIEl0IGNhbiBiZSBjYWxsZWRcbiAqIG9uIG1vZHVsZXMgd2l0aCBjb21wb25lbnRzIHRoYXQgaGF2ZSBub3QgZnVsbHkgY29tcGlsZWQgeWV0LCBidXQgdGhlIHJlc3VsdCBzaG91bGQgbm90IGJlIHVzZWRcbiAqIHVudGlsIHRoZXkgaGF2ZS5cbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGl2ZVNjb3Blc0Zvcihtb2R1bGVUeXBlKSB7XG4gICAgaWYgKCFpc05nTW9kdWxlKG1vZHVsZVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtb2R1bGVUeXBlLm5hbWUgKyBcIiBkb2VzIG5vdCBoYXZlIGFuIG5nTW9kdWxlRGVmXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmID0gZ2V0TmdNb2R1bGVEZWYobW9kdWxlVHlwZSk7XG4gICAgaWYgKGRlZi50cmFuc2l0aXZlQ29tcGlsZVNjb3BlcyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmLnRyYW5zaXRpdmVDb21waWxlU2NvcGVzO1xuICAgIH1cbiAgICB2YXIgc2NvcGVzID0ge1xuICAgICAgICBjb21waWxhdGlvbjoge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxuICAgICAgICAgICAgcGlwZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXhwb3J0ZWQ6IHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHBpcGVzOiBuZXcgU2V0KCksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBkZWYuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmVkKSB7XG4gICAgICAgIHZhciBkZWNsYXJlZFdpdGhEZWZzID0gZGVjbGFyZWQ7XG4gICAgICAgIGlmIChnZXRQaXBlRGVmKGRlY2xhcmVkV2l0aERlZnMpKSB7XG4gICAgICAgICAgICBzY29wZXMuY29tcGlsYXRpb24ucGlwZXMuYWRkKGRlY2xhcmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVpdGhlciBkZWNsYXJlZCBoYXMgYW4gbmdDb21wb25lbnREZWYgb3IgbmdEaXJlY3RpdmVEZWYsIG9yIGl0J3MgYSBjb21wb25lbnQgd2hpY2ggaGFzbid0XG4gICAgICAgICAgICAvLyBoYWQgaXRzIHRlbXBsYXRlIGNvbXBpbGVkIHlldC4gSW4gZWl0aGVyIGNhc2UsIGl0IGdldHMgYWRkZWQgdG8gdGhlIGNvbXBpbGF0aW9uJ3NcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICBzY29wZXMuY29tcGlsYXRpb24uZGlyZWN0aXZlcy5hZGQoZGVjbGFyZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVmLmltcG9ydHMuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0ZWQpIHtcbiAgICAgICAgdmFyIGltcG9ydGVkVHlwZWQgPSBpbXBvcnRlZDtcbiAgICAgICAgaWYgKCFpc05nTW9kdWxlKGltcG9ydGVkVHlwZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbXBvcnRpbmcgXCIgKyBpbXBvcnRlZFR5cGVkLm5hbWUgKyBcIiB3aGljaCBkb2VzIG5vdCBoYXZlIGFuIG5nTW9kdWxlRGVmXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhpcyBtb2R1bGUgaW1wb3J0cyBhbm90aGVyLCB0aGUgaW1wb3J0ZWQgbW9kdWxlJ3MgZXhwb3J0ZWQgZGlyZWN0aXZlcyBhbmQgcGlwZXMgYXJlXG4gICAgICAgIC8vIGFkZGVkIHRvIHRoZSBjb21waWxhdGlvbiBzY29wZSBvZiB0aGlzIG1vZHVsZS5cbiAgICAgICAgdmFyIGltcG9ydGVkU2NvcGUgPSB0cmFuc2l0aXZlU2NvcGVzRm9yKGltcG9ydGVkVHlwZWQpO1xuICAgICAgICBpbXBvcnRlZFNjb3BlLmV4cG9ydGVkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHNjb3Blcy5jb21waWxhdGlvbi5kaXJlY3RpdmVzLmFkZChlbnRyeSk7IH0pO1xuICAgICAgICBpbXBvcnRlZFNjb3BlLmV4cG9ydGVkLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBzY29wZXMuY29tcGlsYXRpb24ucGlwZXMuYWRkKGVudHJ5KTsgfSk7XG4gICAgfSk7XG4gICAgZGVmLmV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWQpIHtcbiAgICAgICAgdmFyIGV4cG9ydGVkVHlwZWQgPSBleHBvcnRlZDtcbiAgICAgICAgLy8gRWl0aGVyIHRoZSB0eXBlIGlzIGEgbW9kdWxlLCBhIHBpcGUsIG9yIGEgY29tcG9uZW50L2RpcmVjdGl2ZSAod2hpY2ggbWF5IG5vdCBoYXZlIGFuXG4gICAgICAgIC8vIG5nQ29tcG9uZW50RGVmIGFzIGl0IG1pZ2h0IGJlIGNvbXBpbGVkIGFzeW5jaHJvbm91c2x5KS5cbiAgICAgICAgaWYgKGlzTmdNb2R1bGUoZXhwb3J0ZWRUeXBlZCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyBtb2R1bGUgZXhwb3J0cyBhbm90aGVyLCB0aGUgZXhwb3J0ZWQgbW9kdWxlJ3MgZXhwb3J0ZWQgZGlyZWN0aXZlcyBhbmQgcGlwZXMgYXJlXG4gICAgICAgICAgICAvLyBhZGRlZCB0byBib3RoIHRoZSBjb21waWxhdGlvbiBhbmQgZXhwb3J0ZWQgc2NvcGVzIG9mIHRoaXMgbW9kdWxlLlxuICAgICAgICAgICAgdmFyIGV4cG9ydGVkU2NvcGUgPSB0cmFuc2l0aXZlU2NvcGVzRm9yKGV4cG9ydGVkVHlwZWQpO1xuICAgICAgICAgICAgZXhwb3J0ZWRTY29wZS5leHBvcnRlZC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLmNvbXBpbGF0aW9uLmRpcmVjdGl2ZXMuYWRkKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBzY29wZXMuZXhwb3J0ZWQuZGlyZWN0aXZlcy5hZGQoZW50cnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBvcnRlZFNjb3BlLmV4cG9ydGVkLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLmNvbXBpbGF0aW9uLnBpcGVzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgc2NvcGVzLmV4cG9ydGVkLnBpcGVzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZXROZ01vZHVsZURlZihleHBvcnRlZFR5cGVkKSkge1xuICAgICAgICAgICAgc2NvcGVzLmV4cG9ydGVkLnBpcGVzLmFkZChleHBvcnRlZFR5cGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjb3Blcy5leHBvcnRlZC5kaXJlY3RpdmVzLmFkZChleHBvcnRlZFR5cGVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlZi50cmFuc2l0aXZlQ29tcGlsZVNjb3BlcyA9IHNjb3BlcztcbiAgICByZXR1cm4gc2NvcGVzO1xufVxuZnVuY3Rpb24gZmxhdHRlbiQxKHZhbHVlcykge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBvdXQucHVzaC5hcHBseShvdXQsIF9fc3ByZWFkKGZsYXR0ZW4kMSh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBleHBhbmRNb2R1bGVXaXRoUHJvdmlkZXJzKHZhbHVlKSB7XG4gICAgaWYgKGlzTW9kdWxlV2l0aFByb3ZpZGVycyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm5nTW9kdWxlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc01vZHVsZVdpdGhQcm92aWRlcnModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNb2R1bGUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzTmdNb2R1bGUodmFsdWUpIHtcbiAgICByZXR1cm4gISFnZXROZ01vZHVsZURlZih2YWx1ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29tcGlsZSBhbiBBbmd1bGFyIGNvbXBvbmVudCBhY2NvcmRpbmcgdG8gaXRzIGRlY29yYXRvciBtZXRhZGF0YSwgYW5kIHBhdGNoIHRoZSByZXN1bHRpbmdcbiAqIG5nQ29tcG9uZW50RGVmIG9udG8gdGhlIGNvbXBvbmVudCB0eXBlLlxuICpcbiAqIENvbXBpbGF0aW9uIG1heSBiZSBhc3luY2hyb25vdXMgKGR1ZSB0byB0aGUgbmVlZCB0byByZXNvbHZlIFVSTHMgZm9yIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgb3JcbiAqIG90aGVyIHJlc291cmNlcywgZm9yIGV4YW1wbGUpLiBJbiB0aGUgZXZlbnQgdGhhdCBjb21waWxhdGlvbiBpcyBub3QgaW1tZWRpYXRlLCBgY29tcGlsZUNvbXBvbmVudGBcbiAqIHdpbGwgZW5xdWV1ZSByZXNvdXJjZSByZXNvbHV0aW9uIGludG8gYSBnbG9iYWwgcXVldWUgYW5kIHdpbGwgZmFpbCB0byByZXR1cm4gdGhlIGBuZ0NvbXBvbmVudERlZmBcbiAqIHVudGlsIHRoZSBnbG9iYWwgcXVldWUgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIGNhbGwgdG8gYHJlc29sdmVDb21wb25lbnRSZXNvdXJjZXNgLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcG9uZW50KHR5cGUsIG1ldGFkYXRhKSB7XG4gICAgdmFyIG5nQ29tcG9uZW50RGVmID0gbnVsbDtcbiAgICAvLyBNZXRhZGF0YSBtYXkgaGF2ZSByZXNvdXJjZXMgd2hpY2ggbmVlZCB0byBiZSByZXNvbHZlZC5cbiAgICBtYXliZVF1ZXVlUmVzb2x1dGlvbk9mQ29tcG9uZW50UmVzb3VyY2VzKG1ldGFkYXRhKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgTkdfQ09NUE9ORU5UX0RFRiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21waWxlciA9IGdldENvbXBpbGVyRmFjYWRlKCk7XG4gICAgICAgICAgICBpZiAobmdDb21wb25lbnREZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50TmVlZHNSZXNvbHV0aW9uKG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBbXCJDb21wb25lbnQgJ1wiICsgc3RyaW5naWZ5KHR5cGUpICsgXCInIGlzIG5vdCByZXNvbHZlZDpcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IucHVzaChcIiAtIHRlbXBsYXRlVXJsOiBcIiArIHN0cmluZ2lmeShtZXRhZGF0YS50ZW1wbGF0ZVVybCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5zdHlsZVVybHMgJiYgbWV0YWRhdGEuc3R5bGVVcmxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IucHVzaChcIiAtIHN0eWxlVXJsczogXCIgKyBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS5zdHlsZVVybHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5wdXNoKFwiRGlkIHlvdSBydW4gYW5kIHdhaXQgZm9yICdyZXNvbHZlQ29tcG9uZW50UmVzb3VyY2VzKCknP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfX2Fzc2lnbih7fSwgZGlyZWN0aXZlTWV0YWRhdGEodHlwZSwgbWV0YWRhdGEpLCB7IHRlbXBsYXRlOiBtZXRhZGF0YS50ZW1wbGF0ZSB8fCAnJywgcHJlc2VydmVXaGl0ZXNwYWNlczogbWV0YWRhdGEucHJlc2VydmVXaGl0ZXNwYWNlcyB8fCBmYWxzZSwgc3R5bGVzOiBtZXRhZGF0YS5zdHlsZXMgfHwgRU1QVFlfQVJSQVksIGFuaW1hdGlvbnM6IG1ldGFkYXRhLmFuaW1hdGlvbnMsIHZpZXdRdWVyaWVzOiBleHRyYWN0UXVlcmllc01ldGFkYXRhKGdldFJlZmxlY3QoKS5wcm9wTWV0YWRhdGEodHlwZSksIGlzVmlld1F1ZXJ5KSwgZGlyZWN0aXZlczogbmV3IE1hcCgpLCBwaXBlczogbmV3IE1hcCgpLCBlbmNhcHN1bGF0aW9uOiBtZXRhZGF0YS5lbmNhcHN1bGF0aW9uIHx8IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLCB2aWV3UHJvdmlkZXJzOiBtZXRhZGF0YS52aWV3UHJvdmlkZXJzIHx8IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgbmdDb21wb25lbnREZWYgPSBjb21waWxlci5jb21waWxlQ29tcG9uZW50KGFuZ3VsYXJDb3JlRW52LCBcIm5nOi8vXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIi90ZW1wbGF0ZS5odG1sXCIsIG1ldGEpO1xuICAgICAgICAgICAgICAgIC8vIElmIGNvbXBvbmVudCBjb21waWxhdGlvbiBpcyBhc3luYywgdGhlbiB0aGUgQE5nTW9kdWxlIGFubm90YXRpb24gd2hpY2ggZGVjbGFyZXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBleGVjdXRlIGFuZCBzZXQgYW4gbmdTZWxlY3RvclNjb3BlIHByb3BlcnR5IG9uIHRoZSBjb21wb25lbnQgdHlwZS4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29tcG9uZW50IHRvIHBhdGNoIGl0c2VsZiB3aXRoIGRpcmVjdGl2ZURlZnMgZnJvbSB0aGUgbW9kdWxlIGFmdGVyIGl0XG4gICAgICAgICAgICAgICAgLy8gZmluaXNoZXMgY29tcGlsaW5nLlxuICAgICAgICAgICAgICAgIGlmIChoYXNTZWxlY3RvclNjb3BlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29wZXMgPSB0cmFuc2l0aXZlU2NvcGVzRm9yKHR5cGUubmdTZWxlY3RvclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hDb21wb25lbnREZWZXaXRoU2NvcGUobmdDb21wb25lbnREZWYsIHNjb3Blcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5nQ29tcG9uZW50RGVmO1xuICAgICAgICB9LFxuICAgICAgICAvLyBNYWtlIHRoZSBwcm9wZXJ0eSBjb25maWd1cmFibGUgaW4gZGV2IG1vZGUgdG8gYWxsb3cgb3ZlcnJpZGluZyBpbiB0ZXN0c1xuICAgICAgICBjb25maWd1cmFibGU6ICEhbmdEZXZNb2RlLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3JTY29wZShjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Lm5nU2VsZWN0b3JTY29wZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDb21waWxlIGFuIEFuZ3VsYXIgZGlyZWN0aXZlIGFjY29yZGluZyB0byBpdHMgZGVjb3JhdG9yIG1ldGFkYXRhLCBhbmQgcGF0Y2ggdGhlIHJlc3VsdGluZ1xuICogbmdEaXJlY3RpdmVEZWYgb250byB0aGUgY29tcG9uZW50IHR5cGUuXG4gKlxuICogSW4gdGhlIGV2ZW50IHRoYXQgY29tcGlsYXRpb24gaXMgbm90IGltbWVkaWF0ZSwgYGNvbXBpbGVEaXJlY3RpdmVgIHdpbGwgcmV0dXJuIGEgYFByb21pc2VgIHdoaWNoXG4gKiB3aWxsIHJlc29sdmUgd2hlbiBjb21waWxhdGlvbiBjb21wbGV0ZXMgYW5kIHRoZSBkaXJlY3RpdmUgYmVjb21lcyB1c2FibGUuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmUodHlwZSwgZGlyZWN0aXZlKSB7XG4gICAgdmFyIG5nRGlyZWN0aXZlRGVmID0gbnVsbDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgTkdfRElSRUNUSVZFX0RFRiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChuZ0RpcmVjdGl2ZURlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBmYWNhZGUgPSBkaXJlY3RpdmVNZXRhZGF0YSh0eXBlLCBkaXJlY3RpdmUpO1xuICAgICAgICAgICAgICAgIG5nRGlyZWN0aXZlRGVmID0gZ2V0Q29tcGlsZXJGYWNhZGUoKS5jb21waWxlRGlyZWN0aXZlKGFuZ3VsYXJDb3JlRW52LCBcIm5nOi8vXCIgKyAodHlwZSAmJiB0eXBlLm5hbWUpICsgXCIvbmdEaXJlY3RpdmVEZWYuanNcIiwgZmFjYWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZ0RpcmVjdGl2ZURlZjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTWFrZSB0aGUgcHJvcGVydHkgY29uZmlndXJhYmxlIGluIGRldiBtb2RlIHRvIGFsbG93IG92ZXJyaWRpbmcgaW4gdGVzdHNcbiAgICAgICAgY29uZmlndXJhYmxlOiAhIW5nRGV2TW9kZSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4dGVuZHNEaXJlY3RseUZyb21PYmplY3QodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodHlwZS5wcm90b3R5cGUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuLyoqXG4gKiBFeHRyYWN0IHRoZSBgUjNEaXJlY3RpdmVNZXRhZGF0YWAgZm9yIGEgcGFydGljdWxhciBkaXJlY3RpdmUgKGVpdGhlciBhIGBEaXJlY3RpdmVgIG9yIGFcbiAqIGBDb21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aXZlTWV0YWRhdGEodHlwZSwgbWV0YWRhdGEpIHtcbiAgICAvLyBSZWZsZWN0IGlucHV0cyBhbmQgb3V0cHV0cy5cbiAgICB2YXIgcHJvcE1ldGFkYXRhID0gZ2V0UmVmbGVjdCgpLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICBzZWxlY3RvcjogbWV0YWRhdGEuc2VsZWN0b3IsXG4gICAgICAgIGRlcHM6IHJlZmxlY3REZXBlbmRlbmNpZXModHlwZSksXG4gICAgICAgIGhvc3Q6IG1ldGFkYXRhLmhvc3QgfHwgRU1QVFlfT0JKJDEsXG4gICAgICAgIHByb3BNZXRhZGF0YTogcHJvcE1ldGFkYXRhLFxuICAgICAgICBpbnB1dHM6IG1ldGFkYXRhLmlucHV0cyB8fCBFTVBUWV9BUlJBWSxcbiAgICAgICAgb3V0cHV0czogbWV0YWRhdGEub3V0cHV0cyB8fCBFTVBUWV9BUlJBWSxcbiAgICAgICAgcXVlcmllczogZXh0cmFjdFF1ZXJpZXNNZXRhZGF0YShwcm9wTWV0YWRhdGEsIGlzQ29udGVudFF1ZXJ5KSxcbiAgICAgICAgbGlmZWN5Y2xlOiB7XG4gICAgICAgICAgICB1c2VzT25DaGFuZ2VzOiB0eXBlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlU291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgdXNlc0luaGVyaXRhbmNlOiAhZXh0ZW5kc0RpcmVjdGx5RnJvbU9iamVjdCh0eXBlKSxcbiAgICAgICAgZXhwb3J0QXM6IG1ldGFkYXRhLmV4cG9ydEFzIHx8IG51bGwsXG4gICAgICAgIHByb3ZpZGVyczogbWV0YWRhdGEucHJvdmlkZXJzIHx8IG51bGwsXG4gICAgfTtcbn1cbnZhciBFTVBUWV9PQkokMSA9IHt9O1xuZnVuY3Rpb24gY29udmVydFRvUjNRdWVyeVByZWRpY2F0ZShzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnID8gc3BsaXRCeUNvbW1hKHNlbGVjdG9yKSA6IHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKHByb3BlcnR5TmFtZSwgYW5uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHByZWRpY2F0ZTogY29udmVydFRvUjNRdWVyeVByZWRpY2F0ZShhbm4uc2VsZWN0b3IpLFxuICAgICAgICBkZXNjZW5kYW50czogYW5uLmRlc2NlbmRhbnRzLFxuICAgICAgICBmaXJzdDogYW5uLmZpcnN0LFxuICAgICAgICByZWFkOiBhbm4ucmVhZCA/IGFubi5yZWFkIDogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYWN0UXVlcmllc01ldGFkYXRhKHByb3BNZXRhZGF0YSwgaXNRdWVyeUFubikge1xuICAgIHZhciBxdWVyaWVzTWV0YSA9IFtdO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChwcm9wTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGFbZmllbGRdLmZvckVhY2goZnVuY3Rpb24gKGFubikge1xuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5QW5uKGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllc01ldGEucHVzaChjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEoZmllbGQsIGFubikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgX2xvb3BfMShmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyaWVzTWV0YTtcbn1cbmZ1bmN0aW9uIGlzQ29udGVudFF1ZXJ5KHZhbHVlKSB7XG4gICAgdmFyIG5hbWUgPSB2YWx1ZS5uZ01ldGFkYXRhTmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ0NvbnRlbnRDaGlsZCcgfHwgbmFtZSA9PT0gJ0NvbnRlbnRDaGlsZHJlbic7XG59XG5mdW5jdGlvbiBpc1ZpZXdRdWVyeSh2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gdmFsdWUubmdNZXRhZGF0YU5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdWaWV3Q2hpbGQnIHx8IG5hbWUgPT09ICdWaWV3Q2hpbGRyZW4nO1xufVxuZnVuY3Rpb24gc3BsaXRCeUNvbW1hKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwaWVjZSkgeyByZXR1cm4gcGllY2UudHJpbSgpOyB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb21waWxlIGFuIEFuZ3VsYXIgaW5qZWN0YWJsZSBhY2NvcmRpbmcgdG8gaXRzIGBJbmplY3RhYmxlYCBtZXRhZGF0YSwgYW5kIHBhdGNoIHRoZSByZXN1bHRpbmdcbiAqIGBuZ0luamVjdGFibGVEZWZgIG9udG8gdGhlIGluamVjdGFibGUgdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUluamVjdGFibGUodHlwZSwgc3JjTWV0YSkge1xuICAgIHZhciBkZWYgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBOR19JTkpFQ1RBQkxFX0RFRiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0YV8xID0gc3JjTWV0YSB8fCB7IHByb3ZpZGVkSW46IG51bGwgfTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQVByb3ZpZGVyID0gaXNVc2VDbGFzc1Byb3ZpZGVyKG1ldGFfMSkgfHwgaXNVc2VGYWN0b3J5UHJvdmlkZXIobWV0YV8xKSB8fFxuICAgICAgICAgICAgICAgICAgICBpc1VzZVZhbHVlUHJvdmlkZXIobWV0YV8xKSB8fCBpc1VzZUV4aXN0aW5nUHJvdmlkZXIobWV0YV8xKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGlsZXJNZXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkSW46IG1ldGFfMS5wcm92aWRlZEluLFxuICAgICAgICAgICAgICAgICAgICBjdG9yRGVwczogcmVmbGVjdERlcGVuZGVuY2llcyh0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRlcHM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKChpc1VzZUNsYXNzUHJvdmlkZXIobWV0YV8xKSB8fCBpc1VzZUZhY3RvcnlQcm92aWRlcihtZXRhXzEpKSAmJiBtZXRhXzEuZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVyTWV0YS51c2VyRGVwcyA9IGNvbnZlcnREZXBlbmRlbmNpZXMobWV0YV8xLmRlcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGUgdXNlciBzcGVjaWZpZXMgYSB0eXBlIHByb3ZpZGVyLCB0cmVhdCBpdCBhcyB7cHJvdmlkZTogWCwgdXNlQ2xhc3M6IFh9LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVwcyB3aWxsIGhhdmUgYmVlbiByZWZsZWN0ZWQgYWJvdmUsIGNhdXNpbmcgdGhlIGZhY3RvcnkgdG8gY3JlYXRlIHRoZSBjbGFzcyBieVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0cyBjb25zdHJ1Y3RvciB3aXRoIGluamVjdGVkIGRlcHMuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVyTWV0YS51c2VDbGFzcyA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVXNlQ2xhc3NQcm92aWRlcihtZXRhXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHVzZUNsYXNzLCBhbmQgbWF5IG9yIG1heSBub3QgaGF2ZSBwcm92aWRlZCBkZXBzLlxuICAgICAgICAgICAgICAgICAgICBjb21waWxlck1ldGEudXNlQ2xhc3MgPSBtZXRhXzEudXNlQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVXNlVmFsdWVQcm92aWRlcihtZXRhXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHVzZVZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBjb21waWxlck1ldGEudXNlVmFsdWUgPSBtZXRhXzEudXNlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVXNlRmFjdG9yeVByb3ZpZGVyKG1ldGFfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgZXhwbGljaXRseSBzcGVjaWZpZWQgdXNlRmFjdG9yeS5cbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZXJNZXRhLnVzZUZhY3RvcnkgPSBtZXRhXzEudXNlRmFjdG9yeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNVc2VFeGlzdGluZ1Byb3ZpZGVyKG1ldGFfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgZXhwbGljaXRseSBzcGVjaWZpZWQgdXNlRXhpc3RpbmcuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVyTWV0YS51c2VFeGlzdGluZyA9IG1ldGFfMS51c2VFeGlzdGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGhhcHBlbiAtIGVpdGhlciBoYXNBUHJvdmlkZXIgd2lsbCBiZSBmYWxzZSwgb3Igb25lIG9mIHRoZSBwcm92aWRlcnMgd2lsbCBiZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlIHN0YXRlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmID0gZ2V0Q29tcGlsZXJGYWNhZGUoKS5jb21waWxlSW5qZWN0YWJsZShhbmd1bGFyQ29yZUVudiwgXCJuZzovL1wiICsgdHlwZS5uYW1lICsgXCIvbmdJbmplY3RhYmxlRGVmLmpzXCIsIGNvbXBpbGVyTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxudmFyIMm1MCQxID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eTtcbnZhciBVU0VfVkFMVUUkMSA9IGdldENsb3N1cmVTYWZlUHJvcGVydHkoeyBwcm92aWRlOiBTdHJpbmcsIHVzZVZhbHVlOiDJtTAkMSB9KTtcbmZ1bmN0aW9uIGlzVXNlQ2xhc3NQcm92aWRlcihtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzVXNlVmFsdWVQcm92aWRlcihtZXRhKSB7XG4gICAgcmV0dXJuIFVTRV9WQUxVRSQxIGluIG1ldGE7XG59XG5mdW5jdGlvbiBpc1VzZUZhY3RvcnlQcm92aWRlcihtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEudXNlRmFjdG9yeSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNVc2VFeGlzdGluZ1Byb3ZpZGVyKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YS51c2VFeGlzdGluZyAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb21waWxlUGlwZSh0eXBlLCBtZXRhKSB7XG4gICAgdmFyIG5nUGlwZURlZiA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIE5HX1BJUEVfREVGLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG5nUGlwZURlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5nUGlwZURlZiA9IGdldENvbXBpbGVyRmFjYWRlKCkuY29tcGlsZVBpcGUoYW5ndWxhckNvcmVFbnYsIFwibmc6Ly9cIiArIHN0cmluZ2lmeSQxKHR5cGUpICsgXCIvbmdQaXBlRGVmLmpzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiByZWZsZWN0RGVwZW5kZW5jaWVzKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBwaXBlTmFtZTogbWV0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBwdXJlOiBtZXRhLnB1cmUgIT09IHVuZGVmaW5lZCA/IG1ldGEucHVyZSA6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZ1BpcGVEZWY7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1ha2UgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYWJsZSBpbiBkZXYgbW9kZSB0byBhbGxvdyBvdmVycmlkaW5nIGluIHRlc3RzXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogISFuZ0Rldk1vZGUsXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBpdnlFbmFibGVkID0gdHJ1ZTtcbnZhciBSM19DT01QSUxFX0NPTVBPTkVOVCA9IGNvbXBpbGVDb21wb25lbnQ7XG52YXIgUjNfQ09NUElMRV9ESVJFQ1RJVkUgPSBjb21waWxlRGlyZWN0aXZlO1xudmFyIFIzX0NPTVBJTEVfSU5KRUNUQUJMRSA9IGNvbXBpbGVJbmplY3RhYmxlO1xudmFyIFIzX0NPTVBJTEVfTkdNT0RVTEUgPSBjb21waWxlTmdNb2R1bGU7XG52YXIgUjNfQ09NUElMRV9QSVBFID0gY29tcGlsZVBpcGU7XG52YXIgUjNfQ09NUElMRV9OR01PRFVMRV9ERUZTID0gY29tcGlsZU5nTW9kdWxlRGVmcztcbnZhciBSM19QQVRDSF9DT01QT05FTlRfREVGX1dUSUhfU0NPUEUgPSBwYXRjaENvbXBvbmVudERlZldpdGhTY29wZTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIFIzX0NPTVBJTEVfQ09NUE9ORU5UX19QT1NUX05HQ0NfXyA9IFIzX0NPTVBJTEVfQ09NUE9ORU5UO1xudmFyIFIzX0NPTVBJTEVfRElSRUNUSVZFX19QT1NUX05HQ0NfXyA9IFIzX0NPTVBJTEVfRElSRUNUSVZFO1xudmFyIFIzX0NPTVBJTEVfSU5KRUNUQUJMRV9fUE9TVF9OR0NDX18gPSBSM19DT01QSUxFX0lOSkVDVEFCTEU7XG52YXIgUjNfQ09NUElMRV9OR01PRFVMRV9fUE9TVF9OR0NDX18gPSBSM19DT01QSUxFX05HTU9EVUxFO1xudmFyIFIzX0NPTVBJTEVfUElQRV9fUE9TVF9OR0NDX18gPSBSM19DT01QSUxFX1BJUEU7XG52YXIgaXZ5RW5hYmxlX19QT1NUX05HQ0NfXyA9IGl2eUVuYWJsZWQ7XG52YXIgUjNfQ09NUElMRV9DT01QT05FTlRfX1BSRV9OR0NDX18gPSBub29wO1xudmFyIFIzX0NPTVBJTEVfRElSRUNUSVZFX19QUkVfTkdDQ19fID0gbm9vcDtcbnZhciBSM19DT01QSUxFX0lOSkVDVEFCTEVfX1BSRV9OR0NDX18gPSBwcmVSM0luamVjdGFibGVDb21waWxlO1xudmFyIFIzX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9OR0NDX18gPSBwcmVSM05nTW9kdWxlQ29tcGlsZTtcbnZhciBSM19DT01QSUxFX1BJUEVfX1BSRV9OR0NDX18gPSBub29wO1xudmFyIGl2eUVuYWJsZV9fUFJFX05HQ0NfXyA9IGZhbHNlO1xudmFyIGl2eUVuYWJsZWQkMSA9IGl2eUVuYWJsZV9fUFJFX05HQ0NfXztcbnZhciBSM19DT01QSUxFX0NPTVBPTkVOVCQxID0gUjNfQ09NUElMRV9DT01QT05FTlRfX1BSRV9OR0NDX187XG52YXIgUjNfQ09NUElMRV9ESVJFQ1RJVkUkMSA9IFIzX0NPTVBJTEVfRElSRUNUSVZFX19QUkVfTkdDQ19fO1xudmFyIFIzX0NPTVBJTEVfSU5KRUNUQUJMRSQxID0gUjNfQ09NUElMRV9JTkpFQ1RBQkxFX19QUkVfTkdDQ19fO1xudmFyIFIzX0NPTVBJTEVfTkdNT0RVTEUkMSA9IFIzX0NPTVBJTEVfTkdNT0RVTEVfX1BSRV9OR0NDX187XG52YXIgUjNfQ09NUElMRV9QSVBFJDEgPSBSM19DT01QSUxFX1BJUEVfX1BSRV9OR0NDX187XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdsdWUgY29kZSB3aGljaCBzaG91bGQgYmUgcmVtb3ZlZCBhZnRlciBJdnkgaXMgZGVmYXVsdCAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBwcmVSM05nTW9kdWxlQ29tcGlsZShtb2R1bGVUeXBlLCBtZXRhZGF0YSkge1xuICAgIHZhciBpbXBvcnRzID0gKG1ldGFkYXRhICYmIG1ldGFkYXRhLmltcG9ydHMpIHx8IFtdO1xuICAgIGlmIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5leHBvcnRzKSB7XG4gICAgICAgIGltcG9ydHMgPSBfX3NwcmVhZChpbXBvcnRzLCBbbWV0YWRhdGEuZXhwb3J0c10pO1xuICAgIH1cbiAgICBtb2R1bGVUeXBlLm5nSW5qZWN0b3JEZWYgPSBkZWZpbmVJbmplY3Rvcih7XG4gICAgICAgIGZhY3Rvcnk6IGNvbnZlcnRJbmplY3RhYmxlUHJvdmlkZXJUb0ZhY3RvcnkobW9kdWxlVHlwZSwgeyB1c2VDbGFzczogbW9kdWxlVHlwZSB9KSxcbiAgICAgICAgcHJvdmlkZXJzOiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5wcm92aWRlcnMsXG4gICAgICAgIGltcG9ydHM6IGltcG9ydHMsXG4gICAgfSk7XG59XG52YXIgybUwJDIgPSBnZXRDbG9zdXJlU2FmZVByb3BlcnR5O1xudmFyIFVTRV9WQUxVRSQyID0gZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSh7IHByb3ZpZGU6IFN0cmluZywgdXNlVmFsdWU6IMm1MCQyIH0pO1xudmFyIEVNUFRZX0FSUkFZJDMgPSBbXTtcbmZ1bmN0aW9uIGNvbnZlcnRJbmplY3RhYmxlUHJvdmlkZXJUb0ZhY3RvcnkodHlwZSwgcHJvdmlkZXIpIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHZhciByZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgdmFyIGRlcHNfMSA9IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucGFyYW1ldGVycyh0eXBlKTtcbiAgICAgICAgLy8gVE9ETyAtIGNvbnZlcnQgdG8gZmxhZ3MuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgKHR5cGUuYmluZC5hcHBseSh0eXBlLCBfX3NwcmVhZChbdm9pZCAwXSwgaW5qZWN0QXJncyhkZXBzXzEpKSkpKCk7IH07XG4gICAgfVxuICAgIGlmIChVU0VfVkFMVUUkMiBpbiBwcm92aWRlcikge1xuICAgICAgICB2YXIgdmFsdWVQcm92aWRlcl8xID0gcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZVByb3ZpZGVyXzEudXNlVmFsdWU7IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUV4aXN0aW5nKSB7XG4gICAgICAgIHZhciBleGlzdGluZ1Byb3ZpZGVyXzEgPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluamVjdChleGlzdGluZ1Byb3ZpZGVyXzEudXNlRXhpc3RpbmcpOyB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgIHZhciBmYWN0b3J5UHJvdmlkZXJfMSA9IHByb3ZpZGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFjdG9yeVByb3ZpZGVyXzEudXNlRmFjdG9yeS5hcHBseShmYWN0b3J5UHJvdmlkZXJfMSwgX19zcHJlYWQoaW5qZWN0QXJncyhmYWN0b3J5UHJvdmlkZXJfMS5kZXBzIHx8IEVNUFRZX0FSUkFZJDMpKSk7IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc1Byb3ZpZGVyXzEgPSBwcm92aWRlcjtcbiAgICAgICAgdmFyIGRlcHNfMiA9IHByb3ZpZGVyLmRlcHM7XG4gICAgICAgIGlmICghZGVwc18yKSB7XG4gICAgICAgICAgICB2YXIgcmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IG5ldyBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgICAgICBkZXBzXzIgPSByZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKChfYSA9IGNsYXNzUHJvdmlkZXJfMS51c2VDbGFzcykuYmluZC5hcHBseShfYSwgX19zcHJlYWQoW3ZvaWQgMF0sIGluamVjdEFyZ3MoZGVwc18yKSkpKSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRlcHNfMyA9IHByb3ZpZGVyLmRlcHM7XG4gICAgICAgIGlmICghZGVwc18zKSB7XG4gICAgICAgICAgICB2YXIgcmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IG5ldyBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgICAgICBkZXBzXzMgPSByZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAodHlwZS5iaW5kLmFwcGx5KHR5cGUsIF9fc3ByZWFkKFt2b2lkIDBdLCBpbmplY3RBcmdzKGRlcHNfMykpKSkoKTsgfTtcbiAgICB9XG59XG4vKipcbiAqIFN1cHBvcnRzIEBJbmplY3RhYmxlKCkgaW4gSklUIG1vZGUgZm9yIFJlbmRlcjIuXG4gKi9cbmZ1bmN0aW9uIHByZVIzSW5qZWN0YWJsZUNvbXBpbGUoaW5qZWN0YWJsZVR5cGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb3ZpZGVkSW4gIT09IHVuZGVmaW5lZCAmJiAhZ2V0SW5qZWN0YWJsZURlZihpbmplY3RhYmxlVHlwZSkpIHtcbiAgICAgICAgaW5qZWN0YWJsZVR5cGUubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBwcm92aWRlZEluOiBvcHRpb25zLnByb3ZpZGVkSW4sXG4gICAgICAgICAgICBmYWN0b3J5OiBjb252ZXJ0SW5qZWN0YWJsZVByb3ZpZGVyVG9GYWN0b3J5KGluamVjdGFibGVUeXBlLCBvcHRpb25zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFR5cGUgb2YgdGhlIERpcmVjdGl2ZSBtZXRhZGF0YS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBEaXJlY3RpdmUgPSBtYWtlRGVjb3JhdG9yKCdEaXJlY3RpdmUnLCBmdW5jdGlvbiAoZGlyKSB7XG4gICAgaWYgKGRpciA9PT0gdm9pZCAwKSB7IGRpciA9IHt9OyB9XG4gICAgcmV0dXJuIGRpcjtcbn0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodHlwZSwgbWV0YSkgeyByZXR1cm4gUjNfQ09NUElMRV9ESVJFQ1RJVkUkMSh0eXBlLCBtZXRhKTsgfSk7XG4vKipcbiAqIENvbXBvbmVudCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICpcbiAqIEBBbm5vdGF0aW9uXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDb21wb25lbnQgPSBtYWtlRGVjb3JhdG9yKCdDb21wb25lbnQnLCBmdW5jdGlvbiAoYykge1xuICAgIGlmIChjID09PSB2b2lkIDApIHsgYyA9IHt9OyB9XG4gICAgcmV0dXJuIChfX2Fzc2lnbih7IGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCB9LCBjKSk7XG59LCBEaXJlY3RpdmUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHR5cGUsIG1ldGEpIHsgcmV0dXJuIFIzX0NPTVBJTEVfQ09NUE9ORU5UJDEodHlwZSwgbWV0YSk7IH0pO1xuLyoqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUGlwZSA9IG1ha2VEZWNvcmF0b3IoJ1BpcGUnLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gKF9fYXNzaWduKHsgcHVyZTogdHJ1ZSB9LCBwKSk7IH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodHlwZSwgbWV0YSkgeyByZXR1cm4gUjNfQ09NUElMRV9QSVBFJDEodHlwZSwgbWV0YSk7IH0pO1xudmFyIGluaXRpYWxpemVCYXNlRGVmID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgaW5oZXJpdGVkQmFzZURlZiA9IGNvbnN0cnVjdG9yLm5nQmFzZURlZjtcbiAgICB2YXIgYmFzZURlZiA9IGNvbnN0cnVjdG9yLm5nQmFzZURlZiA9IHtcbiAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgb3V0cHV0czoge30sXG4gICAgICAgIGRlY2xhcmVkSW5wdXRzOiB7fSxcbiAgICB9O1xuICAgIGlmIChpbmhlcml0ZWRCYXNlRGVmKSB7XG4gICAgICAgIGZpbGxQcm9wZXJ0aWVzKGJhc2VEZWYuaW5wdXRzLCBpbmhlcml0ZWRCYXNlRGVmLmlucHV0cyk7XG4gICAgICAgIGZpbGxQcm9wZXJ0aWVzKGJhc2VEZWYub3V0cHV0cywgaW5oZXJpdGVkQmFzZURlZi5vdXRwdXRzKTtcbiAgICAgICAgZmlsbFByb3BlcnRpZXMoYmFzZURlZi5kZWNsYXJlZElucHV0cywgaW5oZXJpdGVkQmFzZURlZi5kZWNsYXJlZElucHV0cyk7XG4gICAgfVxufTtcbi8qKlxuICogRG9lcyB0aGUgd29yayBvZiBjcmVhdGluZyB0aGUgYG5nQmFzZURlZmAgcHJvcGVydHkgZm9yIHRoZSBASW5wdXQgYW5kIEBPdXRwdXQgZGVjb3JhdG9ycy5cbiAqIEBwYXJhbSBrZXkgXCJpbnB1dHNcIiBvciBcIm91dHB1dHNcIlxuICovXG52YXIgdXBkYXRlQmFzZURlZkZyb21JT1Byb3AgPSBmdW5jdGlvbiAoZ2V0UHJvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShOR19CQVNFX0RFRikpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVCYXNlRGVmKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VEZWYgPSBjb25zdHJ1Y3Rvci5uZ0Jhc2VEZWY7XG4gICAgICAgIHZhciBkZWZQcm9wID0gZ2V0UHJvcChiYXNlRGVmKTtcbiAgICAgICAgZGVmUHJvcFtuYW1lXSA9IGFyZ3NbMF07XG4gICAgfTtcbn07XG4vKipcbiAqIEBBbm5vdGF0aW9uXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBJbnB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdJbnB1dCcsIGZ1bmN0aW9uIChiaW5kaW5nUHJvcGVydHlOYW1lKSB7IHJldHVybiAoeyBiaW5kaW5nUHJvcGVydHlOYW1lOiBiaW5kaW5nUHJvcGVydHlOYW1lIH0pOyB9LCB1bmRlZmluZWQsIHVwZGF0ZUJhc2VEZWZGcm9tSU9Qcm9wKGZ1bmN0aW9uIChiYXNlRGVmKSB7IHJldHVybiBiYXNlRGVmLmlucHV0cyB8fCB7fTsgfSkpO1xuLyoqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgT3V0cHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ091dHB1dCcsIGZ1bmN0aW9uIChiaW5kaW5nUHJvcGVydHlOYW1lKSB7IHJldHVybiAoeyBiaW5kaW5nUHJvcGVydHlOYW1lOiBiaW5kaW5nUHJvcGVydHlOYW1lIH0pOyB9LCB1bmRlZmluZWQsIHVwZGF0ZUJhc2VEZWZGcm9tSU9Qcm9wKGZ1bmN0aW9uIChiYXNlRGVmKSB7IHJldHVybiBiYXNlRGVmLm91dHB1dHMgfHwge307IH0pKTtcbi8qKlxuICogQEFubm90YXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEhvc3RCaW5kaW5nID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RCaW5kaW5nJywgZnVuY3Rpb24gKGhvc3RQcm9wZXJ0eU5hbWUpIHsgcmV0dXJuICh7IGhvc3RQcm9wZXJ0eU5hbWU6IGhvc3RQcm9wZXJ0eU5hbWUgfSk7IH0pO1xuLyoqXG4gKiBCaW5kcyBhIENTUyBldmVudCB0byBhIGhvc3QgbGlzdGVuZXIgYW5kIHN1cHBsaWVzIGNvbmZpZ3VyYXRpb24gbWV0YWRhdGEuXG4gKiBBbmd1bGFyIGludm9rZXMgdGhlIHN1cHBsaWVkIGhhbmRsZXIgbWV0aG9kIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBlbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50LFxuICogYW5kIHVwZGF0ZXMgdGhlIGJvdW5kIGVsZW1lbnQgd2l0aCB0aGUgcmVzdWx0LlxuICogSWYgdGhlIGhhbmRsZXIgbWV0aG9kIHJldHVybnMgZmFsc2UsIGFwcGxpZXMgYHByZXZlbnREZWZhdWx0YCBvbiB0aGUgYm91bmQgZWxlbWVudC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZWNsYXJlcyBhIGRpcmVjdGl2ZVxuICogdGhhdCBhdHRhY2hlcyBhIGNsaWNrIGxpc3RlbmVyIHRvIGEgYnV0dG9uIGFuZCBjb3VudHMgY2xpY2tzLlxuICpcbiAqIGBgYFxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdidXR0b25bY291bnRpbmddJ30pXG4gKiBjbGFzcyBDb3VudENsaWNrcyB7XG4gKiAgIG51bWJlck9mQ2xpY2tzID0gMDtcbiAqXG4gKiAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXG4gKiAgIG9uQ2xpY2soYnRuKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2J1dHRvbicsIGJ0biwgJ251bWJlciBvZiBjbGlja3M6JywgdGhpcy5udW1iZXJPZkNsaWNrcysrKTtcbiAqICB9XG4gKiB9XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAqICAgdGVtcGxhdGU6ICc8YnV0dG9uIGNvdW50aW5nPkluY3JlbWVudDwvYnV0dG9uPicsXG4gKiB9KVxuICogY2xhc3MgQXBwIHt9XG4gKiBgYGBcbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsIGZ1bmN0aW9uIChldmVudE5hbWUsIGFyZ3MpIHsgcmV0dXJuICh7IGV2ZW50TmFtZTogZXZlbnROYW1lLCBhcmdzOiBhcmdzIH0pOyB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgYWxsb3dzIGFuIE5nTW9kdWxlIHRvIGNvbnRhaW4gdGhlIGZvbGxvd2luZzpcbiAqIC0gTm9uLUFuZ3VsYXIgZWxlbWVudHMgbmFtZWQgd2l0aCBkYXNoIGNhc2UgKGAtYCkuXG4gKiAtIEVsZW1lbnQgcHJvcGVydGllcyBuYW1lZCB3aXRoIGRhc2ggY2FzZSAoYC1gKS5cbiAqIERhc2ggY2FzZSBpcyB0aGUgbmFtaW5nIGNvbnZlbnRpb24gZm9yIGN1c3RvbSBlbGVtZW50cy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDVVNUT01fRUxFTUVOVFNfU0NIRU1BID0ge1xuICAgIG5hbWU6ICdjdXN0b20tZWxlbWVudHMnXG59O1xuLyoqXG4gKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgYWxsb3dzIGFueSBwcm9wZXJ0eSBvbiBhbnkgZWxlbWVudC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBOT19FUlJPUlNfU0NIRU1BID0ge1xuICAgIG5hbWU6ICduby1lcnJvcnMtc2NoZW1hJ1xufTtcbi8qKlxuICogQEFubm90YXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5nTW9kdWxlID0gbWFrZURlY29yYXRvcignTmdNb2R1bGUnLCBmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlOyB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXG4vKipcbiAqIERlY29yYXRvciB0aGF0IG1hcmtzIHRoZSBmb2xsb3dpbmcgY2xhc3MgYXMgYW4gTmdNb2R1bGUsIGFuZCBzdXBwbGllc1xuICogY29uZmlndXJhdGlvbiBtZXRhZGF0YSBmb3IgaXQuXG4gKlxuICogKiBUaGUgYGRlY2xhcmF0aW9uc2AgYW5kIGBlbnRyeUNvbXBvbmVudHNgIG9wdGlvbnMgY29uZmlndXJlIHRoZSBjb21waWxlclxuICogd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJlbG9uZ3MgdG8gdGhlIE5nTW9kdWxlLlxuICogKiBUaGUgYHByb3ZpZGVyc2Agb3B0aW9ucyBjb25maWd1cmVzIHRoZSBOZ01vZHVsZSdzIGluamVjdG9yIHRvIHByb3ZpZGVcbiAqIGRlcGVuZGVuY2llcyB0aGUgTmdNb2R1bGUgbWVtYmVycy5cbiAqICogVGhlIGBpbXBvcnRzYCBhbmQgYGV4cG9ydHNgIG9wdGlvbnMgYnJpbmcgaW4gbWVtYmVycyBmcm9tIG90aGVyIG1vZHVsZXMsIGFuZCBtYWtlXG4gKiB0aGlzIG1vZHVsZSdzIG1lbWJlcnMgYXZhaWxhYmxlIHRvIG90aGVycy5cbiAqL1xuZnVuY3Rpb24gKHR5cGUsIG1ldGEpIHsgcmV0dXJuIFIzX0NPTVBJTEVfTkdNT0RVTEUkMSh0eXBlLCBtZXRhKTsgfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmVwcmVzZW50cyB0aGUgdmVyc2lvbiBvZiBBbmd1bGFyXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmVyc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZXJzaW9uKGZ1bGwpIHtcbiAgICAgICAgdGhpcy5mdWxsID0gZnVsbDtcbiAgICAgICAgdGhpcy5tYWpvciA9IGZ1bGwuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgdGhpcy5taW5vciA9IGZ1bGwuc3BsaXQoJy4nKVsxXTtcbiAgICAgICAgdGhpcy5wYXRjaCA9IGZ1bGwuc3BsaXQoJy4nKS5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBWZXJzaW9uO1xufSgpKTtcbi8qKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVkVSU0lPTiA9IG5ldyBWZXJzaW9uKCc3LjAuNCcpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEluamVjdGFibGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBAQW5ub3RhdGlvblxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSW5qZWN0YWJsZSA9IG1ha2VEZWNvcmF0b3IoJ0luamVjdGFibGUnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodHlwZSwgbWV0YSkgeyByZXR1cm4gUjNfQ09NUElMRV9JTkpFQ1RBQkxFJDEodHlwZSwgbWV0YSk7IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRVJST1JfREVCVUdfQ09OVEVYVCA9ICduZ0RlYnVnQ29udGV4dCc7XG52YXIgRVJST1JfT1JJR0lOQUxfRVJST1IgPSAnbmdPcmlnaW5hbEVycm9yJztcbnZhciBFUlJPUl9MT0dHRVIgPSAnbmdFcnJvckxvZ2dlcic7XG5mdW5jdGlvbiBnZXREZWJ1Z0NvbnRleHQoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3JbRVJST1JfREVCVUdfQ09OVEVYVF07XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5hbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yW0VSUk9SX09SSUdJTkFMX0VSUk9SXTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTG9nZ2VyKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yW0VSUk9SX0xPR0dFUl0gfHwgZGVmYXVsdEVycm9yTG9nZ2VyO1xufVxuZnVuY3Rpb24gZGVmYXVsdEVycm9yTG9nZ2VyKGNvbnNvbGUpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkKHZhbHVlcykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY2VudHJhbGl6ZWQgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBFcnJvckhhbmRsZXJgIHByaW50cyBlcnJvciBtZXNzYWdlcyB0byB0aGUgYGNvbnNvbGVgLiBUb1xuICogaW50ZXJjZXB0IGVycm9yIGhhbmRsaW5nLCB3cml0ZSBhIGN1c3RvbSBleGNlcHRpb24gaGFuZGxlciB0aGF0IHJlcGxhY2VzIHRoaXMgZGVmYXVsdCBhc1xuICogYXBwcm9wcmlhdGUgZm9yIHlvdXIgYXBwLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogY2xhc3MgTXlFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBFcnJvckhhbmRsZXIge1xuICogICBoYW5kbGVFcnJvcihlcnJvcikge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBleGNlcHRpb25cbiAqICAgfVxuICogfVxuICpcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBFcnJvckhhbmRsZXIsIHVzZUNsYXNzOiBNeUVycm9ySGFuZGxlcn1dXG4gKiB9KVxuICogY2xhc3MgTXlNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEVycm9ySGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBjb25zb2xlO1xuICAgIH1cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbEVycm9yID0gdGhpcy5fZmluZE9yaWdpbmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2ZpbmRDb250ZXh0KGVycm9yKTtcbiAgICAgICAgLy8gTm90ZTogQnJvd3NlciBjb25zb2xlcyBzaG93IHRoZSBwbGFjZSBmcm9tIHdoZXJlIGNvbnNvbGUuZXJyb3Igd2FzIGNhbGxlZC5cbiAgICAgICAgLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGdpdmUgdXNlcnMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXG4gICAgICAgIHZhciBlcnJvckxvZ2dlciA9IGdldEVycm9yTG9nZ2VyKGVycm9yKTtcbiAgICAgICAgZXJyb3JMb2dnZXIodGhpcy5fY29uc29sZSwgXCJFUlJPUlwiLCBlcnJvcik7XG4gICAgICAgIGlmIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvckxvZ2dlcih0aGlzLl9jb25zb2xlLCBcIk9SSUdJTkFMIEVSUk9SXCIsIG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBlcnJvckxvZ2dlcih0aGlzLl9jb25zb2xlLCAnRVJST1IgQ09OVEVYVCcsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZENvbnRleHQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGVidWdDb250ZXh0KGVycm9yKSA/IGdldERlYnVnQ29udGV4dChlcnJvcikgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb250ZXh0KGdldE9yaWdpbmFsRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgZSA9IGdldE9yaWdpbmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICB3aGlsZSAoZSAmJiBnZXRPcmlnaW5hbEVycm9yKGUpKSB7XG4gICAgICAgICAgICBlID0gZ2V0T3JpZ2luYWxFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvckhhbmRsZXI7XG59KCkpO1xuZnVuY3Rpb24gd3JhcHBlZEVycm9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICB2YXIgbXNnID0gbWVzc2FnZSArIFwiIGNhdXNlZCBieTogXCIgKyAob3JpZ2luYWxFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gb3JpZ2luYWxFcnJvci5tZXNzYWdlIDogb3JpZ2luYWxFcnJvcik7XG4gICAgdmFyIGVycm9yID0gRXJyb3IobXNnKTtcbiAgICBlcnJvcltFUlJPUl9PUklHSU5BTF9FUlJPUl0gPSBvcmlnaW5hbEVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHJlcy5pbmRleE9mKGtleXNbaV0pID4gLTEpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGtleXNbaV0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgoa2V5cykge1xuICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cy5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgICAgIHZhciB0b2tlblN0cnMgPSByZXZlcnNlZC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHN0cmluZ2lmeShrLnRva2VuKTsgfSk7XG4gICAgICAgIHJldHVybiAnICgnICsgdG9rZW5TdHJzLmpvaW4oJyAtPiAnKSArICcpJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gaW5qZWN0aW9uRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgIHZhciBrZXlzID0gW2tleV07XG4gICAgdmFyIGVyck1zZyA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2Uoa2V5cyk7XG4gICAgdmFyIGVycm9yID0gKG9yaWdpbmFsRXJyb3IgPyB3cmFwcGVkRXJyb3IoZXJyTXNnLCBvcmlnaW5hbEVycm9yKSA6IEVycm9yKGVyck1zZykpO1xuICAgIGVycm9yLmFkZEtleSA9IGFkZEtleTtcbiAgICBlcnJvci5rZXlzID0ga2V5cztcbiAgICBlcnJvci5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xuICAgIGVycm9yLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UgPSBjb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlO1xuICAgIGVycm9yW0VSUk9SX09SSUdJTkFMX0VSUk9SXSA9IG9yaWdpbmFsRXJyb3I7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZnVuY3Rpb24gYWRkS2V5KGluamVjdG9yLCBrZXkpIHtcbiAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgIC8vIE5vdGU6IFRoaXMgdXBkYXRlZCBtZXNzYWdlIHdvbid0IGJlIHJlZmxlY3RlZCBpbiB0aGUgYC5zdGFja2AgcHJvcGVydHlcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdHJ5aW5nIHRvIHJldHJpZXZlIGEgZGVwZW5kZW5jeSBieSBrZXkgZnJvbSB7QGxpbmsgSW5qZWN0b3J9LCBidXQgdGhlXG4gKiB7QGxpbmsgSW5qZWN0b3J9IGRvZXMgbm90IGhhdmUgYSB7QGxpbmsgUHJvdmlkZXJ9IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEEge1xuICogICBjb25zdHJ1Y3RvcihiOkIpIHt9XG4gKiB9XG4gKlxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gbm9Qcm92aWRlckVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uRXJyb3IoaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gc3RyaW5naWZ5KGtleXNbMF0udG9rZW4pO1xuICAgICAgICByZXR1cm4gXCJObyBwcm92aWRlciBmb3IgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gZGVwZW5kZW5jaWVzIGZvcm0gYSBjeWNsZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAqICAge3Byb3ZpZGU6IFwib25lXCIsIHVzZUZhY3Rvcnk6ICh0d28pID0+IFwidHdvXCIsIGRlcHM6IFtbbmV3IEluamVjdChcInR3b1wiKV1dfSxcbiAqICAge3Byb3ZpZGU6IFwidHdvXCIsIHVzZUZhY3Rvcnk6IChvbmUpID0+IFwib25lXCIsIGRlcHM6IFtbbmV3IEluamVjdChcIm9uZVwiKV1dfVxuICogXSk7XG4gKlxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChcIm9uZVwiKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqXG4gKiBSZXRyaWV2aW5nIGBBYCBvciBgQmAgdGhyb3dzIGEgYEN5Y2xpY0RlcGVuZGVuY3lFcnJvcmAgYXMgdGhlIGdyYXBoIGFib3ZlIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZC5cbiAqL1xuZnVuY3Rpb24gY3ljbGljRGVwZW5kZW5jeUVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uRXJyb3IoaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5IVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjb25zdHJ1Y3RpbmcgdHlwZSByZXR1cm5zIHdpdGggYW4gRXJyb3IuXG4gKlxuICogVGhlIGBJbnN0YW50aWF0aW9uRXJyb3JgIGNsYXNzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBlcnJvciBwbHVzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHdoaWNoIGNhdXNlZFxuICogdGhpcyBvYmplY3QgdG8gYmUgaW5zdGFudGlhdGVkLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEEge1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UnKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcblxuICogdHJ5IHtcbiAqICAgaW5qZWN0b3IuZ2V0KEEpO1xuICogfSBjYXRjaCAoZSkge1xuICogICBleHBlY3QoZSBpbnN0YW5jZW9mIEluc3RhbnRpYXRpb25FcnJvcikudG9CZSh0cnVlKTtcbiAqICAgZXhwZWN0KGUub3JpZ2luYWxFeGNlcHRpb24ubWVzc2FnZSkudG9FcXVhbChcIm1lc3NhZ2VcIik7XG4gKiAgIGV4cGVjdChlLm9yaWdpbmFsU3RhY2spLnRvQmVEZWZpbmVkKCk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGlvbkVycm9yKGluamVjdG9yLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywga2V5KSB7XG4gICAgcmV0dXJuIGluamVjdGlvbkVycm9yKGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHN0cmluZ2lmeShrZXlzWzBdLnRva2VuKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRXhjZXB0aW9uLm1lc3NhZ2UgKyBcIjogRXJyb3IgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKSArIFwiLlwiO1xuICAgIH0sIG9yaWdpbmFsRXhjZXB0aW9uKTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gb2JqZWN0IG90aGVyIHRoZW4ge0BsaW5rIFByb3ZpZGVyfSAob3IgYFR5cGVgKSBpcyBwYXNzZWQgdG8ge0BsaW5rIEluamVjdG9yfVxuICogY3JlYXRpb24uXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1wibm90IGEgdHlwZVwiXSkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRQcm92aWRlckVycm9yKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIEVycm9yKFwiSW52YWxpZCBwcm92aWRlciAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFwiICsgcHJvdmlkZXIpO1xufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgY2xhc3MgaGFzIG5vIGFubm90YXRpb24gaW5mb3JtYXRpb24uXG4gKlxuICogTGFjayBvZiBhbm5vdGF0aW9uIGluZm9ybWF0aW9uIHByZXZlbnRzIHRoZSB7QGxpbmsgSW5qZWN0b3J9IGZyb20gZGV0ZXJtaW5pbmcgd2hpY2ggZGVwZW5kZW5jaWVzXG4gKiBuZWVkIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEEge1xuICogICBjb25zdHJ1Y3RvcihiKSB7fVxuICogfVxuICpcbiAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKlxuICogVGhpcyBlcnJvciBpcyBhbHNvIHRocm93biB3aGVuIHRoZSBjbGFzcyBub3QgbWFya2VkIHdpdGgge0BsaW5rIEluamVjdGFibGV9IGhhcyBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgQiB7fVxuICpcbiAqIGNsYXNzIEEge1xuICogICBjb25zdHJ1Y3RvcihiOkIpIHt9IC8vIG5vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXJhbWV0ZXIgdHlwZXMgb2YgQSBpcyBhdmFpbGFibGUgYXQgcnVudGltZS5cbiAqIH1cbiAqXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQSxCXSkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKlxuICovXG5mdW5jdGlvbiBub0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICB2YXIgc2lnbmF0dXJlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFyYW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtc1tpXTtcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXIgfHwgcGFyYW1ldGVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzaWduYXR1cmUucHVzaCgnPycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2gocGFyYW1ldGVyLm1hcChzdHJpbmdpZnkpLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXFwnJyArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArICdcXCcoJyArXG4gICAgICAgIHNpZ25hdHVyZS5qb2luKCcsICcpICsgJykuICcgK1xuICAgICAgICAnTWFrZSBzdXJlIHRoYXQgYWxsIHRoZSBwYXJhbWV0ZXJzIGFyZSBkZWNvcmF0ZWQgd2l0aCBJbmplY3Qgb3IgaGF2ZSB2YWxpZCB0eXBlIGFubm90YXRpb25zIGFuZCB0aGF0IFxcJycgK1xuICAgICAgICBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyAnXFwnIGlzIGRlY29yYXRlZCB3aXRoIEluamVjdGFibGUuJyk7XG59XG4vKipcbiAqIFRocm93biB3aGVuIGdldHRpbmcgYW4gb2JqZWN0IGJ5IGluZGV4LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEEge31cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG4gKlxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldEF0KDEwMCkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKlxuICovXG5mdW5jdGlvbiBvdXRPZkJvdW5kc0Vycm9yKGluZGV4KSB7XG4gICAgcmV0dXJuIEVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIGlzIG91dC1vZi1ib3VuZHMuXCIpO1xufVxuLy8gVE9ETzogYWRkIGEgd29ya2luZyBleGFtcGxlIGFmdGVyIGFscGhhMzggaXMgcmVsZWFzZWRcbi8qKlxuICogVGhyb3duIHdoZW4gYSBtdWx0aSBwcm92aWRlciBhbmQgYSByZWd1bGFyIHByb3ZpZGVyIGFyZSBib3VuZCB0byB0aGUgc2FtZSB0b2tlbi5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gKiAgIHsgcHJvdmlkZTogXCJTdHJpbmdzXCIsIHVzZVZhbHVlOiBcInN0cmluZzFcIiwgbXVsdGk6IHRydWV9LFxuICogICB7IHByb3ZpZGU6IFwiU3RyaW5nc1wiLCB1c2VWYWx1ZTogXCJzdHJpbmcyXCIsIG11bHRpOiBmYWxzZX1cbiAqIF0pKS50b1Rocm93RXJyb3IoKTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBtaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IocHJvdmlkZXIxLCBwcm92aWRlcjIpIHtcbiAgICByZXR1cm4gRXJyb3IoXCJDYW5ub3QgbWl4IG11bHRpIHByb3ZpZGVycyBhbmQgcmVndWxhciBwcm92aWRlcnMsIGdvdDogXCIgKyBwcm92aWRlcjEgKyBcIiBcIiArIHByb3ZpZGVyMik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSB1bmlxdWUgb2JqZWN0IHVzZWQgZm9yIHJldHJpZXZpbmcgaXRlbXMgZnJvbSB0aGUge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0uXG4gKlxuICogS2V5cyBoYXZlOlxuICogLSBhIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgLlxuICogLSBhIGB0b2tlbmAuXG4gKlxuICogYEtleWAgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9IGJlY2F1c2UgaXRzIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgIGFsbG93c1xuICogdGhlXG4gKiBpbmplY3RvciB0byBzdG9yZSBjcmVhdGVkIG9iamVjdHMgaW4gYSBtb3JlIGVmZmljaWVudCB3YXkuXG4gKlxuICogYEtleWAgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfSBjcmVhdGVzIGtleXMgYXV0b21hdGljYWxseSB3aGVuXG4gKiByZXNvbHZpbmdcbiAqIHByb3ZpZGVycy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBObyByZXBsYWNlbWVudFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVmbGVjdGl2ZUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUtleSh0b2tlbiwgaWQpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBzdHJpbmdpZnkodGhpcy50b2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGBLZXlgIGZvciBhIHRva2VuLlxuICAgICAqL1xuICAgIFJlZmxlY3RpdmVLZXkuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkuZ2V0KHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUtleSwgXCJudW1iZXJPZktleXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHJlZ2lzdGVyZWQgaW4gdGhlIHN5c3RlbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5Lm51bWJlck9mS2V5czsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVLZXk7XG59KCkpO1xudmFyIEtleVJlZ2lzdHJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleVJlZ2lzdHJ5KCkge1xuICAgICAgICB0aGlzLl9hbGxLZXlzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBLZXlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFJlZmxlY3RpdmVLZXkpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIGlmICh0aGlzLl9hbGxLZXlzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxLZXlzLmdldCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0tleSA9IG5ldyBSZWZsZWN0aXZlS2V5KHRva2VuLCBSZWZsZWN0aXZlS2V5Lm51bWJlck9mS2V5cyk7XG4gICAgICAgIHRoaXMuX2FsbEtleXMuc2V0KHRva2VuLCBuZXdLZXkpO1xuICAgICAgICByZXR1cm4gbmV3S2V5O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleVJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJudW1iZXJPZktleXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbEtleXMuc2l6ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEtleVJlZ2lzdHJ5O1xufSgpKTtcbnZhciBfZ2xvYmFsS2V5UmVnaXN0cnkgPSBuZXcgS2V5UmVnaXN0cnkoKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4gKiB0byBwb3dlciBkZXBlbmRlbmN5IGluamVjdGlvbiBhbmQgY29tcGlsYXRpb24uXG4gKi9cbnZhciBSZWZsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmbGVjdG9yKHJlZmxlY3Rpb25DYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gcmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgICB9XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS51cGRhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoY2FwcykgeyB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBjYXBzOyB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZmFjdG9yeSh0eXBlKTsgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5hbm5vdGF0aW9ucyh0eXBlT3JGdW5jKTtcbiAgICB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmhhc0xpZmVjeWNsZUhvb2sodHlwZSwgbGNQcm9wZXJ0eSk7XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZ2V0dGVyKG5hbWUpOyB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5zZXR0ZXIobmFtZSk7IH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLm1ldGhvZChuYW1lKTsgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW1wb3J0VXJpKHR5cGUpOyB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb3VyY2VVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnJlc291cmNlVXJpKHR5cGUpOyB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBtZW1iZXJzLCBydW50aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucmVzb2x2ZUlkZW50aWZpZXIobmFtZSwgbW9kdWxlVXJsLCBtZW1iZXJzLCBydW50aW1lKTtcbiAgICB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUVudW0gPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnJlc29sdmVFbnVtKGlkZW50aWZpZXIsIG5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmxlY3Rvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBSZWZsZWN0b3J9IHVzZWQgaW50ZXJuYWxseSBpbiBBbmd1bGFyIHRvIGFjY2VzcyBtZXRhZGF0YVxuICogYWJvdXQgc3ltYm9scy5cbiAqL1xudmFyIHJlZmxlY3RvciA9IG5ldyBSZWZsZWN0b3IobmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogYERlcGVuZGVuY3lgIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBleHRlbmQgREkuXG4gKiBUaGlzIGlzIGludGVybmFsIHRvIEFuZ3VsYXIgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS5cbiAqL1xudmFyIFJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVEZXBlbmRlbmN5KGtleSwgb3B0aW9uYWwsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICB9XG4gICAgUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlRGVwZW5kZW5jeShrZXksIGZhbHNlLCBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZsZWN0aXZlRGVwZW5kZW5jeTtcbn0oKSk7XG52YXIgX0VNUFRZX0xJU1QgPSBbXTtcbnZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfKGtleSwgcmVzb2x2ZWRGYWN0b3JpZXMsIG11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGYWN0b3JpZXMgPSByZXNvbHZlZEZhY3RvcmllcztcbiAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEZhY3RvcnkgPSB0aGlzLnJlc29sdmVkRmFjdG9yaWVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfO1xufSgpKTtcbi8qKlxuICogQW4gaW50ZXJuYWwgcmVzb2x2ZWQgcmVwcmVzZW50YXRpb24gb2YgYSBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZWQgYnkgcmVzb2x2aW5nIGBQcm92aWRlcmAuXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkoXG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCByZXByZXNlbnRlZCBieSBhIGtleS5cbiAgICAgKi9cbiAgICBmYWN0b3J5LCBcbiAgICAvKipcbiAgICAgKiBBcmd1bWVudHMgKGRlcGVuZGVuY2llcykgdG8gdGhlIGBmYWN0b3J5YCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5O1xufSgpKTtcbi8qKlxuICogUmVzb2x2ZSBhIHNpbmdsZSBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVGYWN0b3J5KHByb3ZpZGVyKSB7XG4gICAgdmFyIGZhY3RvcnlGbjtcbiAgICB2YXIgcmVzb2x2ZWREZXBzO1xuICAgIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICB2YXIgdXNlQ2xhc3MgPSByZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci51c2VDbGFzcyk7XG4gICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rvci5mYWN0b3J5KHVzZUNsYXNzKTtcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gX2RlcGVuZGVuY2llc0Zvcih1c2VDbGFzcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUV4aXN0aW5nKSB7XG4gICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uIChhbGlhc0luc3RhbmNlKSB7IHJldHVybiBhbGlhc0luc3RhbmNlOyB9O1xuICAgICAgICByZXNvbHZlZERlcHMgPSBbUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleShSZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci51c2VFeGlzdGluZykpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICBmYWN0b3J5Rm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xuICAgICAgICByZXNvbHZlZERlcHMgPSBjb25zdHJ1Y3REZXBlbmRlbmNpZXMocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYWN0b3J5Rm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlci51c2VWYWx1ZTsgfTtcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gX0VNUFRZX0xJU1Q7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeShmYWN0b3J5Rm4sIHJlc29sdmVkRGVwcyk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBgUHJvdmlkZXJgIGludG8gYFJlc29sdmVkUHJvdmlkZXJgLlxuICpcbiAqIGBJbmplY3RvcmAgaW50ZXJuYWxseSBvbmx5IHVzZXMgYFJlc29sdmVkUHJvdmlkZXJgLCBgUHJvdmlkZXJgIGNvbnRhaW5zIGNvbnZlbmllbmNlIHByb3ZpZGVyXG4gKiBzeW50YXguXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhSZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci5wcm92aWRlKSwgW3Jlc29sdmVSZWZsZWN0aXZlRmFjdG9yeShwcm92aWRlcildLCBwcm92aWRlci5tdWx0aSB8fCBmYWxzZSk7XG59XG4vKipcbiAqIFJlc29sdmUgYSBsaXN0IG9mIFByb3ZpZGVycy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgW10pO1xuICAgIHZhciByZXNvbHZlZCA9IG5vcm1hbGl6ZWQubWFwKHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIpO1xuICAgIHZhciByZXNvbHZlZFByb3ZpZGVyTWFwID0gbWVyZ2VSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMocmVzb2x2ZWQsIG5ldyBNYXAoKSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocmVzb2x2ZWRQcm92aWRlck1hcC52YWx1ZXMoKSk7XG59XG4vKipcbiAqIE1lcmdlcyBhIGxpc3Qgb2YgUmVzb2x2ZWRQcm92aWRlcnMgaW50byBhIGxpc3Qgd2hlcmUgZWFjaCBrZXkgaXMgY29udGFpbmVkIGV4YWN0bHkgb25jZSBhbmRcbiAqIG11bHRpIHByb3ZpZGVycyBoYXZlIGJlZW4gbWVyZ2VkLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyhwcm92aWRlcnMsIG5vcm1hbGl6ZWRQcm92aWRlcnNNYXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaV07XG4gICAgICAgIHZhciBleGlzdGluZyA9IG5vcm1hbGl6ZWRQcm92aWRlcnNNYXAuZ2V0KHByb3ZpZGVyLmtleS5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IGV4aXN0aW5nLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IoZXhpc3RpbmcsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZXNvbHZlZEZhY3Rvcmllcy5wdXNoKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhwcm92aWRlci5rZXksIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLnNsaWNlKCksIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCByZXNvbHZlZFByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFByb3ZpZGVyc01hcDtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCByZXMpIHtcbiAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHsgcHJvdmlkZTogYiwgdXNlQ2xhc3M6IGIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0JyAmJiBiLnByb3ZpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzLnB1c2goYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKGIsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkUHJvdmlkZXJFcnJvcihiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3REZXBlbmRlbmNpZXModHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzKSB7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcGFyYW1zXzEgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBbdF07IH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCB0LCBwYXJhbXNfMSk7IH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xuICAgIHZhciBwYXJhbXMgPSByZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmIChwYXJhbXMuc29tZShmdW5jdGlvbiAocCkgeyByZXR1cm4gcCA9PSBudWxsOyB9KSkge1xuICAgICAgICB0aHJvdyBub0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCBwLCBwYXJhbXMpOyB9KTtcbn1cbmZ1bmN0aW9uIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgbWV0YWRhdGEsIHBhcmFtcykge1xuICAgIHZhciB0b2tlbiA9IG51bGw7XG4gICAgdmFyIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1ldGFkYXRhKSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YS50b2tlbiwgb3B0aW9uYWwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLCBvcHRpb25hbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZpc2liaWxpdHkgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcmFtTWV0YWRhdGEgPSBtZXRhZGF0YVtpXTtcbiAgICAgICAgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhLnRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTZWxmIHx8IHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEluamVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgaWYgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KHRva2VuLCBvcHRpb25hbCwgdmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBub0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVEZXBlbmRlbmN5KHRva2VuLCBvcHRpb25hbCwgdmlzaWJpbGl0eSkge1xuICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBvcHRpb25hbCwgdmlzaWJpbGl0eSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxudmFyIFVOREVGSU5FRCA9IG5ldyBPYmplY3QoKTtcbi8qKlxuICogQSBSZWZsZWN0aXZlRGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHVzZWQgZm9yIGluc3RhbnRpYXRpbmcgb2JqZWN0cyBhbmQgcmVzb2x2aW5nXG4gKiBkZXBlbmRlbmNpZXMuXG4gKlxuICogQW4gYEluamVjdG9yYCBpcyBhIHJlcGxhY2VtZW50IGZvciBhIGBuZXdgIG9wZXJhdG9yLCB3aGljaCBjYW4gYXV0b21hdGljYWxseSByZXNvbHZlIHRoZVxuICogY29uc3RydWN0b3IgZGVwZW5kZW5jaWVzLlxuICpcbiAqIEluIHR5cGljYWwgdXNlLCBhcHBsaWNhdGlvbiBjb2RlIGFza3MgZm9yIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGV5IGFyZVxuICogcmVzb2x2ZWQgYnkgdGhlIGBJbmplY3RvcmAuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYW4gYEluamVjdG9yYCBjb25maWd1cmVkIHRvIGNyZWF0ZSBgRW5naW5lYCBhbmQgYENhcmAuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgRW5naW5lIHtcbiAqIH1cbiAqXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBDYXIge1xuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAqIHZhciBjYXIgPSBpbmplY3Rvci5nZXQoQ2FyKTtcbiAqIGV4cGVjdChjYXIgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gKiBleHBlY3QoY2FyLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcbiAqIGBgYFxuICpcbiAqIE5vdGljZSwgd2UgZG9uJ3QgdXNlIHRoZSBgbmV3YCBvcGVyYXRvciBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgd2FudCB0byBoYXZlIHRoZSBgSW5qZWN0b3JgXG4gKiByZXNvbHZlIGFsbCBvZiB0aGUgb2JqZWN0J3MgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQGRlcHJlY2F0ZWQgZnJvbSB2NSAtIHNsb3cgYW5kIGJyaW5ncyBpbiBhIGxvdCBvZiBjb2RlLCBVc2UgYEluamVjdG9yLmNyZWF0ZWAgaW5zdGVhZC5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJlZmxlY3RpdmVJbmplY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm5zIGFuIGFycmF5IG9mIHByb3ZpZGVyIGRlZmluaXRpb25zIGludG8gYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogQSByZXNvbHV0aW9uIGlzIGEgcHJvY2VzcyBvZiBmbGF0dGVuaW5nIG11bHRpcGxlIG5lc3RlZCBhcnJheXMgYW5kIGNvbnZlcnRpbmcgaW5kaXZpZHVhbFxuICAgICAqIHByb3ZpZGVycyBpbnRvIGFuIGFycmF5IG9mIGBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcmBzLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBDYXIge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIFtbRW5naW5lXV1dKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChwcm92aWRlcnMubGVuZ3RoKS50b0VxdWFsKDIpO1xuICAgICAqXG4gICAgICogZXhwZWN0KHByb3ZpZGVyc1swXSBpbnN0YW5jZW9mIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0ua2V5LmRpc3BsYXlOYW1lKS50b0JlKFwiQ2FyXCIpO1xuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZGVwZW5kZW5jaWVzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmZhY3RvcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICpcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzFdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkVuZ2luZVwiKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhbiBpbmplY3RvciBmcm9tIHRob3NlIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIGBQcm92aWRlcmAsXG4gICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycywgcGFyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgRW5naW5lXSk7XG4gICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycywgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhwcm92aWRlcnMsIHBhcmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yO1xufSgpKTtcbnZhciBSZWZsZWN0aXZlSW5qZWN0b3JfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JfKF9wcm92aWRlcnMsIF9wYXJlbnQpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXJzID0gX3Byb3ZpZGVycztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBfcGFyZW50IHx8IG51bGw7XG4gICAgICAgIHZhciBsZW4gPSBfcHJvdmlkZXJzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXlJZHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgdGhpcy5vYmpzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMua2V5SWRzW2ldID0gX3Byb3ZpZGVyc1tpXS5rZXkuaWQ7XG4gICAgICAgICAgICB0aGlzLm9ianNbaV0gPSBVTkRFRklORUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBudWxsLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyk7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIGluaiA9IG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JfKHByb3ZpZGVycyk7XG4gICAgICAgIGluai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaW5qO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUucmVzb2x2ZUFuZEluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlUmVzb2x2ZWQoUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW3Byb3ZpZGVyXSlbMF0pO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuaW5zdGFudGlhdGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5nZXRQcm92aWRlckF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9wcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBvdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJzW2luZGV4XTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyKysgPiB0aGlzLl9nZXRNYXhOdW1iZXJPZk9iamVjdHMoKSkge1xuICAgICAgICAgICAgdGhyb3cgY3ljbGljRGVwZW5kZW5jeUVycm9yKHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub2Jqcy5sZW5ndGg7IH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2luc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbMF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5faW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIsIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkkJDEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZhY3RvcnkgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5JCQxLmZhY3Rvcnk7XG4gICAgICAgIHZhciBkZXBzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVwcyA9XG4gICAgICAgICAgICAgICAgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSQkMS5kZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5hZGRLZXkpIHtcbiAgICAgICAgICAgICAgICBlLmFkZEtleSh0aGlzLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqID0gZmFjdG9yeS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGRlcHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgaW5zdGFudGlhdGlvbkVycm9yKHRoaXMsIGUsIGUuc3RhY2ssIHByb3ZpZGVyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoZGVwLmtleSwgZGVwLnZpc2liaWxpdHksIGRlcC5vcHRpb25hbCA/IG51bGwgOiBUSFJPV19JRl9OT1RfRk9VTkQpO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSwgdmlzaWJpbGl0eSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSBSZWZsZWN0aXZlSW5qZWN0b3JfLklOSkVDVE9SX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2liaWxpdHkgaW5zdGFuY2VvZiBTZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlTZWxmKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlEZWZhdWx0KGtleSwgbm90Rm91bmRWYWx1ZSwgdmlzaWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRPYmpCeUtleUlkID0gZnVuY3Rpb24gKGtleUlkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtleUlkc1tpXSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmpzW2ldID0gdGhpcy5fbmV3KHRoaXMuX3Byb3ZpZGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOREVGSU5FRDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fdGhyb3dPck51bGwgPSBmdW5jdGlvbiAoa2V5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmIChub3RGb3VuZFZhbHVlICE9PSBUSFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbm9Qcm92aWRlckVycm9yKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlTZWxmID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5fZ2V0T2JqQnlLZXlJZChrZXkuaWQpO1xuICAgICAgICByZXR1cm4gKG9iaiAhPT0gVU5ERUZJTkVEKSA/IG9iaiA6IHRoaXMuX3Rocm93T3JOdWxsKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5RGVmYXVsdCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgdmFyIGluajtcbiAgICAgICAgaWYgKHZpc2liaWxpdHkgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgaW5qID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmogPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmogaW5zdGFuY2VvZiBSZWZsZWN0aXZlSW5qZWN0b3JfKSB7XG4gICAgICAgICAgICB2YXIgaW5qXyA9IGluajtcbiAgICAgICAgICAgIHZhciBvYmogPSBpbmpfLl9nZXRPYmpCeUtleUlkKGtleS5pZCk7XG4gICAgICAgICAgICBpZiAob2JqICE9PSBVTkRFRklORUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIGluaiA9IGlual8ucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmogIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmouZ2V0KGtleS50b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gX21hcFByb3ZpZGVycyh0aGlzLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gJyBcIicgKyBiLmtleS5kaXNwbGF5TmFtZSArICdcIiAnOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgcmV0dXJuIFwiUmVmbGVjdGl2ZUluamVjdG9yKHByb3ZpZGVyczogW1wiICsgcHJvdmlkZXJzICsgXCJdKVwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWU7IH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5JTkpFQ1RPUl9LRVkgPSBSZWZsZWN0aXZlS2V5LmdldChJbmplY3Rvcik7XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3Rvcl87XG59KCkpO1xuZnVuY3Rpb24gX21hcFByb3ZpZGVycyhpbmplY3RvciwgZm4pIHtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGluamVjdG9yLl9wcm92aWRlcnMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdG9yLl9wcm92aWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzW2ldID0gZm4oaW5qZWN0b3IuZ2V0UHJvdmlkZXJBdEluZGV4KGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYXJndW1lbnQgaXMgc2hhcGVkIGxpa2UgYSBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAvLyBhbGxvdyBhbnkgUHJvbWlzZS9BKyBjb21wbGlhbnQgdGhlbmFibGUuXG4gICAgLy8gSXQncyB1cCB0byB0aGUgY2FsbGVyIHRvIGVuc3VyZSB0aGF0IG9iai50aGVuIGNvbmZvcm1zIHRvIHRoZSBzcGVjXG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZShvYmopIHtcbiAgICAvLyBUT0RPOiB1c2UgaXNPYnNlcnZhYmxlIG9uY2Ugd2UgdXBkYXRlIHBhc3MgcnhqcyA2LjFcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RpdmVYL3J4anMvYmxvYi9tYXN0ZXIvQ0hBTkdFTE9HLm1kIzYxMC0yMDE4LTA1LTAzXG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmouc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYXBwbGljYXRpb24gaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQVBQX0lOSVRJQUxJWkVSID0gbmV3IEluamVjdGlvblRva2VuKCdBcHBsaWNhdGlvbiBJbml0aWFsaXplcicpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcmVmbGVjdHMgdGhlIHN0YXRlIG9mIHJ1bm5pbmcge0BsaW5rIEFQUF9JTklUSUFMSVpFUn1zLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvbkluaXRTdGF0dXMoYXBwSW5pdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hcHBJbml0cyA9IGFwcEluaXRzO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgX3RoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5wcm90b3R5cGUucnVuSW5pdGlhbGl6ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3luY0luaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBwSW5pdHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcHBJbml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbml0UmVzdWx0ID0gdGhpcy5hcHBJbml0c1tpXSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UoaW5pdFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNJbml0UHJvbWlzZXMucHVzaChpbml0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5hbGwoYXN5bmNJbml0UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9KS5jYXRjaChmdW5jdGlvbiAoZSkgeyBfdGhpcy5yZWplY3QoZSk7IH0pO1xuICAgICAgICBpZiAoYXN5bmNJbml0UHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgQXBwbGljYXRpb25Jbml0U3RhdHVzID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSgwLCBJbmplY3QoQVBQX0lOSVRJQUxJWkVSKSksIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuICAgIF0sIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyk7XG4gICAgcmV0dXJuIEFwcGxpY2F0aW9uSW5pdFN0YXR1cztcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgYSB1bmlxdWUgc3RyaW5nIGlkIGFzc2lnbmVkIHRvIHRoZSBhcHBsaWNhdGlvbiBieSBBbmd1bGFyIGFuZCB1c2VkXG4gKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cbiAqIHtAbGluayBWaWV3RW5jYXBzdWxhdGlvbiNFbXVsYXRlZCBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZH0gaXMgYmVpbmcgdXNlZC5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXG4gKiBhIGN1c3RvbSB2YWx1ZSB2aWEgYSBESSBwcm92aWRlciA8IS0tIFRPRE86IHByb3ZpZGVyIC0tPiBjb25maWd1cmluZyB0aGUgcm9vdCB7QGxpbmsgSW5qZWN0b3J9XG4gKiB1c2luZyB0aGlzIHRva2VuLlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQVBQX0lEID0gbmV3IEluamVjdGlvblRva2VuKCdBcHBJZCcpO1xuZnVuY3Rpb24gX2FwcElkUmFuZG9tUHJvdmlkZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiBcIlwiICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCkgKyBfcmFuZG9tQ2hhcigpO1xufVxuLyoqXG4gKiBQcm92aWRlcnMgdGhhdCB3aWxsIGdlbmVyYXRlIGEgcmFuZG9tIEFQUF9JRF9UT0tFTi5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFQUF9JRF9SQU5ET01fUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogQVBQX0lELFxuICAgIHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSxcbiAgICBkZXBzOiBbXSxcbn07XG5mdW5jdGlvbiBfcmFuZG9tQ2hhcigpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1KSk7XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBwbGF0Zm9ybSBpcyBpbml0aWFsaXplZC5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFBMQVRGT1JNX0lOSVRJQUxJWkVSID0gbmV3IEluamVjdGlvblRva2VuKCdQbGF0Zm9ybSBJbml0aWFsaXplcicpO1xuLyoqXG4gKiBBIHRva2VuIHRoYXQgaW5kaWNhdGVzIGFuIG9wYXF1ZSBwbGF0Zm9ybSBpZC5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFBMQVRGT1JNX0lEID0gbmV3IEluamVjdGlvblRva2VuKCdQbGF0Zm9ybSBJRCcpO1xuLyoqXG4gKiBBbGwgY2FsbGJhY2tzIHByb3ZpZGVkIHZpYSB0aGlzIHRva2VuIHdpbGwgYmUgY2FsbGVkIGZvciBldmVyeSBjb21wb25lbnQgdGhhdCBpcyBib290c3RyYXBwZWQuXG4gKiBTaWduYXR1cmUgb2YgdGhlIGNhbGxiYWNrOlxuICpcbiAqIGAoY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWYpID0+IHZvaWRgLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFQUF9CT09UU1RSQVBfTElTVEVORVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2FwcEJvb3RzdHJhcExpc3RlbmVyJyk7XG4vKipcbiAqIEEgdG9rZW4gd2hpY2ggaW5kaWNhdGVzIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgYXBwbGljYXRpb25cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFBBQ0tBR0VfUk9PVF9VUkwgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0FwcGxpY2F0aW9uIFBhY2thZ2VzIFJvb3QgVVJMJyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDb25zb2xlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnNvbGUoKSB7XG4gICAgfVxuICAgIENvbnNvbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLy8gTm90ZTogZm9yIHJlcG9ydGluZyBlcnJvcnMgdXNlIGBET00ubG9nRXJyb3IoKWAgYXMgaXQgaXMgcGxhdGZvcm0gc3BlY2lmaWNcbiAgICBDb25zb2xlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgQ29uc29sZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKClcbiAgICBdLCBDb25zb2xlKTtcbiAgICByZXR1cm4gQ29uc29sZTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29tYmluYXRpb24gb2YgTmdNb2R1bGVGYWN0b3J5IGFuZCBDb21wb25lbnRGYWN0b3J5cy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMobmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnkgPSBuZ01vZHVsZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yaWVzID0gY29tcG9uZW50RmFjdG9yaWVzO1xuICAgIH1cbiAgICByZXR1cm4gTW9kdWxlV2l0aENvbXBvbmVudEZhY3Rvcmllcztcbn0oKSk7XG5mdW5jdGlvbiBfdGhyb3dFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIGNvbXBpbGVyIGlzIG5vdCBsb2FkZWRcIik7XG59XG4vKipcbiAqIExvdy1sZXZlbCBzZXJ2aWNlIGZvciBydW5uaW5nIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGR1cmluZyBydW50aW1lXG4gKiB0byBjcmVhdGUge0BsaW5rIENvbXBvbmVudEZhY3Rvcnl9cywgd2hpY2hcbiAqIGNhbiBsYXRlciBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgcmVuZGVyIGEgQ29tcG9uZW50IGluc3RhbmNlLlxuICpcbiAqIEVhY2ggYEBOZ01vZHVsZWAgcHJvdmlkZXMgYW4gb3duIGBDb21waWxlcmAgdG8gaXRzIGluamVjdG9yLFxuICogdGhhdCB3aWxsIHVzZSB0aGUgZGlyZWN0aXZlcy9waXBlcyBvZiB0aGUgbmcgbW9kdWxlIGZvciBjb21waWxhdGlvblxuICogb2YgY29tcG9uZW50cy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGlsZXMgdGhlIGdpdmVuIE5nTW9kdWxlIGFuZCBhbGwgb2YgaXRzIGNvbXBvbmVudHMuIEFsbCB0ZW1wbGF0ZXMgb2YgdGhlIGNvbXBvbmVudHMgbGlzdGVkXG4gICAgICogaW4gYGVudHJ5Q29tcG9uZW50c2AgaGF2ZSB0byBiZSBpbmxpbmVkLlxuICAgICAqL1xuICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgLyoqXG4gICAgICogQ29tcGlsZXMgdGhlIGdpdmVuIE5nTW9kdWxlIGFuZCBhbGwgb2YgaXRzIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHsgdGhyb3cgX3Rocm93RXJyb3IoKTsgfTtcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHtAbGluayAjY29tcGlsZU1vZHVsZVN5bmN9IGJ1dCBhbHNvIGNyZWF0ZXMgQ29tcG9uZW50RmFjdG9yaWVzIGZvciBhbGwgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgX3Rocm93RXJyb3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhbWUgYXMge0BsaW5rICNjb21waWxlTW9kdWxlQXN5bmN9IGJ1dCBhbHNvIGNyZWF0ZXMgQ29tcG9uZW50RmFjdG9yaWVzIGZvciBhbGwgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHRocm93IF90aHJvd0Vycm9yKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNhY2hlcy5cbiAgICAgKi9cbiAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50L25nTW9kdWxlLlxuICAgICAqL1xuICAgIENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBmb3IgYSBnaXZlbiBOZ01vZHVsZSwgaWYgb25lIGlzIGRlZmluZWQgYW5kIGtub3duIHRvIHRoZSBjb21waWxlci5cbiAgICAgKi9cbiAgICBDb21waWxlci5wcm90b3R5cGUuZ2V0TW9kdWxlSWQgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9O1xuICAgIENvbXBpbGVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKVxuICAgIF0sIENvbXBpbGVyKTtcbiAgICByZXR1cm4gQ29tcGlsZXI7XG59KCkpO1xuLyoqXG4gKiBUb2tlbiB0byBwcm92aWRlIENvbXBpbGVyT3B0aW9ucyBpbiB0aGUgcGxhdGZvcm0gaW5qZWN0b3IuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQ09NUElMRVJfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignY29tcGlsZXJPcHRpb25zJyk7XG4vKipcbiAqIEEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgYSBDb21waWxlclxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENvbXBpbGVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlckZhY3RvcnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlckZhY3Rvcnk7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgdHJhY2U7XG52YXIgZXZlbnRzO1xuZnVuY3Rpb24gZGV0ZWN0V1RGKCkge1xuICAgIHZhciB3dGYgPSBfZ2xvYmFsIC8qKiBUT0RPICM5MTAwICovWyd3dGYnXTtcbiAgICBpZiAod3RmKSB7XG4gICAgICAgIHRyYWNlID0gd3RmWyd0cmFjZSddO1xuICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRyYWNlWydldmVudHMnXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpIHtcbiAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9IG51bGw7IH1cbiAgICByZXR1cm4gZXZlbnRzLmNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpO1xufVxuZnVuY3Rpb24gbGVhdmUoc2NvcGUsIHJldHVyblZhbHVlKSB7XG4gICAgdHJhY2UubGVhdmVTY29wZShzY29wZSwgcmV0dXJuVmFsdWUpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIHN0YXJ0VGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRyYWNlLmJlZ2luVGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGVuZFRpbWVSYW5nZShyYW5nZSkge1xuICAgIHRyYWNlLmVuZFRpbWVSYW5nZShyYW5nZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVHJ1ZSBpZiBXVEYgaXMgZW5hYmxlZC5cbiAqL1xudmFyIHd0ZkVuYWJsZWQgPSBkZXRlY3RXVEYoKTtcbmZ1bmN0aW9uIG5vb3BTY29wZShhcmcwLCBhcmcxKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENyZWF0ZSB0cmFjZSBzY29wZS5cbiAqXG4gKiBTY29wZXMgbXVzdCBiZSBzdHJpY3RseSBuZXN0ZWQgYW5kIGFyZSBhbmFsb2dvdXMgdG8gc3RhY2sgZnJhbWVzLCBidXRcbiAqIGRvIG5vdCBoYXZlIHRvIGZvbGxvdyB0aGUgc3RhY2sgZnJhbWVzLiBJbnN0ZWFkIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdGhleSBmb2xsb3cgbG9naWNhbFxuICogbmVzdGluZy4gWW91IG1heSB3YW50IHRvIHVzZVxuICogW0V2ZW50XG4gKiBTaWduYXR1cmVzXShodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby90cmFjaW5nLWZyYW1ld29yay9pbnN0cnVtZW50aW5nLWNvZGUuaHRtbCNjdXN0b20tZXZlbnRzKVxuICogYXMgdGhleSBhcmUgZGVmaW5lZCBpbiBXVEYuXG4gKlxuICogVXNlZCB0byBtYXJrIHNjb3BlIGVudHJ5LiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgdG8gbGVhdmUgdGhlIHNjb3BlLlxuICpcbiAqICAgICB2YXIgbXlTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdNeUNsYXNzI215TWV0aG9kKGFzY2lpIHNvbWVWYWwpJyk7XG4gKlxuICogICAgIHNvbWVNZXRob2QoKSB7XG4gKiAgICAgICAgdmFyIHMgPSBteVNjb3BlKCdGb28nKTsgLy8gJ0ZvbycgZ2V0cyBzdG9yZWQgaW4gdHJhY2luZyBVSVxuICogICAgICAgIC8vIERPIFNPTUUgV09SSyBIRVJFXG4gKiAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIDEyMyk7IC8vIFJldHVybiB2YWx1ZSAxMjNcbiAqICAgICB9XG4gKlxuICogTm90ZSwgYWRkaW5nIHRyeS1maW5hbGx5IGJsb2NrIGFyb3VuZCB0aGUgd29yayB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkIGNhblxuICogbmVnYXRpdmVseSBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgYXBwbGljYXRpb24uIEZvciB0aGlzIHJlYXNvbiB3ZSByZWNvbW1lbmQgdGhhdFxuICogeW91IGRvbid0IGFkZCB0aGVtIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQuIEluIHByb2R1Y3Rpb24gYHd0ZkxlYXZlYCBpcyBhIG5vb3AgYW5kXG4gKiBzbyB0cnktZmluYWxseSBibG9jayBoYXMgbm8gdmFsdWUuIFdoZW4gZGVidWdnaW5nIHBlcmYgaXNzdWVzLCBza2lwcGluZyBgd3RmTGVhdmVgLCBkbyB0b1xuICogZXhjZXB0aW9uLCB3aWxsIHByb2R1Y2UgaW5jb3JyZWN0IHRyYWNlLCBidXQgcHJlc2VuY2Ugb2YgZXhjZXB0aW9uIHNpZ25pZmllcyBsb2dpYyBlcnJvciB3aGljaFxuICogbmVlZHMgdG8gYmUgZml4ZWQgYmVmb3JlIHRoZSBhcHAgc2hvdWxkIGJlIHByb2ZpbGVkLiBBZGQgdHJ5LWZpbmFsbHkgb25seSB3aGVuIHlvdSBleHBlY3QgdGhhdFxuICogYW4gZXhjZXB0aW9uIGlzIGV4cGVjdGVkIGR1cmluZyBub3JtYWwgZXhlY3V0aW9uIHdoaWxlIHByb2ZpbGluZy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciB3dGZDcmVhdGVTY29wZSA9IHd0ZkVuYWJsZWQgPyBjcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XG4vKipcbiAqIFVzZWQgdG8gbWFyayBlbmQgb2YgU2NvcGUuXG4gKlxuICogLSBgc2NvcGVgIHRvIGVuZC5cbiAqIC0gYHJldHVyblZhbHVlYCAob3B0aW9uYWwpIHRvIGJlIHBhc3NlZCB0byB0aGUgV1RGLlxuICpcbiAqIFJldHVybnMgdGhlIGByZXR1cm5WYWx1ZSBmb3IgZWFzeSBjaGFpbmluZy5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIHd0ZkxlYXZlID0gd3RmRW5hYmxlZCA/IGxlYXZlIDogZnVuY3Rpb24gKHMsIHIpIHsgcmV0dXJuIHI7IH07XG4vKipcbiAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW4gdGhlIGNhbGwgdG8gW2VuZEFzeW5jXS4gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAqIGVuYWJsZWQuXG4gKlxuICogICAgIHNvbWVNZXRob2QoKSB7XG4gKiAgICAgICAgdmFyIHMgPSB3dGZTdGFydFRpbWVSYW5nZSgnSFRUUDpHRVQnLCAnc29tZS51cmwnKTtcbiAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XG4gKiAgICAgICAgICB3dGZFbmRUaW1lUmFuZ2Uocyk7XG4gKiAgICAgICAgfSk7XG4gKiAgICAgfVxuICogQHB1YmxpY0FwaVxuICovXG52YXIgd3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZFbmFibGVkID8gc3RhcnRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocmFuZ2VUeXBlLCBhY3Rpb24pIHsgcmV0dXJuIG51bGw7IH07XG4vKipcbiAqIEVuZHMgYSBhc3luYyB0aW1lIHJhbmdlIG9wZXJhdGlvbi5cbiAqIFtyYW5nZV0gaXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFt3dGZTdGFydFRpbWVSYW5nZV0gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciB3dGZFbmRUaW1lUmFuZ2UgPSB3dGZFbmFibGVkID8gZW5kVGltZVJhbmdlIDogZnVuY3Rpb24gKHIpIHsgcmV0dXJuIG51bGw7IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIGZvciBleGVjdXRpbmcgd29yayBpbnNpZGUgb3Igb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lLlxuICpcbiAqIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIHdoZW4gc3RhcnRpbmcgYSB3b3JrIGNvbnNpc3Rpbmcgb2ZcbiAqIG9uZSBvciBtb3JlIGFzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IHJlcXVpcmUgVUkgdXBkYXRlcyBvciBlcnJvciBoYW5kbGluZyB0byBiZSBoYW5kbGVkIGJ5XG4gKiBBbmd1bGFyLiBTdWNoIHRhc2tzIGNhbiBiZSBraWNrZWQgb2ZmIHZpYSB7QGxpbmsgI3J1bk91dHNpZGVBbmd1bGFyfSBhbmQgaWYgbmVlZGVkLCB0aGVzZSB0YXNrc1xuICogY2FuIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSB2aWEge0BsaW5rICNydW59LlxuICpcbiAqIDwhLS0gVE9ETzogYWRkL2ZpeCBsaW5rcyB0bzpcbiAqICAgLSBkb2NzIGV4cGxhaW5pbmcgem9uZXMgYW5kIHRoZSB1c2Ugb2Ygem9uZXMgaW4gQW5ndWxhciBhbmQgY2hhbmdlLWRldGVjdGlvblxuICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gKiAgIC0tPlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogaW1wb3J0IHtDb21wb25lbnQsIE5nWm9uZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQge05nSWZ9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbmctem9uZS1kZW1vJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8aDI+RGVtbzogTmdab25lPC9oMj5cbiAqXG4gKiAgICAgPHA+UHJvZ3Jlc3M6IHt7cHJvZ3Jlc3N9fSU8L3A+XG4gKiAgICAgPHAgKm5nSWY9XCJwcm9ncmVzcyA+PSAxMDBcIj5Eb25lIHByb2Nlc3Npbmcge3tsYWJlbH19IG9mIEFuZ3VsYXIgem9uZSE8L3A+XG4gKlxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyB3aXRoaW4gQW5ndWxhciB6b25lPC9idXR0b24+XG4gKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIG91dHNpZGUgb2YgQW5ndWxhciB6b25lPC9idXR0b24+XG4gKiAgIGAsXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE5nWm9uZURlbW8ge1xuICogICBwcm9ncmVzczogbnVtYmVyID0gMDtcbiAqICAgbGFiZWw6IHN0cmluZztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7fVxuICpcbiAqICAgLy8gTG9vcCBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICogICAvLyBzbyB0aGUgVUkgRE9FUyByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxuICogICBwcm9jZXNzV2l0aGluQW5ndWxhclpvbmUoKSB7XG4gKiAgICAgdGhpcy5sYWJlbCA9ICdpbnNpZGUnO1xuICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICogICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4gY29uc29sZS5sb2coJ0luc2lkZSBEb25lIScpKTtcbiAqICAgfVxuICpcbiAqICAgLy8gTG9vcCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmVcbiAqICAgLy8gc28gdGhlIFVJIERPRVMgTk9UIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gKiAgIHByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpIHtcbiAqICAgICB0aGlzLmxhYmVsID0gJ291dHNpZGUnO1xuICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICogICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gKiAgICAgICB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKCgpID0+IHtcbiAqICAgICAgICAgLy8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkaXNwbGF5IGRvbmVcbiAqICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7IGNvbnNvbGUubG9nKCdPdXRzaWRlIERvbmUhJyk7IH0pO1xuICogICAgICAgfSk7XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqXG4gKiAgIF9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICogICAgIHRoaXMucHJvZ3Jlc3MgKz0gMTtcbiAqICAgICBjb25zb2xlLmxvZyhgQ3VycmVudCBwcm9ncmVzczogJHt0aGlzLnByb2dyZXNzfSVgKTtcbiAqXG4gKiAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgPCAxMDApIHtcbiAqICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrKSwgMTApO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICBkb25lQ2FsbGJhY2soKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5nWm9uZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1pvbmUoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuZW5hYmxlTG9uZ1N0YWNrVHJhY2UsIGVuYWJsZUxvbmdTdGFja1RyYWNlID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01pY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWFjcm90YXNrcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGVyZSBhcmUgbm8gb3V0c3RhbmRpbmcgbWljcm90YXNrcyBvciBtYWNyb3Rhc2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpZmllcyB3aGVuIGNvZGUgZW50ZXJzIEFuZ3VsYXIgWm9uZS4gVGhpcyBnZXRzIGZpcmVkIGZpcnN0IG9uIFZNIFR1cm4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uVW5zdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBtaWNyb3Rhc2tzIGVucXVldWVkIGluIHRoZSBjdXJyZW50IFZNIFR1cm4uXG4gICAgICAgICAqIFRoaXMgaXMgYSBoaW50IGZvciBBbmd1bGFyIHRvIGRvIGNoYW5nZSBkZXRlY3Rpb24sIHdoaWNoIG1heSBlbnF1ZXVlIG1vcmUgbWljcm90YXNrcy5cbiAgICAgICAgICogRm9yIHRoaXMgcmVhc29uIHRoaXMgZXZlbnQgY2FuIGZpcmUgbXVsdGlwbGUgdGltZXMgcGVyIFZNIFR1cm4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uTWljcm90YXNrRW1wdHkgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlIGxhc3QgYG9uTWljcm90YXNrRW1wdHlgIGhhcyBydW4gYW5kIHRoZXJlIGFyZSBubyBtb3JlIG1pY3JvdGFza3MsIHdoaWNoXG4gICAgICAgICAqIGltcGxpZXMgd2UgYXJlIGFib3V0IHRvIHJlbGlucXVpc2ggVk0gdHVybi5cbiAgICAgICAgICogVGhpcyBldmVudCBnZXRzIGNhbGxlZCBqdXN0IG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uU3RhYmxlID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpZmllcyB0aGF0IGFuIGVycm9yIGhhcyBiZWVuIGRlbGl2ZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25FcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIFpvbmUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIHRoaXMgY29uZmlndXJhdGlvbiBBbmd1bGFyIHJlcXVpcmVzIFpvbmUuanNcIik7XG4gICAgICAgIH1cbiAgICAgICAgWm9uZS5hc3NlcnRab25lUGF0Y2hlZCgpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuX25lc3RpbmcgPSAwO1xuICAgICAgICBzZWxmLl9vdXRlciA9IHNlbGYuX2lubmVyID0gWm9uZS5jdXJyZW50O1xuICAgICAgICBpZiAoWm9uZVsnd3RmWm9uZVNwZWMnXSkge1xuICAgICAgICAgICAgc2VsZi5faW5uZXIgPSBzZWxmLl9pbm5lci5mb3JrKFpvbmVbJ3d0ZlpvbmVTcGVjJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChab25lWydUYXNrVHJhY2tpbmdab25lU3BlYyddKSB7XG4gICAgICAgICAgICBzZWxmLl9pbm5lciA9IHNlbGYuX2lubmVyLmZvcmsobmV3IFpvbmVbJ1Rhc2tUcmFja2luZ1pvbmVTcGVjJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVMb25nU3RhY2tUcmFjZSAmJiBab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgIHNlbGYuX2lubmVyID0gc2VsZi5faW5uZXIuZm9yayhab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pO1xuICAgICAgICB9XG4gICAgICAgIGZvcmtJbm5lclpvbmVXaXRoQW5ndWxhckJlaGF2aW9yKHNlbGYpO1xuICAgIH1cbiAgICBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWm9uZS5jdXJyZW50LmdldCgnaXNBbmd1bGFyWm9uZScpID09PSB0cnVlOyB9O1xuICAgIE5nWm9uZS5hc3NlcnRJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyBub3QhJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIG5vdCBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyEnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSBhbmQgcmV0dXJucyB2YWx1ZSByZXR1cm5lZCBieVxuICAgICAqIHRoZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBgcnVuYCBhbGxvd3MgeW91IHRvIHJlZW50ZXIgQW5ndWxhciB6b25lIGZyb20gYSB0YXNrIHRoYXQgd2FzIGV4ZWN1dGVkXG4gICAgICogb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lICh0eXBpY2FsbHkgc3RhcnRlZCB2aWEge0BsaW5rICNydW5PdXRzaWRlQW5ndWxhcn0pLlxuICAgICAqXG4gICAgICogQW55IGZ1dHVyZSB0YXNrcyBvciBtaWNyb3Rhc2tzIHNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udGludWUgZXhlY3V0aW5nIGZyb21cbiAgICAgKiB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgKlxuICAgICAqIElmIGEgc3luY2hyb25vdXMgZXJyb3IgaGFwcGVucyBpdCB3aWxsIGJlIHJldGhyb3duIGFuZCBub3QgcmVwb3J0ZWQgdmlhIGBvbkVycm9yYC5cbiAgICAgKi9cbiAgICBOZ1pvbmUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbiwgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnJ1bihmbiwgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24gc3luY2hyb25vdXNseSB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSBhcyBhIHRhc2sgYW5kIHJldHVybnMgdmFsdWVcbiAgICAgKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxuICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSAodHlwaWNhbGx5IHN0YXJ0ZWQgdmlhIHtAbGluayAjcnVuT3V0c2lkZUFuZ3VsYXJ9KS5cbiAgICAgKlxuICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXG4gICAgICogd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICpcbiAgICAgKiBJZiBhIHN5bmNocm9ub3VzIGVycm9yIGhhcHBlbnMgaXQgd2lsbCBiZSByZXRocm93biBhbmQgbm90IHJlcG9ydGVkIHZpYSBgb25FcnJvcmAuXG4gICAgICovXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKGZuLCBhcHBseVRoaXMsIGFwcGx5QXJncywgbmFtZSkge1xuICAgICAgICB2YXIgem9uZSA9IHRoaXMuX2lubmVyO1xuICAgICAgICB2YXIgdGFzayA9IHpvbmUuc2NoZWR1bGVFdmVudFRhc2soJ05nWm9uZUV2ZW50OiAnICsgbmFtZSwgZm4sIEVNUFRZX1BBWUxPQUQsIG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB6b25lLnJ1blRhc2sodGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgem9uZS5jYW5jZWxUYXNrKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBydW5gLCBleGNlcHQgdGhhdCBzeW5jaHJvbm91cyBlcnJvcnMgYXJlIGNhdWdodCBhbmQgZm9yd2FyZGVkIHZpYSBgb25FcnJvcmAgYW5kIG5vdFxuICAgICAqIHJldGhyb3duLlxuICAgICAqL1xuICAgIE5nWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChmbiwgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnJ1bkd1YXJkZWQoZm4sIGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XG4gICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIHtAbGluayAjcnVuT3V0c2lkZUFuZ3VsYXJ9IGFsbG93cyB5b3UgdG8gZXNjYXBlIEFuZ3VsYXIncyB6b25lIGFuZCBkb1xuICAgICAqIHdvcmsgdGhhdFxuICAgICAqIGRvZXNuJ3QgdHJpZ2dlciBBbmd1bGFyIGNoYW5nZS1kZXRlY3Rpb24gb3IgaXMgc3ViamVjdCB0byBBbmd1bGFyJ3MgZXJyb3IgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgKlxuICAgICAqIFVzZSB7QGxpbmsgI3J1bn0gdG8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkbyB3b3JrIHRoYXQgdXBkYXRlcyB0aGUgYXBwbGljYXRpb24gbW9kZWwuXG4gICAgICovXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW5PdXRzaWRlQW5ndWxhciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3V0ZXIucnVuKGZuKTtcbiAgICB9O1xuICAgIHJldHVybiBOZ1pvbmU7XG59KCkpO1xuZnVuY3Rpb24gbm9vcCQxKCkgeyB9XG52YXIgRU1QVFlfUEFZTE9BRCA9IHt9O1xuZnVuY3Rpb24gY2hlY2tTdGFibGUoem9uZSkge1xuICAgIGlmICh6b25lLl9uZXN0aW5nID09IDAgJiYgIXpvbmUuaGFzUGVuZGluZ01pY3JvdGFza3MgJiYgIXpvbmUuaXNTdGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHpvbmUuX25lc3RpbmcrKztcbiAgICAgICAgICAgIHpvbmUub25NaWNyb3Rhc2tFbXB0eS5lbWl0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgem9uZS5fbmVzdGluZy0tO1xuICAgICAgICAgICAgaWYgKCF6b25lLmhhc1BlbmRpbmdNaWNyb3Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiB6b25lLm9uU3RhYmxlLmVtaXQobnVsbCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgem9uZS5pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3Ioem9uZSkge1xuICAgIHpvbmUuX2lubmVyID0gem9uZS5faW5uZXIuZm9yayh7XG4gICAgICAgIG5hbWU6ICdhbmd1bGFyJyxcbiAgICAgICAgcHJvcGVydGllczogeyAnaXNBbmd1bGFyWm9uZSc6IHRydWUgfSxcbiAgICAgICAgb25JbnZva2VUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb25FbnRlcih6b25lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlVGFzayh0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIG9uTGVhdmUoem9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uSW52b2tlOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb25FbnRlcih6b25lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlKHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgb25MZWF2ZSh6b25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25IYXNUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgaGFzVGFza1N0YXRlKSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZS5oYXNUYXNrKHRhcmdldCwgaGFzVGFza1N0YXRlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGhhc1Rhc2sgZXZlbnRzIHdoaWNoIG9yaWdpbmF0ZSBmcm9tIG91ciB6b25lXG4gICAgICAgICAgICAgICAgLy8gKEEgY2hpbGQgaGFzVGFzayBldmVudCBpcyBub3QgaW50ZXJlc3RpbmcgdG8gdXMpXG4gICAgICAgICAgICAgICAgaWYgKGhhc1Rhc2tTdGF0ZS5jaGFuZ2UgPT0gJ21pY3JvVGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgem9uZS5oYXNQZW5kaW5nTWljcm90YXNrcyA9IGhhc1Rhc2tTdGF0ZS5taWNyb1Rhc2s7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU3RhYmxlKHpvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNUYXNrU3RhdGUuY2hhbmdlID09ICdtYWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUuaGFzUGVuZGluZ01hY3JvdGFza3MgPSBoYXNUYXNrU3RhdGUubWFjcm9UYXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25IYW5kbGVFcnJvcjogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGVycm9yKSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZS5oYW5kbGVFcnJvcih0YXJnZXQsIGVycm9yKTtcbiAgICAgICAgICAgIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gem9uZS5vbkVycm9yLmVtaXQoZXJyb3IpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gb25FbnRlcih6b25lKSB7XG4gICAgem9uZS5fbmVzdGluZysrO1xuICAgIGlmICh6b25lLmlzU3RhYmxlKSB7XG4gICAgICAgIHpvbmUuaXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgem9uZS5vblVuc3RhYmxlLmVtaXQobnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25MZWF2ZSh6b25lKSB7XG4gICAgem9uZS5fbmVzdGluZy0tO1xuICAgIGNoZWNrU3RhYmxlKHpvbmUpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIG5vb3AgaW1wbGVtZW50YXRpb24gb2YgYE5nWm9uZWAgd2hpY2ggZG9lcyBub3RoaW5nLiBUaGlzIHpvbmUgcmVxdWlyZXMgZXhwbGljaXQgY2FsbHNcbiAqIHRvIGZyYW1ld29yayB0byBwZXJmb3JtIHJlbmRlcmluZy5cbiAqL1xudmFyIE5vb3BOZ1pvbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9vcE5nWm9uZSgpIHtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWljcm90YXNrcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNYWNyb3Rhc2tzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uVW5zdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub25NaWNyb3Rhc2tFbXB0eSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vblN0YWJsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBOb29wTmdab25lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG4gICAgTm9vcE5nWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcbiAgICBOb29wTmdab25lLnByb3RvdHlwZS5ydW5PdXRzaWRlQW5ndWxhciA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcbiAgICBOb29wTmdab25lLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuICAgIHJldHVybiBOb29wTmdab25lO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGUgVGVzdGFiaWxpdHkgc2VydmljZSBwcm92aWRlcyB0ZXN0aW5nIGhvb2tzIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIGZyb21cbiAqIHRoZSBicm93c2VyIGFuZCBieSBzZXJ2aWNlcyBzdWNoIGFzIFByb3RyYWN0b3IuIEVhY2ggYm9vdHN0cmFwcGVkIEFuZ3VsYXJcbiAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFRlc3RhYmlsaXR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5KF9uZ1pvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgYW55IHdvcmsgd2FzIGRvbmUgc2luY2UgdGhlIGxhc3QgJ3doZW5TdGFibGUnIGNhbGxiYWNrLiBUaGlzIGlzXG4gICAgICAgICAqIHVzZWZ1bCB0byBkZXRlY3QgaWYgdGhpcyBjb3VsZCBoYXZlIHBvdGVudGlhbGx5IGRlc3RhYmlsaXplZCBhbm90aGVyXG4gICAgICAgICAqIGNvbXBvbmVudCB3aGlsZSBpdCBpcyBzdGFiaWxpemluZy5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl93YXRjaEFuZ3VsYXJFdmVudHMoKTtcbiAgICAgICAgX25nWm9uZS5ydW4oZnVuY3Rpb24gKCkgeyBfdGhpcy50YXNrVHJhY2tpbmdab25lID0gWm9uZS5jdXJyZW50LmdldCgnVGFza1RyYWNraW5nWm9uZScpOyB9KTtcbiAgICB9XG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl93YXRjaEFuZ3VsYXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vblVuc3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pc1pvbmVTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbmdab25lLm9uU3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlYXNlcyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVxdWVzdFxuICAgICAqIEBkZXByZWNhdGVkIHBlbmRpbmcgcmVxdWVzdHMgYXJlIG5vdyB0cmFja2VkIHdpdGggem9uZXMuXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmluY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ICs9IDE7XG4gICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVjcmVhc2VzIHRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0XG4gICAgICogQGRlcHJlY2F0ZWQgcGVuZGluZyByZXF1ZXN0cyBhcmUgbm93IHRyYWNrZWQgd2l0aCB6b25lc1xuICAgICAqL1xuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5kZWNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwZW5kaW5nIGFzeW5jIHJlcXVlc3RzIGJlbG93IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFuIGFzc29jaWF0ZWQgYXBwbGljYXRpb24gaXMgc3RhYmxlXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmlzU3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNab25lU3RhYmxlICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiAhdGhpcy5fbmdab25lLmhhc1BlbmRpbmdNYWNyb3Rhc2tzO1xuICAgIH07XG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLl9ydW5DYWxsYmFja3NJZlJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc1N0YWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZXMgdGhlIGNhbGwgYmFja3MgaW4gYSBuZXcgZnJhbWUgc28gdGhhdCBpdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKF90aGlzLl9jYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IF90aGlzLl9jYWxsYmFja3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjYi50aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICBjYi5kb25lQ2IoX3RoaXMuX2RpZFdvcmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGlsbCBub3Qgc3RhYmxlLCBzZW5kIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgcGVuZGluZ18xID0gdGhpcy5nZXRQZW5kaW5nVGFza3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLnVwZGF0ZUNiICYmIGNiLnVwZGF0ZUNiKHBlbmRpbmdfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNiLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZ2V0UGVuZGluZ1Rhc2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFza1RyYWNraW5nWm9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcHkgdGhlIHRhc2tzIGRhdGEgc28gdGhhdCB3ZSBkb24ndCBsZWFrIHRhc2tzLlxuICAgICAgICByZXR1cm4gdGhpcy50YXNrVHJhY2tpbmdab25lLm1hY3JvVGFza3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgLy8gRnJvbSBUYXNrVHJhY2tpbmdab25lOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvYmxvYi9tYXN0ZXIvbGliL3pvbmUtc3BlYy90YXNrLXRyYWNraW5nLnRzI0w0MFxuICAgICAgICAgICAgICAgIGNyZWF0aW9uTG9jYXRpb246IHQuY3JlYXRpb25Mb2NhdGlvbixcbiAgICAgICAgICAgICAgICBkYXRhOiB0LmRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZENhbGxiYWNrID0gZnVuY3Rpb24gKGNiLCB0aW1lb3V0LCB1cGRhdGVDYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGltZW91dElkID0gLTE7XG4gICAgICAgIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2FsbGJhY2tzID0gX3RoaXMuX2NhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYi50aW1lb3V0SWQgIT09IHRpbWVvdXRJZDsgfSk7XG4gICAgICAgICAgICAgICAgY2IoX3RoaXMuX2RpZFdvcmssIF90aGlzLmdldFBlbmRpbmdUYXNrcygpKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKHsgZG9uZUNiOiBjYiwgdGltZW91dElkOiB0aW1lb3V0SWQsIHVwZGF0ZUNiOiB1cGRhdGVDYiB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRoZSBhcHBsaWNhdGlvbiB0byBiZSBzdGFibGUgd2l0aCBhIHRpbWVvdXQuIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQgYmVmb3JlIHRoYXRcbiAgICAgKiBoYXBwZW5zLCB0aGUgY2FsbGJhY2sgcmVjZWl2ZXMgYSBsaXN0IG9mIHRoZSBtYWNybyB0YXNrcyB0aGF0IHdlcmUgcGVuZGluZywgb3RoZXJ3aXNlIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9uZUNiIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBBbmd1bGFyIGlzIHN0YWJsZSBvciB0aGUgdGltZW91dCBleHBpcmVzXG4gICAgICogICAgd2hpY2hldmVyIGNvbWVzIGZpcnN0LlxuICAgICAqIEBwYXJhbSB0aW1lb3V0IE9wdGlvbmFsLiBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIEFuZ3VsYXIgdG8gYmVjb21lIHN0YWJsZS4gSWYgbm90XG4gICAgICogICAgc3BlY2lmaWVkLCB3aGVuU3RhYmxlKCkgd2lsbCB3YWl0IGZvcmV2ZXIuXG4gICAgICogQHBhcmFtIHVwZGF0ZUNiIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzZXQgb2ZcbiAgICAgKiAgICBwZW5kaW5nIG1hY3JvdGFza3MgY2hhbmdlcy4gSWYgdGhpcyBjYWxsYmFjayByZXR1cm5zIHRydWUgZG9uZUNiIHdpbGwgbm90IGJlIGludm9rZWRcbiAgICAgKiAgICBhbmQgbm8gZnVydGhlciB1cGRhdGVzIHdpbGwgYmUgaXNzdWVkLlxuICAgICAqL1xuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS53aGVuU3RhYmxlID0gZnVuY3Rpb24gKGRvbmVDYiwgdGltZW91dCwgdXBkYXRlQ2IpIHtcbiAgICAgICAgaWYgKHVwZGF0ZUNiICYmICF0aGlzLnRhc2tUcmFja2luZ1pvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFzayB0cmFja2luZyB6b25lIGlzIHJlcXVpcmVkIHdoZW4gcGFzc2luZyBhbiB1cGRhdGUgY2FsbGJhY2sgdG8gJyArXG4gICAgICAgICAgICAgICAgJ3doZW5TdGFibGUoKS4gSXMgXCJ6b25lLmpzL2Rpc3QvdGFzay10cmFja2luZy5qc1wiIGxvYWRlZD8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSBhcmd1bWVudHMgYXJlICdGdW5jdGlvbicgYWJvdmUgdG8ga2VlcCB0aGUgcHVibGljIEFQSSBzaW1wbGUuXG4gICAgICAgIHRoaXMuYWRkQ2FsbGJhY2soZG9uZUNiLCB0aW1lb3V0LCB1cGRhdGVDYik7XG4gICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgKiBAZGVwcmVjYXRlZCBwZW5kaW5nIHJlcXVlc3RzIGFyZSBub3cgdHJhY2tlZCB3aXRoIHpvbmVzXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmdldFBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7IH07XG4gICAgLyoqXG4gICAgICogRmluZCBwcm92aWRlcnMgYnkgbmFtZVxuICAgICAqIEBwYXJhbSB1c2luZyBUaGUgcm9vdCBlbGVtZW50IHRvIHNlYXJjaCBmcm9tXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIFRoZSBuYW1lIG9mIGJpbmRpbmcgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gZXhhY3RNYXRjaCBXaGV0aGVyIHVzaW5nIGV4YWN0TWF0Y2hcbiAgICAgKi9cbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBUZXN0YWJpbGl0eSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbiAgICBdLCBUZXN0YWJpbGl0eSk7XG4gICAgcmV0dXJuIFRlc3RhYmlsaXR5O1xufSgpKTtcbi8qKlxuICogQSBnbG9iYWwgcmVnaXN0cnkgb2Yge0BsaW5rIFRlc3RhYmlsaXR5fSBpbnN0YW5jZXMgZm9yIHNwZWNpZmljIGVsZW1lbnRzLlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVGVzdGFiaWxpdHlSZWdpc3RyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXN0YWJpbGl0eVJlZ2lzdHJ5KCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3Rlc3RhYmlsaXR5R2V0dGVyLmFkZFRvV2luZG93KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gYXBwbGljYXRpb24gd2l0aCBhIHRlc3RhYmlsaXR5IGhvb2sgc28gdGhhdCBpdCBjYW4gYmUgdHJhY2tlZFxuICAgICAqIEBwYXJhbSB0b2tlbiB0b2tlbiBvZiBhcHBsaWNhdGlvbiwgcm9vdCBlbGVtZW50XG4gICAgICogQHBhcmFtIHRlc3RhYmlsaXR5IFRlc3RhYmlsaXR5IGhvb2tcbiAgICAgKi9cbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKHRva2VuLCB0ZXN0YWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMuc2V0KHRva2VuLCB0ZXN0YWJpbGl0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhbiBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gdG9rZW4gdG9rZW4gb2YgYXBwbGljYXRpb24sIHJvb3QgZWxlbWVudFxuICAgICAqL1xuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLnVucmVnaXN0ZXJBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbikgeyB0aGlzLl9hcHBsaWNhdGlvbnMuZGVsZXRlKHRva2VuKTsgfTtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhbGwgYXBwbGljYXRpb25zXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUudW5yZWdpc3RlckFsbEFwcGxpY2F0aW9ucyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fYXBwbGljYXRpb25zLmNsZWFyKCk7IH07XG4gICAgLyoqXG4gICAgICogR2V0IGEgdGVzdGFiaWxpdHkgaG9vayBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIGVsZW0gcm9vdCBlbGVtZW50XG4gICAgICovXG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKSB8fCBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVnaXN0ZXJlZCB0ZXN0YWJpbGl0aWVzXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsVGVzdGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fYXBwbGljYXRpb25zLnZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgYXBwbGljYXRpb25zKHJvb3QgZWxlbWVudHMpXG4gICAgICovXG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsUm9vdEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9hcHBsaWNhdGlvbnMua2V5cygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRlc3RhYmlsaXR5IG9mIGEgbm9kZSBpbiB0aGUgVHJlZVxuICAgICAqIEBwYXJhbSBlbGVtIG5vZGVcbiAgICAgKiBAcGFyYW0gZmluZEluQW5jZXN0b3JzIHdoZXRoZXIgZmluZGluZyB0ZXN0YWJpbGl0eSBpbiBhbmNlc3RvcnMgaWYgdGVzdGFiaWxpdHkgd2FzIG5vdCBmb3VuZCBpblxuICAgICAqIGN1cnJlbnQgbm9kZVxuICAgICAqL1xuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICB9O1xuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG4gICAgXSwgVGVzdGFiaWxpdHlSZWdpc3RyeSk7XG4gICAgcmV0dXJuIFRlc3RhYmlsaXR5UmVnaXN0cnk7XG59KCkpO1xudmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX05vb3BHZXRUZXN0YWJpbGl0eSgpIHtcbiAgICB9XG4gICAgX05vb3BHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHsgfTtcbiAgICBfTm9vcEdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAocmVnaXN0cnksIGVsZW0sIGZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBfTm9vcEdldFRlc3RhYmlsaXR5O1xufSgpKTtcbi8qKlxuICogU2V0IHRoZSB7QGxpbmsgR2V0VGVzdGFiaWxpdHl9IGltcGxlbWVudGF0aW9uIHVzZWQgYnkgdGhlIEFuZ3VsYXIgdGVzdGluZyBmcmFtZXdvcmsuXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIHNldFRlc3RhYmlsaXR5R2V0dGVyKGdldHRlcikge1xuICAgIF90ZXN0YWJpbGl0eUdldHRlciA9IGdldHRlcjtcbn1cbnZhciBfdGVzdGFiaWxpdHlHZXR0ZXIgPSBuZXcgX05vb3BHZXRUZXN0YWJpbGl0eSgpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX3BsYXRmb3JtO1xudmFyIGNvbXBpbGVOZ01vZHVsZUZhY3RvcnkgPSBjb21waWxlTmdNb2R1bGVGYWN0b3J5X19QUkVfTkdDQ19fO1xuZnVuY3Rpb24gY29tcGlsZU5nTW9kdWxlRmFjdG9yeV9fUFJFX05HQ0NfXyhpbmplY3Rvciwgb3B0aW9ucywgbW9kdWxlVHlwZSkge1xuICAgIHZhciBjb21waWxlckZhY3RvcnkgPSBpbmplY3Rvci5nZXQoQ29tcGlsZXJGYWN0b3J5KTtcbiAgICB2YXIgY29tcGlsZXIgPSBjb21waWxlckZhY3RvcnkuY3JlYXRlQ29tcGlsZXIoW29wdGlvbnNdKTtcbiAgICByZXR1cm4gY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpO1xufVxuZnVuY3Rpb24gY29tcGlsZU5nTW9kdWxlRmFjdG9yeV9fUE9TVF9OR0NDX18oaW5qZWN0b3IsIG9wdGlvbnMsIG1vZHVsZVR5cGUpIHtcbiAgICBuZ0Rldk1vZGUgJiYgYXNzZXJ0TmdNb2R1bGVUeXBlKG1vZHVsZVR5cGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE5nTW9kdWxlRmFjdG9yeSQxKG1vZHVsZVR5cGUpKTtcbn1cbnZhciBBTExPV19NVUxUSVBMRV9QTEFURk9STVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0FsbG93TXVsdGlwbGVUb2tlbicpO1xuLyoqXG4gKiBBIHRva2VuIGZvciB0aGlyZC1wYXJ0eSBjb21wb25lbnRzIHRoYXQgY2FuIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBOZ1Byb2JlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5nUHJvYmVUb2tlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1Byb2JlVG9rZW4obmFtZSwgdG9rZW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gTmdQcm9iZVRva2VuO1xufSgpKTtcbi8qKlxuICogQ3JlYXRlcyBhIHBsYXRmb3JtLlxuICogUGxhdGZvcm1zIGhhdmUgdG8gYmUgZWFnZXJseSBjcmVhdGVkIHZpYSB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGxhdGZvcm0oaW5qZWN0b3IpIHtcbiAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkICYmXG4gICAgICAgICFfcGxhdGZvcm0uaW5qZWN0b3IuZ2V0KEFMTE9XX01VTFRJUExFX1BMQVRGT1JNUywgZmFsc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIGJlIG9ubHkgb25lIHBsYXRmb3JtLiBEZXN0cm95IHRoZSBwcmV2aW91cyBvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS4nKTtcbiAgICB9XG4gICAgX3BsYXRmb3JtID0gaW5qZWN0b3IuZ2V0KFBsYXRmb3JtUmVmKTtcbiAgICB2YXIgaW5pdHMgPSBpbmplY3Rvci5nZXQoUExBVEZPUk1fSU5JVElBTElaRVIsIG51bGwpO1xuICAgIGlmIChpbml0cylcbiAgICAgICAgaW5pdHMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdCkgeyByZXR1cm4gaW5pdCgpOyB9KTtcbiAgICByZXR1cm4gX3BsYXRmb3JtO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZmFjdG9yeSBmb3IgYSBwbGF0Zm9ybVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGxhdGZvcm1GYWN0b3J5KHBhcmVudFBsYXRmb3JtRmFjdG9yeSwgbmFtZSwgcHJvdmlkZXJzKSB7XG4gICAgaWYgKHByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHByb3ZpZGVycyA9IFtdOyB9XG4gICAgdmFyIGRlc2MgPSBcIlBsYXRmb3JtOiBcIiArIG5hbWU7XG4gICAgdmFyIG1hcmtlciA9IG5ldyBJbmplY3Rpb25Ub2tlbihkZXNjKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgIGlmIChleHRyYVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGV4dHJhUHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgdmFyIHBsYXRmb3JtID0gZ2V0UGxhdGZvcm0oKTtcbiAgICAgICAgaWYgKCFwbGF0Zm9ybSB8fCBwbGF0Zm9ybS5pbmplY3Rvci5nZXQoQUxMT1dfTVVMVElQTEVfUExBVEZPUk1TLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRQbGF0Zm9ybUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRQbGF0Zm9ybUZhY3RvcnkocHJvdmlkZXJzLmNvbmNhdChleHRyYVByb3ZpZGVycykuY29uY2F0KHsgcHJvdmlkZTogbWFya2VyLCB1c2VWYWx1ZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5qZWN0ZWRQcm92aWRlcnMgPSBwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGNyZWF0ZVBsYXRmb3JtKEluamVjdG9yLmNyZWF0ZSh7IHByb3ZpZGVyczogaW5qZWN0ZWRQcm92aWRlcnMsIG5hbWU6IGRlc2MgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRQbGF0Zm9ybShtYXJrZXIpO1xuICAgIH07XG59XG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZXJlIGN1cnJlbnRseSBpcyBhIHBsYXRmb3JtIHdoaWNoIGNvbnRhaW5zIHRoZSBnaXZlbiB0b2tlbiBhcyBhIHByb3ZpZGVyLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UGxhdGZvcm0ocmVxdWlyZWRUb2tlbikge1xuICAgIHZhciBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtKCk7XG4gICAgaWYgKCFwbGF0Zm9ybSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBsYXRmb3JtIGV4aXN0cyEnKTtcbiAgICB9XG4gICAgaWYgKCFwbGF0Zm9ybS5pbmplY3Rvci5nZXQocmVxdWlyZWRUb2tlbiwgbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHBsYXRmb3JtIHdpdGggYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLiBQbGVhc2UgZGVzdHJveSBpdCBmaXJzdC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYXRmb3JtO1xufVxuLyoqXG4gKiBEZXN0cm95IHRoZSBleGlzdGluZyBwbGF0Zm9ybS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lQbGF0Zm9ybSgpIHtcbiAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkKSB7XG4gICAgICAgIF9wbGF0Zm9ybS5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCA/IF9wbGF0Zm9ybSA6IG51bGw7XG59XG4vKipcbiAqIFRoZSBBbmd1bGFyIHBsYXRmb3JtIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgQW5ndWxhciBvbiBhIHdlYiBwYWdlLiBFYWNoIHBhZ2VcbiAqIGhhcyBleGFjdGx5IG9uZSBwbGF0Zm9ybSwgYW5kIHNlcnZpY2VzIChzdWNoIGFzIHJlZmxlY3Rpb24pIHdoaWNoIGFyZSBjb21tb25cbiAqIHRvIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gcnVubmluZyBvbiB0aGUgcGFnZSBhcmUgYm91bmQgaW4gaXRzIHNjb3BlLlxuICpcbiAqIEEgcGFnZSdzIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkIGltcGxpY2l0bHkgd2hlbiBhIHBsYXRmb3JtIGlzIGNyZWF0ZWQgdmlhIGEgcGxhdGZvcm0gZmFjdG9yeVxuICogKGUuZy4ge0BsaW5rIHBsYXRmb3JtQnJvd3Nlcn0pLCBvciBleHBsaWNpdGx5IGJ5IGNhbGxpbmcgdGhlIHtAbGluayBjcmVhdGVQbGF0Zm9ybX0gZnVuY3Rpb24uXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUGxhdGZvcm1SZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmKF9pbmplY3Rvcikge1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgdGhpcy5fbW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIGBATmdNb2R1bGVgIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm1cbiAgICAgKiBmb3Igb2ZmbGluZSBjb21waWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbXlfbW9kdWxlLnRzOlxuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlNb2R1bGUge31cbiAgICAgKlxuICAgICAqIG1haW4udHM6XG4gICAgICogaW1wb3J0IHtNeU1vZHVsZU5nRmFjdG9yeX0gZnJvbSAnLi9teV9tb2R1bGUubmdmYWN0b3J5JztcbiAgICAgKiBpbXBvcnQge3BsYXRmb3JtQnJvd3Nlcn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gICAgICpcbiAgICAgKiBsZXQgbW9kdWxlUmVmID0gcGxhdGZvcm1Ccm93c2VyKCkuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeShNeU1vZHVsZU5nRmFjdG9yeSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgUGxhdGZvcm1SZWYucHJvdG90eXBlLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkgPSBmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNyZWF0ZSB0aGUgTmdab25lIF9iZWZvcmVfIHdlIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUsXG4gICAgICAgIC8vIGFzIGluc3RhbnRpYXRpbmcgdGhlIG1vZHVsZSBjcmVhdGVzIHNvbWUgcHJvdmlkZXJzIGVhZ2VybHkuXG4gICAgICAgIC8vIFNvIHdlIGNyZWF0ZSBhIG1pbmkgcGFyZW50IGluamVjdG9yIHRoYXQganVzdCBjb250YWlucyB0aGUgbmV3IE5nWm9uZSBhbmRcbiAgICAgICAgLy8gcGFzcyB0aGF0IGFzIHBhcmVudCB0byB0aGUgTmdNb2R1bGVGYWN0b3J5LlxuICAgICAgICB2YXIgbmdab25lT3B0aW9uID0gb3B0aW9ucyA/IG9wdGlvbnMubmdab25lIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbmdab25lID0gZ2V0Tmdab25lKG5nWm9uZU9wdGlvbik7XG4gICAgICAgIHZhciBwcm92aWRlcnMgPSBbeyBwcm92aWRlOiBOZ1pvbmUsIHVzZVZhbHVlOiBuZ1pvbmUgfV07XG4gICAgICAgIC8vIEF0dGVudGlvbjogRG9uJ3QgdXNlIEFwcGxpY2F0aW9uUmVmLnJ1biBoZXJlLFxuICAgICAgICAvLyBhcyB3ZSB3YW50IHRvIGJlIHN1cmUgdGhhdCBhbGwgcG9zc2libGUgY29uc3RydWN0b3IgY2FsbHMgYXJlIGluc2lkZSBgbmdab25lLnJ1bmAhXG4gICAgICAgIHJldHVybiBuZ1pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZ1pvbmVJbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7IHByb3ZpZGVyczogcHJvdmlkZXJzLCBwYXJlbnQ6IF90aGlzLmluamVjdG9yLCBuYW1lOiBtb2R1bGVGYWN0b3J5Lm1vZHVsZVR5cGUubmFtZSB9KTtcbiAgICAgICAgICAgIHZhciBtb2R1bGVSZWYgPSBtb2R1bGVGYWN0b3J5LmNyZWF0ZShuZ1pvbmVJbmplY3Rvcik7XG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uSGFuZGxlciA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoRXJyb3JIYW5kbGVyLCBudWxsKTtcbiAgICAgICAgICAgIGlmICghZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gRXJyb3JIYW5kbGVyLiBJcyBwbGF0Zm9ybSBtb2R1bGUgKEJyb3dzZXJNb2R1bGUpIGluY2x1ZGVkPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kdWxlUmVmLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUoX3RoaXMuX21vZHVsZXMsIG1vZHVsZVJlZik7IH0pO1xuICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nWm9uZS5vbkVycm9yLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChlcnJvcikgeyBleGNlcHRpb25IYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yKTsgfSB9KTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NhbGxBbmRSZXBvcnRUb0Vycm9ySGFuZGxlcihleGNlcHRpb25IYW5kbGVyLCBuZ1pvbmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFN0YXR1cyA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoQXBwbGljYXRpb25Jbml0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICBpbml0U3RhdHVzLnJ1bkluaXRpYWxpemVycygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0U3RhdHVzLmRvbmVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbW9kdWxlRG9Cb290c3RyYXAobW9kdWxlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVJlZjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gYEBOZ01vZHVsZWAgZm9yIGEgZ2l2ZW4gcGxhdGZvcm0gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUgY29tcGlsZXIuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBTaW1wbGUgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TW9kdWxlIHt9XG4gICAgICpcbiAgICAgKiBsZXQgbW9kdWxlUmVmID0gcGxhdGZvcm1Ccm93c2VyKCkuYm9vdHN0cmFwTW9kdWxlKE15TW9kdWxlKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb21waWxlck9wdGlvbnMgPT09IHZvaWQgMCkgeyBjb21waWxlck9wdGlvbnMgPSBbXTsgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnNSZWR1Y2VyKHt9LCBjb21waWxlck9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY29tcGlsZU5nTW9kdWxlRmFjdG9yeSh0aGlzLmluamVjdG9yLCBvcHRpb25zLCBtb2R1bGVUeXBlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHsgcmV0dXJuIF90aGlzLmJvb3RzdHJhcE1vZHVsZUZhY3RvcnkobW9kdWxlRmFjdG9yeSwgb3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUGxhdGZvcm1SZWYucHJvdG90eXBlLl9tb2R1bGVEb0Jvb3RzdHJhcCA9IGZ1bmN0aW9uIChtb2R1bGVSZWYpIHtcbiAgICAgICAgdmFyIGFwcFJlZiA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoQXBwbGljYXRpb25SZWYpO1xuICAgICAgICBpZiAobW9kdWxlUmVmLl9ib290c3RyYXBDb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1vZHVsZVJlZi5fYm9vdHN0cmFwQ29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBhcHBSZWYuYm9vdHN0cmFwKGYpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcCkge1xuICAgICAgICAgICAgbW9kdWxlUmVmLmluc3RhbmNlLm5nRG9Cb290c3RyYXAoYXBwUmVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBtb2R1bGUgXCIgKyBzdHJpbmdpZnkobW9kdWxlUmVmLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIHdhcyBib290c3RyYXBwZWQsIGJ1dCBpdCBkb2VzIG5vdCBkZWNsYXJlIFxcXCJATmdNb2R1bGUuYm9vdHN0cmFwXFxcIiBjb21wb25lbnRzIG5vciBhIFxcXCJuZ0RvQm9vdHN0cmFwXFxcIiBtZXRob2QuIFwiICtcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBkZWZpbmUgb25lIG9mIHRoZXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb2R1bGVzLnB1c2gobW9kdWxlUmVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHBsYXRmb3JtIGlzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fZGVzdHJveUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB7QGxpbmsgSW5qZWN0b3J9LCB3aGljaCBpcyB0aGUgcGFyZW50IGluamVjdG9yIGZvclxuICAgICAgICAgKiBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIGFuZCBwcm92aWRlcyBzaW5nbGV0b24gcHJvdmlkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgQW5ndWxhciBwbGF0Zm9ybSBhbmQgYWxsIEFuZ3VsYXIgYXBwbGljYXRpb25zIG9uIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwbGF0Zm9ybSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb2R1bGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBtb2R1bGUuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoKTsgfSk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWYucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQbGF0Zm9ybVJlZiA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW5qZWN0b3JdKVxuICAgIF0sIFBsYXRmb3JtUmVmKTtcbiAgICByZXR1cm4gUGxhdGZvcm1SZWY7XG59KCkpO1xuZnVuY3Rpb24gZ2V0Tmdab25lKG5nWm9uZU9wdGlvbikge1xuICAgIHZhciBuZ1pvbmU7XG4gICAgaWYgKG5nWm9uZU9wdGlvbiA9PT0gJ25vb3AnKSB7XG4gICAgICAgIG5nWm9uZSA9IG5ldyBOb29wTmdab25lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZ1pvbmUgPSAobmdab25lT3B0aW9uID09PSAnem9uZS5qcycgPyB1bmRlZmluZWQgOiBuZ1pvbmVPcHRpb24pIHx8XG4gICAgICAgICAgICBuZXcgTmdab25lKHsgZW5hYmxlTG9uZ1N0YWNrVHJhY2U6IGlzRGV2TW9kZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmdab25lO1xufVxuZnVuY3Rpb24gX2NhbGxBbmRSZXBvcnRUb0Vycm9ySGFuZGxlcihlcnJvckhhbmRsZXIsIG5nWm9uZSwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlKTsgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIG5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7IH0pO1xuICAgICAgICAvLyByZXRocm93IGFzIHRoZSBleGNlcHRpb24gaGFuZGxlciBtaWdodCBub3QgZG8gaXRcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBvcHRpb25zUmVkdWNlcihkc3QsIG9ianMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpzKSkge1xuICAgICAgICBkc3QgPSBvYmpzLnJlZHVjZShvcHRpb25zUmVkdWNlciwgZHN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRzdCA9IF9fYXNzaWduKHt9LCBkc3QsIG9ianMpO1xuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gYSBwYWdlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFwcGxpY2F0aW9uUmVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZihfem9uZSwgX2NvbnNvbGUsIF9pbmplY3RvciwgX2V4Y2VwdGlvbkhhbmRsZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9pbml0U3RhdHVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgdGhpcy5fZXhjZXB0aW9uSGFuZGxlciA9IF9leGNlcHRpb25IYW5kbGVyO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9pbml0U3RhdHVzID0gX2luaXRTdGF0dXM7XG4gICAgICAgIHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLl92aWV3cyA9IFtdO1xuICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbmZvcmNlTm9OZXdDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBsaXN0IG9mIGNvbXBvbmVudCB0eXBlcyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAqIFRoaXMgbGlzdCBpcyBwb3B1bGF0ZWQgZXZlbiBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgbGlzdCBvZiBjb21wb25lbnRzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbmZvcmNlTm9OZXdDaGFuZ2VzID0gaXNEZXZNb2RlKCk7XG4gICAgICAgIHRoaXMuX3pvbmUub25NaWNyb3Rhc2tFbXB0eS5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0gfSk7XG4gICAgICAgIHZhciBpc0N1cnJlbnRseVN0YWJsZSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3N0YWJsZSA9IF90aGlzLl96b25lLmlzU3RhYmxlICYmICFfdGhpcy5fem9uZS5oYXNQZW5kaW5nTWFjcm90YXNrcyAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5fem9uZS5oYXNQZW5kaW5nTWljcm90YXNrcztcbiAgICAgICAgICAgIF90aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KF90aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc1N0YWJsZSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdWJzY3JpcHRpb24gdG8gb25TdGFibGUgb3V0c2lkZSB0aGUgQW5ndWxhciBab25lIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayBpcyBydW4gb3V0c2lkZSB0aGUgQW5ndWxhciBab25lLlxuICAgICAgICAgICAgdmFyIHN0YWJsZVN1YjtcbiAgICAgICAgICAgIF90aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdGFibGVTdWIgPSBfdGhpcy5fem9uZS5vblN0YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBubyBwZW5kaW5nIG1hY3JvL21pY3JvIHRhc2tzIGluIHRoZSBuZXh0IHRpY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIE5nWm9uZSB0byB1cGRhdGUgdGhlIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9zdGFibGUgJiYgIV90aGlzLl96b25lLmhhc1BlbmRpbmdNYWNyb3Rhc2tzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLl96b25lLmhhc1BlbmRpbmdNaWNyb3Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB1bnN0YWJsZVN1YiA9IF90aGlzLl96b25lLm9uVW5zdGFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBOZ1pvbmUuYXNzZXJ0SW5Bbmd1bGFyWm9uZSgpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyBvYnNlcnZlci5uZXh0KGZhbHNlKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0YWJsZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHVuc3RhYmxlU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc1N0YWJsZSA9XG4gICAgICAgICAgICBtZXJnZShpc0N1cnJlbnRseVN0YWJsZSwgaXNTdGFibGUucGlwZShzaGFyZSgpKSk7XG4gICAgfVxuICAgIEFwcGxpY2F0aW9uUmVmXzEgPSBBcHBsaWNhdGlvblJlZjtcbiAgICAvKipcbiAgICAgKiBCb290c3RyYXAgYSBuZXcgY29tcG9uZW50IGF0IHRoZSByb290IGxldmVsIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIEJvb3RzdHJhcCBwcm9jZXNzXG4gICAgICpcbiAgICAgKiBXaGVuIGJvb3RzdHJhcHBpbmcgYSBuZXcgcm9vdCBjb21wb25lbnQgaW50byBhbiBhcHBsaWNhdGlvbiwgQW5ndWxhciBtb3VudHMgdGhlXG4gICAgICogc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGNvbXBvbmVudCBvbnRvIERPTSBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IHRoZSBjb21wb25lbnRUeXBlJ3NcbiAgICAgKiBzZWxlY3RvciBhbmQga2lja3Mgb2ZmIGF1dG9tYXRpYyBjaGFuZ2UgZGV0ZWN0aW9uIHRvIGZpbmlzaCBpbml0aWFsaXppbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIE9wdGlvbmFsbHksIGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIG9udG8gYSBET00gZWxlbWVudCB0aGF0IGRvZXMgbm90IG1hdGNoIHRoZVxuICAgICAqIGNvbXBvbmVudFR5cGUncyBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvcGxhdGZvcm0vcGxhdGZvcm0udHMgcmVnaW9uPSdsb25nZm9ybSd9XG4gICAgICovXG4gICAgQXBwbGljYXRpb25SZWYucHJvdG90eXBlLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChjb21wb25lbnRPckZhY3RvcnksIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX2luaXRTdGF0dXMuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYm9vdHN0cmFwIGFzIHRoZXJlIGFyZSBzdGlsbCBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIHJ1bm5pbmcuIEJvb3RzdHJhcCBjb21wb25lbnRzIGluIHRoZSBgbmdEb0Jvb3RzdHJhcGAgbWV0aG9kIG9mIHRoZSByb290IG1vZHVsZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgaWYgKGNvbXBvbmVudE9yRmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudEZhY3RvcnkgPSBjb21wb25lbnRPckZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50T3JGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50RmFjdG9yeS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZmFjdG9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbW9kdWxlIGlmIGl0J3Mgbm90IGJvdW5kIHRvIHNvbWUgb3RoZXJcbiAgICAgICAgdmFyIG5nTW9kdWxlID0gY29tcG9uZW50RmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnlCb3VuZFRvTW9kdWxlID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IuZ2V0KE5nTW9kdWxlUmVmKTtcbiAgICAgICAgdmFyIHNlbGVjdG9yT3JOb2RlID0gcm9vdFNlbGVjdG9yT3JOb2RlIHx8IGNvbXBvbmVudEZhY3Rvcnkuc2VsZWN0b3I7XG4gICAgICAgIHZhciBjb21wUmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoSW5qZWN0b3IuTlVMTCwgW10sIHNlbGVjdG9yT3JOb2RlLCBuZ01vZHVsZSk7XG4gICAgICAgIGNvbXBSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgX3RoaXMuX3VubG9hZENvbXBvbmVudChjb21wUmVmKTsgfSk7XG4gICAgICAgIHZhciB0ZXN0YWJpbGl0eSA9IGNvbXBSZWYuaW5qZWN0b3IuZ2V0KFRlc3RhYmlsaXR5LCBudWxsKTtcbiAgICAgICAgaWYgKHRlc3RhYmlsaXR5KSB7XG4gICAgICAgICAgICBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgIC5yZWdpc3RlckFwcGxpY2F0aW9uKGNvbXBSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudCwgdGVzdGFiaWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWRDb21wb25lbnQoY29tcFJlZik7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZS5sb2coXCJBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gdGhlIGRldmVsb3BtZW50IG1vZGUuIENhbGwgZW5hYmxlUHJvZE1vZGUoKSB0byBlbmFibGUgdGhlIHByb2R1Y3Rpb24gbW9kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gZXhwbGljaXRseSBwcm9jZXNzIGNoYW5nZSBkZXRlY3Rpb24gYW5kIGl0cyBzaWRlLWVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBJbiBkZXZlbG9wbWVudCBtb2RlLCBgdGljaygpYCBhbHNvIHBlcmZvcm1zIGEgc2Vjb25kIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUgdG8gZW5zdXJlIHRoYXQgbm9cbiAgICAgKiBmdXJ0aGVyIGNoYW5nZXMgYXJlIGRldGVjdGVkLiBJZiBhZGRpdGlvbmFsIGNoYW5nZXMgYXJlIHBpY2tlZCB1cCBkdXJpbmcgdGhpcyBzZWNvbmQgY3ljbGUsXG4gICAgICogYmluZGluZ3MgaW4gdGhlIGFwcCBoYXZlIHNpZGUtZWZmZWN0cyB0aGF0IGNhbm5vdCBiZSByZXNvbHZlZCBpbiBhIHNpbmdsZSBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICogcGFzcy5cbiAgICAgKiBJbiB0aGlzIGNhc2UsIEFuZ3VsYXIgdGhyb3dzIGFuIGVycm9yLCBzaW5jZSBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIGNhbiBvbmx5IGhhdmUgb25lIGNoYW5nZVxuICAgICAqIGRldGVjdGlvbiBwYXNzIGR1cmluZyB3aGljaCBhbGwgY2hhbmdlIGRldGVjdGlvbiBtdXN0IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcnVubmluZ1RpY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXBwbGljYXRpb25SZWYudGljayBpcyBjYWxsZWQgcmVjdXJzaXZlbHknKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGUgPSBBcHBsaWNhdGlvblJlZl8xLl90aWNrU2NvcGUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHsgcmV0dXJuIHZpZXcuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmZvcmNlTm9OZXdDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5jaGVja05vQ2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gQXR0ZW50aW9uOiBEb24ndCByZXRocm93IGFzIGl0IGNvdWxkIGNhbmNlbCBzdWJzY3JpcHRpb25zIHRvIE9ic2VydmFibGVzIVxuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZXhjZXB0aW9uSGFuZGxlci5oYW5kbGVFcnJvcihlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgd3RmTGVhdmUoc2NvcGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhIHZpZXcgc28gdGhhdCBpdCB3aWxsIGJlIGRpcnR5IGNoZWNrZWQuXG4gICAgICogVGhlIHZpZXcgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRldGFjaGVkIHdoZW4gaXQgaXMgZGVzdHJveWVkLlxuICAgICAqIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmlldyBpcyBhbHJlYWR5IGF0dGFjaGVkIHRvIGEgVmlld0NvbnRhaW5lci5cbiAgICAgKi9cbiAgICBBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUuYXR0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdmlld1JlZjtcbiAgICAgICAgdGhpcy5fdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5hdHRhY2hUb0FwcFJlZih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGFjaGVzIGEgdmlldyBmcm9tIGRpcnR5IGNoZWNraW5nIGFnYWluLlxuICAgICAqL1xuICAgIEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB2aWV3UmVmO1xuICAgICAgICByZW1vdmUodGhpcy5fdmlld3MsIHZpZXcpO1xuICAgICAgICB2aWV3LmRldGFjaEZyb21BcHBSZWYoKTtcbiAgICB9O1xuICAgIEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZS5fbG9hZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjb21wb25lbnRSZWYpO1xuICAgICAgICAvLyBHZXQgdGhlIGxpc3RlbmVycyBsYXppbHkgdG8gcHJldmVudCBESSBjeWNsZXMuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgW10pLmNvbmNhdCh0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMpO1xuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKGNvbXBvbmVudFJlZik7IH0pO1xuICAgIH07XG4gICAgQXBwbGljYXRpb25SZWYucHJvdG90eXBlLl91bmxvYWRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICByZW1vdmUodGhpcy5jb21wb25lbnRzLCBjb21wb25lbnRSZWYpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgIHRoaXMuX3ZpZXdzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5kZXN0cm95KCk7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJ2aWV3Q291bnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGF0dGFjaGVkIHZpZXdzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3cy5sZW5ndGg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBBcHBsaWNhdGlvblJlZl8xO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBBcHBsaWNhdGlvblJlZi5fdGlja1Njb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ0FwcGxpY2F0aW9uUmVmI3RpY2soKScpO1xuICAgIEFwcGxpY2F0aW9uUmVmID0gQXBwbGljYXRpb25SZWZfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lLCBDb25zb2xlLCBJbmplY3RvcixcbiAgICAgICAgICAgIEVycm9ySGFuZGxlcixcbiAgICAgICAgICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1c10pXG4gICAgXSwgQXBwbGljYXRpb25SZWYpO1xuICAgIHJldHVybiBBcHBsaWNhdGlvblJlZjtcbn0oKSk7XG5mdW5jdGlvbiByZW1vdmUobGlzdCwgZWwpIHtcbiAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFVzZWQgdG8gbG9hZCBuZyBtb2R1bGUgZmFjdG9yaWVzLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZUZhY3RvcnlMb2FkZXI7XG59KCkpO1xudmFyIG1vZHVsZUZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogUmVnaXN0ZXJzIGEgbG9hZGVkIG1vZHVsZS4gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gZ2VuZXJhdGVkIE5nTW9kdWxlRmFjdG9yeSBjb2RlLlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiByZWdpc3Rlck1vZHVsZUZhY3RvcnkoaWQsIGZhY3RvcnkpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtb2R1bGVGYWN0b3JpZXMuZ2V0KGlkKTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIG1vZHVsZSByZWdpc3RlcmVkIGZvciBcIiArIGlkICsgXCIgLSBcIiArIGV4aXN0aW5nLm1vZHVsZVR5cGUubmFtZSArIFwiIHZzIFwiICsgZmFjdG9yeS5tb2R1bGVUeXBlLm5hbWUpO1xuICAgIH1cbiAgICBtb2R1bGVGYWN0b3JpZXMuc2V0KGlkLCBmYWN0b3J5KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgTmdNb2R1bGVGYWN0b3J5IHdpdGggdGhlIGdpdmVuIGlkLCBpZiBpdCBleGlzdHMgYW5kIGhhcyBiZWVuIGxvYWRlZC5cbiAqIEZhY3RvcmllcyBmb3IgbW9kdWxlcyB0aGF0IGRvIG5vdCBzcGVjaWZ5IGFuIGBpZGAgY2Fubm90IGJlIHJldHJpZXZlZC4gVGhyb3dzIGlmIHRoZSBtb2R1bGVcbiAqIGNhbm5vdCBiZSBmb3VuZC5cbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWxlRmFjdG9yeShpZCkge1xuICAgIHZhciBmYWN0b3J5ID0gbW9kdWxlRmFjdG9yaWVzLmdldChpZCk7XG4gICAgaWYgKCFmYWN0b3J5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2R1bGUgd2l0aCBJRCBcIiArIGlkICsgXCIgbG9hZGVkXCIpO1xuICAgIHJldHVybiBmYWN0b3J5O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIHVubW9kaWZpYWJsZSBsaXN0IG9mIGl0ZW1zIHRoYXQgQW5ndWxhciBrZWVwcyB1cCB0byBkYXRlIHdoZW4gdGhlIHN0YXRlXG4gKiBvZiB0aGUgYXBwbGljYXRpb24gY2hhbmdlcy5cbiAqXG4gKiBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB7QGxpbmsgVmlld0NoaWxkcmVufSwge0BsaW5rIENvbnRlbnRDaGlsZHJlbn0sIGFuZCB7QGxpbmsgUXVlcnlMaXN0fVxuICogcHJvdmlkZS5cbiAqXG4gKiBJbXBsZW1lbnRzIGFuIGl0ZXJhYmxlIGludGVyZmFjZSwgdGhlcmVmb3JlIGl0IGNhbiBiZSB1c2VkIGluIGJvdGggRVM2XG4gKiBqYXZhc2NyaXB0IGBmb3IgKHZhciBpIG9mIGl0ZW1zKWAgbG9vcHMgYXMgd2VsbCBhcyBpbiBBbmd1bGFyIHRlbXBsYXRlcyB3aXRoXG4gKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICpcbiAqIENoYW5nZXMgY2FuIGJlIG9ic2VydmVkIGJ5IHN1YnNjcmliaW5nIHRvIHRoZSBjaGFuZ2VzIGBPYnNlcnZhYmxlYC5cbiAqXG4gKiBOT1RFOiBJbiB0aGUgZnV0dXJlIHRoaXMgY2xhc3Mgd2lsbCBpbXBsZW1lbnQgYW4gYE9ic2VydmFibGVgIGludGVyZmFjZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBDb21wb25lbnQoey4uLn0pXG4gKiBjbGFzcyBDb250YWluZXIge1xuICogICBAVmlld0NoaWxkcmVuKEl0ZW0pIGl0ZW1zOlF1ZXJ5TGlzdDxJdGVtPjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFF1ZXJ5TGlzdCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5TGlzdCgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZVxuICAgICAqIFtBcnJheS5tYXBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcClcbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5tYXAoZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIFNlZVxuICAgICAqIFtBcnJheS5maWx0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlcilcbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5maWx0ZXIoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogW0FycmF5LmZpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmQpXG4gICAgICovXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRzLmZpbmQoZm4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogW0FycmF5LnJlZHVjZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlKVxuICAgICAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRzLnJlZHVjZShmbiwgaW5pdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWVcbiAgICAgKiBbQXJyYXkuZm9yRWFjaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaClcbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fcmVzdWx0cy5mb3JFYWNoKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBTZWVcbiAgICAgKiBbQXJyYXkuc29tZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZSlcbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMuc29tZShmbik7XG4gICAgfTtcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnNsaWNlKCk7IH07XG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZVtnZXRTeW1ib2xJdGVyYXRvcigpXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTsgfTtcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSBmbGF0dGVuJDIocmVzKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX3Jlc3VsdHMubGVuZ3RoO1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLl9yZXN1bHRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuZmlyc3QgPSB0aGlzLl9yZXN1bHRzWzBdO1xuICAgIH07XG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuY2hhbmdlcy5lbWl0KHRoaXMpOyB9O1xuICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGlydHkgPSB0cnVlOyB9O1xuICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXJ5TGlzdDtcbn0oKSk7XG5mdW5jdGlvbiBmbGF0dGVuJDIobGlzdCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICB2YXIgZmxhdEl0ZW0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gZmxhdHRlbiQyKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfU0VQQVJBVE9SID0gJyMnO1xudmFyIEZBQ1RPUllfQ0xBU1NfU1VGRklYID0gJ05nRmFjdG9yeSc7XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuXG4gKiB0b2tlbi5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcoKSB7XG4gICAgfVxuICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xufSgpKTtcbnZhciBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgZmFjdG9yeVBhdGhTdWZmaXg6ICcubmdmYWN0b3J5Jyxcbn07XG4vKipcbiAqIE5nTW9kdWxlRmFjdG9yeUxvYWRlciB0aGF0IHVzZXMgU3lzdGVtSlMgdG8gbG9hZCBOZ01vZHVsZUZhY3RvcnlcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcihfY29tcGlsZXIsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9jb21waWxlciA9IF9jb21waWxlcjtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnIHx8IERFRkFVTFRfQ09ORklHO1xuICAgIH1cbiAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIG9mZmxpbmVNb2RlID0gdGhpcy5fY29tcGlsZXIgaW5zdGFuY2VvZiBDb21waWxlcjtcbiAgICAgICAgcmV0dXJuIG9mZmxpbmVNb2RlID8gdGhpcy5sb2FkRmFjdG9yeShwYXRoKSA6IHRoaXMubG9hZEFuZENvbXBpbGUocGF0aCk7XG4gICAgfTtcbiAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkQW5kQ29tcGlsZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCAyKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0TmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydChtb2R1bGUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eSh0eXBlLCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModHlwZSk7IH0pO1xuICAgIH07XG4gICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEZhY3RvcnkgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgMiksIG1vZHVsZSA9IF9hWzBdLCBleHBvcnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciBmYWN0b3J5Q2xhc3NTdWZmaXggPSBGQUNUT1JZX0NMQVNTX1NVRkZJWDtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0TmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGZhY3RvcnlDbGFzc1N1ZmZpeCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeXN0ZW0uaW1wb3J0KHRoaXMuX2NvbmZpZy5mYWN0b3J5UGF0aFByZWZpeCArIG1vZHVsZSArIHRoaXMuX2NvbmZpZy5mYWN0b3J5UGF0aFN1ZmZpeClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lICsgZmFjdG9yeUNsYXNzU3VmZml4XTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBjaGVja05vdEVtcHR5KGZhY3RvcnksIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pO1xuICAgIH07XG4gICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29tcGlsZXIsIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWddKVxuICAgIF0sIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIpO1xuICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGNoZWNrTm90RW1wdHkodmFsdWUsIG1vZHVsZVBhdGgsIGV4cG9ydE5hbWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kICdcIiArIGV4cG9ydE5hbWUgKyBcIicgaW4gJ1wiICsgbW9kdWxlUGF0aCArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb250YWluZXIgd2hlcmUgb25lIG9yIG1vcmUgdmlld3MgY2FuIGJlIGF0dGFjaGVkIHRvIGEgY29tcG9uZW50LlxuICpcbiAqIENhbiBjb250YWluICpob3N0IHZpZXdzKiAoY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAqIGNvbXBvbmVudCB3aXRoIHRoZSBgY3JlYXRlQ29tcG9uZW50KClgIG1ldGhvZCksIGFuZCAqZW1iZWRkZWQgdmlld3MqXG4gKiAoY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGEgYFRlbXBsYXRlUmVmYCB3aXRoIHRoZSBgY3JlYXRlRW1iZWRkZWRWaWV3KClgIG1ldGhvZCkuXG4gKlxuICogQSB2aWV3IGNvbnRhaW5lciBpbnN0YW5jZSBjYW4gY29udGFpbiBvdGhlciB2aWV3IGNvbnRhaW5lcnMsXG4gKiBjcmVhdGluZyBhIFt2aWV3IGhpZXJhcmNoeV0oZ3VpZGUvZ2xvc3Nhcnkjdmlldy10cmVlKS5cbiAqXG4gKiBAc2VlIGBDb21wb25lbnRSZWZgXG4gKiBAc2VlIGBFbWJlZGRlZFZpZXdSZWZgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmlld0NvbnRhaW5lclJlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29udGFpbmVyUmVmKCkge1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgVmlld0NvbnRhaW5lclJlZi5fX05HX0VMRU1FTlRfSURfXyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFIzX1ZJRVdfQ09OVEFJTkVSX1JFRl9GQUNUT1JZJDEoVmlld0NvbnRhaW5lclJlZiwgRWxlbWVudFJlZik7IH07XG4gICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWY7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIEFuZ3VsYXIgVmlld3MsIHByb3ZpZGVzIGNoYW5nZSBkZXRlY3Rpb24gZnVuY3Rpb25hbGl0eS5cbiAqIEEgY2hhbmdlLWRldGVjdGlvbiB0cmVlIGNvbGxlY3RzIGFsbCB2aWV3cyB0aGF0IGFyZSB0byBiZSBjaGVja2VkIGZvciBjaGFuZ2VzLlxuICogVXNlIHRoZSBtZXRob2RzIHRvIGFkZCBhbmQgcmVtb3ZlIHZpZXdzIGZyb20gdGhlIHRyZWUsIGluaXRpYXRlIGNoYW5nZS1kZXRlY3Rpb24sXG4gKiBhbmQgZXhwbGljaXRseSBtYXJrIHZpZXdzIGFzIF9kaXJ0eV8sIG1lYW5pbmcgdGhhdCB0aGV5IGhhdmUgY2hhbmdlZCBhbmQgbmVlZCB0byBiZSByZXJlbmRlcmVkLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlcyBkZW1vbnN0cmF0ZSBob3cgdG8gbW9kaWZ5IGRlZmF1bHQgY2hhbmdlLWRldGVjdGlvbiBiZWhhdmlvclxuICogdG8gcGVyZm9ybSBleHBsaWNpdCBkZXRlY3Rpb24gd2hlbiBuZWVkZWQuXG4gKlxuICogIyMjIFVzZSBgbWFya0ZvckNoZWNrKClgIHdpdGggYENoZWNrT25jZWAgc3RyYXRlZ3lcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2V0cyB0aGUgYE9uUHVzaGAgY2hhbmdlLWRldGVjdGlvbiBzdHJhdGVneSBmb3IgYSBjb21wb25lbnRcbiAqIChgQ2hlY2tPbmNlYCwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYENoZWNrQWx3YXlzYCksIHRoZW4gZm9yY2VzIGEgc2Vjb25kIGNoZWNrXG4gKiBhZnRlciBhbiBpbnRlcnZhbC4gU2VlIFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0dDNTEyYj9wPXByZXZpZXcpLlxuICpcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cImNvcmUvdHMvY2hhbmdlX2RldGVjdC9jaGFuZ2UtZGV0ZWN0aW9uLnRzXCJcbiAqIHJlZ2lvbj1cIm1hcmstZm9yLWNoZWNrXCI+PC9jb2RlLWV4YW1wbGU+XG4gKlxuICogIyMjIERldGFjaCBjaGFuZ2UgZGV0ZWN0b3IgdG8gbGltaXQgaG93IG9mdGVuIGNoZWNrIG9jY3Vyc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZWZpbmVzIGEgY29tcG9uZW50IHdpdGggYSBsYXJnZSBsaXN0IG9mIHJlYWQtb25seSBkYXRhXG4gKiB0aGF0IGlzIGV4cGVjdGVkIHRvIGNoYW5nZSBjb25zdGFudGx5LCBtYW55IHRpbWVzIHBlciBzZWNvbmQuXG4gKiBUbyBpbXByb3ZlIHBlcmZvcm1hbmNlLCB3ZSB3YW50IHRvIGNoZWNrIGFuZCB1cGRhdGUgdGhlIGxpc3RcbiAqIGxlc3Mgb2Z0ZW4gdGhhbiB0aGUgY2hhbmdlcyBhY3R1YWxseSBvY2N1ci4gVG8gZG8gdGhhdCwgd2UgZGV0YWNoXG4gKiB0aGUgY29tcG9uZW50J3MgY2hhbmdlIGRldGVjdG9yIGFuZCBwZXJmb3JtIGFuIGV4cGxpY2l0IGxvY2FsIGNoZWNrIGV2ZXJ5IGZpdmUgc2Vjb25kcy5cbiAqXG4gKiA8Y29kZS1leGFtcGxlIHBhdGg9XCJjb3JlL3RzL2NoYW5nZV9kZXRlY3QvY2hhbmdlLWRldGVjdGlvbi50c1wiIHJlZ2lvbj1cImRldGFjaFwiPjwvY29kZS1leGFtcGxlPlxuICpcbiAqXG4gKiAjIyMgUmVhdHRhY2hpbmcgYSBkZXRhY2hlZCBjb21wb25lbnRcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCBkaXNwbGF5aW5nIGxpdmUgZGF0YS5cbiAqIFRoZSBjb21wb25lbnQgZGV0YWNoZXMgaXRzIGNoYW5nZSBkZXRlY3RvciBmcm9tIHRoZSBtYWluIGNoYW5nZSBkZXRlY3RvciB0cmVlXG4gKiB3aGVuIHRoZSBgbGl2ZWAgcHJvcGVydHkgaXMgc2V0IHRvIGZhbHNlLCBhbmQgcmVhdHRhY2hlcyBpdCB3aGVuIHRoZSBwcm9wZXJ0eVxuICogYmVjb21lcyB0cnVlLlxuICpcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cImNvcmUvdHMvY2hhbmdlX2RldGVjdC9jaGFuZ2UtZGV0ZWN0aW9uLnRzXCIgcmVnaW9uPVwicmVhdHRhY2hcIj48L2NvZGUtZXhhbXBsZT5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDaGFuZ2VEZXRlY3RvclJlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIENoYW5nZURldGVjdG9yUmVmLl9fTkdfRUxFTUVOVF9JRF9fID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUjNfQ0hBTkdFX0RFVEVDVE9SX1JFRl9GQUNUT1JZJDEoKTsgfTtcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWY7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBbdmlld10oZ3VpZGUvZ2xvc3NhcnkjdmlldyksXG4gKiBzcGVjaWZpY2FsbHkgdGhlIFtob3N0IHZpZXddKGd1aWRlL2dsb3NzYXJ5I3ZpZXctdHJlZSkgdGhhdCBpcyBkZWZpbmVkIGJ5IGEgY29tcG9uZW50LlxuICogQWxzbyBzZXJ2ZXMgYXMgdGhlIGJhc2UgY2xhc3NcbiAqIHRoYXQgYWRkcyBkZXN0cm95IG1ldGhvZHMgZm9yIFtlbWJlZGRlZCB2aWV3c10oZ3VpZGUvZ2xvc3Nhcnkjdmlldy10cmVlKS5cbiAqXG4gKiBAc2VlIGBFbWJlZGRlZFZpZXdSZWZgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVmlld1JlZiQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3UmVmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXdSZWYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFZpZXdSZWY7XG59KENoYW5nZURldGVjdG9yUmVmKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBbdmlld10oZ3VpZGUvZ2xvc3NhcnkjdmlldykgaW4gYSB2aWV3IGNvbnRhaW5lci5cbiAqIEFuIFtlbWJlZGRlZCB2aWV3XShndWlkZS9nbG9zc2FyeSN2aWV3LXRyZWUpIGNhbiBiZSByZWZlcmVuY2VkIGZyb20gYSBjb21wb25lbnRcbiAqIG90aGVyIHRoYW4gdGhlIGhvc3RpbmcgY29tcG9uZW50IHdob3NlIHRlbXBsYXRlIGRlZmluZXMgaXQsIG9yIGl0IGNhbiBiZSBkZWZpbmVkXG4gKiBpbmRlcGVuZGVudGx5IGJ5IGEgYFRlbXBsYXRlUmVmYC5cbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGVsZW1lbnRzIGluIGEgdmlldyBjYW4gY2hhbmdlLCBidXQgdGhlIHN0cnVjdHVyZSAobnVtYmVyIGFuZCBvcmRlcikgb2YgZWxlbWVudHMgaW5cbiAqIGEgdmlldyBjYW5ub3QuIENoYW5nZSB0aGUgc3RydWN0dXJlIG9mIGVsZW1lbnRzIGJ5IGluc2VydGluZywgbW92aW5nLCBvclxuICogcmVtb3ZpbmcgbmVzdGVkIHZpZXdzIGluIGEgdmlldyBjb250YWluZXIuXG4gKlxuICogQHNlZSBgVmlld0NvbnRhaW5lclJlZmBcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgYnJlYWtzIGRvd24gaW50byB0d28gc2VwYXJhdGUgYFRlbXBsYXRlUmVmYCBpbnN0YW5jZXMsXG4gKiBhbiBvdXRlciBvbmUgYW5kIGFuIGlubmVyIG9uZS5cbiAqXG4gKiBgYGBcbiAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XG4gKiA8dWw+XG4gKiAgIDxsaSAqbmdGb3I9XCJsZXQgIGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fTwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogVGhpcyBpcyB0aGUgb3V0ZXIgYFRlbXBsYXRlUmVmYDpcbiAqXG4gKiBgYGBcbiAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XG4gKiA8dWw+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJpdGVtc1wiPjwvbmctdGVtcGxhdGU+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogVGhpcyBpcyB0aGUgaW5uZXIgYFRlbXBsYXRlUmVmYDpcbiAqXG4gKiBgYGBcbiAqICAgPGxpPnt7aXRlbX19PC9saT5cbiAqIGBgYFxuICpcbiAqIFRoZSBvdXRlciBhbmQgaW5uZXIgYFRlbXBsYXRlUmVmYCBpbnN0YW5jZXMgYXJlIGFzc2VtYmxlZCBpbnRvIHZpZXdzIGFzIGZvbGxvd3M6XG4gKlxuICogYGBgXG4gKiA8IS0tIFZpZXdSZWY6IG91dGVyLTAgLS0+XG4gKiBDb3VudDogMlxuICogPHVsPlxuICogICA8bmctdGVtcGxhdGUgdmlldy1jb250YWluZXItcmVmPjwvbmctdGVtcGxhdGU+XG4gKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMSAtLT48bGk+Zmlyc3Q8L2xpPjwhLS0gL1ZpZXdSZWY6IGlubmVyLTEgLS0+XG4gKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMiAtLT48bGk+c2Vjb25kPC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0yIC0tPlxuICogPC91bD5cbiAqIDwhLS0gL1ZpZXdSZWY6IG91dGVyLTAgLS0+XG4gKiBgYGBcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEVtYmVkZGVkVmlld1JlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1iZWRkZWRWaWV3UmVmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtYmVkZGVkVmlld1JlZigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRW1iZWRkZWRWaWV3UmVmO1xufShWaWV3UmVmJDEpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXI7XG59KCkpO1xuLyoqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBEZWJ1Z05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVidWdOb2RlKG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnQ29udGV4dCkge1xuICAgICAgICB0aGlzLm5hdGl2ZU5vZGUgPSBuYXRpdmVOb2RlO1xuICAgICAgICB0aGlzLl9kZWJ1Z0NvbnRleHQgPSBfZGVidWdDb250ZXh0O1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50IGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnQ29udGV4dC5pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29tcG9uZW50SW5zdGFuY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnQ29udGV4dC5jb21wb25lbnQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnQ29udGV4dC5jb250ZXh0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWJ1Z0NvbnRleHQucmVmZXJlbmNlczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnQ29udGV4dC5wcm92aWRlclRva2VuczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERlYnVnTm9kZTtcbn0oKSk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIERlYnVnRWxlbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVidWdFbGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYnVnRWxlbWVudChuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0NvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdDb250ZXh0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuY2xhc3NlcyA9IHt9O1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBfdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlTm9kZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnNwbGljZShjaGlsZEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5pbnNlcnRDaGlsZHJlbkFmdGVyID0gZnVuY3Rpb24gKGNoaWxkLCBuZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBzaWJsaW5nSW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChzaWJsaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNoaWxkTm9kZXMpLnNwbGljZS5hcHBseShfYSwgX19zcHJlYWQoW3NpYmxpbmdJbmRleCArIDEsIDBdLCBuZXdDaGlsZHJlbikpO1xuICAgICAgICAgICAgbmV3Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5yZW1vdmVDaGlsZChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBfdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChyZWZDaGlsZCwgbmV3Q2hpbGQpIHtcbiAgICAgICAgdmFyIHJlZkluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YocmVmQ2hpbGQpO1xuICAgICAgICBpZiAocmVmSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UocmVmSW5kZXgsIDAsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnF1ZXJ5QWxsKHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzWzBdIHx8IG51bGw7XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBfcXVlcnlFbGVtZW50Q2hpbGRyZW4odGhpcywgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsTm9kZXMgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbih0aGlzLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZE5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudDsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUudHJpZ2dlckV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjayhldmVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERlYnVnRWxlbWVudDtcbn0oRGVidWdOb2RlKSk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gYXNOYXRpdmVFbGVtZW50cyhkZWJ1Z0Vscykge1xuICAgIHJldHVybiBkZWJ1Z0Vscy5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uYXRpdmVFbGVtZW50OyB9KTtcbn1cbmZ1bmN0aW9uIF9xdWVyeUVsZW1lbnRDaGlsZHJlbihlbGVtZW50LCBwcmVkaWNhdGUsIG1hdGNoZXMpIHtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9xdWVyeUVsZW1lbnRDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfcXVlcnlOb2RlQ2hpbGRyZW4ocGFyZW50Tm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBOZWVkIHRvIGtlZXAgdGhlIG5vZGVzIGluIGEgZ2xvYmFsIE1hcCBzbyB0aGF0IG11bHRpcGxlIGFuZ3VsYXIgYXBwcyBhcmUgc3VwcG9ydGVkLlxudmFyIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gZ2V0RGVidWdOb2RlKG5hdGl2ZU5vZGUpIHtcbiAgICByZXR1cm4gX25hdGl2ZU5vZGVUb0RlYnVnTm9kZS5nZXQobmF0aXZlTm9kZSkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGluZGV4RGVidWdOb2RlKG5vZGUpIHtcbiAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLnNldChub2RlLm5hdGl2ZU5vZGUsIG5vZGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRGVidWdOb2RlRnJvbUluZGV4KG5vZGUpIHtcbiAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLmRlbGV0ZShub2RlLm5hdGl2ZU5vZGUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCkge1xuICAgIH1cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGlzTGlzdExpa2VJdGVyYWJsZShvYmopOyB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0cmFja0J5Rm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXIodHJhY2tCeUZuKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5O1xufSgpKTtcbnZhciB0cmFja0J5SWRlbnRpdHkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH07XG4vKipcbiAqIEBkZXByZWNhdGVkIHY0LjAuMCAtIFNob3VsZCBub3QgYmUgcGFydCBvZiBwdWJsaWMgQVBJLlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlcih0cmFja0J5Rm4pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdXNlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIChkdXJpbmcgJiBhY3Jvc3MgYF9jaGVjaygpYCBjYWxscylcbiAgICAgICAgdGhpcy5fbGlua2VkUmVjb3JkcyA9IG51bGw7XG4gICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSByZW1vdmVkIHJlY29yZHMgYXQgYW55IHBvaW50IGluIHRpbWUgZHVyaW5nIGBfY2hlY2soKWAgY2FsbHMuXG4gICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiByZWNvcmRzIHdoZXJlIGN1c3RvbSB0cmFjayBieSBpcyB0aGUgc2FtZSwgYnV0IGl0ZW0gaWRlbnRpdHkgaGFzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSB0cmFja0J5Rm4gfHwgdHJhY2tCeUlkZW50aXR5O1xuICAgIH1cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoT3BlcmF0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBuZXh0SXQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgIHZhciBuZXh0UmVtb3ZlID0gdGhpcy5fcmVtb3ZhbHNIZWFkO1xuICAgICAgICB2YXIgYWRkUmVtb3ZlT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1vdmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5leHRJdCB8fCBuZXh0UmVtb3ZlKSB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGlzIHRoZSBuZXh0IHJlY29yZCB0byBwcm9jZXNzXG4gICAgICAgICAgICAvLyBPcmRlcjogcmVtb3ZlLCBhZGQsIG1vdmVcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSAhbmV4dFJlbW92ZSB8fFxuICAgICAgICAgICAgICAgIG5leHRJdCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0SXQuY3VycmVudEluZGV4IDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFByZXZpb3VzSW5kZXgobmV4dFJlbW92ZSwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cykgP1xuICAgICAgICAgICAgICAgIG5leHRJdCA6XG4gICAgICAgICAgICAgICAgbmV4dFJlbW92ZTtcbiAgICAgICAgICAgIHZhciBhZGpQcmV2aW91c0luZGV4ID0gZ2V0UHJldmlvdXNJbmRleChyZWNvcmQsIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAvLyBjb25zdW1lIHRoZSBpdGVtLCBhbmQgYWRqdXN0IHRoZSBhZGRSZW1vdmVPZmZzZXQgYW5kIHVwZGF0ZSBtb3ZlRGlzdGFuY2UgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAocmVjb3JkID09PSBuZXh0UmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYWRkUmVtb3ZlT2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgbmV4dFJlbW92ZSA9IG5leHRSZW1vdmUuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dEl0ID0gbmV4dEl0Ll9uZXh0O1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSU5WQVJJQU5UOiAgY3VycmVudEluZGV4IDwgcHJldmlvdXNJbmRleFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdmVPZmZzZXRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsTW92ZVByZXZpb3VzSW5kZXggPSBhZGpQcmV2aW91c0luZGV4IC0gYWRkUmVtb3ZlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxDdXJyZW50SW5kZXggPSBjdXJyZW50SW5kZXggLSBhZGRSZW1vdmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1vdmVQcmV2aW91c0luZGV4ICE9IGxvY2FsQ3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpIDwgbW92ZU9mZnNldHMubGVuZ3RoID8gbW92ZU9mZnNldHNbaV0gOiAobW92ZU9mZnNldHNbaV0gPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXQgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEN1cnJlbnRJbmRleCA8PSBpbmRleCAmJiBpbmRleCA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldHNbaV0gPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gcmVjb3JkLnByZXZpb3VzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0c1twcmV2aW91c0luZGV4XSA9IGxvY2FsQ3VycmVudEluZGV4IC0gbG9jYWxNb3ZlUHJldmlvdXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGpQcmV2aW91c0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQsIGFkalByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hNb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRJZGVudGl0eUNoYW5nZSkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbClcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgaWYgKCFpc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIHN0cmluZ2lmeShjb2xsZWN0aW9uKSArIFwiJy4gT25seSBhcnJheXMgYW5kIGl0ZXJhYmxlcyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGVjayhjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIHZhciByZWNvcmQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgIHZhciBtYXlCZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHZhciBpdGVtVHJhY2tCeTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleF8xID0gMDsgaW5kZXhfMSA8IHRoaXMubGVuZ3RoOyBpbmRleF8xKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gY29sbGVjdGlvbltpbmRleF8xXTtcbiAgICAgICAgICAgICAgICBpdGVtVHJhY2tCeSA9IHRoaXMuX3RyYWNrQnlGbihpbmRleF8xLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCBpdGVtVHJhY2tCeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fbWlzbWF0Y2gocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleF8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGl0ZXJhdGVMaXN0TGlrZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gX3RoaXMuX3RyYWNrQnlGbihpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl9taXNtYXRjaChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBfdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RydW5jYXRlKHJlY29yZCk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgLyogQ29sbGVjdGlvbkNoYW5nZXMgaXMgY29uc2lkZXJlZCBkaXJ0eSBpZiBpdCBoYXMgYW55IGFkZGl0aW9ucywgbW92ZXMsIHJlbW92YWxzLCBvciBpZGVudGl0eVxuICAgICAgICAgKiBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9tb3Zlc0hlYWQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGwgfHwgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBjaGFuZ2Ugb2JqZWN0cyB0byBzaG93IG5vIGNoYW5nZXMuIFRoaXMgbWVhbnMgc2V0IHByZXZpb3VzS2V5IHRvXG4gICAgICogY3VycmVudEtleSwgYW5kIGNsZWFyIGFsbCBvZiB0aGUgcXVldWVzIChhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscykuXG4gICAgICogU2V0IHRoZSBwcmV2aW91c0luZGV4ZXMgb2YgbW92ZWQgYW5kIGFkZGVkIGl0ZW1zIHRvIHRoZWlyIGN1cnJlbnRJbmRleGVzXG4gICAgICogUmVzZXQgdGhlIGxpc3Qgb2YgYWRkaXRpb25zLCBtb3ZlcyBhbmQgcmVtb3ZhbHNcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gbmV4dFJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSB0aGlzLl9tb3Zlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRPRE8odmljYik6IHdoZW4gYXNzZXJ0IGdldHMgc3VwcG9ydGVkXG4gICAgICAgICAgICAvLyBhc3NlcnQoIXRoaXMuaXNEaXJ0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyBkaWZmZXJlbmNlcyBiZXR3ZWVuIGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogLSBgcmVjb3JkYCBpcyB0aGUgcmVjb3JkIHdoaWNoIHdlIHNhdyBhdCB0aGlzIHBvc2l0aW9uIGxhc3QgdGltZS4gSWYgbnVsbCB0aGVuIGl0IGlzIGEgbmV3XG4gICAgICogICBpdGVtLlxuICAgICAqIC0gYGl0ZW1gIGlzIHRoZSBjdXJyZW50IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiAtIGBpbmRleGAgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9taXNtYXRjaCA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICAvLyBUaGUgcHJldmlvdXMgcmVjb3JkIGFmdGVyIHdoaWNoIHdlIHdpbGwgYXBwZW5kIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgdmFyIHByZXZpb3VzUmVjb3JkO1xuICAgICAgICBpZiAocmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2aW91c1JlY29yZCA9IHRoaXMuX2l0VGFpbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gcmVjb3JkLl9wcmV2O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgY29sbGVjdGlvbiBzaW5jZSB3ZSBrbm93IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzZWUgaWYgd2UgaGF2ZSBzZWVuIHRoZSBpdGVtIGJlZm9yZS5cbiAgICAgICAgcmVjb3JkID0gdGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBiZWZvcmUsIHdlIG5lZWQgdG8gbW92ZSBpdCBmb3J3YXJkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgLy8gQnV0IGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgaWYgaWRlbnRpdHkgY2hhbmdlZCwgc28gd2UgY2FuIHVwZGF0ZSBpbiB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX21vdmVBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOZXZlciBzZWVuIGl0LCBjaGVjayBldmljdGVkIGxpc3QuXG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gaXRlbSB3aGljaCB3ZSBoYXZlIGV2aWN0ZWQgZWFybGllcjogcmVpbnNlcnQgaXQgYmFjayBpbnRvIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGlkZW50aXR5IGNoYW5nZWQsIHNvIHdlIGNhbiB1cGRhdGUgaW4gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWluc2VydEFmdGVyKHJlY29yZCwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgbmV3IGl0ZW06IGFkZCBpdC5cbiAgICAgICAgICAgICAgICByZWNvcmQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRBZnRlcihuZXcgSXRlcmFibGVDaGFuZ2VSZWNvcmRfKGl0ZW0sIGl0ZW1UcmFja0J5KSwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGVjayBpcyBvbmx5IG5lZWRlZCBpZiBhbiBhcnJheSBjb250YWlucyBkdXBsaWNhdGVzLiAoU2hvcnQgY2lyY3VpdCBvZiBub3RoaW5nIGRpcnR5KVxuICAgICAqXG4gICAgICogVXNlIGNhc2U6IGBbYSwgYV1gID0+IGBbYiwgYSwgYV1gXG4gICAgICpcbiAgICAgKiBJZiB3ZSBkaWQgbm90IGhhdmUgdGhpcyBjaGVjayB0aGVuIHRoZSBpbnNlcnRpb24gb2YgYGJgIHdvdWxkOlxuICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXG4gICAgICogICAyKSBpbnNlcnQgYGJgIGF0IGAwYCBpbmRleC5cbiAgICAgKiAgIDMpIGxlYXZlIGBhYCBhdCBpbmRleCBgMWAgYXMgaXMuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDIuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAqXG4gICAgICogVGhlIGNvcnJlY3QgYmVoYXZpb3IgaXM6XG4gICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcbiAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxuICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDEuXG4gICAgICogICAzKSBtb3ZlIGBhYCBhdCBmcm9tIGAxYCB0byBgMmAuXG4gICAgICpcbiAgICAgKlxuICAgICAqIERvdWJsZSBjaGVjayB0aGF0IHdlIGhhdmUgbm90IGV2aWN0ZWQgYSBkdXBsaWNhdGUgaXRlbS4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaXRlbSB0eXBlIG1heVxuICAgICAqIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQ6XG4gICAgICogVGhlIGluc2VydGlvbiBvZiBiIHdpbGwgZXZpY3QgdGhlIGZpcnN0ICdhJy4gSWYgd2UgZG9uJ3QgcmVpbnNlcnQgaXQgbm93IGl0IHdpbGwgYmUgcmVpbnNlcnRlZFxuICAgICAqIGF0IHRoZSBlbmQuIFdoaWNoIHdpbGwgc2hvdyB1cCBhcyB0aGUgdHdvICdhJ3Mgc3dpdGNoaW5nIHBvc2l0aW9uLiBUaGlzIGlzIGluY29ycmVjdCwgc2luY2UgYVxuICAgICAqIGJldHRlciB3YXkgdG8gdGhpbmsgb2YgaXQgaXMgYXMgaW5zZXJ0IG9mICdiJyByYXRoZXIgdGhlbiBzd2l0Y2ggJ2EnIHdpdGggJ2InIGFuZCB0aGVuIGFkZCAnYSdcbiAgICAgKiBhdCB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdmVyaWZ5UmVpbnNlcnRpb24gPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlaW5zZXJ0UmVjb3JkID0gdGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3VubGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnksIG51bGwpO1xuICAgICAgICBpZiAocmVpbnNlcnRSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3JlaW5zZXJ0QWZ0ZXIocmVpbnNlcnRSZWNvcmQsIHJlY29yZC5fcHJldiwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlY29yZC5jdXJyZW50SW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCByaWQgb2YgYW55IGV4Y2VzcyB7QGxpbmsgSXRlcmFibGVDaGFuZ2VSZWNvcmRffXMgZnJvbSB0aGUgcHJldmlvdXMgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtAbGluayBJdGVyYWJsZUNoYW5nZVJlY29yZF99LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdHJ1bmNhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGFmdGVyIHRoYXQgbmVlZHMgdG8gYmUgcmVtb3ZlZDtcbiAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsLl9uZXh0TW92ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pdFRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbC5fbmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwuX25leHRJZGVudGl0eUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZWluc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnJlbW92ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2UmVtb3ZlZDtcbiAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHRSZW1vdmVkO1xuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYuX25leHRSZW1vdmVkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuX3ByZXZSZW1vdmVkID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9tb3ZlQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICB0aGlzLl91bmxpbmsocmVjb3JkKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRPRE8odmljYik6XG4gICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zSGVhZCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8odmljYik6XG4gICAgICAgICAgICAvLyBhc3NlcnQoX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2luc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTpcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZCAhPSBwcmV2UmVjb3JkKTtcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX3ByZXYgPT09IG51bGwpO1xuICAgICAgICB2YXIgbmV4dCA9IHByZXZSZWNvcmQgPT09IG51bGwgPyB0aGlzLl9pdEhlYWQgOiBwcmV2UmVjb3JkLl9uZXh0O1xuICAgICAgICAvLyBUT0RPKHZpY2IpOlxuICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xuICAgICAgICAvLyBhc3NlcnQocHJldlJlY29yZCAhPSByZWNvcmQpO1xuICAgICAgICByZWNvcmQuX25leHQgPSBuZXh0O1xuICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dC5fcHJldiA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldlJlY29yZC5fbmV4dCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcbiAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3VubGluayA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAvLyBUT0RPKHZpY2IpOlxuICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fcHJldiA9IG51bGwpID09PSBudWxsKTtcbiAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX25leHQgPSBudWxsKSA9PT0gbnVsbCk7XG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvTW92ZXMgPSBmdW5jdGlvbiAocmVjb3JkLCB0b0luZGV4KSB7XG4gICAgICAgIC8vIFRPRE8odmljYik6XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRNb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNJbmRleCA9PT0gdG9JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW92ZXNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHZpY2IpOlxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTpcbiAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNUYWlsLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNUYWlsLl9uZXh0TW92ZWQgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xuICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRPRE8odmljYik6XG4gICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSB0aGlzLl9yZW1vdmFsc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8odmljYik6XG4gICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRJZGVudGl0eUNoYW5nZSA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0pIHtcbiAgICAgICAgcmVjb3JkLml0ZW0gPSBpdGVtO1xuICAgICAgICBpZiAodGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbC5fbmV4dElkZW50aXR5Q2hhbmdlID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xufSgpKTtcbnZhciBJdGVyYWJsZUNoYW5nZVJlY29yZF8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXRlcmFibGVDaGFuZ2VSZWNvcmRfKGl0ZW0sIHRyYWNrQnlJZCkge1xuICAgICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgICAgICB0aGlzLnRyYWNrQnlJZCA9IHRyYWNrQnlJZDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzSW5kZXggPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRNb3ZlZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dElkZW50aXR5Q2hhbmdlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEl0ZXJhYmxlQ2hhbmdlUmVjb3JkXztcbn0oKSk7XG4vLyBBIGxpbmtlZCBsaXN0IG9mIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmRzIHdpdGggdGhlIHNhbWUgSXRlcmFibGVDaGFuZ2VSZWNvcmRfLml0ZW1cbnZhciBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgdGhlIHJlY29yZCB0byB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAqXG4gICAgICogTm90ZTogYnkgZGVzaWduIGFsbCByZWNvcmRzIGluIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaG9sZCB0aGUgc2FtZSB2YWx1ZSBpbiByZWNvcmQuaXRlbS5cbiAgICAgKi9cbiAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPKHZpY2IpOlxuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5pdGVtID09ICBfaGVhZC5pdGVtIHx8XG4gICAgICAgICAgICAvLyAgICAgICByZWNvcmQuaXRlbSBpcyBudW0gJiYgcmVjb3JkLml0ZW0uaXNOYU4gJiYgX2hlYWQuaXRlbSBpcyBudW0gJiYgX2hlYWQuaXRlbS5pc05hTik7XG4gICAgICAgICAgICB0aGlzLl90YWlsLl9uZXh0RHVwID0gcmVjb3JkO1xuICAgICAgICAgICAgcmVjb3JkLl9wcmV2RHVwID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIGEgSXRlcmFibGVDaGFuZ2VSZWNvcmRfIGhhdmluZyBJdGVyYWJsZUNoYW5nZVJlY29yZF8udHJhY2tCeUlkID09IHRyYWNrQnlJZCBhbmRcbiAgICAvLyBJdGVyYWJsZUNoYW5nZVJlY29yZF8uY3VycmVudEluZGV4ID49IGF0T3JBZnRlckluZGV4XG4gICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodHJhY2tCeUlkLCBhdE9yQWZ0ZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0RHVwKSB7XG4gICAgICAgICAgICBpZiAoKGF0T3JBZnRlckluZGV4ID09PSBudWxsIHx8IGF0T3JBZnRlckluZGV4IDw9IHJlY29yZC5jdXJyZW50SW5kZXgpICYmXG4gICAgICAgICAgICAgICAgbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgdHJhY2tCeUlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgb25lIHtAbGluayBJdGVyYWJsZUNoYW5nZVJlY29yZF99IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyBUT0RPKHZpY2IpOlxuICAgICAgICAvLyBhc3NlcnQoKCkge1xuICAgICAgICAvLyAgLy8gdmVyaWZ5IHRoYXQgdGhlIHJlY29yZCBiZWluZyByZW1vdmVkIGlzIGluIHRoZSBsaXN0LlxuICAgICAgICAvLyAgZm9yIChJdGVyYWJsZUNoYW5nZVJlY29yZF8gY3Vyc29yID0gX2hlYWQ7IGN1cnNvciAhPSBudWxsOyBjdXJzb3IgPSBjdXJzb3IuX25leHREdXApIHtcbiAgICAgICAgLy8gICAgaWYgKGlkZW50aWNhbChjdXJzb3IsIHJlY29yZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAgfVxuICAgICAgICAvLyAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvL30pO1xuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldkR1cDtcbiAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHREdXA7XG4gICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYuX25leHREdXAgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuX3ByZXZEdXAgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkID09PSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdDtcbn0oKSk7XG52YXIgX0R1cGxpY2F0ZU1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRHVwbGljYXRlTWFwKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICB2YXIga2V5ID0gcmVjb3JkLnRyYWNrQnlJZDtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICBkdXBsaWNhdGVzID0gbmV3IF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgZHVwbGljYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZHVwbGljYXRlcy5hZGQocmVjb3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBgdmFsdWVgIHVzaW5nIGtleS4gQmVjYXVzZSB0aGUgSXRlcmFibGVDaGFuZ2VSZWNvcmRfIHZhbHVlIG1heSBiZSBvbmUgd2hpY2ggd2VcbiAgICAgKiBoYXZlIGFscmVhZHkgaXRlcmF0ZWQgb3Zlciwgd2UgdXNlIHRoZSBgYXRPckFmdGVySW5kZXhgIHRvIHByZXRlbmQgaXQgaXMgbm90IHRoZXJlLlxuICAgICAqXG4gICAgICogVXNlIGNhc2U6IGBbYSwgYiwgYywgYSwgYV1gIGlmIHdlIGFyZSBhdCBpbmRleCBgM2Agd2hpY2ggaXMgdGhlIHNlY29uZCBgYWAgdGhlbiBhc2tpbmcgaWYgd2VcbiAgICAgKiBoYXZlIGFueSBtb3JlIGBhYHMgbmVlZHMgdG8gcmV0dXJuIHRoZSBzZWNvbmQgYGFgLlxuICAgICAqL1xuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0cmFja0J5SWQsIGF0T3JBZnRlckluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFja0J5SWQ7XG4gICAgICAgIHZhciByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiByZWNvcmRMaXN0ID8gcmVjb3JkTGlzdC5nZXQodHJhY2tCeUlkLCBhdE9yQWZ0ZXJJbmRleCkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHtAbGluayBJdGVyYWJsZUNoYW5nZVJlY29yZF99IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgYWxzbyBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBpZiBpdCBnZXRzIGVtcHR5LlxuICAgICAqL1xuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgdmFyIGtleSA9IHJlY29yZC50cmFja0J5SWQ7XG4gICAgICAgIHZhciByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxuICAgICAgICBpZiAocmVjb3JkTGlzdC5yZW1vdmUocmVjb3JkKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1hcC5zaXplID09PSAwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5tYXAuY2xlYXIoKTsgfTtcbiAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcbn0oKSk7XG5mdW5jdGlvbiBnZXRQcmV2aW91c0luZGV4KGl0ZW0sIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpIHtcbiAgICB2YXIgcHJldmlvdXNJbmRleCA9IGl0ZW0ucHJldmlvdXNJbmRleDtcbiAgICBpZiAocHJldmlvdXNJbmRleCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzSW5kZXg7XG4gICAgdmFyIG1vdmVPZmZzZXQgPSAwO1xuICAgIGlmIChtb3ZlT2Zmc2V0cyAmJiBwcmV2aW91c0luZGV4IDwgbW92ZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgIG1vdmVPZmZzZXQgPSBtb3ZlT2Zmc2V0c1twcmV2aW91c0luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzSW5kZXggKyBhZGRSZW1vdmVPZmZzZXQgKyBtb3ZlT2Zmc2V0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5KCkge1xuICAgIH1cbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1hcCB8fCBpc0pzT2JqZWN0KG9iaik7IH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlcigpOyB9O1xuICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5O1xufSgpKTtcbnZhciBEZWZhdWx0S2V5VmFsdWVEaWZmZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xuICAgICAgICB0aGlzLl9yZWNvcmRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgLy8gX2FwcGVuZEFmdGVyIGlzIHVzZWQgaW4gdGhlIGNoZWNrIGxvb3BcbiAgICAgICAgdGhpcy5fYXBwZW5kQWZ0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmV2aW91c01hcEhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9jaGFuZ2VzSGVhZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaENoYW5nZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQWRkZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIHN0cmluZ2lmeShtYXApICsgXCInLiBPbmx5IG1hcHMgYW5kIG9iamVjdHMgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2sobWFwKSA/IHRoaXMgOiBudWxsO1xuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1hcCB2cyB0aGUgcHJldmlvdXMuXG4gICAgICogVGhlIGFsZ29yaXRobSBpcyBvcHRpbWlzZWQgZm9yIHdoZW4gdGhlIGtleXMgZG8gbm8gY2hhbmdlLlxuICAgICAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIHZhciBpbnNlcnRCZWZvcmUgPSB0aGlzLl9tYXBIZWFkO1xuICAgICAgICB0aGlzLl9hcHBlbmRBZnRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZvckVhY2gobWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgaWYgKGluc2VydEJlZm9yZSAmJiBpbnNlcnRCZWZvcmUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWF5YmVBZGRUb0NoYW5nZXMoaW5zZXJ0QmVmb3JlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FwcGVuZEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZS5fbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBfdGhpcy5fZ2V0T3JDcmVhdGVSZWNvcmRGb3JLZXkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlID0gX3RoaXMuX2luc2VydEJlZm9yZU9yQXBwZW5kKGluc2VydEJlZm9yZSwgcmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEl0ZW1zIHJlbWFpbmluZyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGhhdmUgYmVlbiBkZWxldGVkXG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRCZWZvcmUuX3ByZXYpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUuX3ByZXYuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgICAgICAgZm9yICh2YXIgcmVjb3JkID0gaW5zZXJ0QmVmb3JlOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSB0aGlzLl9tYXBIZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvcmRzLmRlbGV0ZShyZWNvcmQua2V5KTtcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHRSZW1vdmVkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c1ZhbHVlID0gcmVjb3JkLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZWNvcmQuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRhaWxzIGhhdmUgbm8gbmV4dCByZWNvcmRzIGZyb20gcHJldmlvdXMgcnVuc1xuICAgICAgICBpZiAodGhpcy5fY2hhbmdlc1RhaWwpXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbC5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbClcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgcmVjb3JkIGJlZm9yZSBgYmVmb3JlYCBvciBhcHBlbmQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCB3aGVuIGBiZWZvcmVgIGlzIG51bGwuXG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAtIFRoaXMgbWV0aG9kIGFwcGVuZHMgYXQgYHRoaXMuX2FwcGVuZEFmdGVyYCxcbiAgICAgKiAtIFRoaXMgbWV0aG9kIHVwZGF0ZXMgYHRoaXMuX2FwcGVuZEFmdGVyYCxcbiAgICAgKiAtIFRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGluc2VydGlvbiBwb2ludGVyLlxuICAgICAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZU9yQXBwZW5kID0gZnVuY3Rpb24gKGJlZm9yZSwgcmVjb3JkKSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gYmVmb3JlLl9wcmV2O1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gYmVmb3JlO1xuICAgICAgICAgICAgcmVjb3JkLl9wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIGJlZm9yZS5fcHJldiA9IHJlY29yZDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZWZvcmUgPT09IHRoaXMuX21hcEhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kQWZ0ZXIgPSBiZWZvcmU7XG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hcHBlbmRBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5fYXBwZW5kQWZ0ZXIuX25leHQgPSByZWNvcmQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXYgPSB0aGlzLl9hcHBlbmRBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwZW5kQWZ0ZXIgPSByZWNvcmQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVSZWNvcmRGb3JLZXkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVjb3Jkcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHJlY29yZF8xID0gdGhpcy5fcmVjb3Jkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuX21heWJlQWRkVG9DaGFuZ2VzKHJlY29yZF8xLCB2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZF8xLl9wcmV2O1xuICAgICAgICAgICAgdmFyIG5leHQgPSByZWNvcmRfMS5fbmV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkXzEuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgcmVjb3JkXzEuX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZF8xO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgS2V5VmFsdWVDaGFuZ2VSZWNvcmRfKGtleSk7XG4gICAgICAgIHRoaXMuX3JlY29yZHMuc2V0KGtleSwgcmVjb3JkKTtcbiAgICAgICAgcmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9hZGRUb0FkZGl0aW9ucyhyZWNvcmQpO1xuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgLy8gbGV0IGBfcHJldmlvdXNNYXBIZWFkYCBjb250YWluIHRoZSBzdGF0ZSBvZiB0aGUgbWFwIGJlZm9yZSB0aGUgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gdGhpcy5fbWFwSGVhZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGByZWNvcmQucHJldmlvdXNWYWx1ZWAgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGl0ZW0gYmVmb3JlIHRoZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBhbGwgY2hhbmdlZCBpdGVtcyAodGhhdCdzIHRob3NlIHdoaWNoIGhhdmUgYmVlbiBhZGRlZCBhbmQgY2hhbmdlZClcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c1ZhbHVlID0gcmVjb3JkLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBZGQgdGhlIHJlY29yZCBvciBhIGdpdmVuIGtleSB0byB0aGUgbGlzdCBvZiBjaGFuZ2VzIG9ubHkgd2hlbiB0aGUgdmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWRcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9tYXliZUFkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyZWNvcmQsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICghbG9vc2VJZGVudGljYWwobmV3VmFsdWUsIHJlY29yZC5jdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0NoYW5nZXMocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9BZGRpdGlvbnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNIZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXNIZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IHRoaXMuX2NoYW5nZXNUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwuX25leHRDaGFuZ2VkID0gcmVjb3JkO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9mb3JFYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihvYmpba10sIGspOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlcjtcbn0oKSk7XG52YXIgS2V5VmFsdWVDaGFuZ2VSZWNvcmRfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleVZhbHVlQ2hhbmdlUmVjb3JkXyhrZXkpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRDaGFuZ2VkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEtleVZhbHVlQ2hhbmdlUmVjb3JkXztcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBpdGVyYWJsZSBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0ZvciwgTmdDbGFzcywgYW5kIG90aGVycy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBJdGVyYWJsZURpZmZlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjb3BpZWQgPSBwYXJlbnQuZmFjdG9yaWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMuY29uY2F0KGNvcGllZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBJdGVyYWJsZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICogaW5oZXJpdGVkIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGZhY3RvcmllcyBhbmQgcmV0dXJuIGEgbmV3XG4gICAgICoge0BsaW5rIEl0ZXJhYmxlRGlmZmVyc30gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGV4dGVuZCBhbiBleGlzdGluZyBsaXN0IG9mIGZhY3RvcmllcyxcbiAgICAgKiB3aGljaCB3aWxsIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgaW5qZWN0b3IgZm9yIHRoaXMgY29tcG9uZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgSXRlcmFibGVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAqICAgICBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kKFtuZXcgSW1tdXRhYmxlTGlzdERpZmZlcigpXSlcbiAgICAgKiAgIF1cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHdvdWxkIG9jY3VyIHdoZW4gY2FsbGluZyBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kIGluc2lkZSBvZiBkZXBlbmRlbmNpZXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCBJdGVyYWJsZURpZmZlcnMgd2l0aG91dCBhIHBhcmVudCBpbmplY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gSXRlcmFibGVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICBkZXBzOiBbW0l0ZXJhYmxlRGlmZmVycywgbmV3IFNraXBTZWxmKCksIG5ldyBPcHRpb25hbCgpXV1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEl0ZXJhYmxlRGlmZmVycy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoaXRlcmFibGUpOyB9KTtcbiAgICAgICAgaWYgKGZhY3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyBpdGVyYWJsZSArIFwiJyBvZiB0eXBlICdcIiArIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGl0ZXJhYmxlKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSXRlcmFibGVEaWZmZXJzLm5nSW5qZWN0YWJsZURlZiA9IGRlZmluZUluamVjdGFibGUoe1xuICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgIGZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoW25ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCldKTsgfVxuICAgIH0pO1xuICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnM7XG59KCkpO1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIHJldHVybiB0eXBlWyduYW1lJ10gfHwgdHlwZW9mIHR5cGU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBNYXAgZGlmZmluZyBzdHJhdGVnaWVzIHVzZWQgYnkgTmdDbGFzcywgTmdTdHlsZSwgYW5kIG90aGVycy5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBLZXlWYWx1ZURpZmZlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY29waWVkID0gcGFyZW50LmZhY3Rvcmllcy5zbGljZSgpO1xuICAgICAgICAgICAgZmFjdG9yaWVzID0gZmFjdG9yaWVzLmNvbmNhdChjb3BpZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiB7QGxpbmsgS2V5VmFsdWVEaWZmZXJGYWN0b3J5fSBhbmQgcmV0dXJucyBhIHByb3ZpZGVyIHVzZWQgdG8gZXh0ZW5kIHRoZVxuICAgICAqIGluaGVyaXRlZCB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAqIHtAbGluayBLZXlWYWx1ZURpZmZlcnN9IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIFRoaXMgc3RlcCBpcyBhbGwgdGhhdCdzIHJlcXVpcmVkIHRvIG1ha2UgYSBuZXcge0BsaW5rIEtleVZhbHVlRGlmZmVyfSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgKiAgICAgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZChbbmV3IEltbXV0YWJsZU1hcERpZmZlcigpXSlcbiAgICAgKiAgIF1cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm92aWRlOiBLZXlWYWx1ZURpZmZlcnMsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHdvdWxkIG9jY3VyIHdoZW4gY2FsbGluZyBLZXlWYWx1ZURpZmZlcnMuZXh0ZW5kIGluc2lkZSBvZiBkZXBlbmRlbmNpZXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCBLZXlWYWx1ZURpZmZlcnMgd2l0aG91dCBhIHBhcmVudCBpbmplY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICBkZXBzOiBbW0tleVZhbHVlRGlmZmVycywgbmV3IFNraXBTZWxmKCksIG5ldyBPcHRpb25hbCgpXV1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEtleVZhbHVlRGlmZmVycy5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrdikge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoa3YpOyB9KTtcbiAgICAgICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGt2ICsgXCInXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycztcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgT2JqZWN0YHMgYW5kIGBNYXBgcy5cbiAqL1xudmFyIGtleVZhbERpZmYgPSBbbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKV07XG4vKipcbiAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYEl0ZXJhYmxlYCB0eXBlcyBzdWNoIGFzIGBBcnJheWBzLlxuICovXG52YXIgaXRlcmFibGVEaWZmID0gW25ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCldO1xudmFyIGRlZmF1bHRJdGVyYWJsZURpZmZlcnMgPSBuZXcgSXRlcmFibGVEaWZmZXJzKGl0ZXJhYmxlRGlmZik7XG52YXIgZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBLZXlWYWx1ZURpZmZlcnMoa2V5VmFsRGlmZik7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9DT1JFX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICAvLyBTZXQgYSBkZWZhdWx0IHBsYXRmb3JtIG5hbWUgZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHNldCBpdCBleHBsaWNpdGx5LlxuICAgIHsgcHJvdmlkZTogUExBVEZPUk1fSUQsIHVzZVZhbHVlOiAndW5rbm93bicgfSxcbiAgICB7IHByb3ZpZGU6IFBsYXRmb3JtUmVmLCBkZXBzOiBbSW5qZWN0b3JdIH0sXG4gICAgeyBwcm92aWRlOiBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCBkZXBzOiBbXSB9LFxuICAgIHsgcHJvdmlkZTogQ29uc29sZSwgZGVwczogW10gfSxcbl07XG4vKipcbiAqIFRoaXMgcGxhdGZvcm0gaGFzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBvdGhlciBwbGF0Zm9ybVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIHBsYXRmb3JtQ29yZSA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShudWxsLCAnY29yZScsIF9DT1JFX1BMQVRGT1JNX1BST1ZJREVSUyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUHJvdmlkZSB0aGlzIHRva2VuIHRvIHNldCB0aGUgbG9jYWxlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gKiBJdCBpcyB1c2VkIGZvciBpMThuIGV4dHJhY3Rpb24sIGJ5IGkxOG4gcGlwZXMgKERhdGVQaXBlLCBJMThuUGx1cmFsUGlwZSwgQ3VycmVuY3lQaXBlLFxuICogRGVjaW1hbFBpcGUgYW5kIFBlcmNlbnRQaXBlKSBhbmQgYnkgSUNVIGV4cHJlc3Npb25zLlxuICpcbiAqIFNlZSB0aGUgW2kxOG4gZ3VpZGVdKGd1aWRlL2kxOG4jc2V0dGluZy11cC1sb2NhbGUpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IExPQ0FMRV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAubW9kdWxlJztcbiAqXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSwge1xuICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogTE9DQUxFX0lELCB1c2VWYWx1ZTogJ2VuLVVTJyB9XVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBMT0NBTEVfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0xvY2FsZUlkJyk7XG4vKipcbiAqIFVzZSB0aGlzIHRva2VuIGF0IGJvb3RzdHJhcCB0byBwcm92aWRlIHRoZSBjb250ZW50IG9mIHlvdXIgdHJhbnNsYXRpb24gZmlsZSAoYHh0YmAsXG4gKiBgeGxmYCBvciBgeGxmMmApIHdoZW4geW91IHdhbnQgdG8gdHJhbnNsYXRlIHlvdXIgYXBwbGljYXRpb24gaW4gYW5vdGhlciBsYW5ndWFnZS5cbiAqXG4gKiBTZWUgdGhlIFtpMThuIGd1aWRlXShndWlkZS9pMThuI21lcmdlKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBUUkFOU0xBVElPTlMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICogaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZSc7XG4gKlxuICogLy8gY29udGVudCBvZiB5b3VyIHRyYW5zbGF0aW9uIGZpbGVcbiAqIGNvbnN0IHRyYW5zbGF0aW9ucyA9ICcuLi4uJztcbiAqXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSwge1xuICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogVFJBTlNMQVRJT05TLCB1c2VWYWx1ZTogdHJhbnNsYXRpb25zIH1dXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFRSQU5TTEFUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignVHJhbnNsYXRpb25zJyk7XG4vKipcbiAqIFByb3ZpZGUgdGhpcyB0b2tlbiBhdCBib290c3RyYXAgdG8gc2V0IHRoZSBmb3JtYXQgb2YgeW91ciB7QGxpbmsgVFJBTlNMQVRJT05TfTogYHh0YmAsXG4gKiBgeGxmYCBvciBgeGxmMmAuXG4gKlxuICogU2VlIHRoZSBbaTE4biBndWlkZV0oZ3VpZGUvaTE4biNtZXJnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgVFJBTlNMQVRJT05TX0ZPUk1BVCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKiBpbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAubW9kdWxlJztcbiAqXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSwge1xuICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogVFJBTlNMQVRJT05TX0ZPUk1BVCwgdXNlVmFsdWU6ICd4bGYnIH1dXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFRSQU5TTEFUSU9OU19GT1JNQVQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1RyYW5zbGF0aW9uc0Zvcm1hdCcpO1xuLyoqXG4gKiBVc2UgdGhpcyBlbnVtIGF0IGJvb3RzdHJhcCBhcyBhbiBvcHRpb24gb2YgYGJvb3RzdHJhcE1vZHVsZWAgdG8gZGVmaW5lIHRoZSBzdHJhdGVneVxuICogdGhhdCB0aGUgY29tcGlsZXIgc2hvdWxkIHVzZSBpbiBjYXNlIG9mIG1pc3NpbmcgdHJhbnNsYXRpb25zOlxuICogLSBFcnJvcjogdGhyb3cgaWYgeW91IGhhdmUgbWlzc2luZyB0cmFuc2xhdGlvbnMuXG4gKiAtIFdhcm5pbmcgKGRlZmF1bHQpOiBzaG93IGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBhbmQvb3Igc2hlbGwuXG4gKiAtIElnbm9yZTogZG8gbm90aGluZy5cbiAqXG4gKiBTZWUgdGhlIFtpMThuIGd1aWRlXShndWlkZS9pMThuI21pc3NpbmctdHJhbnNsYXRpb24pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xuICogaW1wb3J0IHsgQXBwTW9kdWxlIH0gZnJvbSAnLi9hcHAvYXBwLm1vZHVsZSc7XG4gKlxuICogcGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUsIHtcbiAqICAgbWlzc2luZ1RyYW5zbGF0aW9uOiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5FcnJvclxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIkVycm9yXCJdID0gMF0gPSBcIkVycm9yXCI7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJXYXJuaW5nXCJdID0gMV0gPSBcIldhcm5pbmdcIjtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIklnbm9yZVwiXSA9IDJdID0gXCJJZ25vcmVcIjtcbn0pKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5IHx8IChNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5KCkge1xuICAgIHJldHVybiBkZWZhdWx0SXRlcmFibGVEaWZmZXJzO1xufVxuZnVuY3Rpb24gX2tleVZhbHVlRGlmZmVyc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRLZXlWYWx1ZURpZmZlcnM7XG59XG5mdW5jdGlvbiBfbG9jYWxlRmFjdG9yeShsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlIHx8ICdlbi1VUyc7XG59XG4vKipcbiAqIEEgYnVpbHQtaW4gW2RlcGVuZGVuY3kgaW5qZWN0aW9uIHRva2VuXShndWlkZS9nbG9zc2FyeSNkaS10b2tlbilcbiAqIHRoYXQgaXMgdXNlZCB0byBjb25maWd1cmUgdGhlIHJvb3QgaW5qZWN0b3IgZm9yIGJvb3RzdHJhcHBpbmcuXG4gKi9cbnZhciBBUFBMSUNBVElPTl9NT0RVTEVfUFJPVklERVJTID0gW1xuICAgIHtcbiAgICAgICAgcHJvdmlkZTogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHVzZUNsYXNzOiBBcHBsaWNhdGlvblJlZixcbiAgICAgICAgZGVwczogW05nWm9uZSwgQ29uc29sZSwgSW5qZWN0b3IsIEVycm9ySGFuZGxlciwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBBcHBsaWNhdGlvbkluaXRTdGF0dXNdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IEFwcGxpY2F0aW9uSW5pdFN0YXR1cyxcbiAgICAgICAgdXNlQ2xhc3M6IEFwcGxpY2F0aW9uSW5pdFN0YXR1cyxcbiAgICAgICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgQVBQX0lOSVRJQUxJWkVSXV1cbiAgICB9LFxuICAgIHsgcHJvdmlkZTogQ29tcGlsZXIsIHVzZUNsYXNzOiBDb21waWxlciwgZGVwczogW10gfSxcbiAgICBBUFBfSURfUkFORE9NX1BST1ZJREVSLFxuICAgIHsgcHJvdmlkZTogSXRlcmFibGVEaWZmZXJzLCB1c2VGYWN0b3J5OiBfaXRlcmFibGVEaWZmZXJzRmFjdG9yeSwgZGVwczogW10gfSxcbiAgICB7IHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycywgdXNlRmFjdG9yeTogX2tleVZhbHVlRGlmZmVyc0ZhY3RvcnksIGRlcHM6IFtdIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBMT0NBTEVfSUQsXG4gICAgICAgIHVzZUZhY3Rvcnk6IF9sb2NhbGVGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbW25ldyBJbmplY3QoTE9DQUxFX0lEKSwgbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpXV1cbiAgICB9LFxuXTtcbi8qKlxuICogQ29uZmlndXJlcyB0aGUgcm9vdCBpbmplY3RvciBmb3IgYW4gYXBwIHdpdGhcbiAqIHByb3ZpZGVycyBvZiBgQGFuZ3VsYXIvY29yZWAgZGVwZW5kZW5jaWVzIHRoYXQgYEFwcGxpY2F0aW9uUmVmYCBuZWVkc1xuICogdG8gYm9vdHN0cmFwIGNvbXBvbmVudHMuXG4gKlxuICogUmUtZXhwb3J0ZWQgYnkgYEJyb3dzZXJNb2R1bGVgLCB3aGljaCBpcyBpbmNsdWRlZCBhdXRvbWF0aWNhbGx5IGluIHRoZSByb290XG4gKiBgQXBwTW9kdWxlYCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgYXBwIHdpdGggdGhlIENMSSBgbmV3YCBjb21tYW5kLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFwcGxpY2F0aW9uTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIEluamVjdCBBcHBsaWNhdGlvblJlZiB0byBtYWtlIGl0IGVhZ2VyLi4uXG4gICAgZnVuY3Rpb24gQXBwbGljYXRpb25Nb2R1bGUoYXBwUmVmKSB7XG4gICAgfVxuICAgIEFwcGxpY2F0aW9uTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHsgcHJvdmlkZXJzOiBBUFBMSUNBVElPTl9NT0RVTEVfUFJPVklERVJTIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FwcGxpY2F0aW9uUmVmXSlcbiAgICBdLCBBcHBsaWNhdGlvbk1vZHVsZSk7XG4gICAgcmV0dXJuIEFwcGxpY2F0aW9uTW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gQ2FsbGVkIGJlZm9yZSBlYWNoIGN5Y2xlIG9mIGEgdmlldydzIGNoZWNrIHRvIGRldGVjdCB3aGV0aGVyIHRoaXMgaXMgaW4gdGhlXG4vLyBpbml0U3RhdGUgZm9yIHdoaWNoIHdlIG5lZWQgdG8gY2FsbCBuZ09uSW5pdCwgbmdBZnRlckNvbnRlbnRJbml0IG9yIG5nQWZ0ZXJWaWV3SW5pdFxuLy8gbGlmZWN5Y2xlIG1ldGhvZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNoZWNrIGN5Y2xlIHNob3VsZCBjYWxsIGxpZmVjeWNsZVxuLy8gbWV0aG9kcy5cbmZ1bmN0aW9uIHNoaWZ0SW5pdFN0YXRlKHZpZXcsIHByaW9ySW5pdFN0YXRlLCBuZXdJbml0U3RhdGUpIHtcbiAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgSW5pdFN0YXRlIGlmIHdlIGFyZSBjdXJyZW50bHkgaW4gdGhlIHByaW9yIHN0YXRlLlxuICAgIC8vIEZvciBleGFtcGxlLCBvbmx5IG1vdmUgaW50byBDYWxsaW5nSW5pdCBpZiB3ZSBhcmUgaW4gQmVmb3JlSW5pdC4gT25seVxuICAgIC8vIG1vdmUgaW50byBDYWxsaW5nQ29udGVudEluaXQgaWYgd2UgYXJlIGluIENhbGxpbmdJbml0LiBOb3JtYWxseSB0aGlzIHdpbGxcbiAgICAvLyBhbHdheXMgYmUgdHJ1ZSBiZWNhdXNlIG9mIGhvdyBjaGVja0N5Y2xlIGlzIGNhbGxlZCBpbiBjaGVja0FuZFVwZGF0ZVZpZXcuXG4gICAgLy8gSG93ZXZlciwgaWYgY2hlY2tBbmRVcGRhdGVWaWV3IGlzIGNhbGxlZCByZWN1cnNpdmVseSBvciBpZiBhbiBleGNlcHRpb24gaXNcbiAgICAvLyB0aHJvd24gd2hpbGUgY2hlY2tBbmRVcGRhdGVWaWV3IGlzIHJ1bm5pbmcsIGNoZWNrQW5kVXBkYXRlVmlldyBzdGFydHMgb3ZlclxuICAgIC8vIGZyb20gdGhlIGJlZ2lubmluZy4gVGhpcyBlbnN1cmVzIHRoZSBzdGF0ZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcsXG4gICAgLy8gdGVybWluYXRpbmcgaW4gdGhlIEFmdGVySW5pdCBzdGF0ZSwgd2hpY2ggZW5zdXJlcyB0aGUgSW5pdCBtZXRob2RzIGFyZSBjYWxsZWRcbiAgICAvLyBhdCBsZWFzdCBvbmNlIGFuZCBvbmx5IG9uY2UuXG4gICAgdmFyIHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICB2YXIgaW5pdFN0YXRlID0gc3RhdGUgJiAxNzkyIC8qIEluaXRTdGF0ZV9NYXNrICovO1xuICAgIGlmIChpbml0U3RhdGUgPT09IHByaW9ySW5pdFN0YXRlKSB7XG4gICAgICAgIHZpZXcuc3RhdGUgPSAoc3RhdGUgJiB+MTc5MiAvKiBJbml0U3RhdGVfTWFzayAqLykgfCBuZXdJbml0U3RhdGU7XG4gICAgICAgIHZpZXcuaW5pdEluZGV4ID0gLTE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdFN0YXRlID09PSBuZXdJbml0U3RhdGU7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGxpZmVjeWNsZSBpbml0IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGZvciB0aGUgbm9kZSB3aXRoXG4vLyB0aGUgZ2l2ZW4gaW5pdCBpbmRleC5cbmZ1bmN0aW9uIHNob3VsZENhbGxMaWZlY3ljbGVJbml0SG9vayh2aWV3LCBpbml0U3RhdGUsIGluZGV4KSB7XG4gICAgaWYgKCh2aWV3LnN0YXRlICYgMTc5MiAvKiBJbml0U3RhdGVfTWFzayAqLykgPT09IGluaXRTdGF0ZSAmJiB2aWV3LmluaXRJbmRleCA8PSBpbmRleCkge1xuICAgICAgICB2aWV3LmluaXRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQWNjZXNzb3IgZm9yIHZpZXcubm9kZXMsIGVuZm9yY2luZyB0aGF0IGV2ZXJ5IHVzYWdlIHNpdGUgc3RheXMgbW9ub21vcnBoaWMuXG4gKi9cbmZ1bmN0aW9uIGFzVGV4dERhdGEodmlldywgaW5kZXgpIHtcbiAgICByZXR1cm4gdmlldy5ub2Rlc1tpbmRleF07XG59XG4vKipcbiAqIEFjY2Vzc29yIGZvciB2aWV3Lm5vZGVzLCBlbmZvcmNpbmcgdGhhdCBldmVyeSB1c2FnZSBzaXRlIHN0YXlzIG1vbm9tb3JwaGljLlxuICovXG5mdW5jdGlvbiBhc0VsZW1lbnREYXRhKHZpZXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHZpZXcubm9kZXNbaW5kZXhdO1xufVxuLyoqXG4gKiBBY2Nlc3NvciBmb3Igdmlldy5ub2RlcywgZW5mb3JjaW5nIHRoYXQgZXZlcnkgdXNhZ2Ugc2l0ZSBzdGF5cyBtb25vbW9ycGhpYy5cbiAqL1xuZnVuY3Rpb24gYXNQcm92aWRlckRhdGEodmlldywgaW5kZXgpIHtcbiAgICByZXR1cm4gdmlldy5ub2Rlc1tpbmRleF07XG59XG4vKipcbiAqIEFjY2Vzc29yIGZvciB2aWV3Lm5vZGVzLCBlbmZvcmNpbmcgdGhhdCBldmVyeSB1c2FnZSBzaXRlIHN0YXlzIG1vbm9tb3JwaGljLlxuICovXG5mdW5jdGlvbiBhc1B1cmVFeHByZXNzaW9uRGF0YSh2aWV3LCBpbmRleCkge1xuICAgIHJldHVybiB2aWV3Lm5vZGVzW2luZGV4XTtcbn1cbi8qKlxuICogQWNjZXNzb3IgZm9yIHZpZXcubm9kZXMsIGVuZm9yY2luZyB0aGF0IGV2ZXJ5IHVzYWdlIHNpdGUgc3RheXMgbW9ub21vcnBoaWMuXG4gKi9cbmZ1bmN0aW9uIGFzUXVlcnlMaXN0KHZpZXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHZpZXcubm9kZXNbaW5kZXhdO1xufVxudmFyIERlYnVnQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHQoKSB7XG4gICAgfVxuICAgIHJldHVybiBEZWJ1Z0NvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBUaGlzIG9iamVjdCBpcyB1c2VkIHRvIHByZXZlbnQgY3ljbGVzIGluIHRoZSBzb3VyY2UgZmlsZXMgYW5kIHRvIGhhdmUgYSBwbGFjZSB3aGVyZVxuICogZGVidWcgbW9kZSBjYW4gaG9vayBpdC4gSXQgaXMgbGF6aWx5IGZpbGxlZCB3aGVuIGBpc0Rldk1vZGVgIGlzIGtub3duLlxuICovXG52YXIgU2VydmljZXMgPSB7XG4gICAgc2V0Q3VycmVudE5vZGU6IHVuZGVmaW5lZCxcbiAgICBjcmVhdGVSb290VmlldzogdW5kZWZpbmVkLFxuICAgIGNyZWF0ZUVtYmVkZGVkVmlldzogdW5kZWZpbmVkLFxuICAgIGNyZWF0ZUNvbXBvbmVudFZpZXc6IHVuZGVmaW5lZCxcbiAgICBjcmVhdGVOZ01vZHVsZVJlZjogdW5kZWZpbmVkLFxuICAgIG92ZXJyaWRlUHJvdmlkZXI6IHVuZGVmaW5lZCxcbiAgICBvdmVycmlkZUNvbXBvbmVudFZpZXc6IHVuZGVmaW5lZCxcbiAgICBjbGVhck92ZXJyaWRlczogdW5kZWZpbmVkLFxuICAgIGNoZWNrQW5kVXBkYXRlVmlldzogdW5kZWZpbmVkLFxuICAgIGNoZWNrTm9DaGFuZ2VzVmlldzogdW5kZWZpbmVkLFxuICAgIGRlc3Ryb3lWaWV3OiB1bmRlZmluZWQsXG4gICAgcmVzb2x2ZURlcDogdW5kZWZpbmVkLFxuICAgIGNyZWF0ZURlYnVnQ29udGV4dDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZUV2ZW50OiB1bmRlZmluZWQsXG4gICAgdXBkYXRlRGlyZWN0aXZlczogdW5kZWZpbmVkLFxuICAgIHVwZGF0ZVJlbmRlcmVyOiB1bmRlZmluZWQsXG4gICAgZGlydHlQYXJlbnRRdWVyaWVzOiB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBleHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKGNvbnRleHQsIG9sZFZhbHVlLCBjdXJyVmFsdWUsIGlzRmlyc3RDaGVjaykge1xuICAgIHZhciBtc2cgPSBcIkV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3I6IEV4cHJlc3Npb24gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQuIFByZXZpb3VzIHZhbHVlOiAnXCIgKyBvbGRWYWx1ZSArIFwiJy4gQ3VycmVudCB2YWx1ZTogJ1wiICsgY3VyclZhbHVlICsgXCInLlwiO1xuICAgIGlmIChpc0ZpcnN0Q2hlY2spIHtcbiAgICAgICAgbXNnICs9XG4gICAgICAgICAgICBcIiBJdCBzZWVtcyBsaWtlIHRoZSB2aWV3IGhhcyBiZWVuIGNyZWF0ZWQgYWZ0ZXIgaXRzIHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBkaXJ0eSBjaGVja2VkLlwiICtcbiAgICAgICAgICAgICAgICBcIiBIYXMgaXQgYmVlbiBjcmVhdGVkIGluIGEgY2hhbmdlIGRldGVjdGlvbiBob29rID9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdEZWJ1Z0Vycm9yKG1zZywgY29udGV4dCk7XG59XG5mdW5jdGlvbiB2aWV3V3JhcHBlZERlYnVnRXJyb3IoZXJyLCBjb250ZXh0KSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgIC8vIGVycm9ycyB0aGF0IGFyZSBub3QgRXJyb3IgaW5zdGFuY2VzIGRvbid0IGhhdmUgYSBzdGFjayxcbiAgICAgICAgLy8gc28gaXQgaXMgb2sgdG8gd3JhcCB0aGVtIGludG8gYSBuZXcgRXJyb3Igb2JqZWN0Li4uXG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIF9hZGREZWJ1Z0NvbnRleHQoZXJyLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdmlld0RlYnVnRXJyb3IobXNnLCBjb250ZXh0KSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgIF9hZGREZWJ1Z0NvbnRleHQoZXJyLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gX2FkZERlYnVnQ29udGV4dChlcnIsIGNvbnRleHQpIHtcbiAgICBlcnJbRVJST1JfREVCVUdfQ09OVEVYVF0gPSBjb250ZXh0O1xuICAgIGVycltFUlJPUl9MT0dHRVJdID0gY29udGV4dC5sb2dFcnJvci5iaW5kKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNWaWV3RGVidWdFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gISFnZXREZWJ1Z0NvbnRleHQoZXJyKTtcbn1cbmZ1bmN0aW9uIHZpZXdEZXN0cm95ZWRFcnJvcihhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiVmlld0Rlc3Ryb3llZEVycm9yOiBBdHRlbXB0IHRvIHVzZSBhIGRlc3Ryb3llZCB2aWV3OiBcIiArIGFjdGlvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBOT09QID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIF90b2tlbktleUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gdG9rZW5LZXkodG9rZW4pIHtcbiAgICB2YXIga2V5ID0gX3Rva2VuS2V5Q2FjaGUuZ2V0KHRva2VuKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICBrZXkgPSBzdHJpbmdpZnkodG9rZW4pICsgJ18nICsgX3Rva2VuS2V5Q2FjaGUuc2l6ZTtcbiAgICAgICAgX3Rva2VuS2V5Q2FjaGUuc2V0KHRva2VuLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gdW53cmFwVmFsdWUodmlldywgbm9kZUlkeCwgYmluZGluZ0lkeCwgdmFsdWUpIHtcbiAgICBpZiAoV3JhcHBlZFZhbHVlLmlzV3JhcHBlZCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBXcmFwcGVkVmFsdWUudW53cmFwKHZhbHVlKTtcbiAgICAgICAgdmFyIGdsb2JhbEJpbmRpbmdJZHggPSB2aWV3LmRlZi5ub2Rlc1tub2RlSWR4XS5iaW5kaW5nSW5kZXggKyBiaW5kaW5nSWR4O1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBXcmFwcGVkVmFsdWUudW53cmFwKHZpZXcub2xkVmFsdWVzW2dsb2JhbEJpbmRpbmdJZHhdKTtcbiAgICAgICAgdmlldy5vbGRWYWx1ZXNbZ2xvYmFsQmluZGluZ0lkeF0gPSBuZXcgV3JhcHBlZFZhbHVlKG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxudmFyIFVOREVGSU5FRF9SRU5ERVJFUl9UWVBFX0lEID0gJyQkdW5kZWZpbmVkJztcbnZhciBFTVBUWV9SRU5ERVJFUl9UWVBFX0lEID0gJyQkZW1wdHknO1xuLy8gQXR0ZW50aW9uOiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhcyB0b3AgbGV2ZWwgZnVuY3Rpb24uXG4vLyBQdXR0aW5nIGFueSBsb2dpYyBpbiBoZXJlIHdpbGwgZGVzdHJveSBjbG9zdXJlIHRyZWUgc2hha2luZyFcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyVHlwZTIodmFsdWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IFVOREVGSU5FRF9SRU5ERVJFUl9UWVBFX0lELFxuICAgICAgICBzdHlsZXM6IHZhbHVlcy5zdHlsZXMsXG4gICAgICAgIGVuY2Fwc3VsYXRpb246IHZhbHVlcy5lbmNhcHN1bGF0aW9uLFxuICAgICAgICBkYXRhOiB2YWx1ZXMuZGF0YVxuICAgIH07XG59XG52YXIgX3JlbmRlckNvbXBDb3VudCQxID0gMDtcbmZ1bmN0aW9uIHJlc29sdmVSZW5kZXJlclR5cGUyKHR5cGUpIHtcbiAgICBpZiAodHlwZSAmJiB0eXBlLmlkID09PSBVTkRFRklORURfUkVOREVSRVJfVFlQRV9JRCkge1xuICAgICAgICAvLyBmaXJzdCB0aW1lIHdlIHNlZSB0aGlzIFJlbmRlcmVyVHlwZTIuIEluaXRpYWxpemUgaXQuLi5cbiAgICAgICAgdmFyIGlzRmlsbGVkID0gKCh0eXBlLmVuY2Fwc3VsYXRpb24gIT0gbnVsbCAmJiB0eXBlLmVuY2Fwc3VsYXRpb24gIT09IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUpIHx8XG4gICAgICAgICAgICB0eXBlLnN0eWxlcy5sZW5ndGggfHwgT2JqZWN0LmtleXModHlwZS5kYXRhKS5sZW5ndGgpO1xuICAgICAgICBpZiAoaXNGaWxsZWQpIHtcbiAgICAgICAgICAgIHR5cGUuaWQgPSBcImNcIiArIF9yZW5kZXJDb21wQ291bnQkMSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZS5pZCA9IEVNUFRZX1JFTkRFUkVSX1RZUEVfSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUgJiYgdHlwZS5pZCA9PT0gRU1QVFlfUkVOREVSRVJfVFlQRV9JRCkge1xuICAgICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIGJpbmRpbmdJZHgsIHZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlcyA9IHZpZXcub2xkVmFsdWVzO1xuICAgIGlmICgodmlldy5zdGF0ZSAmIDIgLyogRmlyc3RDaGVjayAqLykgfHxcbiAgICAgICAgIWxvb3NlSWRlbnRpY2FsKG9sZFZhbHVlc1tkZWYuYmluZGluZ0luZGV4ICsgYmluZGluZ0lkeF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgYmluZGluZ0lkeCwgdmFsdWUpIHtcbiAgICBpZiAoY2hlY2tCaW5kaW5nKHZpZXcsIGRlZiwgYmluZGluZ0lkeCwgdmFsdWUpKSB7XG4gICAgICAgIHZpZXcub2xkVmFsdWVzW2RlZi5iaW5kaW5nSW5kZXggKyBiaW5kaW5nSWR4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tCaW5kaW5nTm9DaGFuZ2VzKHZpZXcsIGRlZiwgYmluZGluZ0lkeCwgdmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB2aWV3Lm9sZFZhbHVlc1tkZWYuYmluZGluZ0luZGV4ICsgYmluZGluZ0lkeF07XG4gICAgaWYgKCh2aWV3LnN0YXRlICYgMSAvKiBCZWZvcmVGaXJzdENoZWNrICovKSB8fCAhZGV2TW9kZUVxdWFsKG9sZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdOYW1lID0gZGVmLmJpbmRpbmdzW2JpbmRpbmdJZHhdLm5hbWU7XG4gICAgICAgIHRocm93IGV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IoU2VydmljZXMuY3JlYXRlRGVidWdDb250ZXh0KHZpZXcsIGRlZi5ub2RlSW5kZXgpLCBiaW5kaW5nTmFtZSArIFwiOiBcIiArIG9sZFZhbHVlLCBiaW5kaW5nTmFtZSArIFwiOiBcIiArIHZhbHVlLCAodmlldy5zdGF0ZSAmIDEgLyogQmVmb3JlRmlyc3RDaGVjayAqLykgIT09IDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXJlbnRWaWV3c0ZvckNoZWNrKHZpZXcpIHtcbiAgICB2YXIgY3VyclZpZXcgPSB2aWV3O1xuICAgIHdoaWxlIChjdXJyVmlldykge1xuICAgICAgICBpZiAoY3VyclZpZXcuZGVmLmZsYWdzICYgMiAvKiBPblB1c2ggKi8pIHtcbiAgICAgICAgICAgIGN1cnJWaWV3LnN0YXRlIHw9IDggLyogQ2hlY2tzRW5hYmxlZCAqLztcbiAgICAgICAgfVxuICAgICAgICBjdXJyVmlldyA9IGN1cnJWaWV3LnZpZXdDb250YWluZXJQYXJlbnQgfHwgY3VyclZpZXcucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXJlbnRWaWV3c0ZvckNoZWNrUHJvamVjdGVkVmlld3ModmlldywgZW5kVmlldykge1xuICAgIHZhciBjdXJyVmlldyA9IHZpZXc7XG4gICAgd2hpbGUgKGN1cnJWaWV3ICYmIGN1cnJWaWV3ICE9PSBlbmRWaWV3KSB7XG4gICAgICAgIGN1cnJWaWV3LnN0YXRlIHw9IDY0IC8qIENoZWNrUHJvamVjdGVkVmlld3MgKi87XG4gICAgICAgIGN1cnJWaWV3ID0gY3VyclZpZXcudmlld0NvbnRhaW5lclBhcmVudCB8fCBjdXJyVmlldy5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh2aWV3LCBub2RlSW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbm9kZURlZiA9IHZpZXcuZGVmLm5vZGVzW25vZGVJbmRleF07XG4gICAgICAgIHZhciBzdGFydFZpZXcgPSBub2RlRGVmLmZsYWdzICYgMzM1NTQ0MzIgLyogQ29tcG9uZW50VmlldyAqLyA/XG4gICAgICAgICAgICBhc0VsZW1lbnREYXRhKHZpZXcsIG5vZGVJbmRleCkuY29tcG9uZW50VmlldyA6XG4gICAgICAgICAgICB2aWV3O1xuICAgICAgICBtYXJrUGFyZW50Vmlld3NGb3JDaGVjayhzdGFydFZpZXcpO1xuICAgICAgICByZXR1cm4gU2VydmljZXMuaGFuZGxlRXZlbnQodmlldywgbm9kZUluZGV4LCBldmVudE5hbWUsIGV2ZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQXR0ZW50aW9uOiBEb24ndCByZXRocm93LCBhcyBpdCB3b3VsZCBjYW5jZWwgT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zIVxuICAgICAgICB2aWV3LnJvb3QuZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2xhcmVkVmlld0NvbnRhaW5lcih2aWV3KSB7XG4gICAgaWYgKHZpZXcucGFyZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRWaWV3ID0gdmlldy5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBhc0VsZW1lbnREYXRhKHBhcmVudFZpZXcsIHZpZXcucGFyZW50Tm9kZURlZi5ub2RlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogZm9yIGNvbXBvbmVudCB2aWV3cywgdGhpcyBpcyB0aGUgaG9zdCBlbGVtZW50LlxuICogZm9yIGVtYmVkZGVkIHZpZXdzLCB0aGlzIGlzIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IG5vZGVcbiAqIHRoYXQgY29udGFpbnMgdGhlIHZpZXcgY29udGFpbmVyLlxuICovXG5mdW5jdGlvbiB2aWV3UGFyZW50RWwodmlldykge1xuICAgIHZhciBwYXJlbnRWaWV3ID0gdmlldy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudFZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcucGFyZW50Tm9kZURlZi5wYXJlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJOb2RlKHZpZXcsIGRlZikge1xuICAgIHN3aXRjaCAoZGVmLmZsYWdzICYgMjAxMzQ3MDY3IC8qIFR5cGVzICovKSB7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlRWxlbWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBhc0VsZW1lbnREYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpLnJlbmRlckVsZW1lbnQ7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlVGV4dCAqLzpcbiAgICAgICAgICAgIHJldHVybiBhc1RleHREYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpLnJlbmRlclRleHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldCA/IHRhcmdldCArIFwiOlwiICsgbmFtZSA6IG5hbWU7XG59XG5mdW5jdGlvbiBpc0NvbXBvbmVudFZpZXcodmlldykge1xuICAgIHJldHVybiAhIXZpZXcucGFyZW50ICYmICEhKHZpZXcucGFyZW50Tm9kZURlZi5mbGFncyAmIDMyNzY4IC8qIENvbXBvbmVudCAqLyk7XG59XG5mdW5jdGlvbiBpc0VtYmVkZGVkVmlldyh2aWV3KSB7XG4gICAgcmV0dXJuICEhdmlldy5wYXJlbnQgJiYgISh2aWV3LnBhcmVudE5vZGVEZWYuZmxhZ3MgJiAzMjc2OCAvKiBDb21wb25lbnQgKi8pO1xufVxuZnVuY3Rpb24gZmlsdGVyUXVlcnlJZChxdWVyeUlkKSB7XG4gICAgcmV0dXJuIDEgPDwgKHF1ZXJ5SWQgJSAzMik7XG59XG5mdW5jdGlvbiBzcGxpdE1hdGNoZWRRdWVyaWVzRHNsKG1hdGNoZWRRdWVyaWVzRHNsKSB7XG4gICAgdmFyIG1hdGNoZWRRdWVyaWVzID0ge307XG4gICAgdmFyIG1hdGNoZWRRdWVyeUlkcyA9IDA7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSB7fTtcbiAgICBpZiAobWF0Y2hlZFF1ZXJpZXNEc2wpIHtcbiAgICAgICAgbWF0Y2hlZFF1ZXJpZXNEc2wuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHF1ZXJ5SWQgPSBfYlswXSwgdmFsdWVUeXBlID0gX2JbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5SWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFF1ZXJpZXNbcXVlcnlJZF0gPSB2YWx1ZVR5cGU7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFF1ZXJ5SWRzIHw9IGZpbHRlclF1ZXJ5SWQocXVlcnlJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzW3F1ZXJ5SWRdID0gdmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlZFF1ZXJpZXM6IG1hdGNoZWRRdWVyaWVzLCByZWZlcmVuY2VzOiByZWZlcmVuY2VzLCBtYXRjaGVkUXVlcnlJZHM6IG1hdGNoZWRRdWVyeUlkcyB9O1xufVxuZnVuY3Rpb24gc3BsaXREZXBzRHNsKGRlcHMsIHNvdXJjZU5hbWUpIHtcbiAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB2YXIgZmxhZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgX2EgPSBfX3JlYWQodmFsdWUsIDIpLCBmbGFncyA9IF9hWzBdLCB0b2tlbiA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICB0b2tlbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiAmJiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcpICYmIHNvdXJjZU5hbWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0b2tlbiwgU09VUkNFLCB7IHZhbHVlOiBzb3VyY2VOYW1lLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmxhZ3M6IGZsYWdzLCB0b2tlbjogdG9rZW4sIHRva2VuS2V5OiB0b2tlbktleSh0b2tlbikgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudFJlbmRlckVsZW1lbnQodmlldywgcmVuZGVySG9zdCwgZGVmKSB7XG4gICAgdmFyIHJlbmRlclBhcmVudCA9IGRlZi5yZW5kZXJQYXJlbnQ7XG4gICAgaWYgKHJlbmRlclBhcmVudCkge1xuICAgICAgICBpZiAoKHJlbmRlclBhcmVudC5mbGFncyAmIDEgLyogVHlwZUVsZW1lbnQgKi8pID09PSAwIHx8XG4gICAgICAgICAgICAocmVuZGVyUGFyZW50LmZsYWdzICYgMzM1NTQ0MzIgLyogQ29tcG9uZW50VmlldyAqLykgPT09IDAgfHxcbiAgICAgICAgICAgIChyZW5kZXJQYXJlbnQuZWxlbWVudC5jb21wb25lbnRSZW5kZXJlclR5cGUgJiZcbiAgICAgICAgICAgICAgICByZW5kZXJQYXJlbnQuZWxlbWVudC5jb21wb25lbnRSZW5kZXJlclR5cGUuZW5jYXBzdWxhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlKSkge1xuICAgICAgICAgICAgLy8gb25seSBjaGlsZHJlbiBvZiBub24gY29tcG9uZW50cywgb3IgY2hpbGRyZW4gb2YgY29tcG9uZW50cyB3aXRoIG5hdGl2ZSBlbmNhcHN1bGF0aW9uIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgYXR0YWNoZWQuXG4gICAgICAgICAgICByZXR1cm4gYXNFbGVtZW50RGF0YSh2aWV3LCBkZWYucmVuZGVyUGFyZW50Lm5vZGVJbmRleCkucmVuZGVyRWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlckhvc3Q7XG4gICAgfVxufVxudmFyIERFRklOSVRJT05fQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcmVzb2x2ZURlZmluaXRpb24oZmFjdG9yeSkge1xuICAgIHZhciB2YWx1ZSA9IERFRklOSVRJT05fQ0FDSEUuZ2V0KGZhY3RvcnkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBmYWN0b3J5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5PT1A7IH0pO1xuICAgICAgICB2YWx1ZS5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgREVGSU5JVElPTl9DQUNIRS5zZXQoZmFjdG9yeSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByb290UmVuZGVyTm9kZXModmlldykge1xuICAgIHZhciByZW5kZXJOb2RlcyA9IFtdO1xuICAgIHZpc2l0Um9vdFJlbmRlck5vZGVzKHZpZXcsIDAgLyogQ29sbGVjdCAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHJlbmRlck5vZGVzKTtcbiAgICByZXR1cm4gcmVuZGVyTm9kZXM7XG59XG5mdW5jdGlvbiB2aXNpdFJvb3RSZW5kZXJOb2Rlcyh2aWV3LCBhY3Rpb24sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHJlLWNvbXB1dGUgdGhlIHBhcmVudCBub2RlIGluIGNhc2UgdGhlIG5vZGVzIGhhdmUgYmVlbiBtb3ZlZCBhcm91bmQgbWFudWFsbHlcbiAgICBpZiAoYWN0aW9uID09PSAzIC8qIFJlbW92ZUNoaWxkICovKSB7XG4gICAgICAgIHBhcmVudE5vZGUgPSB2aWV3LnJlbmRlcmVyLnBhcmVudE5vZGUocmVuZGVyTm9kZSh2aWV3LCB2aWV3LmRlZi5sYXN0UmVuZGVyUm9vdE5vZGUpKTtcbiAgICB9XG4gICAgdmlzaXRTaWJsaW5nUmVuZGVyTm9kZXModmlldywgYWN0aW9uLCAwLCB2aWV3LmRlZi5ub2Rlcy5sZW5ndGggLSAxLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHZpc2l0U2libGluZ1JlbmRlck5vZGVzKHZpZXcsIGFjdGlvbiwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlRGVmID0gdmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgKDEgLyogVHlwZUVsZW1lbnQgKi8gfCAyIC8qIFR5cGVUZXh0ICovIHwgOCAvKiBUeXBlTmdDb250ZW50ICovKSkge1xuICAgICAgICAgICAgdmlzaXRSZW5kZXJOb2RlKHZpZXcsIG5vZGVEZWYsIGFjdGlvbiwgcGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ganVtcCB0byBuZXh0IHNpYmxpbmdcbiAgICAgICAgaSArPSBub2RlRGVmLmNoaWxkQ291bnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdmlzaXRQcm9qZWN0ZWRSZW5kZXJOb2Rlcyh2aWV3LCBuZ0NvbnRlbnRJbmRleCwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KSB7XG4gICAgdmFyIGNvbXBWaWV3ID0gdmlldztcbiAgICB3aGlsZSAoY29tcFZpZXcgJiYgIWlzQ29tcG9uZW50Vmlldyhjb21wVmlldykpIHtcbiAgICAgICAgY29tcFZpZXcgPSBjb21wVmlldy5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBob3N0VmlldyA9IGNvbXBWaWV3LnBhcmVudDtcbiAgICB2YXIgaG9zdEVsRGVmID0gdmlld1BhcmVudEVsKGNvbXBWaWV3KTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IGhvc3RFbERlZi5ub2RlSW5kZXggKyAxO1xuICAgIHZhciBlbmRJbmRleCA9IGhvc3RFbERlZi5ub2RlSW5kZXggKyBob3N0RWxEZWYuY2hpbGRDb3VudDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlRGVmID0gaG9zdFZpZXcuZGVmLm5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZURlZi5uZ0NvbnRlbnRJbmRleCA9PT0gbmdDb250ZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHZpc2l0UmVuZGVyTm9kZShob3N0Vmlldywgbm9kZURlZiwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqdW1wIHRvIG5leHQgc2libGluZ1xuICAgICAgICBpICs9IG5vZGVEZWYuY2hpbGRDb3VudDtcbiAgICB9XG4gICAgaWYgKCFob3N0Vmlldy5wYXJlbnQpIHtcbiAgICAgICAgLy8gYSByb290IHZpZXdcbiAgICAgICAgdmFyIHByb2plY3RlZE5vZGVzID0gdmlldy5yb290LnByb2plY3RhYmxlTm9kZXNbbmdDb250ZW50SW5kZXhdO1xuICAgICAgICBpZiAocHJvamVjdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvamVjdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleGVjUmVuZGVyTm9kZUFjdGlvbih2aWV3LCBwcm9qZWN0ZWROb2Rlc1tpXSwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZpc2l0UmVuZGVyTm9kZSh2aWV3LCBub2RlRGVmLCBhY3Rpb24sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpIHtcbiAgICBpZiAobm9kZURlZi5mbGFncyAmIDggLyogVHlwZU5nQ29udGVudCAqLykge1xuICAgICAgICB2aXNpdFByb2plY3RlZFJlbmRlck5vZGVzKHZpZXcsIG5vZGVEZWYubmdDb250ZW50LmluZGV4LCBhY3Rpb24sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJuID0gcmVuZGVyTm9kZSh2aWV3LCBub2RlRGVmKTtcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gMyAvKiBSZW1vdmVDaGlsZCAqLyAmJiAobm9kZURlZi5mbGFncyAmIDMzNTU0NDMyIC8qIENvbXBvbmVudFZpZXcgKi8pICYmXG4gICAgICAgICAgICAobm9kZURlZi5iaW5kaW5nRmxhZ3MgJiA0OCAvKiBDYXRTeW50aGV0aWNQcm9wZXJ0eSAqLykpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdlIG1pZ2h0IG5lZWQgdG8gZG8gYm90aCBhY3Rpb25zLlxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuYmluZGluZ0ZsYWdzICYgKDE2IC8qIFN5bnRoZXRpY1Byb3BlcnR5ICovKSkge1xuICAgICAgICAgICAgICAgIGV4ZWNSZW5kZXJOb2RlQWN0aW9uKHZpZXcsIHJuLCBhY3Rpb24sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuYmluZGluZ0ZsYWdzICYgKDMyIC8qIFN5bnRoZXRpY0hvc3RQcm9wZXJ0eSAqLykpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcFZpZXcgPSBhc0VsZW1lbnREYXRhKHZpZXcsIG5vZGVEZWYubm9kZUluZGV4KS5jb21wb25lbnRWaWV3O1xuICAgICAgICAgICAgICAgIGV4ZWNSZW5kZXJOb2RlQWN0aW9uKGNvbXBWaWV3LCBybiwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWNSZW5kZXJOb2RlQWN0aW9uKHZpZXcsIHJuLCBhY3Rpb24sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgMTY3NzcyMTYgLyogRW1iZWRkZWRWaWV3cyAqLykge1xuICAgICAgICAgICAgdmFyIGVtYmVkZGVkVmlld3MgPSBhc0VsZW1lbnREYXRhKHZpZXcsIG5vZGVEZWYubm9kZUluZGV4KS52aWV3Q29udGFpbmVyLl9lbWJlZGRlZFZpZXdzO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbWJlZGRlZFZpZXdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRSb290UmVuZGVyTm9kZXMoZW1iZWRkZWRWaWV3c1trXSwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDEgLyogVHlwZUVsZW1lbnQgKi8gJiYgIW5vZGVEZWYuZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICB2aXNpdFNpYmxpbmdSZW5kZXJOb2Rlcyh2aWV3LCBhY3Rpb24sIG5vZGVEZWYubm9kZUluZGV4ICsgMSwgbm9kZURlZi5ub2RlSW5kZXggKyBub2RlRGVmLmNoaWxkQ291bnQsIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXhlY1JlbmRlck5vZGVBY3Rpb24odmlldywgcmVuZGVyTm9kZSwgYWN0aW9uLCBwYXJlbnROb2RlLCBuZXh0U2libGluZywgdGFyZ2V0KSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdmlldy5yZW5kZXJlcjtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIDEgLyogQXBwZW5kQ2hpbGQgKi86XG4gICAgICAgICAgICByZW5kZXJlci5hcHBlbmRDaGlsZChwYXJlbnROb2RlLCByZW5kZXJOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogSW5zZXJ0QmVmb3JlICovOlxuICAgICAgICAgICAgcmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIHJlbmRlck5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogUmVtb3ZlQ2hpbGQgKi86XG4gICAgICAgICAgICByZW5kZXJlci5yZW1vdmVDaGlsZChwYXJlbnROb2RlLCByZW5kZXJOb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogQ29sbGVjdCAqLzpcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHJlbmRlck5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxudmFyIE5TX1BSRUZJWF9SRSA9IC9eOihbXjpdKyk6KC4rKSQvO1xuZnVuY3Rpb24gc3BsaXROYW1lc3BhY2UobmFtZSkge1xuICAgIGlmIChuYW1lWzBdID09PSAnOicpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChOU19QUkVGSVhfUkUpO1xuICAgICAgICByZXR1cm4gW21hdGNoWzFdLCBtYXRjaFsyXV07XG4gICAgfVxuICAgIHJldHVybiBbJycsIG5hbWVdO1xufVxuZnVuY3Rpb24gY2FsY0JpbmRpbmdGbGFncyhiaW5kaW5ncykge1xuICAgIHZhciBmbGFncyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyB8PSBiaW5kaW5nc1tpXS5mbGFncztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodmFsdWVDb3VudCwgY29uc3RBbmRJbnRlcnApIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUNvdW50ICogMjsgaSA9IGkgKyAyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIGNvbnN0QW5kSW50ZXJwW2ldICsgX3RvU3RyaW5nV2l0aE51bGwoY29uc3RBbmRJbnRlcnBbaSArIDFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIGNvbnN0QW5kSW50ZXJwW3ZhbHVlQ291bnQgKiAyXTtcbn1cbmZ1bmN0aW9uIGlubGluZUludGVycG9sYXRlKHZhbHVlQ291bnQsIGMwLCBhMSwgYzEsIGEyLCBjMiwgYTMsIGMzLCBhNCwgYzQsIGE1LCBjNSwgYTYsIGM2LCBhNywgYzcsIGE4LCBjOCwgYTksIGM5KSB7XG4gICAgc3dpdGNoICh2YWx1ZUNvdW50KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgKyBjNjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgIGM2ICsgX3RvU3RyaW5nV2l0aE51bGwoYTcpICsgYzcgKyBfdG9TdHJpbmdXaXRoTnVsbChhOCkgKyBjODtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzggKyBfdG9TdHJpbmdXaXRoTnVsbChhOSkgKyBjOTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvZXMgbm90IHN1cHBvcnQgbW9yZSB0aGFuIDkgZXhwcmVzc2lvbnNcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX3RvU3RyaW5nV2l0aE51bGwodikge1xuICAgIHJldHVybiB2ICE9IG51bGwgPyB2LnRvU3RyaW5nKCkgOiAnJztcbn1cbnZhciBFTVBUWV9BUlJBWSQ0ID0gW107XG52YXIgRU1QVFlfTUFQID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGFuY2hvckRlZihmbGFncywgbWF0Y2hlZFF1ZXJpZXNEc2wsIG5nQ29udGVudEluZGV4LCBjaGlsZENvdW50LCBoYW5kbGVFdmVudCwgdGVtcGxhdGVGYWN0b3J5KSB7XG4gICAgZmxhZ3MgfD0gMSAvKiBUeXBlRWxlbWVudCAqLztcbiAgICB2YXIgX2EgPSBzcGxpdE1hdGNoZWRRdWVyaWVzRHNsKG1hdGNoZWRRdWVyaWVzRHNsKSwgbWF0Y2hlZFF1ZXJpZXMgPSBfYS5tYXRjaGVkUXVlcmllcywgcmVmZXJlbmNlcyA9IF9hLnJlZmVyZW5jZXMsIG1hdGNoZWRRdWVyeUlkcyA9IF9hLm1hdGNoZWRRdWVyeUlkcztcbiAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZUZhY3RvcnkgPyByZXNvbHZlRGVmaW5pdGlvbih0ZW1wbGF0ZUZhY3RvcnkpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyB3aWxsIGJldCBzZXQgYnkgdGhlIHZpZXcgZGVmaW5pdGlvblxuICAgICAgICBub2RlSW5kZXg6IC0xLFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIHJlbmRlclBhcmVudDogbnVsbCxcbiAgICAgICAgYmluZGluZ0luZGV4OiAtMSxcbiAgICAgICAgb3V0cHV0SW5kZXg6IC0xLFxuICAgICAgICAvLyByZWd1bGFyIHZhbHVlc1xuICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgIGNoZWNrSW5kZXg6IC0xLFxuICAgICAgICBjaGlsZEZsYWdzOiAwLFxuICAgICAgICBkaXJlY3RDaGlsZEZsYWdzOiAwLFxuICAgICAgICBjaGlsZE1hdGNoZWRRdWVyaWVzOiAwLCBtYXRjaGVkUXVlcmllczogbWF0Y2hlZFF1ZXJpZXMsIG1hdGNoZWRRdWVyeUlkczogbWF0Y2hlZFF1ZXJ5SWRzLCByZWZlcmVuY2VzOiByZWZlcmVuY2VzLCBuZ0NvbnRlbnRJbmRleDogbmdDb250ZW50SW5kZXgsIGNoaWxkQ291bnQ6IGNoaWxkQ291bnQsXG4gICAgICAgIGJpbmRpbmdzOiBbXSxcbiAgICAgICAgYmluZGluZ0ZsYWdzOiAwLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgbnM6IG51bGwsXG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgYXR0cnM6IG51bGwsIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFByb3ZpZGVyOiBudWxsLFxuICAgICAgICAgICAgY29tcG9uZW50VmlldzogbnVsbCxcbiAgICAgICAgICAgIGNvbXBvbmVudFJlbmRlcmVyVHlwZTogbnVsbCxcbiAgICAgICAgICAgIHB1YmxpY1Byb3ZpZGVyczogbnVsbCxcbiAgICAgICAgICAgIGFsbFByb3ZpZGVyczogbnVsbCxcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudCB8fCBOT09QXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgbmdDb250ZW50OiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnREZWYoY2hlY2tJbmRleCwgZmxhZ3MsIG1hdGNoZWRRdWVyaWVzRHNsLCBuZ0NvbnRlbnRJbmRleCwgY2hpbGRDb3VudCwgbmFtZXNwYWNlQW5kTmFtZSwgZml4ZWRBdHRycywgYmluZGluZ3MsIG91dHB1dHMsIGhhbmRsZUV2ZW50LCBjb21wb25lbnRWaWV3LCBjb21wb25lbnRSZW5kZXJlclR5cGUpIHtcbiAgICBpZiAoZml4ZWRBdHRycyA9PT0gdm9pZCAwKSB7IGZpeGVkQXR0cnMgPSBbXTsgfVxuICAgIHZhciBfYTtcbiAgICBpZiAoIWhhbmRsZUV2ZW50KSB7XG4gICAgICAgIGhhbmRsZUV2ZW50ID0gTk9PUDtcbiAgICB9XG4gICAgdmFyIF9iID0gc3BsaXRNYXRjaGVkUXVlcmllc0RzbChtYXRjaGVkUXVlcmllc0RzbCksIG1hdGNoZWRRdWVyaWVzID0gX2IubWF0Y2hlZFF1ZXJpZXMsIHJlZmVyZW5jZXMgPSBfYi5yZWZlcmVuY2VzLCBtYXRjaGVkUXVlcnlJZHMgPSBfYi5tYXRjaGVkUXVlcnlJZHM7XG4gICAgdmFyIG5zID0gbnVsbDtcbiAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgaWYgKG5hbWVzcGFjZUFuZE5hbWUpIHtcbiAgICAgICAgX2EgPSBfX3JlYWQoc3BsaXROYW1lc3BhY2UobmFtZXNwYWNlQW5kTmFtZSksIDIpLCBucyA9IF9hWzBdLCBuYW1lID0gX2FbMV07XG4gICAgfVxuICAgIGJpbmRpbmdzID0gYmluZGluZ3MgfHwgW107XG4gICAgdmFyIGJpbmRpbmdEZWZzID0gbmV3IEFycmF5KGJpbmRpbmdzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoYmluZGluZ3NbaV0sIDMpLCBiaW5kaW5nRmxhZ3MgPSBfY1swXSwgbmFtZXNwYWNlQW5kTmFtZV8xID0gX2NbMV0sIHN1ZmZpeE9yU2VjdXJpdHlDb250ZXh0ID0gX2NbMl07XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChzcGxpdE5hbWVzcGFjZShuYW1lc3BhY2VBbmROYW1lXzEpLCAyKSwgbnNfMSA9IF9kWzBdLCBuYW1lXzEgPSBfZFsxXTtcbiAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3dpdGNoIChiaW5kaW5nRmxhZ3MgJiAxNSAvKiBUeXBlcyAqLykge1xuICAgICAgICAgICAgY2FzZSA0IC8qIFR5cGVFbGVtZW50U3R5bGUgKi86XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4T3JTZWN1cml0eUNvbnRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogVHlwZUVsZW1lbnRBdHRyaWJ1dGUgKi86XG4gICAgICAgICAgICBjYXNlIDggLyogVHlwZVByb3BlcnR5ICovOlxuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IHN1ZmZpeE9yU2VjdXJpdHlDb250ZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmdEZWZzW2ldID1cbiAgICAgICAgICAgIHsgZmxhZ3M6IGJpbmRpbmdGbGFncywgbnM6IG5zXzEsIG5hbWU6IG5hbWVfMSwgbm9uTWluaWZpZWROYW1lOiBuYW1lXzEsIHNlY3VyaXR5Q29udGV4dDogc2VjdXJpdHlDb250ZXh0LCBzdWZmaXg6IHN1ZmZpeCB9O1xuICAgIH1cbiAgICBvdXRwdXRzID0gb3V0cHV0cyB8fCBbXTtcbiAgICB2YXIgb3V0cHV0RGVmcyA9IG5ldyBBcnJheShvdXRwdXRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChvdXRwdXRzW2ldLCAyKSwgdGFyZ2V0ID0gX2VbMF0sIGV2ZW50TmFtZSA9IF9lWzFdO1xuICAgICAgICBvdXRwdXREZWZzW2ldID0ge1xuICAgICAgICAgICAgdHlwZTogMCAvKiBFbGVtZW50T3V0cHV0ICovLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsIGV2ZW50TmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgcHJvcE5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZml4ZWRBdHRycyA9IGZpeGVkQXR0cnMgfHwgW107XG4gICAgdmFyIGF0dHJzID0gZml4ZWRBdHRycy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIG5hbWVzcGFjZUFuZE5hbWUgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKHNwbGl0TmFtZXNwYWNlKG5hbWVzcGFjZUFuZE5hbWUpLCAyKSwgbnMgPSBfY1swXSwgbmFtZSA9IF9jWzFdO1xuICAgICAgICByZXR1cm4gW25zLCBuYW1lLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgY29tcG9uZW50UmVuZGVyZXJUeXBlID0gcmVzb2x2ZVJlbmRlcmVyVHlwZTIoY29tcG9uZW50UmVuZGVyZXJUeXBlKTtcbiAgICBpZiAoY29tcG9uZW50Vmlldykge1xuICAgICAgICBmbGFncyB8PSAzMzU1NDQzMiAvKiBDb21wb25lbnRWaWV3ICovO1xuICAgIH1cbiAgICBmbGFncyB8PSAxIC8qIFR5cGVFbGVtZW50ICovO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIHdpbGwgYmV0IHNldCBieSB0aGUgdmlldyBkZWZpbml0aW9uXG4gICAgICAgIG5vZGVJbmRleDogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcmVuZGVyUGFyZW50OiBudWxsLFxuICAgICAgICBiaW5kaW5nSW5kZXg6IC0xLFxuICAgICAgICBvdXRwdXRJbmRleDogLTEsXG4gICAgICAgIC8vIHJlZ3VsYXIgdmFsdWVzXG4gICAgICAgIGNoZWNrSW5kZXg6IGNoZWNrSW5kZXgsXG4gICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgY2hpbGRGbGFnczogMCxcbiAgICAgICAgZGlyZWN0Q2hpbGRGbGFnczogMCxcbiAgICAgICAgY2hpbGRNYXRjaGVkUXVlcmllczogMCwgbWF0Y2hlZFF1ZXJpZXM6IG1hdGNoZWRRdWVyaWVzLCBtYXRjaGVkUXVlcnlJZHM6IG1hdGNoZWRRdWVyeUlkcywgcmVmZXJlbmNlczogcmVmZXJlbmNlcywgbmdDb250ZW50SW5kZXg6IG5nQ29udGVudEluZGV4LCBjaGlsZENvdW50OiBjaGlsZENvdW50LFxuICAgICAgICBiaW5kaW5nczogYmluZGluZ0RlZnMsXG4gICAgICAgIGJpbmRpbmdGbGFnczogY2FsY0JpbmRpbmdGbGFncyhiaW5kaW5nRGVmcyksXG4gICAgICAgIG91dHB1dHM6IG91dHB1dERlZnMsXG4gICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgIG5zOiBucyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbnVsbCxcbiAgICAgICAgICAgIC8vIHdpbGwgYmV0IHNldCBieSB0aGUgdmlldyBkZWZpbml0aW9uXG4gICAgICAgICAgICBjb21wb25lbnRQcm92aWRlcjogbnVsbCxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXc6IGNvbXBvbmVudFZpZXcgfHwgbnVsbCxcbiAgICAgICAgICAgIGNvbXBvbmVudFJlbmRlcmVyVHlwZTogY29tcG9uZW50UmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgcHVibGljUHJvdmlkZXJzOiBudWxsLFxuICAgICAgICAgICAgYWxsUHJvdmlkZXJzOiBudWxsLFxuICAgICAgICAgICAgaGFuZGxlRXZlbnQ6IGhhbmRsZUV2ZW50IHx8IE5PT1AsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgbmdDb250ZW50OiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodmlldywgcmVuZGVySG9zdCwgZGVmKSB7XG4gICAgdmFyIGVsRGVmID0gZGVmLmVsZW1lbnQ7XG4gICAgdmFyIHJvb3RTZWxlY3Rvck9yTm9kZSA9IHZpZXcucm9vdC5zZWxlY3Rvck9yTm9kZTtcbiAgICB2YXIgcmVuZGVyZXIgPSB2aWV3LnJlbmRlcmVyO1xuICAgIHZhciBlbDtcbiAgICBpZiAodmlldy5wYXJlbnQgfHwgIXJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICBpZiAoZWxEZWYubmFtZSkge1xuICAgICAgICAgICAgZWwgPSByZW5kZXJlci5jcmVhdGVFbGVtZW50KGVsRGVmLm5hbWUsIGVsRGVmLm5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gcmVuZGVyZXIuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudEVsID0gZ2V0UGFyZW50UmVuZGVyRWxlbWVudCh2aWV3LCByZW5kZXJIb3N0LCBkZWYpO1xuICAgICAgICBpZiAocGFyZW50RWwpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmFwcGVuZENoaWxkKHBhcmVudEVsLCBlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdXNpbmcgbmF0aXZlIFNoYWRvdyBET00sIGRvIG5vdCBjbGVhciB0aGUgcm9vdCBlbGVtZW50IGNvbnRlbnRzIHRvIGFsbG93IHNsb3QgcHJvamVjdGlvblxuICAgICAgICB2YXIgcHJlc2VydmVDb250ZW50ID0gKCEhZWxEZWYuY29tcG9uZW50UmVuZGVyZXJUeXBlICYmXG4gICAgICAgICAgICBlbERlZi5jb21wb25lbnRSZW5kZXJlclR5cGUuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uU2hhZG93RG9tKTtcbiAgICAgICAgZWwgPSByZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChyb290U2VsZWN0b3JPck5vZGUsIHByZXNlcnZlQ29udGVudCk7XG4gICAgfVxuICAgIGlmIChlbERlZi5hdHRycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsRGVmLmF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZWxEZWYuYXR0cnNbaV0sIDMpLCBucyA9IF9hWzBdLCBuYW1lXzIgPSBfYVsxXSwgdmFsdWUgPSBfYVsyXTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbCwgbmFtZV8yLCB2YWx1ZSwgbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvRWxlbWVudE91dHB1dHModmlldywgY29tcFZpZXcsIGRlZiwgZWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkZWYub3V0cHV0c1tpXTtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50Q2xvc3VyZSA9IHJlbmRlckV2ZW50SGFuZGxlckNsb3N1cmUodmlldywgZGVmLm5vZGVJbmRleCwgZWxlbWVudEV2ZW50RnVsbE5hbWUob3V0cHV0LnRhcmdldCwgb3V0cHV0LmV2ZW50TmFtZSkpO1xuICAgICAgICB2YXIgbGlzdGVuVGFyZ2V0ID0gb3V0cHV0LnRhcmdldDtcbiAgICAgICAgdmFyIGxpc3RlbmVyVmlldyA9IHZpZXc7XG4gICAgICAgIGlmIChvdXRwdXQudGFyZ2V0ID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgbGlzdGVuVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGxpc3RlbmVyVmlldyA9IGNvbXBWaWV3O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXNwb3NhYmxlID0gbGlzdGVuZXJWaWV3LnJlbmRlcmVyLmxpc3RlbihsaXN0ZW5UYXJnZXQgfHwgZWwsIG91dHB1dC5ldmVudE5hbWUsIGhhbmRsZUV2ZW50Q2xvc3VyZSk7XG4gICAgICAgIHZpZXcuZGlzcG9zYWJsZXNbZGVmLm91dHB1dEluZGV4ICsgaV0gPSBkaXNwb3NhYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckV2ZW50SGFuZGxlckNsb3N1cmUodmlldywgaW5kZXgsIGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGRpc3BhdGNoRXZlbnQodmlldywgaW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpOyB9O1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVFbGVtZW50SW5saW5lKHZpZXcsIGRlZiwgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpIHtcbiAgICB2YXIgYmluZExlbiA9IGRlZi5iaW5kaW5ncy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoYmluZExlbiA+IDAgJiYgY2hlY2tBbmRVcGRhdGVFbGVtZW50VmFsdWUodmlldywgZGVmLCAwLCB2MCkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gMSAmJiBjaGVja0FuZFVwZGF0ZUVsZW1lbnRWYWx1ZSh2aWV3LCBkZWYsIDEsIHYxKSlcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGJpbmRMZW4gPiAyICYmIGNoZWNrQW5kVXBkYXRlRWxlbWVudFZhbHVlKHZpZXcsIGRlZiwgMiwgdjIpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDMgJiYgY2hlY2tBbmRVcGRhdGVFbGVtZW50VmFsdWUodmlldywgZGVmLCAzLCB2MykpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNCAmJiBjaGVja0FuZFVwZGF0ZUVsZW1lbnRWYWx1ZSh2aWV3LCBkZWYsIDQsIHY0KSlcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGJpbmRMZW4gPiA1ICYmIGNoZWNrQW5kVXBkYXRlRWxlbWVudFZhbHVlKHZpZXcsIGRlZiwgNSwgdjUpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDYgJiYgY2hlY2tBbmRVcGRhdGVFbGVtZW50VmFsdWUodmlldywgZGVmLCA2LCB2NikpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNyAmJiBjaGVja0FuZFVwZGF0ZUVsZW1lbnRWYWx1ZSh2aWV3LCBkZWYsIDcsIHY3KSlcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgaWYgKGJpbmRMZW4gPiA4ICYmIGNoZWNrQW5kVXBkYXRlRWxlbWVudFZhbHVlKHZpZXcsIGRlZiwgOCwgdjgpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDkgJiYgY2hlY2tBbmRVcGRhdGVFbGVtZW50VmFsdWUodmlldywgZGVmLCA5LCB2OSkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVFbGVtZW50RHluYW1pYyh2aWV3LCBkZWYsIHZhbHVlcykge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrQW5kVXBkYXRlRWxlbWVudFZhbHVlKHZpZXcsIGRlZiwgaSwgdmFsdWVzW2ldKSlcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGNoZWNrQW5kVXBkYXRlRWxlbWVudFZhbHVlKHZpZXcsIGRlZiwgYmluZGluZ0lkeCwgdmFsdWUpIHtcbiAgICBpZiAoIWNoZWNrQW5kVXBkYXRlQmluZGluZyh2aWV3LCBkZWYsIGJpbmRpbmdJZHgsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBiaW5kaW5nID0gZGVmLmJpbmRpbmdzW2JpbmRpbmdJZHhdO1xuICAgIHZhciBlbERhdGEgPSBhc0VsZW1lbnREYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpO1xuICAgIHZhciByZW5kZXJOb2RlJCQxID0gZWxEYXRhLnJlbmRlckVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBiaW5kaW5nLm5hbWU7XG4gICAgc3dpdGNoIChiaW5kaW5nLmZsYWdzICYgMTUgLyogVHlwZXMgKi8pIHtcbiAgICAgICAgY2FzZSAxIC8qIFR5cGVFbGVtZW50QXR0cmlidXRlICovOlxuICAgICAgICAgICAgc2V0RWxlbWVudEF0dHJpYnV0ZSh2aWV3LCBiaW5kaW5nLCByZW5kZXJOb2RlJCQxLCBiaW5kaW5nLm5zLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIFR5cGVFbGVtZW50Q2xhc3MgKi86XG4gICAgICAgICAgICBzZXRFbGVtZW50Q2xhc3ModmlldywgcmVuZGVyTm9kZSQkMSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBUeXBlRWxlbWVudFN0eWxlICovOlxuICAgICAgICAgICAgc2V0RWxlbWVudFN0eWxlKHZpZXcsIGJpbmRpbmcsIHJlbmRlck5vZGUkJDEsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDggLyogVHlwZVByb3BlcnR5ICovOlxuICAgICAgICAgICAgdmFyIGJpbmRWaWV3ID0gKGRlZi5mbGFncyAmIDMzNTU0NDMyIC8qIENvbXBvbmVudFZpZXcgKi8gJiZcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmZsYWdzICYgMzIgLyogU3ludGhldGljSG9zdFByb3BlcnR5ICovKSA/XG4gICAgICAgICAgICAgICAgZWxEYXRhLmNvbXBvbmVudFZpZXcgOlxuICAgICAgICAgICAgICAgIHZpZXc7XG4gICAgICAgICAgICBzZXRFbGVtZW50UHJvcGVydHkoYmluZFZpZXcsIGJpbmRpbmcsIHJlbmRlck5vZGUkJDEsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRBdHRyaWJ1dGUodmlldywgYmluZGluZywgcmVuZGVyTm9kZSQkMSwgbnMsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHNlY3VyaXR5Q29udGV4dCA9IGJpbmRpbmcuc2VjdXJpdHlDb250ZXh0O1xuICAgIHZhciByZW5kZXJWYWx1ZSA9IHNlY3VyaXR5Q29udGV4dCA/IHZpZXcucm9vdC5zYW5pdGl6ZXIuc2FuaXRpemUoc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICByZW5kZXJWYWx1ZSA9IHJlbmRlclZhbHVlICE9IG51bGwgPyByZW5kZXJWYWx1ZS50b1N0cmluZygpIDogbnVsbDtcbiAgICB2YXIgcmVuZGVyZXIgPSB2aWV3LnJlbmRlcmVyO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZShyZW5kZXJOb2RlJCQxLCBuYW1lLCByZW5kZXJWYWx1ZSwgbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHJlbmRlck5vZGUkJDEsIG5hbWUsIG5zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50Q2xhc3ModmlldywgcmVuZGVyTm9kZSQkMSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB2aWV3LnJlbmRlcmVyO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZW5kZXJlci5hZGRDbGFzcyhyZW5kZXJOb2RlJCQxLCBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnJlbW92ZUNsYXNzKHJlbmRlck5vZGUkJDEsIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRTdHlsZSh2aWV3LCBiaW5kaW5nLCByZW5kZXJOb2RlJCQxLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciByZW5kZXJWYWx1ZSA9IHZpZXcucm9vdC5zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCB2YWx1ZSk7XG4gICAgaWYgKHJlbmRlclZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmVuZGVyVmFsdWUgPSByZW5kZXJWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgdW5pdCA9IGJpbmRpbmcuc3VmZml4O1xuICAgICAgICBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJWYWx1ZSA9IHJlbmRlclZhbHVlICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVuZGVyVmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSB2aWV3LnJlbmRlcmVyO1xuICAgIGlmIChyZW5kZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFN0eWxlKHJlbmRlck5vZGUkJDEsIG5hbWUsIHJlbmRlclZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnJlbW92ZVN0eWxlKHJlbmRlck5vZGUkJDEsIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRQcm9wZXJ0eSh2aWV3LCBiaW5kaW5nLCByZW5kZXJOb2RlJCQxLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzZWN1cml0eUNvbnRleHQgPSBiaW5kaW5nLnNlY3VyaXR5Q29udGV4dDtcbiAgICB2YXIgcmVuZGVyVmFsdWUgPSBzZWN1cml0eUNvbnRleHQgPyB2aWV3LnJvb3Quc2FuaXRpemVyLnNhbml0aXplKHNlY3VyaXR5Q29udGV4dCwgdmFsdWUpIDogdmFsdWU7XG4gICAgdmlldy5yZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJOb2RlJCQxLCBuYW1lLCByZW5kZXJWYWx1ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBVTkRFRklORURfVkFMVUUgPSBuZXcgT2JqZWN0KCk7XG52YXIgSW5qZWN0b3JSZWZUb2tlbktleSA9IHRva2VuS2V5KEluamVjdG9yKTtcbnZhciBJTkpFQ1RPUlJlZlRva2VuS2V5ID0gdG9rZW5LZXkoSU5KRUNUT1IpO1xudmFyIE5nTW9kdWxlUmVmVG9rZW5LZXkgPSB0b2tlbktleShOZ01vZHVsZVJlZik7XG5mdW5jdGlvbiBtb2R1bGVQcm92aWRlRGVmKGZsYWdzLCB0b2tlbiwgdmFsdWUsIGRlcHMpIHtcbiAgICAvLyBOZWVkIHRvIHJlc29sdmUgZm9yd2FyZFJlZnMgYXMgZS5nLiBmb3IgYHVzZVZhbHVlYCB3ZVxuICAgIC8vIGxvd2VyZWQgdGhlIGV4cHJlc3Npb24gYW5kIHRoZW4gc3RvcHBlZCBldmFsdWF0aW5nIGl0LFxuICAgIC8vIGkuZS4gYWxzbyBkaWRuJ3QgdW53cmFwIGl0LlxuICAgIHZhbHVlID0gcmVzb2x2ZUZvcndhcmRSZWYodmFsdWUpO1xuICAgIHZhciBkZXBEZWZzID0gc3BsaXREZXBzRHNsKGRlcHMsIHN0cmluZ2lmeSh0b2tlbikpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIHdpbGwgYmV0IHNldCBieSB0aGUgbW9kdWxlIGRlZmluaXRpb25cbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBkZXBzOiBkZXBEZWZzLCBmbGFnczogZmxhZ3MsIHRva2VuOiB0b2tlbiwgdmFsdWU6IHZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vZHVsZURlZihwcm92aWRlcnMpIHtcbiAgICB2YXIgcHJvdmlkZXJzQnlLZXkgPSB7fTtcbiAgICB2YXIgbW9kdWxlcyA9IFtdO1xuICAgIHZhciBpc1Jvb3QgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSBwcm92aWRlcnNbaV07XG4gICAgICAgIGlmIChwcm92aWRlci50b2tlbiA9PT0gQVBQX1JPT1QgJiYgcHJvdmlkZXIudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlzUm9vdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyLmZsYWdzICYgMTA3Mzc0MTgyNCAvKiBUeXBlTmdNb2R1bGUgKi8pIHtcbiAgICAgICAgICAgIG1vZHVsZXMucHVzaChwcm92aWRlci50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIuaW5kZXggPSBpO1xuICAgICAgICBwcm92aWRlcnNCeUtleVt0b2tlbktleShwcm92aWRlci50b2tlbildID0gcHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFdpbGwgYmUgZmlsbGVkIGxhdGVyLi4uXG4gICAgICAgIGZhY3Rvcnk6IG51bGwsXG4gICAgICAgIHByb3ZpZGVyc0J5S2V5OiBwcm92aWRlcnNCeUtleSxcbiAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgIG1vZHVsZXM6IG1vZHVsZXMsXG4gICAgICAgIGlzUm9vdDogaXNSb290LFxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0TmdNb2R1bGUoZGF0YSkge1xuICAgIHZhciBkZWYgPSBkYXRhLl9kZWY7XG4gICAgdmFyIHByb3ZpZGVycyA9IGRhdGEuX3Byb3ZpZGVycyA9IG5ldyBBcnJheShkZWYucHJvdmlkZXJzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYucHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm92RGVmID0gZGVmLnByb3ZpZGVyc1tpXTtcbiAgICAgICAgaWYgKCEocHJvdkRlZi5mbGFncyAmIDQwOTYgLyogTGF6eVByb3ZpZGVyICovKSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcm92aWRlciBoYXMgbm90IGJlZW4gYWxyZWFkeSBpbml0aWFsaXplZCBvdXRzaWRlIHRoaXMgbG9vcC5cbiAgICAgICAgICAgIGlmIChwcm92aWRlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyc1tpXSA9IF9jcmVhdGVQcm92aWRlckluc3RhbmNlKGRhdGEsIHByb3ZEZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU5nTW9kdWxlRGVwKGRhdGEsIGRlcERlZiwgbm90Rm91bmRWYWx1ZSkge1xuICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgIHZhciBmb3JtZXIgPSBzZXRDdXJyZW50SW5qZWN0b3IoZGF0YSk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGRlcERlZi5mbGFncyAmIDggLyogVmFsdWUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBkZXBEZWYudG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcERlZi5mbGFncyAmIDIgLyogT3B0aW9uYWwgKi8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kVmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBEZWYuZmxhZ3MgJiAxIC8qIFNraXBTZWxmICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5fcGFyZW50LmdldChkZXBEZWYudG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbktleV8xID0gZGVwRGVmLnRva2VuS2V5O1xuICAgICAgICBzd2l0Y2ggKHRva2VuS2V5XzEpIHtcbiAgICAgICAgICAgIGNhc2UgSW5qZWN0b3JSZWZUb2tlbktleTpcbiAgICAgICAgICAgIGNhc2UgSU5KRUNUT1JSZWZUb2tlbktleTpcbiAgICAgICAgICAgIGNhc2UgTmdNb2R1bGVSZWZUb2tlbktleTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdmlkZXJEZWYgPSBkYXRhLl9kZWYucHJvdmlkZXJzQnlLZXlbdG9rZW5LZXlfMV07XG4gICAgICAgIHZhciBpbmplY3RhYmxlRGVmID0gdm9pZCAwO1xuICAgICAgICBpZiAocHJvdmlkZXJEZWYpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlckluc3RhbmNlID0gZGF0YS5fcHJvdmlkZXJzW3Byb3ZpZGVyRGVmLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlckluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckluc3RhbmNlID0gZGF0YS5fcHJvdmlkZXJzW3Byb3ZpZGVyRGVmLmluZGV4XSA9XG4gICAgICAgICAgICAgICAgICAgIF9jcmVhdGVQcm92aWRlckluc3RhbmNlKGRhdGEsIHByb3ZpZGVyRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlckluc3RhbmNlID09PSBVTkRFRklORURfVkFMVUUgPyB1bmRlZmluZWQgOiBwcm92aWRlckluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChpbmplY3RhYmxlRGVmID0gZ2V0SW5qZWN0YWJsZURlZihkZXBEZWYudG9rZW4pKSAmJiB0YXJnZXRzTW9kdWxlKGRhdGEsIGluamVjdGFibGVEZWYpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBkYXRhLl9wcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YS5fZGVmLnByb3ZpZGVyc0J5S2V5W2RlcERlZi50b2tlbktleV0gPSB7XG4gICAgICAgICAgICAgICAgZmxhZ3M6IDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLyB8IDQwOTYgLyogTGF6eVByb3ZpZGVyICovLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmplY3RhYmxlRGVmLmZhY3RvcnksXG4gICAgICAgICAgICAgICAgZGVwczogW10sIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB0b2tlbjogZGVwRGVmLnRva2VuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuX3Byb3ZpZGVyc1tpbmRleF0gPSBVTkRFRklORURfVkFMVUU7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGEuX3Byb3ZpZGVyc1tpbmRleF0gPVxuICAgICAgICAgICAgICAgIF9jcmVhdGVQcm92aWRlckluc3RhbmNlKGRhdGEsIGRhdGEuX2RlZi5wcm92aWRlcnNCeUtleVtkZXBEZWYudG9rZW5LZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVwRGVmLmZsYWdzICYgNCAvKiBTZWxmICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5fcGFyZW50LmdldChkZXBEZWYudG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc2V0Q3VycmVudEluamVjdG9yKGZvcm1lcik7XG4gICAgfVxufVxuZnVuY3Rpb24gbW9kdWxlVHJhbnNpdGl2ZWx5UHJlc2VudChuZ01vZHVsZSwgc2NvcGUpIHtcbiAgICByZXR1cm4gbmdNb2R1bGUuX2RlZi5tb2R1bGVzLmluZGV4T2Yoc2NvcGUpID4gLTE7XG59XG5mdW5jdGlvbiB0YXJnZXRzTW9kdWxlKG5nTW9kdWxlLCBkZWYpIHtcbiAgICByZXR1cm4gZGVmLnByb3ZpZGVkSW4gIT0gbnVsbCAmJiAobW9kdWxlVHJhbnNpdGl2ZWx5UHJlc2VudChuZ01vZHVsZSwgZGVmLnByb3ZpZGVkSW4pIHx8XG4gICAgICAgIGRlZi5wcm92aWRlZEluID09PSAncm9vdCcgJiYgbmdNb2R1bGUuX2RlZi5pc1Jvb3QpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZVByb3ZpZGVySW5zdGFuY2UobmdNb2R1bGUsIHByb3ZpZGVyRGVmKSB7XG4gICAgdmFyIGluamVjdGFibGU7XG4gICAgc3dpdGNoIChwcm92aWRlckRlZi5mbGFncyAmIDIwMTM0NzA2NyAvKiBUeXBlcyAqLykge1xuICAgICAgICBjYXNlIDUxMiAvKiBUeXBlQ2xhc3NQcm92aWRlciAqLzpcbiAgICAgICAgICAgIGluamVjdGFibGUgPSBfY3JlYXRlQ2xhc3MobmdNb2R1bGUsIHByb3ZpZGVyRGVmLnZhbHVlLCBwcm92aWRlckRlZi5kZXBzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLzpcbiAgICAgICAgICAgIGluamVjdGFibGUgPSBfY2FsbEZhY3RvcnkobmdNb2R1bGUsIHByb3ZpZGVyRGVmLnZhbHVlLCBwcm92aWRlckRlZi5kZXBzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIwNDggLyogVHlwZVVzZUV4aXN0aW5nUHJvdmlkZXIgKi86XG4gICAgICAgICAgICBpbmplY3RhYmxlID0gcmVzb2x2ZU5nTW9kdWxlRGVwKG5nTW9kdWxlLCBwcm92aWRlckRlZi5kZXBzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1NiAvKiBUeXBlVmFsdWVQcm92aWRlciAqLzpcbiAgICAgICAgICAgIGluamVjdGFibGUgPSBwcm92aWRlckRlZi52YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUaGUgcmVhZCBvZiBgbmdPbkRlc3Ryb3lgIGhlcmUgaXMgc2xpZ2h0bHkgZXhwZW5zaXZlIGFzIGl0J3MgbWVnYW1vcnBoaWMsIHNvIGl0IHNob3VsZCBiZVxuICAgIC8vIGF2b2lkZWQgaWYgcG9zc2libGUuIFRoZSBzZXF1ZW5jZSBvZiBjaGVja3MgaGVyZSBkZXRlcm1pbmVzIHdoZXRoZXIgbmdPbkRlc3Ryb3kgbmVlZHMgdG8gYmVcbiAgICAvLyBjaGVja2VkLiBJdCBtaWdodCBub3QgaWYgdGhlIGBpbmplY3RhYmxlYCBpc24ndCBhbiBvYmplY3Qgb3IgaWYgTm9kZUZsYWdzLk9uRGVzdHJveSBpcyBhbHJlYWR5XG4gICAgLy8gc2V0IChuZ09uRGVzdHJveSB3YXMgZGV0ZWN0ZWQgc3RhdGljYWxseSkuXG4gICAgaWYgKGluamVjdGFibGUgIT09IFVOREVGSU5FRF9WQUxVRSAmJiBpbmplY3RhYmxlICE9IG51bGwgJiYgdHlwZW9mIGluamVjdGFibGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICEocHJvdmlkZXJEZWYuZmxhZ3MgJiAxMzEwNzIgLyogT25EZXN0cm95ICovKSAmJiB0eXBlb2YgaW5qZWN0YWJsZS5uZ09uRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm92aWRlckRlZi5mbGFncyB8PSAxMzEwNzIgLyogT25EZXN0cm95ICovO1xuICAgIH1cbiAgICByZXR1cm4gaW5qZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gVU5ERUZJTkVEX1ZBTFVFIDogaW5qZWN0YWJsZTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhuZ01vZHVsZSwgY3RvciwgZGVwcykge1xuICAgIHZhciBsZW4gPSBkZXBzLmxlbmd0aDtcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHJlc29sdmVOZ01vZHVsZURlcChuZ01vZHVsZSwgZGVwc1swXSkpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IocmVzb2x2ZU5nTW9kdWxlRGVwKG5nTW9kdWxlLCBkZXBzWzBdKSwgcmVzb2x2ZU5nTW9kdWxlRGVwKG5nTW9kdWxlLCBkZXBzWzFdKSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcihyZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMF0pLCByZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMV0pLCByZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBkZXBWYWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXBWYWx1ZXNbaV0gPSByZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoY3Rvci5iaW5kLmFwcGx5KGN0b3IsIF9fc3ByZWFkKFt2b2lkIDBdLCBkZXBWYWx1ZXMpKSkoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY2FsbEZhY3RvcnkobmdNb2R1bGUsIGZhY3RvcnksIGRlcHMpIHtcbiAgICB2YXIgbGVuID0gZGVwcy5sZW5ndGg7XG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkocmVzb2x2ZU5nTW9kdWxlRGVwKG5nTW9kdWxlLCBkZXBzWzBdKSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHJlc29sdmVOZ01vZHVsZURlcChuZ01vZHVsZSwgZGVwc1swXSksIHJlc29sdmVOZ01vZHVsZURlcChuZ01vZHVsZSwgZGVwc1sxXSkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShyZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMF0pLCByZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMV0pLCByZXNvbHZlTmdNb2R1bGVEZXAobmdNb2R1bGUsIGRlcHNbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBkZXBWYWx1ZXMgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlcFZhbHVlc1tpXSA9IHJlc29sdmVOZ01vZHVsZURlcChuZ01vZHVsZSwgZGVwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGRlcFZhbHVlcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxOZ01vZHVsZUxpZmVjeWNsZShuZ01vZHVsZSwgbGlmZWN5Y2xlcykge1xuICAgIHZhciBkZWYgPSBuZ01vZHVsZS5fZGVmO1xuICAgIHZhciBkZXN0cm95ZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYucHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm92RGVmID0gZGVmLnByb3ZpZGVyc1tpXTtcbiAgICAgICAgaWYgKHByb3ZEZWYuZmxhZ3MgJiAxMzEwNzIgLyogT25EZXN0cm95ICovKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZ01vZHVsZS5fcHJvdmlkZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlICE9PSBVTkRFRklORURfVkFMVUUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25EZXN0cm95ID0gaW5zdGFuY2UubmdPbkRlc3Ryb3k7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkRlc3Ryb3kgPT09ICdmdW5jdGlvbicgJiYgIWRlc3Ryb3llZC5oYXMoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVzdHJveS5hcHBseShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3llZC5hZGQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gYXR0YWNoRW1iZWRkZWRWaWV3KHBhcmVudFZpZXcsIGVsZW1lbnREYXRhLCB2aWV3SW5kZXgsIHZpZXcpIHtcbiAgICB2YXIgZW1iZWRkZWRWaWV3cyA9IGVsZW1lbnREYXRhLnZpZXdDb250YWluZXIuX2VtYmVkZGVkVmlld3M7XG4gICAgaWYgKHZpZXdJbmRleCA9PT0gbnVsbCB8fCB2aWV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2aWV3SW5kZXggPSBlbWJlZGRlZFZpZXdzLmxlbmd0aDtcbiAgICB9XG4gICAgdmlldy52aWV3Q29udGFpbmVyUGFyZW50ID0gcGFyZW50VmlldztcbiAgICBhZGRUb0FycmF5KGVtYmVkZGVkVmlld3MsIHZpZXdJbmRleCwgdmlldyk7XG4gICAgYXR0YWNoUHJvamVjdGVkVmlldyhlbGVtZW50RGF0YSwgdmlldyk7XG4gICAgU2VydmljZXMuZGlydHlQYXJlbnRRdWVyaWVzKHZpZXcpO1xuICAgIHZhciBwcmV2VmlldyA9IHZpZXdJbmRleCA+IDAgPyBlbWJlZGRlZFZpZXdzW3ZpZXdJbmRleCAtIDFdIDogbnVsbDtcbiAgICByZW5kZXJBdHRhY2hFbWJlZGRlZFZpZXcoZWxlbWVudERhdGEsIHByZXZWaWV3LCB2aWV3KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaFByb2plY3RlZFZpZXcodmNFbGVtZW50RGF0YSwgdmlldykge1xuICAgIHZhciBkdmNFbGVtZW50RGF0YSA9IGRlY2xhcmVkVmlld0NvbnRhaW5lcih2aWV3KTtcbiAgICBpZiAoIWR2Y0VsZW1lbnREYXRhIHx8IGR2Y0VsZW1lbnREYXRhID09PSB2Y0VsZW1lbnREYXRhIHx8XG4gICAgICAgIHZpZXcuc3RhdGUgJiAxNiAvKiBJc1Byb2plY3RlZFZpZXcgKi8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOb3RlOiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2VcbiAgICAvLyAtIGFkZCBhIHZpZXcgdG8gdGVtcGxhdGUuX3Byb2plY3RlZFZpZXdzIG9ubHkgMXggdGhyb3VnaG91dCBpdHMgbGlmZXRpbWUsXG4gICAgLy8gICBhbmQgcmVtb3ZlIGl0IG5vdCB1bnRpbCB0aGUgdmlldyBpcyBkZXN0cm95ZWQuXG4gICAgLy8gICAoaGFyZCwgYXMgd2hlbiBhIHBhcmVudCB2aWV3IGlzIGF0dGFjaGVkL2RldGFjaGVkIHdlIHdvdWxkIG5lZWQgdG8gYXR0YWNoL2RldGFjaCBhbGxcbiAgICAvLyAgICBuZXN0ZWQgcHJvamVjdGVkIHZpZXdzIGFzIHdlbGwsIGV2ZW4gYWNyb3NzIGNvbXBvbmVudCBib3VuZGFyaWVzKS5cbiAgICAvLyAtIGRvbid0IHRyYWNrIHRoZSBpbnNlcnRpb24gb3JkZXIgb2Ygdmlld3MgaW4gdGhlIHByb2plY3RlZCB2aWV3cyBhcnJheVxuICAgIC8vICAgKGhhcmQsIGFzIHdoZW4gdGhlIHZpZXdzIG9mIHRoZSBzYW1lIHRlbXBsYXRlIGFyZSBpbnNlcnRlZCBkaWZmZXJlbnQgdmlldyBjb250YWluZXJzKVxuICAgIHZpZXcuc3RhdGUgfD0gMTYgLyogSXNQcm9qZWN0ZWRWaWV3ICovO1xuICAgIHZhciBwcm9qZWN0ZWRWaWV3cyA9IGR2Y0VsZW1lbnREYXRhLnRlbXBsYXRlLl9wcm9qZWN0ZWRWaWV3cztcbiAgICBpZiAoIXByb2plY3RlZFZpZXdzKSB7XG4gICAgICAgIHByb2plY3RlZFZpZXdzID0gZHZjRWxlbWVudERhdGEudGVtcGxhdGUuX3Byb2plY3RlZFZpZXdzID0gW107XG4gICAgfVxuICAgIHByb2plY3RlZFZpZXdzLnB1c2godmlldyk7XG4gICAgLy8gTm90ZTogd2UgYXJlIGNoYW5naW5nIHRoZSBOb2RlRGVmIGhlcmUgYXMgd2UgY2Fubm90IGNhbGN1bGF0ZVxuICAgIC8vIHRoZSBmYWN0IHdoZXRoZXIgYSB0ZW1wbGF0ZSBpcyB1c2VkIGZvciBwcm9qZWN0aW9uIGR1cmluZyBjb21waWxhdGlvbi5cbiAgICBtYXJrTm9kZUFzUHJvamVjdGVkVGVtcGxhdGUodmlldy5wYXJlbnQuZGVmLCB2aWV3LnBhcmVudE5vZGVEZWYpO1xufVxuZnVuY3Rpb24gbWFya05vZGVBc1Byb2plY3RlZFRlbXBsYXRlKHZpZXdEZWYsIG5vZGVEZWYpIHtcbiAgICBpZiAobm9kZURlZi5mbGFncyAmIDQgLyogUHJvamVjdGVkVGVtcGxhdGUgKi8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3RGVmLm5vZGVGbGFncyB8PSA0IC8qIFByb2plY3RlZFRlbXBsYXRlICovO1xuICAgIG5vZGVEZWYuZmxhZ3MgfD0gNCAvKiBQcm9qZWN0ZWRUZW1wbGF0ZSAqLztcbiAgICB2YXIgcGFyZW50Tm9kZURlZiA9IG5vZGVEZWYucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnROb2RlRGVmKSB7XG4gICAgICAgIHBhcmVudE5vZGVEZWYuY2hpbGRGbGFncyB8PSA0IC8qIFByb2plY3RlZFRlbXBsYXRlICovO1xuICAgICAgICBwYXJlbnROb2RlRGVmID0gcGFyZW50Tm9kZURlZi5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoRW1iZWRkZWRWaWV3KGVsZW1lbnREYXRhLCB2aWV3SW5kZXgpIHtcbiAgICB2YXIgZW1iZWRkZWRWaWV3cyA9IGVsZW1lbnREYXRhLnZpZXdDb250YWluZXIuX2VtYmVkZGVkVmlld3M7XG4gICAgaWYgKHZpZXdJbmRleCA9PSBudWxsIHx8IHZpZXdJbmRleCA+PSBlbWJlZGRlZFZpZXdzLmxlbmd0aCkge1xuICAgICAgICB2aWV3SW5kZXggPSBlbWJlZGRlZFZpZXdzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGlmICh2aWV3SW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmlldyA9IGVtYmVkZGVkVmlld3Nbdmlld0luZGV4XTtcbiAgICB2aWV3LnZpZXdDb250YWluZXJQYXJlbnQgPSBudWxsO1xuICAgIHJlbW92ZUZyb21BcnJheShlbWJlZGRlZFZpZXdzLCB2aWV3SW5kZXgpO1xuICAgIC8vIFNlZSBhdHRhY2hQcm9qZWN0ZWRWaWV3IGZvciB3aHkgd2UgZG9uJ3QgdXBkYXRlIHByb2plY3RlZFZpZXdzIGhlcmUuXG4gICAgU2VydmljZXMuZGlydHlQYXJlbnRRdWVyaWVzKHZpZXcpO1xuICAgIHJlbmRlckRldGFjaFZpZXcodmlldyk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5mdW5jdGlvbiBkZXRhY2hQcm9qZWN0ZWRWaWV3KHZpZXcpIHtcbiAgICBpZiAoISh2aWV3LnN0YXRlICYgMTYgLyogSXNQcm9qZWN0ZWRWaWV3ICovKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkdmNFbGVtZW50RGF0YSA9IGRlY2xhcmVkVmlld0NvbnRhaW5lcih2aWV3KTtcbiAgICBpZiAoZHZjRWxlbWVudERhdGEpIHtcbiAgICAgICAgdmFyIHByb2plY3RlZFZpZXdzID0gZHZjRWxlbWVudERhdGEudGVtcGxhdGUuX3Byb2plY3RlZFZpZXdzO1xuICAgICAgICBpZiAocHJvamVjdGVkVmlld3MpIHtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheShwcm9qZWN0ZWRWaWV3cywgcHJvamVjdGVkVmlld3MuaW5kZXhPZih2aWV3KSk7XG4gICAgICAgICAgICBTZXJ2aWNlcy5kaXJ0eVBhcmVudFF1ZXJpZXModmlldyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtb3ZlRW1iZWRkZWRWaWV3KGVsZW1lbnREYXRhLCBvbGRWaWV3SW5kZXgsIG5ld1ZpZXdJbmRleCkge1xuICAgIHZhciBlbWJlZGRlZFZpZXdzID0gZWxlbWVudERhdGEudmlld0NvbnRhaW5lci5fZW1iZWRkZWRWaWV3cztcbiAgICB2YXIgdmlldyA9IGVtYmVkZGVkVmlld3Nbb2xkVmlld0luZGV4XTtcbiAgICByZW1vdmVGcm9tQXJyYXkoZW1iZWRkZWRWaWV3cywgb2xkVmlld0luZGV4KTtcbiAgICBpZiAobmV3Vmlld0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgbmV3Vmlld0luZGV4ID0gZW1iZWRkZWRWaWV3cy5sZW5ndGg7XG4gICAgfVxuICAgIGFkZFRvQXJyYXkoZW1iZWRkZWRWaWV3cywgbmV3Vmlld0luZGV4LCB2aWV3KTtcbiAgICAvLyBOb3RlOiBEb24ndCBuZWVkIHRvIGNoYW5nZSBwcm9qZWN0ZWRWaWV3cyBhcyB0aGUgb3JkZXIgaW4gdGhlcmVcbiAgICAvLyBhcyBhbHdheXMgaW52YWxpZC4uLlxuICAgIFNlcnZpY2VzLmRpcnR5UGFyZW50UXVlcmllcyh2aWV3KTtcbiAgICByZW5kZXJEZXRhY2hWaWV3KHZpZXcpO1xuICAgIHZhciBwcmV2VmlldyA9IG5ld1ZpZXdJbmRleCA+IDAgPyBlbWJlZGRlZFZpZXdzW25ld1ZpZXdJbmRleCAtIDFdIDogbnVsbDtcbiAgICByZW5kZXJBdHRhY2hFbWJlZGRlZFZpZXcoZWxlbWVudERhdGEsIHByZXZWaWV3LCB2aWV3KTtcbiAgICByZXR1cm4gdmlldztcbn1cbmZ1bmN0aW9uIHJlbmRlckF0dGFjaEVtYmVkZGVkVmlldyhlbGVtZW50RGF0YSwgcHJldlZpZXcsIHZpZXcpIHtcbiAgICB2YXIgcHJldlJlbmRlck5vZGUgPSBwcmV2VmlldyA/IHJlbmRlck5vZGUocHJldlZpZXcsIHByZXZWaWV3LmRlZi5sYXN0UmVuZGVyUm9vdE5vZGUpIDpcbiAgICAgICAgZWxlbWVudERhdGEucmVuZGVyRWxlbWVudDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZpZXcucmVuZGVyZXIucGFyZW50Tm9kZShwcmV2UmVuZGVyTm9kZSk7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gdmlldy5yZW5kZXJlci5uZXh0U2libGluZyhwcmV2UmVuZGVyTm9kZSk7XG4gICAgLy8gTm90ZTogV2UgY2FuJ3QgY2hlY2sgaWYgYG5leHRTaWJsaW5nYCBpcyBwcmVzZW50LCBhcyBvbiBXZWJXb3JrZXJzIGl0IHdpbGwgYWx3YXlzIGJlIVxuICAgIC8vIEhvd2V2ZXIsIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgZG8gYGFwcGVuZENoaWxkYCB3aGVuIHRoZXJlIGlzIG5vIGBuZXh0U2libGluZ2AuXG4gICAgdmlzaXRSb290UmVuZGVyTm9kZXModmlldywgMiAvKiBJbnNlcnRCZWZvcmUgKi8sIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGV0YWNoVmlldyh2aWV3KSB7XG4gICAgdmlzaXRSb290UmVuZGVyTm9kZXModmlldywgMyAvKiBSZW1vdmVDaGlsZCAqLywgbnVsbCwgbnVsbCwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGFkZFRvQXJyYXkoYXJyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAvLyBwZXJmOiBhcnJheS5wdXNoIGlzIGZhc3RlciB0aGFuIGFycmF5LnNwbGljZSFcbiAgICBpZiAoaW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgaW5kZXgpIHtcbiAgICAvLyBwZXJmOiBhcnJheS5wb3AgaXMgZmFzdGVyIHRoYW4gYXJyYXkuc3BsaWNlIVxuICAgIGlmIChpbmRleCA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICBhcnIucG9wKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFTVBUWV9DT05URVhUID0gbmV3IE9iamVjdCgpO1xuLy8gQXR0ZW50aW9uOiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhcyB0b3AgbGV2ZWwgZnVuY3Rpb24uXG4vLyBQdXR0aW5nIGFueSBsb2dpYyBpbiBoZXJlIHdpbGwgZGVzdHJveSBjbG9zdXJlIHRyZWUgc2hha2luZyFcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIGNvbXBvbmVudFR5cGUsIHZpZXdEZWZGYWN0b3J5LCBpbnB1dHMsIG91dHB1dHMsIG5nQ29udGVudFNlbGVjdG9ycykge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50RmFjdG9yeV8oc2VsZWN0b3IsIGNvbXBvbmVudFR5cGUsIHZpZXdEZWZGYWN0b3J5LCBpbnB1dHMsIG91dHB1dHMsIG5nQ29udGVudFNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRWaWV3RGVmaW5pdGlvbkZhY3RvcnkoY29tcG9uZW50RmFjdG9yeSkge1xuICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5LnZpZXdEZWZGYWN0b3J5O1xufVxudmFyIENvbXBvbmVudEZhY3RvcnlfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRGYWN0b3J5XywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5XyhzZWxlY3RvciwgY29tcG9uZW50VHlwZSwgdmlld0RlZkZhY3RvcnksIF9pbnB1dHMsIF9vdXRwdXRzLCBuZ0NvbnRlbnRTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIEF0dGVudGlvbjogdGhpcyBjdG9yIGlzIGNhbGxlZCBhcyB0b3AgbGV2ZWwgZnVuY3Rpb24uXG4gICAgICAgIC8vIFB1dHRpbmcgYW55IGxvZ2ljIGluIGhlcmUgd2lsbCBkZXN0cm95IGNsb3N1cmUgdHJlZSBzaGFraW5nIVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICBfdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgX3RoaXMuX2lucHV0cyA9IF9pbnB1dHM7XG4gICAgICAgIF90aGlzLl9vdXRwdXRzID0gX291dHB1dHM7XG4gICAgICAgIF90aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IG5nQ29udGVudFNlbGVjdG9ycztcbiAgICAgICAgX3RoaXMudmlld0RlZkZhY3RvcnkgPSB2aWV3RGVmRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50RmFjdG9yeV8ucHJvdG90eXBlLCBcImlucHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0c0FyciA9IFtdO1xuICAgICAgICAgICAgdmFyIGlucHV0cyA9IHRoaXMuX2lucHV0cztcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGlucHV0cykge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSBpbnB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlucHV0c0Fyci5wdXNoKHsgcHJvcE5hbWU6IHByb3BOYW1lLCB0ZW1wbGF0ZU5hbWU6IHRlbXBsYXRlTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dHNBcnI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRGYWN0b3J5Xy5wcm90b3R5cGUsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dHNBcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHRoaXMuX291dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVOYW1lID0gdGhpcy5fb3V0cHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgb3V0cHV0c0Fyci5wdXNoKHsgcHJvcE5hbWU6IHByb3BOYW1lLCB0ZW1wbGF0ZU5hbWU6IHRlbXBsYXRlTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzQXJyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBDb21wb25lbnRGYWN0b3J5Xy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUsIG5nTW9kdWxlKSB7XG4gICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmdNb2R1bGUgc2hvdWxkIGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdEZWYgPSByZXNvbHZlRGVmaW5pdGlvbih0aGlzLnZpZXdEZWZGYWN0b3J5KTtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5vZGVJbmRleCA9IHZpZXdEZWYubm9kZXNbMF0uZWxlbWVudC5jb21wb25lbnRQcm92aWRlci5ub2RlSW5kZXg7XG4gICAgICAgIHZhciB2aWV3ID0gU2VydmljZXMuY3JlYXRlUm9vdFZpZXcoaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMgfHwgW10sIHJvb3RTZWxlY3Rvck9yTm9kZSwgdmlld0RlZiwgbmdNb2R1bGUsIEVNUFRZX0NPTlRFWFQpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gYXNQcm92aWRlckRhdGEodmlldywgY29tcG9uZW50Tm9kZUluZGV4KS5pbnN0YW5jZTtcbiAgICAgICAgaWYgKHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICAgICAgdmlldy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoYXNFbGVtZW50RGF0YSh2aWV3LCAwKS5yZW5kZXJFbGVtZW50LCAnbmctdmVyc2lvbicsIFZFUlNJT04uZnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRSZWZfKHZpZXcsIG5ldyBWaWV3UmVmXyh2aWV3KSwgY29tcG9uZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5Xztcbn0oQ29tcG9uZW50RmFjdG9yeSkpO1xudmFyIENvbXBvbmVudFJlZl8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBvbmVudFJlZl8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmXyhfdmlldywgX3ZpZXdSZWYsIF9jb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgX3RoaXMuX3ZpZXdSZWYgPSBfdmlld1JlZjtcbiAgICAgICAgX3RoaXMuX2NvbXBvbmVudCA9IF9jb21wb25lbnQ7XG4gICAgICAgIF90aGlzLl9lbERlZiA9IF90aGlzLl92aWV3LmRlZi5ub2Rlc1swXTtcbiAgICAgICAgX3RoaXMuaG9zdFZpZXcgPSBfdmlld1JlZjtcbiAgICAgICAgX3RoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBfdmlld1JlZjtcbiAgICAgICAgX3RoaXMuaW5zdGFuY2UgPSBfY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50UmVmKGFzRWxlbWVudERhdGEodGhpcy5fdmlldywgdGhpcy5fZWxEZWYubm9kZUluZGV4KS5yZW5kZXJFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSW5qZWN0b3JfKHRoaXMuX3ZpZXcsIHRoaXMuX2VsRGVmKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudC5jb25zdHJ1Y3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcG9uZW50UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlld1JlZi5kZXN0cm95KCk7IH07XG4gICAgQ29tcG9uZW50UmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX3ZpZXdSZWYub25EZXN0cm95KGNhbGxiYWNrKTsgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50UmVmXztcbn0oQ29tcG9uZW50UmVmKSk7XG5mdW5jdGlvbiBjcmVhdGVWaWV3Q29udGFpbmVyRGF0YSh2aWV3LCBlbERlZiwgZWxEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3Q29udGFpbmVyUmVmXyh2aWV3LCBlbERlZiwgZWxEYXRhKTtcbn1cbnZhciBWaWV3Q29udGFpbmVyUmVmXyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29udGFpbmVyUmVmXyhfdmlldywgX2VsRGVmLCBfZGF0YSkge1xuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgIHRoaXMuX2VsRGVmID0gX2VsRGVmO1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MgPSBbXTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJlbGVtZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLl9kYXRhLnJlbmRlckVsZW1lbnQpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSW5qZWN0b3JfKHRoaXMuX3ZpZXcsIHRoaXMuX2VsRGVmKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBObyByZXBsYWNlbWVudCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlldztcbiAgICAgICAgICAgIHZhciBlbERlZiA9IHRoaXMuX2VsRGVmLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghZWxEZWYgJiYgdmlldykge1xuICAgICAgICAgICAgICAgIGVsRGVmID0gdmlld1BhcmVudEVsKHZpZXcpO1xuICAgICAgICAgICAgICAgIHZpZXcgPSB2aWV3LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2aWV3ID8gbmV3IEluamVjdG9yXyh2aWV3LCBlbERlZikgOiBuZXcgSW5qZWN0b3JfKHRoaXMuX3ZpZXcsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9lbWJlZGRlZFZpZXdzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IGRldGFjaEVtYmVkZGVkVmlldyh0aGlzLl9kYXRhLCBpKTtcbiAgICAgICAgICAgIFNlcnZpY2VzLmRlc3Ryb3lWaWV3KHZpZXcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3c1tpbmRleF07XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gbmV3IFZpZXdSZWZfKHZpZXcpO1xuICAgICAgICAgICAgcmVmLmF0dGFjaFRvVmlld0NvbnRhaW5lclJlZih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW1iZWRkZWRWaWV3cy5sZW5ndGg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAodGVtcGxhdGVSZWYsIGNvbnRleHQsIGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQgfHwge30pO1xuICAgICAgICB0aGlzLmluc2VydCh2aWV3UmVmLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB2aWV3UmVmO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5LCBpbmRleCwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIG5nTW9kdWxlUmVmKSB7XG4gICAgICAgIHZhciBjb250ZXh0SW5qZWN0b3IgPSBpbmplY3RvciB8fCB0aGlzLnBhcmVudEluamVjdG9yO1xuICAgICAgICBpZiAoIW5nTW9kdWxlUmVmICYmICEoY29tcG9uZW50RmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnlCb3VuZFRvTW9kdWxlKSkge1xuICAgICAgICAgICAgbmdNb2R1bGVSZWYgPSBjb250ZXh0SW5qZWN0b3IuZ2V0KE5nTW9kdWxlUmVmKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzLCB1bmRlZmluZWQsIG5nTW9kdWxlUmVmKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoY29tcG9uZW50UmVmLmhvc3RWaWV3LCBpbmRleCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZpZXdSZWYsIGluZGV4KSB7XG4gICAgICAgIGlmICh2aWV3UmVmLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW5zZXJ0IGEgZGVzdHJveWVkIFZpZXcgaW4gYSBWaWV3Q29udGFpbmVyIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3UmVmXyA9IHZpZXdSZWY7XG4gICAgICAgIHZhciB2aWV3RGF0YSA9IHZpZXdSZWZfLl92aWV3O1xuICAgICAgICBhdHRhY2hFbWJlZGRlZFZpZXcodGhpcy5fdmlldywgdGhpcy5fZGF0YSwgaW5kZXgsIHZpZXdEYXRhKTtcbiAgICAgICAgdmlld1JlZl8uYXR0YWNoVG9WaWV3Q29udGFpbmVyUmVmKHRoaXMpO1xuICAgICAgICByZXR1cm4gdmlld1JlZjtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICBpZiAodmlld1JlZi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgYSBkZXN0cm95ZWQgVmlldyBpbiBhIFZpZXdDb250YWluZXIhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSB0aGlzLl9lbWJlZGRlZFZpZXdzLmluZGV4T2Yodmlld1JlZi5fdmlldyk7XG4gICAgICAgIG1vdmVFbWJlZGRlZFZpZXcodGhpcy5fZGF0YSwgcHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWJlZGRlZFZpZXdzLmluZGV4T2Yodmlld1JlZi5fdmlldyk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3RGF0YSA9IGRldGFjaEVtYmVkZGVkVmlldyh0aGlzLl9kYXRhLCBpbmRleCk7XG4gICAgICAgIGlmICh2aWV3RGF0YSkge1xuICAgICAgICAgICAgU2VydmljZXMuZGVzdHJveVZpZXcodmlld0RhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3ID0gZGV0YWNoRW1iZWRkZWRWaWV3KHRoaXMuX2RhdGEsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZpZXcgPyBuZXcgVmlld1JlZl8odmlldykgOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWZfO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUNoYW5nZURldGVjdG9yUmVmKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IFZpZXdSZWZfKHZpZXcpO1xufVxudmFyIFZpZXdSZWZfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdSZWZfKF92aWV3KSB7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb290UmVuZGVyTm9kZXModGhpcy5fdmlldyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX3ZpZXcuc3RhdGUgJiAxMjggLyogRGVzdHJveWVkICovKSAhPT0gMDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLm1hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHsgbWFya1BhcmVudFZpZXdzRm9yQ2hlY2sodGhpcy5fdmlldyk7IH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5zdGF0ZSAmPSB+NCAvKiBBdHRhY2hlZCAqLzsgfTtcbiAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZzID0gdGhpcy5fdmlldy5yb290LnJlbmRlcmVyRmFjdG9yeTtcbiAgICAgICAgaWYgKGZzLmJlZ2luKSB7XG4gICAgICAgICAgICBmcy5iZWdpbigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBTZXJ2aWNlcy5jaGVja0FuZFVwZGF0ZVZpZXcodGhpcy5fdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgZnMuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5jaGVja05vQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgU2VydmljZXMuY2hlY2tOb0NoYW5nZXNWaWV3KHRoaXMuX3ZpZXcpOyB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5zdGF0ZSB8PSA0IC8qIEF0dGFjaGVkICovOyB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3LmRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3LmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlldy5kaXNwb3NhYmxlcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYXBwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBSZWYuZGV0YWNoVmlldyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl92aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmRldGFjaCh0aGlzLl92aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIFNlcnZpY2VzLmRlc3Ryb3lWaWV3KHRoaXMuX3ZpZXcpO1xuICAgIH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGFjaEZyb21BcHBSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IG51bGw7XG4gICAgICAgIHJlbmRlckRldGFjaFZpZXcodGhpcy5fdmlldyk7XG4gICAgICAgIFNlcnZpY2VzLmRpcnR5UGFyZW50UXVlcmllcyh0aGlzLl92aWV3KTtcbiAgICB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5hdHRhY2hUb0FwcFJlZiA9IGZ1bmN0aW9uIChhcHBSZWYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB2aWV3IGlzIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBWaWV3Q29udGFpbmVyIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IGFwcFJlZjtcbiAgICB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5hdHRhY2hUb1ZpZXdDb250YWluZXJSZWYgPSBmdW5jdGlvbiAodmNSZWYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FwcFJlZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHZpZXcgaXMgYWxyZWFkeSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgQXBwbGljYXRpb25SZWYhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IHZjUmVmO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdSZWZfO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlRGF0YSh2aWV3LCBkZWYpIHtcbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUmVmXyh2aWV3LCBkZWYpO1xufVxudmFyIFRlbXBsYXRlUmVmXyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVSZWZfLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmXyhfcGFyZW50VmlldywgX2RlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcGFyZW50VmlldyA9IF9wYXJlbnRWaWV3O1xuICAgICAgICBfdGhpcy5fZGVmID0gX2RlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZW1wbGF0ZVJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1JlZl8oU2VydmljZXMuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3BhcmVudFZpZXcsIHRoaXMuX2RlZiwgdGhpcy5fZGVmLmVsZW1lbnQudGVtcGxhdGUsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVJlZl8ucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFJlZihhc0VsZW1lbnREYXRhKHRoaXMuX3BhcmVudFZpZXcsIHRoaXMuX2RlZi5ub2RlSW5kZXgpLnJlbmRlckVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGVtcGxhdGVSZWZfO1xufShUZW1wbGF0ZVJlZikpO1xuZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3IkMSh2aWV3LCBlbERlZikge1xuICAgIHJldHVybiBuZXcgSW5qZWN0b3JfKHZpZXcsIGVsRGVmKTtcbn1cbnZhciBJbmplY3Rvcl8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0b3JfKHZpZXcsIGVsRGVmKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZWxEZWYgPSBlbERlZjtcbiAgICB9XG4gICAgSW5qZWN0b3JfLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgIHZhciBhbGxvd1ByaXZhdGVTZXJ2aWNlcyA9IHRoaXMuZWxEZWYgPyAodGhpcy5lbERlZi5mbGFncyAmIDMzNTU0NDMyIC8qIENvbXBvbmVudFZpZXcgKi8pICE9PSAwIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBTZXJ2aWNlcy5yZXNvbHZlRGVwKHRoaXMudmlldywgdGhpcy5lbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIHsgZmxhZ3M6IDAgLyogTm9uZSAqLywgdG9rZW46IHRva2VuLCB0b2tlbktleTogdG9rZW5LZXkodG9rZW4pIH0sIG5vdEZvdW5kVmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEluamVjdG9yXztcbn0oKSk7XG5mdW5jdGlvbiBub2RlVmFsdWUodmlldywgaW5kZXgpIHtcbiAgICB2YXIgZGVmID0gdmlldy5kZWYubm9kZXNbaW5kZXhdO1xuICAgIGlmIChkZWYuZmxhZ3MgJiAxIC8qIFR5cGVFbGVtZW50ICovKSB7XG4gICAgICAgIHZhciBlbERhdGEgPSBhc0VsZW1lbnREYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpO1xuICAgICAgICByZXR1cm4gZGVmLmVsZW1lbnQudGVtcGxhdGUgPyBlbERhdGEudGVtcGxhdGUgOiBlbERhdGEucmVuZGVyRWxlbWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmZsYWdzICYgMiAvKiBUeXBlVGV4dCAqLykge1xuICAgICAgICByZXR1cm4gYXNUZXh0RGF0YSh2aWV3LCBkZWYubm9kZUluZGV4KS5yZW5kZXJUZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYuZmxhZ3MgJiAoMjAyMjQgLyogQ2F0UHJvdmlkZXIgKi8gfCAxNiAvKiBUeXBlUGlwZSAqLykpIHtcbiAgICAgICAgcmV0dXJuIGFzUHJvdmlkZXJEYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpLmluc3RhbmNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiByZWFkIG5vZGVWYWx1ZSBmb3Igbm9kZSBpbmRleCBcIiArIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyVjEodmlldykge1xuICAgIHJldHVybiBuZXcgUmVuZGVyZXJBZGFwdGVyKHZpZXcucmVuZGVyZXIpO1xufVxudmFyIFJlbmRlcmVyQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlckFkYXB0ZXIoZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIH1cbiAgICBSZW5kZXJlckFkYXB0ZXIucHJvdG90eXBlLnNlbGVjdFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWVzcGFjZUFuZE5hbWUpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHNwbGl0TmFtZXNwYWNlKG5hbWVzcGFjZUFuZE5hbWUpLCAyKSwgbnMgPSBfYVswXSwgbmFtZSA9IF9hWzFdO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZUVsZW1lbnQobmFtZSwgbnMpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZENoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgcmV0dXJuIGhvc3RFbGVtZW50OyB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCkge1xuICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuZGVsZWdhdGUuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZENoaWxkKHBhcmVudEVsZW1lbnQsIGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVUZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kQ2hpbGQocGFyZW50RWxlbWVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBSZW5kZXJlckFkYXB0ZXIucHJvdG90eXBlLnByb2plY3ROb2RlcyA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBub2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmFwcGVuZENoaWxkKHBhcmVudEVsZW1lbnQsIG5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2Rlcykge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IHRoaXMuZGVsZWdhdGUucGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGhpcy5kZWxlZ2F0ZS5uZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Um9vdE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmluc2VydEJlZm9yZShwYXJlbnRFbGVtZW50LCB2aWV3Um9vdE5vZGVzW2ldLCBuZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuZGV0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld1Jvb3ROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB2aWV3Um9vdE5vZGVzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0aGlzLmRlbGVnYXRlLnBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZUNoaWxkKHBhcmVudEVsZW1lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlckFkYXB0ZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3QWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZGVzdHJveU5vZGUodmlld0FsbE5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHJlbmRlckVsZW1lbnQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUubGlzdGVuR2xvYmFsID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5zZXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0UHJvcGVydHkocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lc3BhY2VBbmROYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc3BsaXROYW1lc3BhY2UobmFtZXNwYWNlQW5kTmFtZSksIDIpLCBucyA9IF9hWzBdLCBuYW1lID0gX2FbMV07XG4gICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNldEF0dHJpYnV0ZShyZW5kZXJFbGVtZW50LCBuYW1lLCBhdHRyaWJ1dGVWYWx1ZSwgbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgbmFtZSwgbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlckFkYXB0ZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7IH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICBpZiAoaXNBZGQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuYWRkQ2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlQ2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0U3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlU3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5pbnZva2VFbGVtZW50TWV0aG9kID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmVuZGVyRWxlbWVudFttZXRob2ROYW1lXS5hcHBseShyZW5kZXJFbGVtZW50LCBhcmdzKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyQWRhcHRlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlJCQxLCB0ZXh0KSB7IHRoaXMuZGVsZWdhdGUuc2V0VmFsdWUocmVuZGVyTm9kZSQkMSwgdGV4dCk7IH07XG4gICAgUmVuZGVyZXJBZGFwdGVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyLmFuaW1hdGUgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCEnKTsgfTtcbiAgICByZXR1cm4gUmVuZGVyZXJBZGFwdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZU5nTW9kdWxlUmVmKG1vZHVsZVR5cGUsIHBhcmVudCwgYm9vdHN0cmFwQ29tcG9uZW50cywgZGVmKSB7XG4gICAgcmV0dXJuIG5ldyBOZ01vZHVsZVJlZl8obW9kdWxlVHlwZSwgcGFyZW50LCBib290c3RyYXBDb21wb25lbnRzLCBkZWYpO1xufVxudmFyIE5nTW9kdWxlUmVmXyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZl8oX21vZHVsZVR5cGUsIF9wYXJlbnQsIF9ib290c3RyYXBDb21wb25lbnRzLCBfZGVmKSB7XG4gICAgICAgIHRoaXMuX21vZHVsZVR5cGUgPSBfbW9kdWxlVHlwZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ib290c3RyYXBDb21wb25lbnRzO1xuICAgICAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gdGhpcztcbiAgICAgICAgaW5pdE5nTW9kdWxlKHRoaXMpO1xuICAgIH1cbiAgICBOZ01vZHVsZVJlZl8ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSwgaW5qZWN0RmxhZ3MpIHtcbiAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgIGlmIChpbmplY3RGbGFncyA9PT0gdm9pZCAwKSB7IGluamVjdEZsYWdzID0gMCAvKiBEZWZhdWx0ICovOyB9XG4gICAgICAgIHZhciBmbGFncyA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgaWYgKGluamVjdEZsYWdzICYgNCAvKiBTa2lwU2VsZiAqLykge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMSAvKiBTa2lwU2VsZiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmplY3RGbGFncyAmIDIgLyogU2VsZiAqLykge1xuICAgICAgICAgICAgZmxhZ3MgfD0gNCAvKiBTZWxmICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlTmdNb2R1bGVEZXAodGhpcywgeyB0b2tlbjogdG9rZW4sIHRva2VuS2V5OiB0b2tlbktleSh0b2tlbiksIGZsYWdzOiBmbGFncyB9LCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZl8ucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdldCh0aGlzLl9tb2R1bGVUeXBlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kdWxlUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdldChDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ01vZHVsZVJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBuZyBtb2R1bGUgXCIgKyBzdHJpbmdpZnkodGhpcy5pbnN0YW5jZS5jb25zdHJ1Y3RvcikgKyBcIiBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbE5nTW9kdWxlTGlmZWN5Y2xlKHRoaXMsIDEzMTA3MiAvKiBPbkRlc3Ryb3kgKi8pO1xuICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcigpOyB9KTtcbiAgICB9O1xuICAgIE5nTW9kdWxlUmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgcmV0dXJuIE5nTW9kdWxlUmVmXztcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSZW5kZXJlclYxVG9rZW5LZXkgPSB0b2tlbktleShSZW5kZXJlcik7XG52YXIgUmVuZGVyZXIyVG9rZW5LZXkgPSB0b2tlbktleShSZW5kZXJlcjIpO1xudmFyIEVsZW1lbnRSZWZUb2tlbktleSA9IHRva2VuS2V5KEVsZW1lbnRSZWYpO1xudmFyIFZpZXdDb250YWluZXJSZWZUb2tlbktleSA9IHRva2VuS2V5KFZpZXdDb250YWluZXJSZWYpO1xudmFyIFRlbXBsYXRlUmVmVG9rZW5LZXkgPSB0b2tlbktleShUZW1wbGF0ZVJlZik7XG52YXIgQ2hhbmdlRGV0ZWN0b3JSZWZUb2tlbktleSA9IHRva2VuS2V5KENoYW5nZURldGVjdG9yUmVmKTtcbnZhciBJbmplY3RvclJlZlRva2VuS2V5JDEgPSB0b2tlbktleShJbmplY3Rvcik7XG52YXIgSU5KRUNUT1JSZWZUb2tlbktleSQxID0gdG9rZW5LZXkoSU5KRUNUT1IpO1xuZnVuY3Rpb24gZGlyZWN0aXZlRGVmKGNoZWNrSW5kZXgsIGZsYWdzLCBtYXRjaGVkUXVlcmllcywgY2hpbGRDb3VudCwgY3RvciwgZGVwcywgcHJvcHMsIG91dHB1dHMpIHtcbiAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHByb3BzW3Byb3BdLCAyKSwgYmluZGluZ0luZGV4ID0gX2FbMF0sIG5vbk1pbmlmaWVkTmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgYmluZGluZ3NbYmluZGluZ0luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBmbGFnczogOCAvKiBUeXBlUHJvcGVydHkgKi8sXG4gICAgICAgICAgICAgICAgbmFtZTogcHJvcCwgbm9uTWluaWZpZWROYW1lOiBub25NaW5pZmllZE5hbWUsXG4gICAgICAgICAgICAgICAgbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgb3V0cHV0RGVmcyA9IFtdO1xuICAgIGlmIChvdXRwdXRzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIG91dHB1dHMpIHtcbiAgICAgICAgICAgIG91dHB1dERlZnMucHVzaCh7IHR5cGU6IDEgLyogRGlyZWN0aXZlT3V0cHV0ICovLCBwcm9wTmFtZTogcHJvcE5hbWUsIHRhcmdldDogbnVsbCwgZXZlbnROYW1lOiBvdXRwdXRzW3Byb3BOYW1lXSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbGFncyB8PSAxNjM4NCAvKiBUeXBlRGlyZWN0aXZlICovO1xuICAgIHJldHVybiBfZGVmKGNoZWNrSW5kZXgsIGZsYWdzLCBtYXRjaGVkUXVlcmllcywgY2hpbGRDb3VudCwgY3RvciwgY3RvciwgZGVwcywgYmluZGluZ3MsIG91dHB1dERlZnMpO1xufVxuZnVuY3Rpb24gcGlwZURlZihmbGFncywgY3RvciwgZGVwcykge1xuICAgIGZsYWdzIHw9IDE2IC8qIFR5cGVQaXBlICovO1xuICAgIHJldHVybiBfZGVmKC0xLCBmbGFncywgbnVsbCwgMCwgY3RvciwgY3RvciwgZGVwcyk7XG59XG5mdW5jdGlvbiBwcm92aWRlckRlZihmbGFncywgbWF0Y2hlZFF1ZXJpZXMsIHRva2VuLCB2YWx1ZSwgZGVwcykge1xuICAgIHJldHVybiBfZGVmKC0xLCBmbGFncywgbWF0Y2hlZFF1ZXJpZXMsIDAsIHRva2VuLCB2YWx1ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiBfZGVmKGNoZWNrSW5kZXgsIGZsYWdzLCBtYXRjaGVkUXVlcmllc0RzbCwgY2hpbGRDb3VudCwgdG9rZW4sIHZhbHVlLCBkZXBzLCBiaW5kaW5ncywgb3V0cHV0cykge1xuICAgIHZhciBfYSA9IHNwbGl0TWF0Y2hlZFF1ZXJpZXNEc2wobWF0Y2hlZFF1ZXJpZXNEc2wpLCBtYXRjaGVkUXVlcmllcyA9IF9hLm1hdGNoZWRRdWVyaWVzLCByZWZlcmVuY2VzID0gX2EucmVmZXJlbmNlcywgbWF0Y2hlZFF1ZXJ5SWRzID0gX2EubWF0Y2hlZFF1ZXJ5SWRzO1xuICAgIGlmICghb3V0cHV0cykge1xuICAgICAgICBvdXRwdXRzID0gW107XG4gICAgfVxuICAgIGlmICghYmluZGluZ3MpIHtcbiAgICAgICAgYmluZGluZ3MgPSBbXTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byByZXNvbHZlIGZvcndhcmRSZWZzIGFzIGUuZy4gZm9yIGB1c2VWYWx1ZWAgd2VcbiAgICAvLyBsb3dlcmVkIHRoZSBleHByZXNzaW9uIGFuZCB0aGVuIHN0b3BwZWQgZXZhbHVhdGluZyBpdCxcbiAgICAvLyBpLmUuIGFsc28gZGlkbid0IHVud3JhcCBpdC5cbiAgICB2YWx1ZSA9IHJlc29sdmVGb3J3YXJkUmVmKHZhbHVlKTtcbiAgICB2YXIgZGVwRGVmcyA9IHNwbGl0RGVwc0RzbChkZXBzLCBzdHJpbmdpZnkodG9rZW4pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyB3aWxsIGJldCBzZXQgYnkgdGhlIHZpZXcgZGVmaW5pdGlvblxuICAgICAgICBub2RlSW5kZXg6IC0xLFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIHJlbmRlclBhcmVudDogbnVsbCxcbiAgICAgICAgYmluZGluZ0luZGV4OiAtMSxcbiAgICAgICAgb3V0cHV0SW5kZXg6IC0xLFxuICAgICAgICAvLyByZWd1bGFyIHZhbHVlc1xuICAgICAgICBjaGVja0luZGV4OiBjaGVja0luZGV4LFxuICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgIGNoaWxkRmxhZ3M6IDAsXG4gICAgICAgIGRpcmVjdENoaWxkRmxhZ3M6IDAsXG4gICAgICAgIGNoaWxkTWF0Y2hlZFF1ZXJpZXM6IDAsIG1hdGNoZWRRdWVyaWVzOiBtYXRjaGVkUXVlcmllcywgbWF0Y2hlZFF1ZXJ5SWRzOiBtYXRjaGVkUXVlcnlJZHMsIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgIG5nQ29udGVudEluZGV4OiAtMSwgY2hpbGRDb3VudDogY2hpbGRDb3VudCwgYmluZGluZ3M6IGJpbmRpbmdzLFxuICAgICAgICBiaW5kaW5nRmxhZ3M6IGNhbGNCaW5kaW5nRmxhZ3MoYmluZGluZ3MpLCBvdXRwdXRzOiBvdXRwdXRzLFxuICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICBwcm92aWRlcjogeyB0b2tlbjogdG9rZW4sIHZhbHVlOiB2YWx1ZSwgZGVwczogZGVwRGVmcyB9LFxuICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgbmdDb250ZW50OiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVySW5zdGFuY2UodmlldywgZGVmKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVQcm92aWRlckluc3RhbmNlJDEodmlldywgZGVmKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBpcGVJbnN0YW5jZSh2aWV3LCBkZWYpIHtcbiAgICAvLyBkZXBzIGFyZSBsb29rZWQgdXAgZnJvbSBjb21wb25lbnQuXG4gICAgdmFyIGNvbXBWaWV3ID0gdmlldztcbiAgICB3aGlsZSAoY29tcFZpZXcucGFyZW50ICYmICFpc0NvbXBvbmVudFZpZXcoY29tcFZpZXcpKSB7XG4gICAgICAgIGNvbXBWaWV3ID0gY29tcFZpZXcucGFyZW50O1xuICAgIH1cbiAgICAvLyBwaXBlcyBjYW4gc2VlIHRoZSBwcml2YXRlIHNlcnZpY2VzIG9mIHRoZSBjb21wb25lbnRcbiAgICB2YXIgYWxsb3dQcml2YXRlU2VydmljZXMgPSB0cnVlO1xuICAgIC8vIHBpcGVzIGFyZSBhbHdheXMgZWFnZXIgYW5kIGNsYXNzZXMhXG4gICAgcmV0dXJuIGNyZWF0ZUNsYXNzKGNvbXBWaWV3LnBhcmVudCwgdmlld1BhcmVudEVsKGNvbXBWaWV3KSwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlZi5wcm92aWRlci52YWx1ZSwgZGVmLnByb3ZpZGVyLmRlcHMpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGlyZWN0aXZlSW5zdGFuY2UodmlldywgZGVmKSB7XG4gICAgLy8gY29tcG9uZW50cyBjYW4gc2VlIG90aGVyIHByaXZhdGUgc2VydmljZXMsIG90aGVyIGRpcmVjdGl2ZXMgY2FuJ3QuXG4gICAgdmFyIGFsbG93UHJpdmF0ZVNlcnZpY2VzID0gKGRlZi5mbGFncyAmIDMyNzY4IC8qIENvbXBvbmVudCAqLykgPiAwO1xuICAgIC8vIGRpcmVjdGl2ZXMgYXJlIGFsd2F5cyBlYWdlciBhbmQgY2xhc3NlcyFcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVDbGFzcyh2aWV3LCBkZWYucGFyZW50LCBhbGxvd1ByaXZhdGVTZXJ2aWNlcywgZGVmLnByb3ZpZGVyLnZhbHVlLCBkZWYucHJvdmlkZXIuZGVwcyk7XG4gICAgaWYgKGRlZi5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZGVmLm91dHB1dHNbaV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0T2JzZXJ2YWJsZSA9IGluc3RhbmNlW291dHB1dC5wcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKG91dHB1dE9ic2VydmFibGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG91dHB1dE9ic2VydmFibGUuc3Vic2NyaWJlKGV2ZW50SGFuZGxlckNsb3N1cmUodmlldywgZGVmLnBhcmVudC5ub2RlSW5kZXgsIG91dHB1dC5ldmVudE5hbWUpKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3Bvc2FibGVzW2RlZi5vdXRwdXRJbmRleCArIGldID0gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlLmJpbmQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBPdXRwdXQgXCIgKyBvdXRwdXQucHJvcE5hbWUgKyBcIiBub3QgaW5pdGlhbGl6ZWQgaW4gJ1wiICsgaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZSArIFwiJy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyQ2xvc3VyZSh2aWV3LCBpbmRleCwgZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZGlzcGF0Y2hFdmVudCh2aWV3LCBpbmRleCwgZXZlbnROYW1lLCBldmVudCk7IH07XG59XG5mdW5jdGlvbiBjaGVja0FuZFVwZGF0ZURpcmVjdGl2ZUlubGluZSh2aWV3LCBkZWYsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KSB7XG4gICAgdmFyIHByb3ZpZGVyRGF0YSA9IGFzUHJvdmlkZXJEYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpO1xuICAgIHZhciBkaXJlY3RpdmUgPSBwcm92aWRlckRhdGEuaW5zdGFuY2U7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgY2hhbmdlcyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgYmluZExlbiA9IGRlZi5iaW5kaW5ncy5sZW5ndGg7XG4gICAgaWYgKGJpbmRMZW4gPiAwICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDAsIHYwKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDAsIHYwLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiAxICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDEsIHYxKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDEsIHYxLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiAyICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDIsIHYyKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDIsIHYyLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiAzICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDMsIHYzKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDMsIHYzLCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA0ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDQsIHY0KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDQsIHY0LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA1ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDUsIHY1KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDUsIHY1LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA2ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDYsIHY2KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDYsIHY2LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA3ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDcsIHY3KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDcsIHY3LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA4ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDgsIHY4KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDgsIHY4LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGJpbmRMZW4gPiA5ICYmIGNoZWNrQmluZGluZyh2aWV3LCBkZWYsIDksIHY5KSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgY2hhbmdlcyA9IHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIDksIHY5LCBjaGFuZ2VzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgZGlyZWN0aXZlLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH1cbiAgICBpZiAoKGRlZi5mbGFncyAmIDY1NTM2IC8qIE9uSW5pdCAqLykgJiZcbiAgICAgICAgc2hvdWxkQ2FsbExpZmVjeWNsZUluaXRIb29rKHZpZXcsIDI1NiAvKiBJbml0U3RhdGVfQ2FsbGluZ09uSW5pdCAqLywgZGVmLm5vZGVJbmRleCkpIHtcbiAgICAgICAgZGlyZWN0aXZlLm5nT25Jbml0KCk7XG4gICAgfVxuICAgIGlmIChkZWYuZmxhZ3MgJiAyNjIxNDQgLyogRG9DaGVjayAqLykge1xuICAgICAgICBkaXJlY3RpdmUubmdEb0NoZWNrKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVEaXJlY3RpdmVEeW5hbWljKHZpZXcsIGRlZiwgdmFsdWVzKSB7XG4gICAgdmFyIHByb3ZpZGVyRGF0YSA9IGFzUHJvdmlkZXJEYXRhKHZpZXcsIGRlZi5ub2RlSW5kZXgpO1xuICAgIHZhciBkaXJlY3RpdmUgPSBwcm92aWRlckRhdGEuaW5zdGFuY2U7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgY2hhbmdlcyA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2hlY2tCaW5kaW5nKHZpZXcsIGRlZiwgaSwgdmFsdWVzW2ldKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGFuZ2VzID0gdXBkYXRlUHJvcCh2aWV3LCBwcm92aWRlckRhdGEsIGRlZiwgaSwgdmFsdWVzW2ldLCBjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICBkaXJlY3RpdmUubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfVxuICAgIGlmICgoZGVmLmZsYWdzICYgNjU1MzYgLyogT25Jbml0ICovKSAmJlxuICAgICAgICBzaG91bGRDYWxsTGlmZWN5Y2xlSW5pdEhvb2sodmlldywgMjU2IC8qIEluaXRTdGF0ZV9DYWxsaW5nT25Jbml0ICovLCBkZWYubm9kZUluZGV4KSkge1xuICAgICAgICBkaXJlY3RpdmUubmdPbkluaXQoKTtcbiAgICB9XG4gICAgaWYgKGRlZi5mbGFncyAmIDI2MjE0NCAvKiBEb0NoZWNrICovKSB7XG4gICAgICAgIGRpcmVjdGl2ZS5uZ0RvQ2hlY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBfY3JlYXRlUHJvdmlkZXJJbnN0YW5jZSQxKHZpZXcsIGRlZikge1xuICAgIC8vIHByaXZhdGUgc2VydmljZXMgY2FuIHNlZSBvdGhlciBwcml2YXRlIHNlcnZpY2VzXG4gICAgdmFyIGFsbG93UHJpdmF0ZVNlcnZpY2VzID0gKGRlZi5mbGFncyAmIDgxOTIgLyogUHJpdmF0ZVByb3ZpZGVyICovKSA+IDA7XG4gICAgdmFyIHByb3ZpZGVyRGVmID0gZGVmLnByb3ZpZGVyO1xuICAgIHN3aXRjaCAoZGVmLmZsYWdzICYgMjAxMzQ3MDY3IC8qIFR5cGVzICovKSB7XG4gICAgICAgIGNhc2UgNTEyIC8qIFR5cGVDbGFzc1Byb3ZpZGVyICovOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNsYXNzKHZpZXcsIGRlZi5wYXJlbnQsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBwcm92aWRlckRlZi52YWx1ZSwgcHJvdmlkZXJEZWYuZGVwcyk7XG4gICAgICAgIGNhc2UgMTAyNCAvKiBUeXBlRmFjdG9yeVByb3ZpZGVyICovOlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxGYWN0b3J5KHZpZXcsIGRlZi5wYXJlbnQsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBwcm92aWRlckRlZi52YWx1ZSwgcHJvdmlkZXJEZWYuZGVwcyk7XG4gICAgICAgIGNhc2UgMjA0OCAvKiBUeXBlVXNlRXhpc3RpbmdQcm92aWRlciAqLzpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRGVwKHZpZXcsIGRlZi5wYXJlbnQsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBwcm92aWRlckRlZi5kZXBzWzBdKTtcbiAgICAgICAgY2FzZSAyNTYgLyogVHlwZVZhbHVlUHJvdmlkZXIgKi86XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJEZWYudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xhc3ModmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBjdG9yLCBkZXBzKSB7XG4gICAgdmFyIGxlbiA9IGRlcHMubGVuZ3RoO1xuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IocmVzb2x2ZURlcCh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlcHNbMF0pKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzWzBdKSwgcmVzb2x2ZURlcCh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlcHNbMV0pKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzWzBdKSwgcmVzb2x2ZURlcCh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlcHNbMV0pLCByZXNvbHZlRGVwKHZpZXcsIGVsRGVmLCBhbGxvd1ByaXZhdGVTZXJ2aWNlcywgZGVwc1syXSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyIGRlcFZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlcFZhbHVlc1tpXSA9IHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgKGN0b3IuYmluZC5hcHBseShjdG9yLCBfX3NwcmVhZChbdm9pZCAwXSwgZGVwVmFsdWVzKSkpKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbEZhY3RvcnkodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBmYWN0b3J5LCBkZXBzKSB7XG4gICAgdmFyIGxlbiA9IGRlcHMubGVuZ3RoO1xuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzWzBdKSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzWzBdKSwgcmVzb2x2ZURlcCh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlcHNbMV0pKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkocmVzb2x2ZURlcCh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMsIGRlcHNbMF0pLCByZXNvbHZlRGVwKHZpZXcsIGVsRGVmLCBhbGxvd1ByaXZhdGVTZXJ2aWNlcywgZGVwc1sxXSksIHJlc29sdmVEZXAodmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzLCBkZXBzWzJdKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgZGVwVmFsdWVzID0gQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXBWYWx1ZXNbaV0gPSByZXNvbHZlRGVwKHZpZXcsIGVsRGVmLCBhbGxvd1ByaXZhdGVTZXJ2aWNlcywgZGVwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGRlcFZhbHVlcykpO1xuICAgIH1cbn1cbi8vIFRoaXMgZGVmYXVsdCB2YWx1ZSBpcyB3aGVuIGNoZWNraW5nIHRoZSBoaWVyYXJjaHkgZm9yIGEgdG9rZW4uXG4vL1xuLy8gSXQgbWVhbnMgYm90aDpcbi8vIC0gdGhlIHRva2VuIGlzIG5vdCBwcm92aWRlZCBieSB0aGUgY3VycmVudCBpbmplY3Rvcixcbi8vIC0gb25seSB0aGUgZWxlbWVudCBpbmplY3RvcnMgc2hvdWxkIGJlIGNoZWNrZWQgKGllIGRvIG5vdCBjaGVjayBtb2R1bGUgaW5qZWN0b3JzXG4vL1xuLy8gICAgICAgICAgbW9kMVxuLy8gICAgICAgICAvXG4vLyAgICAgICBlbDEgICBtb2QyXG4vLyAgICAgICAgIFxcICAvXG4vLyAgICAgICAgIGVsMlxuLy9cbi8vIFdoZW4gcmVxdWVzdGluZyBlbDIuaW5qZWN0b3IuZ2V0KHRva2VuKSwgd2Ugc2hvdWxkIGNoZWNrIGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgYW5kIHJldHVybiB0aGVcbi8vIGZpcnN0IGZvdW5kIHZhbHVlOlxuLy8gLSBlbDIuaW5qZWN0b3IuZ2V0KHRva2VuLCBkZWZhdWx0KVxuLy8gLSBlbDEuaW5qZWN0b3IuZ2V0KHRva2VuLCBOT1RfRk9VTkRfQ0hFQ0tfT05MWV9FTEVNRU5UX0lOSkVDVE9SKSAtPiBkbyBub3QgY2hlY2sgdGhlIG1vZHVsZVxuLy8gLSBtb2QyLmluamVjdG9yLmdldCh0b2tlbiwgZGVmYXVsdClcbnZhciBOT1RfRk9VTkRfQ0hFQ0tfT05MWV9FTEVNRU5UX0lOSkVDVE9SID0ge307XG5mdW5jdGlvbiByZXNvbHZlRGVwKHZpZXcsIGVsRGVmLCBhbGxvd1ByaXZhdGVTZXJ2aWNlcywgZGVwRGVmLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgaWYgKGRlcERlZi5mbGFncyAmIDggLyogVmFsdWUgKi8pIHtcbiAgICAgICAgcmV0dXJuIGRlcERlZi50b2tlbjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VmlldyA9IHZpZXc7XG4gICAgaWYgKGRlcERlZi5mbGFncyAmIDIgLyogT3B0aW9uYWwgKi8pIHtcbiAgICAgICAgbm90Rm91bmRWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciB0b2tlbktleSQkMSA9IGRlcERlZi50b2tlbktleTtcbiAgICBpZiAodG9rZW5LZXkkJDEgPT09IENoYW5nZURldGVjdG9yUmVmVG9rZW5LZXkpIHtcbiAgICAgICAgLy8gZGlyZWN0aXZlcyBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIGEgY29tcG9uZW50IHNob3VsZCBiZSBhYmxlIHRvIGNvbnRyb2wgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAgICAvLyBvZiB0aGF0IGNvbXBvbmVudCBhcyB3ZWxsLlxuICAgICAgICBhbGxvd1ByaXZhdGVTZXJ2aWNlcyA9ICEhKGVsRGVmICYmIGVsRGVmLmVsZW1lbnQuY29tcG9uZW50Vmlldyk7XG4gICAgfVxuICAgIGlmIChlbERlZiAmJiAoZGVwRGVmLmZsYWdzICYgMSAvKiBTa2lwU2VsZiAqLykpIHtcbiAgICAgICAgYWxsb3dQcml2YXRlU2VydmljZXMgPSBmYWxzZTtcbiAgICAgICAgZWxEZWYgPSBlbERlZi5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBzZWFyY2hWaWV3ID0gdmlldztcbiAgICB3aGlsZSAoc2VhcmNoVmlldykge1xuICAgICAgICBpZiAoZWxEZWYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5LZXkkJDEpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlbmRlcmVyVjFUb2tlbktleToge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcFZpZXcgPSBmaW5kQ29tcFZpZXcoc2VhcmNoVmlldywgZWxEZWYsIGFsbG93UHJpdmF0ZVNlcnZpY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlcmVyVjEoY29tcFZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFJlbmRlcmVyMlRva2VuS2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wVmlldyA9IGZpbmRDb21wVmlldyhzZWFyY2hWaWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcFZpZXcucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRWxlbWVudFJlZlRva2VuS2V5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRSZWYoYXNFbGVtZW50RGF0YShzZWFyY2hWaWV3LCBlbERlZi5ub2RlSW5kZXgpLnJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNhc2UgVmlld0NvbnRhaW5lclJlZlRva2VuS2V5OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNFbGVtZW50RGF0YShzZWFyY2hWaWV3LCBlbERlZi5ub2RlSW5kZXgpLnZpZXdDb250YWluZXI7XG4gICAgICAgICAgICAgICAgY2FzZSBUZW1wbGF0ZVJlZlRva2VuS2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbERlZi5lbGVtZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNFbGVtZW50RGF0YShzZWFyY2hWaWV3LCBlbERlZi5ub2RlSW5kZXgpLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENoYW5nZURldGVjdG9yUmVmVG9rZW5LZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNkVmlldyA9IGZpbmRDb21wVmlldyhzZWFyY2hWaWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhbmdlRGV0ZWN0b3JSZWYoY2RWaWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBJbmplY3RvclJlZlRva2VuS2V5JDE6XG4gICAgICAgICAgICAgICAgY2FzZSBJTkpFQ1RPUlJlZlRva2VuS2V5JDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbmplY3RvciQxKHNlYXJjaFZpZXcsIGVsRGVmKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJEZWZfMSA9IChhbGxvd1ByaXZhdGVTZXJ2aWNlcyA/IGVsRGVmLmVsZW1lbnQuYWxsUHJvdmlkZXJzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsRGVmLmVsZW1lbnQucHVibGljUHJvdmlkZXJzKVt0b2tlbktleSQkMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlckRlZl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJEYXRhID0gYXNQcm92aWRlckRhdGEoc2VhcmNoVmlldywgcHJvdmlkZXJEZWZfMS5ub2RlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlckRhdGEgPSB7IGluc3RhbmNlOiBfY3JlYXRlUHJvdmlkZXJJbnN0YW5jZSQxKHNlYXJjaFZpZXcsIHByb3ZpZGVyRGVmXzEpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoVmlldy5ub2Rlc1twcm92aWRlckRlZl8xLm5vZGVJbmRleF0gPSBwcm92aWRlckRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJEYXRhLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWxsb3dQcml2YXRlU2VydmljZXMgPSBpc0NvbXBvbmVudFZpZXcoc2VhcmNoVmlldyk7XG4gICAgICAgIGVsRGVmID0gdmlld1BhcmVudEVsKHNlYXJjaFZpZXcpO1xuICAgICAgICBzZWFyY2hWaWV3ID0gc2VhcmNoVmlldy5wYXJlbnQ7XG4gICAgICAgIGlmIChkZXBEZWYuZmxhZ3MgJiA0IC8qIFNlbGYgKi8pIHtcbiAgICAgICAgICAgIHNlYXJjaFZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHN0YXJ0Vmlldy5yb290LmluamVjdG9yLmdldChkZXBEZWYudG9rZW4sIE5PVF9GT1VORF9DSEVDS19PTkxZX0VMRU1FTlRfSU5KRUNUT1IpO1xuICAgIGlmICh2YWx1ZSAhPT0gTk9UX0ZPVU5EX0NIRUNLX09OTFlfRUxFTUVOVF9JTkpFQ1RPUiB8fFxuICAgICAgICBub3RGb3VuZFZhbHVlID09PSBOT1RfRk9VTkRfQ0hFQ0tfT05MWV9FTEVNRU5UX0lOSkVDVE9SKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZnJvbSB0aGUgcm9vdCBlbGVtZW50IGluamVjdG9yIHdoZW5cbiAgICAgICAgLy8gLSBpdCBwcm92aWRlcyBpdFxuICAgICAgICAvLyAgICh2YWx1ZSAhPT0gTk9UX0ZPVU5EX0NIRUNLX09OTFlfRUxFTUVOVF9JTkpFQ1RPUilcbiAgICAgICAgLy8gLSB0aGUgbW9kdWxlIGluamVjdG9yIHNob3VsZCBub3QgYmUgY2hlY2tlZFxuICAgICAgICAvLyAgIChub3RGb3VuZFZhbHVlID09PSBOT1RfRk9VTkRfQ0hFQ0tfT05MWV9FTEVNRU5UX0lOSkVDVE9SKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFZpZXcucm9vdC5uZ01vZHVsZS5pbmplY3Rvci5nZXQoZGVwRGVmLnRva2VuLCBub3RGb3VuZFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wVmlldyh2aWV3LCBlbERlZiwgYWxsb3dQcml2YXRlU2VydmljZXMpIHtcbiAgICB2YXIgY29tcFZpZXc7XG4gICAgaWYgKGFsbG93UHJpdmF0ZVNlcnZpY2VzKSB7XG4gICAgICAgIGNvbXBWaWV3ID0gYXNFbGVtZW50RGF0YSh2aWV3LCBlbERlZi5ub2RlSW5kZXgpLmNvbXBvbmVudFZpZXc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb21wVmlldyA9IHZpZXc7XG4gICAgICAgIHdoaWxlIChjb21wVmlldy5wYXJlbnQgJiYgIWlzQ29tcG9uZW50Vmlldyhjb21wVmlldykpIHtcbiAgICAgICAgICAgIGNvbXBWaWV3ID0gY29tcFZpZXcucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wVmlldztcbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3AodmlldywgcHJvdmlkZXJEYXRhLCBkZWYsIGJpbmRpbmdJZHgsIHZhbHVlLCBjaGFuZ2VzKSB7XG4gICAgaWYgKGRlZi5mbGFncyAmIDMyNzY4IC8qIENvbXBvbmVudCAqLykge1xuICAgICAgICB2YXIgY29tcFZpZXcgPSBhc0VsZW1lbnREYXRhKHZpZXcsIGRlZi5wYXJlbnQubm9kZUluZGV4KS5jb21wb25lbnRWaWV3O1xuICAgICAgICBpZiAoY29tcFZpZXcuZGVmLmZsYWdzICYgMiAvKiBPblB1c2ggKi8pIHtcbiAgICAgICAgICAgIGNvbXBWaWV3LnN0YXRlIHw9IDggLyogQ2hlY2tzRW5hYmxlZCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmluZGluZyA9IGRlZi5iaW5kaW5nc1tiaW5kaW5nSWR4XTtcbiAgICB2YXIgcHJvcE5hbWUgPSBiaW5kaW5nLm5hbWU7XG4gICAgLy8gTm90ZTogVGhpcyBpcyBzdGlsbCBzYWZlIHdpdGggQ2xvc3VyZSBDb21waWxlciBhc1xuICAgIC8vIHRoZSB1c2VyIHBhc3NlZCBpbiB0aGUgcHJvcGVydHkgbmFtZSBhcyBhbiBvYmplY3QgaGFzIHRvIGBwcm92aWRlckRlZmAsXG4gICAgLy8gc28gQ2xvc3VyZSBDb21waWxlciB3aWxsIGhhdmUgcmVuYW1lZCB0aGUgcHJvcGVydHkgY29ycmVjdGx5IGFscmVhZHkuXG4gICAgcHJvdmlkZXJEYXRhLmluc3RhbmNlW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgIGlmIChkZWYuZmxhZ3MgJiA1MjQyODggLyogT25DaGFuZ2VzICovKSB7XG4gICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHx8IHt9O1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBXcmFwcGVkVmFsdWUudW53cmFwKHZpZXcub2xkVmFsdWVzW2RlZi5iaW5kaW5nSW5kZXggKyBiaW5kaW5nSWR4XSk7XG4gICAgICAgIHZhciBiaW5kaW5nXzEgPSBkZWYuYmluZGluZ3NbYmluZGluZ0lkeF07XG4gICAgICAgIGNoYW5nZXNbYmluZGluZ18xLm5vbk1pbmlmaWVkTmFtZV0gPVxuICAgICAgICAgICAgbmV3IFNpbXBsZUNoYW5nZShvbGRWYWx1ZSwgdmFsdWUsICh2aWV3LnN0YXRlICYgMiAvKiBGaXJzdENoZWNrICovKSAhPT0gMCk7XG4gICAgfVxuICAgIHZpZXcub2xkVmFsdWVzW2RlZi5iaW5kaW5nSW5kZXggKyBiaW5kaW5nSWR4XSA9IHZhbHVlO1xuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBjYWxscyB0aGUgbmdBZnRlckNvbnRlbnRDaGVjaywgbmdBZnRlckNvbnRlbnRJbml0LFxuLy8gbmdBZnRlclZpZXdDaGVjaywgYW5kIG5nQWZ0ZXJWaWV3SW5pdCBsaWZlY3ljbGUgaG9va3MgKGRlcGVuZGluZyBvbiB0aGUgbm9kZVxuLy8gZmxhZ3MgaW4gbGlmZWN5Y2xlKS4gVW5saWtlIG5nRG9DaGVjaywgbmdPbkNoYW5nZXMgYW5kIG5nT25Jbml0LCB3aGljaCBhcmVcbi8vIGNhbGxlZCBkdXJpbmcgYSBwcmUtb3JkZXIgdHJhdmVyc2FsIG9mIHRoZSB2aWV3IHRyZWUgKHRoYXQgaXMgY2FsbGluZyB0aGVcbi8vIHBhcmVudCBob29rcyBiZWZvcmUgdGhlIGNoaWxkIGhvb2tzKSB0aGVzZSBldmVudHMgYXJlIHNlbnQgaW4gdXNpbmcgYVxuLy8gcG9zdC1vcmRlciB0cmF2ZXJzYWwgb2YgdGhlIHRyZWUgKGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzKS4gVGhpcyBjaGFuZ2VzIHRoZVxuLy8gbWVhbmluZyBvZiBpbml0SW5kZXggaW4gdGhlIHZpZXcgc3RhdGUuIEZvciBuZ09uSW5pdCwgaW5pdEluZGV4IHRyYWNrcyB0aGVcbi8vIGV4cGVjdGVkIG5vZGVJbmRleCB3aGljaCBhIG5nT25Jbml0IHNob3VsZCBiZSBjYWxsZWQuIFdoZW4gc2VuZGluZ1xuLy8gbmdBZnRlckNvbnRlbnRJbml0IGFuZCBuZ0FmdGVyVmlld0luaXQgaXQgaXMgdGhlIGV4cGVjdGVkIGNvdW50IG9mXG4vLyBuZ0FmdGVyQ29udGVudEluaXQgb3IgbmdBZnRlclZpZXdJbml0IG1ldGhvZHMgdGhhdCBoYXZlIGJlZW4gY2FsbGVkLiBUaGlzXG4vLyBlbnN1cmUgdGhhdCBkZXNwaXRlIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseSBvciBhZnRlciBwaWNraW5nIHVwIGFmdGVyIGFuXG4vLyBleGNlcHRpb24sIHRoZSBuZ0FmdGVyQ29udGVudEluaXQgb3IgbmdBZnRlclZpZXdJbml0IHdpbGwgYmUgY2FsbGVkIG9uIHRoZVxuLy8gY29ycmVjdCBub2Rlcy4gQ29uc2lkZXIgZm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgKHdoZXJlIEUgaXMgYW4gZWxlbWVudFxuLy8gYW5kIEQgaXMgYSBkaXJlY3RpdmUpXG4vLyAgVHJlZTogICAgICAgcHJlLW9yZGVyIGluZGV4ICBwb3N0LW9yZGVyIGluZGV4XG4vLyAgICBFMSAgICAgICAgMCAgICAgICAgICAgICAgICA2XG4vLyAgICAgIEUyICAgICAgMSAgICAgICAgICAgICAgICAxXG4vLyAgICAgICBEMyAgICAgMiAgICAgICAgICAgICAgICAwXG4vLyAgICAgIEU0ICAgICAgMyAgICAgICAgICAgICAgICA1XG4vLyAgICAgICBFNSAgICAgNCAgICAgICAgICAgICAgICA0XG4vLyAgICAgICAgRTYgICAgNSAgICAgICAgICAgICAgICAyXG4vLyAgICAgICAgRTcgICAgNiAgICAgICAgICAgICAgICAzXG4vLyBBcyBjYW4gYmUgc2VlbiwgdGhlIHBvc3Qtb3JkZXIgaW5kZXggaGFzIGFuIHVuY2xlYXIgcmVsYXRpb25zaGlwIHRvIHRoZVxuLy8gcHJlLW9yZGVyIGluZGV4IChwb3N0T3JkZXJJbmRleCA9PT0gcHJlT3JkZXJJbmRleCAtIHBhcmVudENvdW50ICtcbi8vIGNoaWxkQ291bnQpLiBTaW5jZSBudW1iZXIgb2YgY2FsbHMgdG8gbmdBZnRlckNvbnRlbnRJbml0IGFuZCBuZ0FmdGVyVmlld0luaXRcbi8vIGFyZSBzdGFibGUgKHdpbGwgYmUgdGhlIHNhbWUgZm9yIHRoZSBzYW1lIHZpZXcgcmVnYXJkbGVzcyBvZiBleGNlcHRpb25zIG9yXG4vLyByZWN1cnNpb24pIHdlIGp1c3QgbmVlZCB0byBjb3VudCB0aGVtIHdoaWNoIHdpbGwgcm91Z2hseSBjb3JyZXNwb25kIHRvIHRoZVxuLy8gcG9zdC1vcmRlciBpbmRleCAoaXQgc2tpcHMgZWxlbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCBkbyBub3QgaGF2ZVxuLy8gbGlmZWN5Y2xlIGhvb2tzKS5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgaWYgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZCBpbiB0aGUgRTYub25BZnRlclZpZXdJbml0KCkgdGhlXG4vLyBpbml0SW5kZXggaXMgbGVmdCBhdCAzIChieSBzaG91bGRDYWxsTGlmZWN5Y2xlSW5pdEhvb2soKSB3aGljaCBzZXQgaXQgdG9cbi8vIGluaXRJbmRleCArIDEpLiBXaGVuIGNoZWNrQW5kVXBkYXRlVmlldygpIGlzIGNhbGxlZCBhZ2FpbiBEMywgRTIgYW5kIEU2IHdpbGxcbi8vIG5vdCBoYXZlIHRoZWlyIG5nQWZ0ZXJWaWV3SW5pdCgpIGNhbGxlZCBidXQsIHN0YXJ0aW5nIHdpdGggRTcsIHRoZSByZXN0IG9mXG4vLyB0aGUgdmlldyB3aWxsIGJlZ2luIGdldHRpbmcgbmdBZnRlclZpZXdJbml0KCkgY2FsbGVkIHVudGlsIGEgY2hlY2sgYW5kXG4vLyBwYXNzIGlzIGNvbXBsZXRlLlxuLy9cbi8vIFRoaXMgYWxnb3J0aGltIGFsc28gaGFuZGxlcyByZWN1cnNpb24uIENvbnNpZGVyIGlmIEU0J3MgbmdBZnRlclZpZXdJbml0KClcbi8vIGluZGlyZWN0bHkgY2FsbHMgRTEncyBDaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCkuIFRoZSBleHBlY3RlZFxuLy8gaW5pdEluZGV4IGlzIHNldCB0byA2LCB0aGUgcmVjdXNpdmUgY2hlY2tBbmRVcGRhdGVWaWV3KCkgc3RhcnRzIHdhbGsgYWdhaW4uXG4vLyBEMywgRTIsIEU2LCBFNywgRTUgYW5kIEU0IGFyZSBza2lwcGVkLCBuZ0FmdGVyVmlld0luaXQoKSBpcyBjYWxsZWQgb24gRTEuXG4vLyBXaGVuIHRoZSByZWN1cnNpb24gcmV0dXJucyB0aGUgaW5pdEluZGV4IHdpbGwgYmUgNyBzbyBFMSBpcyBza2lwcGVkIGFzIGl0XG4vLyBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCBpbiB0aGUgcmVjdXJzaXZlbHkgY2FsbGVkIGNoZWNrQW5VcGRhdGVWaWV3KCkuXG5mdW5jdGlvbiBjYWxsTGlmZWN5Y2xlSG9va3NDaGlsZHJlbkZpcnN0KHZpZXcsIGxpZmVjeWNsZXMpIHtcbiAgICBpZiAoISh2aWV3LmRlZi5ub2RlRmxhZ3MgJiBsaWZlY3ljbGVzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlcyA9IHZpZXcuZGVmLm5vZGVzO1xuICAgIHZhciBpbml0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVEZWYgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBhcmVudF8xID0gbm9kZURlZi5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50XzEgJiYgbm9kZURlZi5mbGFncyAmIGxpZmVjeWNsZXMpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIHJvb3Qgbm9kZSAoZS5nLiBhIHBpcGUpXG4gICAgICAgICAgICBjYWxsUHJvdmlkZXJMaWZlY3ljbGVzKHZpZXcsIGksIG5vZGVEZWYuZmxhZ3MgJiBsaWZlY3ljbGVzLCBpbml0SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChub2RlRGVmLmNoaWxkRmxhZ3MgJiBsaWZlY3ljbGVzKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gbm8gY2hpbGQgbWF0Y2hlcyBvbmUgb2YgdGhlIGxpZmVjeWNsZXNcbiAgICAgICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwYXJlbnRfMSAmJiAocGFyZW50XzEuZmxhZ3MgJiAxIC8qIFR5cGVFbGVtZW50ICovKSAmJlxuICAgICAgICAgICAgaSA9PT0gcGFyZW50XzEubm9kZUluZGV4ICsgcGFyZW50XzEuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgLy8gbGFzdCBjaGlsZCBvZiBhbiBlbGVtZW50XG4gICAgICAgICAgICBpZiAocGFyZW50XzEuZGlyZWN0Q2hpbGRGbGFncyAmIGxpZmVjeWNsZXMpIHtcbiAgICAgICAgICAgICAgICBpbml0SW5kZXggPSBjYWxsRWxlbWVudFByb3ZpZGVyc0xpZmVjeWNsZXModmlldywgcGFyZW50XzEsIGxpZmVjeWNsZXMsIGluaXRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRfMSA9IHBhcmVudF8xLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxFbGVtZW50UHJvdmlkZXJzTGlmZWN5Y2xlcyh2aWV3LCBlbERlZiwgbGlmZWN5Y2xlcywgaW5pdEluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IGVsRGVmLm5vZGVJbmRleCArIDE7IGkgPD0gZWxEZWYubm9kZUluZGV4ICsgZWxEZWYuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlRGVmID0gdmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgbGlmZWN5Y2xlcykge1xuICAgICAgICAgICAgY2FsbFByb3ZpZGVyTGlmZWN5Y2xlcyh2aWV3LCBpLCBub2RlRGVmLmZsYWdzICYgbGlmZWN5Y2xlcywgaW5pdEluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgdmlzaXQgZGlyZWN0IGNoaWxkcmVuXG4gICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgIH1cbiAgICByZXR1cm4gaW5pdEluZGV4O1xufVxuZnVuY3Rpb24gY2FsbFByb3ZpZGVyTGlmZWN5Y2xlcyh2aWV3LCBpbmRleCwgbGlmZWN5Y2xlcywgaW5pdEluZGV4KSB7XG4gICAgdmFyIHByb3ZpZGVyRGF0YSA9IGFzUHJvdmlkZXJEYXRhKHZpZXcsIGluZGV4KTtcbiAgICBpZiAoIXByb3ZpZGVyRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcm92aWRlciA9IHByb3ZpZGVyRGF0YS5pbnN0YW5jZTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgU2VydmljZXMuc2V0Q3VycmVudE5vZGUodmlldywgaW5kZXgpO1xuICAgIGlmIChsaWZlY3ljbGVzICYgMTA0ODU3NiAvKiBBZnRlckNvbnRlbnRJbml0ICovICYmXG4gICAgICAgIHNob3VsZENhbGxMaWZlY3ljbGVJbml0SG9vayh2aWV3LCA1MTIgLyogSW5pdFN0YXRlX0NhbGxpbmdBZnRlckNvbnRlbnRJbml0ICovLCBpbml0SW5kZXgpKSB7XG4gICAgICAgIHByb3ZpZGVyLm5nQWZ0ZXJDb250ZW50SW5pdCgpO1xuICAgIH1cbiAgICBpZiAobGlmZWN5Y2xlcyAmIDIwOTcxNTIgLyogQWZ0ZXJDb250ZW50Q2hlY2tlZCAqLykge1xuICAgICAgICBwcm92aWRlci5uZ0FmdGVyQ29udGVudENoZWNrZWQoKTtcbiAgICB9XG4gICAgaWYgKGxpZmVjeWNsZXMgJiA0MTk0MzA0IC8qIEFmdGVyVmlld0luaXQgKi8gJiZcbiAgICAgICAgc2hvdWxkQ2FsbExpZmVjeWNsZUluaXRIb29rKHZpZXcsIDc2OCAvKiBJbml0U3RhdGVfQ2FsbGluZ0FmdGVyVmlld0luaXQgKi8sIGluaXRJbmRleCkpIHtcbiAgICAgICAgcHJvdmlkZXIubmdBZnRlclZpZXdJbml0KCk7XG4gICAgfVxuICAgIGlmIChsaWZlY3ljbGVzICYgODM4ODYwOCAvKiBBZnRlclZpZXdDaGVja2VkICovKSB7XG4gICAgICAgIHByb3ZpZGVyLm5nQWZ0ZXJWaWV3Q2hlY2tlZCgpO1xuICAgIH1cbiAgICBpZiAobGlmZWN5Y2xlcyAmIDEzMTA3MiAvKiBPbkRlc3Ryb3kgKi8pIHtcbiAgICAgICAgcHJvdmlkZXIubmdPbkRlc3Ryb3koKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5RGVmKGZsYWdzLCBpZCwgYmluZGluZ3MpIHtcbiAgICB2YXIgYmluZGluZ0RlZnMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBiaW5kaW5ncykge1xuICAgICAgICB2YXIgYmluZGluZ1R5cGUgPSBiaW5kaW5nc1twcm9wTmFtZV07XG4gICAgICAgIGJpbmRpbmdEZWZzLnB1c2goeyBwcm9wTmFtZTogcHJvcE5hbWUsIGJpbmRpbmdUeXBlOiBiaW5kaW5nVHlwZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gd2lsbCBiZXQgc2V0IGJ5IHRoZSB2aWV3IGRlZmluaXRpb25cbiAgICAgICAgbm9kZUluZGV4OiAtMSxcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICByZW5kZXJQYXJlbnQ6IG51bGwsXG4gICAgICAgIGJpbmRpbmdJbmRleDogLTEsXG4gICAgICAgIG91dHB1dEluZGV4OiAtMSxcbiAgICAgICAgLy8gcmVndWxhciB2YWx1ZXNcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogY2hlY2tcbiAgICAgICAgY2hlY2tJbmRleDogLTEsIGZsYWdzOiBmbGFncyxcbiAgICAgICAgY2hpbGRGbGFnczogMCxcbiAgICAgICAgZGlyZWN0Q2hpbGRGbGFnczogMCxcbiAgICAgICAgY2hpbGRNYXRjaGVkUXVlcmllczogMCxcbiAgICAgICAgbmdDb250ZW50SW5kZXg6IC0xLFxuICAgICAgICBtYXRjaGVkUXVlcmllczoge30sXG4gICAgICAgIG1hdGNoZWRRdWVyeUlkczogMCxcbiAgICAgICAgcmVmZXJlbmNlczoge30sXG4gICAgICAgIGNoaWxkQ291bnQ6IDAsXG4gICAgICAgIGJpbmRpbmdzOiBbXSxcbiAgICAgICAgYmluZGluZ0ZsYWdzOiAwLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgcHJvdmlkZXI6IG51bGwsXG4gICAgICAgIHRleHQ6IG51bGwsXG4gICAgICAgIHF1ZXJ5OiB7IGlkOiBpZCwgZmlsdGVySWQ6IGZpbHRlclF1ZXJ5SWQoaWQpLCBiaW5kaW5nczogYmluZGluZ0RlZnMgfSxcbiAgICAgICAgbmdDb250ZW50OiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5JDEoKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpc3QkMSgpO1xufVxuZnVuY3Rpb24gZGlydHlQYXJlbnRRdWVyaWVzKHZpZXcpIHtcbiAgICB2YXIgcXVlcnlJZHMgPSB2aWV3LmRlZi5ub2RlTWF0Y2hlZFF1ZXJpZXM7XG4gICAgd2hpbGUgKHZpZXcucGFyZW50ICYmIGlzRW1iZWRkZWRWaWV3KHZpZXcpKSB7XG4gICAgICAgIHZhciB0cGxEZWYgPSB2aWV3LnBhcmVudE5vZGVEZWY7XG4gICAgICAgIHZpZXcgPSB2aWV3LnBhcmVudDtcbiAgICAgICAgLy8gY29udGVudCBxdWVyaWVzXG4gICAgICAgIHZhciBlbmQgPSB0cGxEZWYubm9kZUluZGV4ICsgdHBsRGVmLmNoaWxkQ291bnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZURlZiA9IHZpZXcuZGVmLm5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKChub2RlRGVmLmZsYWdzICYgNjcxMDg4NjQgLyogVHlwZUNvbnRlbnRRdWVyeSAqLykgJiZcbiAgICAgICAgICAgICAgICAobm9kZURlZi5mbGFncyAmIDUzNjg3MDkxMiAvKiBEeW5hbWljUXVlcnkgKi8pICYmXG4gICAgICAgICAgICAgICAgKG5vZGVEZWYucXVlcnkuZmlsdGVySWQgJiBxdWVyeUlkcykgPT09IG5vZGVEZWYucXVlcnkuZmlsdGVySWQpIHtcbiAgICAgICAgICAgICAgICBhc1F1ZXJ5TGlzdCh2aWV3LCBpKS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChub2RlRGVmLmZsYWdzICYgMSAvKiBUeXBlRWxlbWVudCAqLyAmJiBpICsgbm9kZURlZi5jaGlsZENvdW50IDwgdHBsRGVmLm5vZGVJbmRleCkgfHxcbiAgICAgICAgICAgICAgICAhKG5vZGVEZWYuY2hpbGRGbGFncyAmIDY3MTA4ODY0IC8qIFR5cGVDb250ZW50UXVlcnkgKi8pIHx8XG4gICAgICAgICAgICAgICAgIShub2RlRGVmLmNoaWxkRmxhZ3MgJiA1MzY4NzA5MTIgLyogRHluYW1pY1F1ZXJ5ICovKSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZWxlbWVudHMgdGhhdCBkb24ndCBjb250YWluIHRoZSB0ZW1wbGF0ZSBlbGVtZW50IG9yIG5vIHF1ZXJ5LlxuICAgICAgICAgICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHZpZXcgcXVlcmllc1xuICAgIGlmICh2aWV3LmRlZi5ub2RlRmxhZ3MgJiAxMzQyMTc3MjggLyogVHlwZVZpZXdRdWVyeSAqLykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcuZGVmLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZURlZiA9IHZpZXcuZGVmLm5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKChub2RlRGVmLmZsYWdzICYgMTM0MjE3NzI4IC8qIFR5cGVWaWV3UXVlcnkgKi8pICYmIChub2RlRGVmLmZsYWdzICYgNTM2ODcwOTEyIC8qIER5bmFtaWNRdWVyeSAqLykpIHtcbiAgICAgICAgICAgICAgICBhc1F1ZXJ5TGlzdCh2aWV3LCBpKS5zZXREaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSB2aXNpdCB0aGUgcm9vdCBub2Rlc1xuICAgICAgICAgICAgaSArPSBub2RlRGVmLmNoaWxkQ291bnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0FuZFVwZGF0ZVF1ZXJ5KHZpZXcsIG5vZGVEZWYpIHtcbiAgICB2YXIgcXVlcnlMaXN0ID0gYXNRdWVyeUxpc3Qodmlldywgbm9kZURlZi5ub2RlSW5kZXgpO1xuICAgIGlmICghcXVlcnlMaXN0LmRpcnR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlO1xuICAgIHZhciBuZXdWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiA2NzEwODg2NCAvKiBUeXBlQ29udGVudFF1ZXJ5ICovKSB7XG4gICAgICAgIHZhciBlbGVtZW50RGVmID0gbm9kZURlZi5wYXJlbnQucGFyZW50O1xuICAgICAgICBuZXdWYWx1ZXMgPSBjYWxjUXVlcnlWYWx1ZXModmlldywgZWxlbWVudERlZi5ub2RlSW5kZXgsIGVsZW1lbnREZWYubm9kZUluZGV4ICsgZWxlbWVudERlZi5jaGlsZENvdW50LCBub2RlRGVmLnF1ZXJ5LCBbXSk7XG4gICAgICAgIGRpcmVjdGl2ZUluc3RhbmNlID0gYXNQcm92aWRlckRhdGEodmlldywgbm9kZURlZi5wYXJlbnQubm9kZUluZGV4KS5pbnN0YW5jZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZURlZi5mbGFncyAmIDEzNDIxNzcyOCAvKiBUeXBlVmlld1F1ZXJ5ICovKSB7XG4gICAgICAgIG5ld1ZhbHVlcyA9IGNhbGNRdWVyeVZhbHVlcyh2aWV3LCAwLCB2aWV3LmRlZi5ub2Rlcy5sZW5ndGggLSAxLCBub2RlRGVmLnF1ZXJ5LCBbXSk7XG4gICAgICAgIGRpcmVjdGl2ZUluc3RhbmNlID0gdmlldy5jb21wb25lbnQ7XG4gICAgfVxuICAgIHF1ZXJ5TGlzdC5yZXNldChuZXdWYWx1ZXMpO1xuICAgIHZhciBiaW5kaW5ncyA9IG5vZGVEZWYucXVlcnkuYmluZGluZ3M7XG4gICAgdmFyIG5vdGlmeSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgdmFyIGJvdW5kVmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAoYmluZGluZy5iaW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEZpcnN0ICovOlxuICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBxdWVyeUxpc3QuZmlyc3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogQWxsICovOlxuICAgICAgICAgICAgICAgIGJvdW5kVmFsdWUgPSBxdWVyeUxpc3Q7XG4gICAgICAgICAgICAgICAgbm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmVJbnN0YW5jZVtiaW5kaW5nLnByb3BOYW1lXSA9IGJvdW5kVmFsdWU7XG4gICAgfVxuICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgcXVlcnlMaXN0Lm5vdGlmeU9uQ2hhbmdlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGNRdWVyeVZhbHVlcyh2aWV3LCBzdGFydEluZGV4LCBlbmRJbmRleCwgcXVlcnlEZWYsIHZhbHVlcykge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVEZWYgPSB2aWV3LmRlZi5ub2Rlc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IG5vZGVEZWYubWF0Y2hlZFF1ZXJpZXNbcXVlcnlEZWYuaWRdO1xuICAgICAgICBpZiAodmFsdWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGdldFF1ZXJ5VmFsdWUodmlldywgbm9kZURlZiwgdmFsdWVUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiAxIC8qIFR5cGVFbGVtZW50ICovICYmIG5vZGVEZWYuZWxlbWVudC50ZW1wbGF0ZSAmJlxuICAgICAgICAgICAgKG5vZGVEZWYuZWxlbWVudC50ZW1wbGF0ZS5ub2RlTWF0Y2hlZFF1ZXJpZXMgJiBxdWVyeURlZi5maWx0ZXJJZCkgPT09XG4gICAgICAgICAgICAgICAgcXVlcnlEZWYuZmlsdGVySWQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50RGF0YSA9IGFzRWxlbWVudERhdGEodmlldywgaSk7XG4gICAgICAgICAgICAvLyBjaGVjayBlbWJlZGRlZCB2aWV3cyB0aGF0IHdlcmUgYXR0YWNoZWQgYXQgdGhlIHBsYWNlIG9mIHRoZWlyIHRlbXBsYXRlLFxuICAgICAgICAgICAgLy8gYnV0IHByb2Nlc3MgY2hpbGQgbm9kZXMgZmlyc3QgaWYgc29tZSBtYXRjaCB0aGUgcXVlcnkgKHNlZSBpc3N1ZSAjMTY1NjgpXG4gICAgICAgICAgICBpZiAoKG5vZGVEZWYuY2hpbGRNYXRjaGVkUXVlcmllcyAmIHF1ZXJ5RGVmLmZpbHRlcklkKSA9PT0gcXVlcnlEZWYuZmlsdGVySWQpIHtcbiAgICAgICAgICAgICAgICBjYWxjUXVlcnlWYWx1ZXModmlldywgaSArIDEsIGkgKyBub2RlRGVmLmNoaWxkQ291bnQsIHF1ZXJ5RGVmLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiAxNjc3NzIxNiAvKiBFbWJlZGRlZFZpZXdzICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtYmVkZGVkVmlld3MgPSBlbGVtZW50RGF0YS52aWV3Q29udGFpbmVyLl9lbWJlZGRlZFZpZXdzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZW1iZWRkZWRWaWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW1iZWRkZWRWaWV3ID0gZW1iZWRkZWRWaWV3c1trXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR2YyA9IGRlY2xhcmVkVmlld0NvbnRhaW5lcihlbWJlZGRlZFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHZjICYmIGR2YyA9PT0gZWxlbWVudERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNRdWVyeVZhbHVlcyhlbWJlZGRlZFZpZXcsIDAsIGVtYmVkZGVkVmlldy5kZWYubm9kZXMubGVuZ3RoIC0gMSwgcXVlcnlEZWYsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkVmlld3MgPSBlbGVtZW50RGF0YS50ZW1wbGF0ZS5fcHJvamVjdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAocHJvamVjdGVkVmlld3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHByb2plY3RlZFZpZXdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRWaWV3ID0gcHJvamVjdGVkVmlld3Nba107XG4gICAgICAgICAgICAgICAgICAgIGNhbGNRdWVyeVZhbHVlcyhwcm9qZWN0ZWRWaWV3LCAwLCBwcm9qZWN0ZWRWaWV3LmRlZi5ub2Rlcy5sZW5ndGggLSAxLCBxdWVyeURlZiwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChub2RlRGVmLmNoaWxkTWF0Y2hlZFF1ZXJpZXMgJiBxdWVyeURlZi5maWx0ZXJJZCkgIT09IHF1ZXJ5RGVmLmZpbHRlcklkKSB7XG4gICAgICAgICAgICAvLyBpZiBubyBjaGlsZCBtYXRjaGVzIHRoZSBxdWVyeSwgc2tpcCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICBpICs9IG5vZGVEZWYuY2hpbGRDb3VudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnlWYWx1ZSh2aWV3LCBub2RlRGVmLCBxdWVyeVZhbHVlVHlwZSkge1xuICAgIGlmIChxdWVyeVZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIGEgbWF0Y2hcbiAgICAgICAgc3dpdGNoIChxdWVyeVZhbHVlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIFJlbmRlckVsZW1lbnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzRWxlbWVudERhdGEodmlldywgbm9kZURlZi5ub2RlSW5kZXgpLnJlbmRlckVsZW1lbnQ7XG4gICAgICAgICAgICBjYXNlIDAgLyogRWxlbWVudFJlZiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRSZWYoYXNFbGVtZW50RGF0YSh2aWV3LCBub2RlRGVmLm5vZGVJbmRleCkucmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBjYXNlIDIgLyogVGVtcGxhdGVSZWYgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzRWxlbWVudERhdGEodmlldywgbm9kZURlZi5ub2RlSW5kZXgpLnRlbXBsYXRlO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFZpZXdDb250YWluZXJSZWYgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzRWxlbWVudERhdGEodmlldywgbm9kZURlZi5ub2RlSW5kZXgpLnZpZXdDb250YWluZXI7XG4gICAgICAgICAgICBjYXNlIDQgLyogUHJvdmlkZXIgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzUHJvdmlkZXJEYXRhKHZpZXcsIG5vZGVEZWYubm9kZUluZGV4KS5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbmdDb250ZW50RGVmKG5nQ29udGVudEluZGV4LCBpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIHdpbGwgYmV0IHNldCBieSB0aGUgdmlldyBkZWZpbml0aW9uXG4gICAgICAgIG5vZGVJbmRleDogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcmVuZGVyUGFyZW50OiBudWxsLFxuICAgICAgICBiaW5kaW5nSW5kZXg6IC0xLFxuICAgICAgICBvdXRwdXRJbmRleDogLTEsXG4gICAgICAgIC8vIHJlZ3VsYXIgdmFsdWVzXG4gICAgICAgIGNoZWNrSW5kZXg6IC0xLFxuICAgICAgICBmbGFnczogOCAvKiBUeXBlTmdDb250ZW50ICovLFxuICAgICAgICBjaGlsZEZsYWdzOiAwLFxuICAgICAgICBkaXJlY3RDaGlsZEZsYWdzOiAwLFxuICAgICAgICBjaGlsZE1hdGNoZWRRdWVyaWVzOiAwLFxuICAgICAgICBtYXRjaGVkUXVlcmllczoge30sXG4gICAgICAgIG1hdGNoZWRRdWVyeUlkczogMCxcbiAgICAgICAgcmVmZXJlbmNlczoge30sIG5nQ29udGVudEluZGV4OiBuZ0NvbnRlbnRJbmRleCxcbiAgICAgICAgY2hpbGRDb3VudDogMCxcbiAgICAgICAgYmluZGluZ3M6IFtdLFxuICAgICAgICBiaW5kaW5nRmxhZ3M6IDAsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICBwcm92aWRlcjogbnVsbCxcbiAgICAgICAgdGV4dDogbnVsbCxcbiAgICAgICAgcXVlcnk6IG51bGwsXG4gICAgICAgIG5nQ29udGVudDogeyBpbmRleDogaW5kZXggfVxuICAgIH07XG59XG5mdW5jdGlvbiBhcHBlbmROZ0NvbnRlbnQodmlldywgcmVuZGVySG9zdCwgZGVmKSB7XG4gICAgdmFyIHBhcmVudEVsID0gZ2V0UGFyZW50UmVuZGVyRWxlbWVudCh2aWV3LCByZW5kZXJIb3N0LCBkZWYpO1xuICAgIGlmICghcGFyZW50RWwpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmdDb250ZW50SW5kZXggPSBkZWYubmdDb250ZW50LmluZGV4O1xuICAgIHZpc2l0UHJvamVjdGVkUmVuZGVyTm9kZXModmlldywgbmdDb250ZW50SW5kZXgsIDEgLyogQXBwZW5kQ2hpbGQgKi8sIHBhcmVudEVsLCBudWxsLCB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBwdXJlUGlwZURlZihjaGVja0luZGV4LCBhcmdDb3VudCkge1xuICAgIC8vIGFyZ0NvdW50ICsgMSB0byBpbmNsdWRlIHRoZSBwaXBlIGFzIGZpcnN0IGFyZ1xuICAgIHJldHVybiBfcHVyZUV4cHJlc3Npb25EZWYoMTI4IC8qIFR5cGVQdXJlUGlwZSAqLywgY2hlY2tJbmRleCwgbmV3IEFycmF5KGFyZ0NvdW50ICsgMSkpO1xufVxuZnVuY3Rpb24gcHVyZUFycmF5RGVmKGNoZWNrSW5kZXgsIGFyZ0NvdW50KSB7XG4gICAgcmV0dXJuIF9wdXJlRXhwcmVzc2lvbkRlZigzMiAvKiBUeXBlUHVyZUFycmF5ICovLCBjaGVja0luZGV4LCBuZXcgQXJyYXkoYXJnQ291bnQpKTtcbn1cbmZ1bmN0aW9uIHB1cmVPYmplY3REZWYoY2hlY2tJbmRleCwgcHJvcFRvSW5kZXgpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BUb0luZGV4KTtcbiAgICB2YXIgbmJLZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHByb3BlcnR5TmFtZXMgPSBuZXcgQXJyYXkobmJLZXlzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iS2V5czsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgaW5kZXggPSBwcm9wVG9JbmRleFtrZXldO1xuICAgICAgICBwcm9wZXJ0eU5hbWVzW2luZGV4XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIF9wdXJlRXhwcmVzc2lvbkRlZig2NCAvKiBUeXBlUHVyZU9iamVjdCAqLywgY2hlY2tJbmRleCwgcHJvcGVydHlOYW1lcyk7XG59XG5mdW5jdGlvbiBfcHVyZUV4cHJlc3Npb25EZWYoZmxhZ3MsIGNoZWNrSW5kZXgsIHByb3BlcnR5TmFtZXMpIHtcbiAgICB2YXIgYmluZGluZ3MgPSBuZXcgQXJyYXkocHJvcGVydHlOYW1lcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIGJpbmRpbmdzW2ldID0ge1xuICAgICAgICAgICAgZmxhZ3M6IDggLyogVHlwZVByb3BlcnR5ICovLFxuICAgICAgICAgICAgbmFtZTogcHJvcCxcbiAgICAgICAgICAgIG5zOiBudWxsLFxuICAgICAgICAgICAgbm9uTWluaWZpZWROYW1lOiBwcm9wLFxuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgc3VmZml4OiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIHdpbGwgYmV0IHNldCBieSB0aGUgdmlldyBkZWZpbml0aW9uXG4gICAgICAgIG5vZGVJbmRleDogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgcmVuZGVyUGFyZW50OiBudWxsLFxuICAgICAgICBiaW5kaW5nSW5kZXg6IC0xLFxuICAgICAgICBvdXRwdXRJbmRleDogLTEsXG4gICAgICAgIC8vIHJlZ3VsYXIgdmFsdWVzXG4gICAgICAgIGNoZWNrSW5kZXg6IGNoZWNrSW5kZXgsXG4gICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgY2hpbGRGbGFnczogMCxcbiAgICAgICAgZGlyZWN0Q2hpbGRGbGFnczogMCxcbiAgICAgICAgY2hpbGRNYXRjaGVkUXVlcmllczogMCxcbiAgICAgICAgbWF0Y2hlZFF1ZXJpZXM6IHt9LFxuICAgICAgICBtYXRjaGVkUXVlcnlJZHM6IDAsXG4gICAgICAgIHJlZmVyZW5jZXM6IHt9LFxuICAgICAgICBuZ0NvbnRlbnRJbmRleDogLTEsXG4gICAgICAgIGNoaWxkQ291bnQ6IDAsIGJpbmRpbmdzOiBiaW5kaW5ncyxcbiAgICAgICAgYmluZGluZ0ZsYWdzOiBjYWxjQmluZGluZ0ZsYWdzKGJpbmRpbmdzKSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgbmdDb250ZW50OiBudWxsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVB1cmVFeHByZXNzaW9uKHZpZXcsIGRlZikge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrQW5kVXBkYXRlUHVyZUV4cHJlc3Npb25JbmxpbmUodmlldywgZGVmLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSkge1xuICAgIHZhciBiaW5kaW5ncyA9IGRlZi5iaW5kaW5ncztcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBiaW5kTGVuID0gYmluZGluZ3MubGVuZ3RoO1xuICAgIGlmIChiaW5kTGVuID4gMCAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCAwLCB2MCkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gMSAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCAxLCB2MSkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gMiAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCAyLCB2MikpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gMyAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCAzLCB2MykpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNCAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA0LCB2NCkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNSAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA1LCB2NSkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNiAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA2LCB2NikpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gNyAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA3LCB2NykpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gOCAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA4LCB2OCkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChiaW5kTGVuID4gOSAmJiBjaGVja0FuZFVwZGF0ZUJpbmRpbmcodmlldywgZGVmLCA5LCB2OSkpXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXNQdXJlRXhwcmVzc2lvbkRhdGEodmlldywgZGVmLm5vZGVJbmRleCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgc3dpdGNoIChkZWYuZmxhZ3MgJiAyMDEzNDcwNjcgLyogVHlwZXMgKi8pIHtcbiAgICAgICAgICAgIGNhc2UgMzIgLyogVHlwZVB1cmVBcnJheSAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBcnJheShiaW5kaW5ncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gMClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMF0gPSB2MDtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDEpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdID0gdjE7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiAyKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVsyXSA9IHYyO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gMylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbM10gPSB2MztcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzRdID0gdjQ7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiA1KVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVs1XSA9IHY1O1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gNilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbNl0gPSB2NjtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDcpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzddID0gdjc7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiA4KVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVs4XSA9IHY4O1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gOSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbOV0gPSB2OTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjQgLyogVHlwZVB1cmVPYmplY3QgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDApXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2JpbmRpbmdzWzBdLm5hbWVdID0gdjA7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiAxKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtiaW5kaW5nc1sxXS5uYW1lXSA9IHYxO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gMilcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbYmluZGluZ3NbMl0ubmFtZV0gPSB2MjtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDMpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2JpbmRpbmdzWzNdLm5hbWVdID0gdjM7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtiaW5kaW5nc1s0XS5uYW1lXSA9IHY0O1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gNSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbYmluZGluZ3NbNV0ubmFtZV0gPSB2NTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDYpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2JpbmRpbmdzWzZdLm5hbWVdID0gdjY7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRMZW4gPiA3KVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtiaW5kaW5nc1s3XS5uYW1lXSA9IHY3O1xuICAgICAgICAgICAgICAgIGlmIChiaW5kTGVuID4gOClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbYmluZGluZ3NbOF0ubmFtZV0gPSB2ODtcbiAgICAgICAgICAgICAgICBpZiAoYmluZExlbiA+IDkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2JpbmRpbmdzWzldLm5hbWVdID0gdjk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOCAvKiBUeXBlUHVyZVBpcGUgKi86XG4gICAgICAgICAgICAgICAgdmFyIHBpcGUgPSB2MDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJpbmRMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSwgdjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGlwZS50cmFuc2Zvcm0odjEsIHYyLCB2Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSwgdjIsIHYzLCB2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSwgdjIsIHYzLCB2NCwgdjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGlwZS50cmFuc2Zvcm0odjEsIHYyLCB2MywgdjQsIHY1LCB2Nik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwaXBlLnRyYW5zZm9ybSh2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBpcGUudHJhbnNmb3JtKHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBjaGVja0FuZFVwZGF0ZVB1cmVFeHByZXNzaW9uRHluYW1pYyh2aWV3LCBkZWYsIHZhbHVlcykge1xuICAgIHZhciBiaW5kaW5ncyA9IGRlZi5iaW5kaW5ncztcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gbG9vcCBvdmVyIGFsbCB2YWx1ZXMsIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIG9sZCB2YWx1ZXMgYXJlIHVwZGF0ZXMgYXMgd2VsbCFcbiAgICAgICAgaWYgKGNoZWNrQW5kVXBkYXRlQmluZGluZyh2aWV3LCBkZWYsIGksIHZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXNQdXJlRXhwcmVzc2lvbkRhdGEodmlldywgZGVmLm5vZGVJbmRleCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgc3dpdGNoIChkZWYuZmxhZ3MgJiAyMDEzNDcwNjcgLyogVHlwZXMgKi8pIHtcbiAgICAgICAgICAgIGNhc2UgMzIgLyogVHlwZVB1cmVBcnJheSAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjQgLyogVHlwZVB1cmVPYmplY3QgKi86XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtiaW5kaW5nc1tpXS5uYW1lXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOCAvKiBUeXBlUHVyZVBpcGUgKi86XG4gICAgICAgICAgICAgICAgdmFyIHBpcGUgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBpcGUudHJhbnNmb3JtLmFwcGx5KHBpcGUsIF9fc3ByZWFkKHBhcmFtcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHRleHREZWYoY2hlY2tJbmRleCwgbmdDb250ZW50SW5kZXgsIHN0YXRpY1RleHQpIHtcbiAgICB2YXIgYmluZGluZ3MgPSBuZXcgQXJyYXkoc3RhdGljVGV4dC5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0YXRpY1RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmluZGluZ3NbaSAtIDFdID0ge1xuICAgICAgICAgICAgZmxhZ3M6IDggLyogVHlwZVByb3BlcnR5ICovLFxuICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgIG5zOiBudWxsLFxuICAgICAgICAgICAgbm9uTWluaWZpZWROYW1lOiBudWxsLFxuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgc3VmZml4OiBzdGF0aWNUZXh0W2ldLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyB3aWxsIGJldCBzZXQgYnkgdGhlIHZpZXcgZGVmaW5pdGlvblxuICAgICAgICBub2RlSW5kZXg6IC0xLFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIHJlbmRlclBhcmVudDogbnVsbCxcbiAgICAgICAgYmluZGluZ0luZGV4OiAtMSxcbiAgICAgICAgb3V0cHV0SW5kZXg6IC0xLFxuICAgICAgICAvLyByZWd1bGFyIHZhbHVlc1xuICAgICAgICBjaGVja0luZGV4OiBjaGVja0luZGV4LFxuICAgICAgICBmbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgY2hpbGRGbGFnczogMCxcbiAgICAgICAgZGlyZWN0Q2hpbGRGbGFnczogMCxcbiAgICAgICAgY2hpbGRNYXRjaGVkUXVlcmllczogMCxcbiAgICAgICAgbWF0Y2hlZFF1ZXJpZXM6IHt9LFxuICAgICAgICBtYXRjaGVkUXVlcnlJZHM6IDAsXG4gICAgICAgIHJlZmVyZW5jZXM6IHt9LCBuZ0NvbnRlbnRJbmRleDogbmdDb250ZW50SW5kZXgsXG4gICAgICAgIGNoaWxkQ291bnQ6IDAsIGJpbmRpbmdzOiBiaW5kaW5ncyxcbiAgICAgICAgYmluZGluZ0ZsYWdzOiA4IC8qIFR5cGVQcm9wZXJ0eSAqLyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICB0ZXh0OiB7IHByZWZpeDogc3RhdGljVGV4dFswXSB9LFxuICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgbmdDb250ZW50OiBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0KHZpZXcsIHJlbmRlckhvc3QsIGRlZikge1xuICAgIHZhciByZW5kZXJOb2RlJCQxO1xuICAgIHZhciByZW5kZXJlciA9IHZpZXcucmVuZGVyZXI7XG4gICAgcmVuZGVyTm9kZSQkMSA9IHJlbmRlcmVyLmNyZWF0ZVRleHQoZGVmLnRleHQucHJlZml4KTtcbiAgICB2YXIgcGFyZW50RWwgPSBnZXRQYXJlbnRSZW5kZXJFbGVtZW50KHZpZXcsIHJlbmRlckhvc3QsIGRlZik7XG4gICAgaWYgKHBhcmVudEVsKSB7XG4gICAgICAgIHJlbmRlcmVyLmFwcGVuZENoaWxkKHBhcmVudEVsLCByZW5kZXJOb2RlJCQxKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyVGV4dDogcmVuZGVyTm9kZSQkMSB9O1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVUZXh0SW5saW5lKHZpZXcsIGRlZiwgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpIHtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBiaW5kaW5ncyA9IGRlZi5iaW5kaW5ncztcbiAgICB2YXIgYmluZExlbiA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICBpZiAoYmluZExlbiA+IDAgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgMCwgdjApKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDEgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgMSwgdjEpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDIgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgMiwgdjIpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDMgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgMywgdjMpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDQgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgNCwgdjQpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDUgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgNSwgdjUpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDYgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgNiwgdjYpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDcgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgNywgdjcpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDggJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgOCwgdjgpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoYmluZExlbiA+IDkgJiYgY2hlY2tBbmRVcGRhdGVCaW5kaW5nKHZpZXcsIGRlZiwgOSwgdjkpKVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWYudGV4dC5wcmVmaXg7XG4gICAgICAgIGlmIChiaW5kTGVuID4gMClcbiAgICAgICAgICAgIHZhbHVlICs9IF9hZGRJbnRlcnBvbGF0aW9uUGFydCh2MCwgYmluZGluZ3NbMF0pO1xuICAgICAgICBpZiAoYmluZExlbiA+IDEpXG4gICAgICAgICAgICB2YWx1ZSArPSBfYWRkSW50ZXJwb2xhdGlvblBhcnQodjEsIGJpbmRpbmdzWzFdKTtcbiAgICAgICAgaWYgKGJpbmRMZW4gPiAyKVxuICAgICAgICAgICAgdmFsdWUgKz0gX2FkZEludGVycG9sYXRpb25QYXJ0KHYyLCBiaW5kaW5nc1syXSk7XG4gICAgICAgIGlmIChiaW5kTGVuID4gMylcbiAgICAgICAgICAgIHZhbHVlICs9IF9hZGRJbnRlcnBvbGF0aW9uUGFydCh2MywgYmluZGluZ3NbM10pO1xuICAgICAgICBpZiAoYmluZExlbiA+IDQpXG4gICAgICAgICAgICB2YWx1ZSArPSBfYWRkSW50ZXJwb2xhdGlvblBhcnQodjQsIGJpbmRpbmdzWzRdKTtcbiAgICAgICAgaWYgKGJpbmRMZW4gPiA1KVxuICAgICAgICAgICAgdmFsdWUgKz0gX2FkZEludGVycG9sYXRpb25QYXJ0KHY1LCBiaW5kaW5nc1s1XSk7XG4gICAgICAgIGlmIChiaW5kTGVuID4gNilcbiAgICAgICAgICAgIHZhbHVlICs9IF9hZGRJbnRlcnBvbGF0aW9uUGFydCh2NiwgYmluZGluZ3NbNl0pO1xuICAgICAgICBpZiAoYmluZExlbiA+IDcpXG4gICAgICAgICAgICB2YWx1ZSArPSBfYWRkSW50ZXJwb2xhdGlvblBhcnQodjcsIGJpbmRpbmdzWzddKTtcbiAgICAgICAgaWYgKGJpbmRMZW4gPiA4KVxuICAgICAgICAgICAgdmFsdWUgKz0gX2FkZEludGVycG9sYXRpb25QYXJ0KHY4LCBiaW5kaW5nc1s4XSk7XG4gICAgICAgIGlmIChiaW5kTGVuID4gOSlcbiAgICAgICAgICAgIHZhbHVlICs9IF9hZGRJbnRlcnBvbGF0aW9uUGFydCh2OSwgYmluZGluZ3NbOV0pO1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSQkMSA9IGFzVGV4dERhdGEodmlldywgZGVmLm5vZGVJbmRleCkucmVuZGVyVGV4dDtcbiAgICAgICAgdmlldy5yZW5kZXJlci5zZXRWYWx1ZShyZW5kZXJOb2RlJCQxLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVUZXh0RHluYW1pYyh2aWV3LCBkZWYsIHZhbHVlcykge1xuICAgIHZhciBiaW5kaW5ncyA9IGRlZi5iaW5kaW5ncztcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gbG9vcCBvdmVyIGFsbCB2YWx1ZXMsIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIG9sZCB2YWx1ZXMgYXJlIHVwZGF0ZXMgYXMgd2VsbCFcbiAgICAgICAgaWYgKGNoZWNrQW5kVXBkYXRlQmluZGluZyh2aWV3LCBkZWYsIGksIHZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIF9hZGRJbnRlcnBvbGF0aW9uUGFydCh2YWx1ZXNbaV0sIGJpbmRpbmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGRlZi50ZXh0LnByZWZpeCArIHZhbHVlO1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSQkMSA9IGFzVGV4dERhdGEodmlldywgZGVmLm5vZGVJbmRleCkucmVuZGVyVGV4dDtcbiAgICAgICAgdmlldy5yZW5kZXJlci5zZXRWYWx1ZShyZW5kZXJOb2RlJCQxLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gX2FkZEludGVycG9sYXRpb25QYXJ0KHZhbHVlLCBiaW5kaW5nKSB7XG4gICAgdmFyIHZhbHVlU3RyID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcbiAgICByZXR1cm4gdmFsdWVTdHIgKyBiaW5kaW5nLnN1ZmZpeDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gdmlld0RlZihmbGFncywgbm9kZXMsIHVwZGF0ZURpcmVjdGl2ZXMsIHVwZGF0ZVJlbmRlcmVyKSB7XG4gICAgLy8gY2xvbmUgbm9kZXMgYW5kIHNldCBhdXRvIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgdmFyIHZpZXdCaW5kaW5nQ291bnQgPSAwO1xuICAgIHZhciB2aWV3RGlzcG9zYWJsZUNvdW50ID0gMDtcbiAgICB2YXIgdmlld05vZGVGbGFncyA9IDA7XG4gICAgdmFyIHZpZXdSb290Tm9kZUZsYWdzID0gMDtcbiAgICB2YXIgdmlld01hdGNoZWRRdWVyaWVzID0gMDtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRSZW5kZXJQYXJlbnQgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RWxlbWVudEhhc1B1YmxpY1Byb3ZpZGVycyA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50RWxlbWVudEhhc1ByaXZhdGVQcm92aWRlcnMgPSBmYWxzZTtcbiAgICB2YXIgbGFzdFJlbmRlclJvb3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIG5vZGUubm9kZUluZGV4ID0gaTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICBub2RlLmJpbmRpbmdJbmRleCA9IHZpZXdCaW5kaW5nQ291bnQ7XG4gICAgICAgIG5vZGUub3V0cHV0SW5kZXggPSB2aWV3RGlzcG9zYWJsZUNvdW50O1xuICAgICAgICBub2RlLnJlbmRlclBhcmVudCA9IGN1cnJlbnRSZW5kZXJQYXJlbnQ7XG4gICAgICAgIHZpZXdOb2RlRmxhZ3MgfD0gbm9kZS5mbGFncztcbiAgICAgICAgdmlld01hdGNoZWRRdWVyaWVzIHw9IG5vZGUubWF0Y2hlZFF1ZXJ5SWRzO1xuICAgICAgICBpZiAobm9kZS5lbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZWxEZWYgPSBub2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICBlbERlZi5wdWJsaWNQcm92aWRlcnMgPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPyBjdXJyZW50UGFyZW50LmVsZW1lbnQucHVibGljUHJvdmlkZXJzIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGVsRGVmLmFsbFByb3ZpZGVycyA9IGVsRGVmLnB1YmxpY1Byb3ZpZGVycztcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFzc3VtZSB0aGF0IGFsbCBwcm92aWRlcnMgb2YgYW4gZWxlbWVudCBhcmUgYmVmb3JlIGFueSBjaGlsZCBlbGVtZW50IVxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnRIYXNQdWJsaWNQcm92aWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50SGFzUHJpdmF0ZVByb3ZpZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5vZGUuZWxlbWVudC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZpZXdNYXRjaGVkUXVlcmllcyB8PSBub2RlLmVsZW1lbnQudGVtcGxhdGUubm9kZU1hdGNoZWRRdWVyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlTm9kZShjdXJyZW50UGFyZW50LCBub2RlLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICB2aWV3QmluZGluZ0NvdW50ICs9IG5vZGUuYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICB2aWV3RGlzcG9zYWJsZUNvdW50ICs9IG5vZGUub3V0cHV0cy5sZW5ndGg7XG4gICAgICAgIGlmICghY3VycmVudFJlbmRlclBhcmVudCAmJiAobm9kZS5mbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLykpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSb290Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZmxhZ3MgJiAyMDIyNCAvKiBDYXRQcm92aWRlciAqLykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50RWxlbWVudEhhc1B1YmxpY1Byb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50SGFzUHVibGljUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgcHJvdG90eXBpY2FsIGluaGVyaXRhbmNlIHRvIG5vdCBnZXQgTyhuXjIpIGNvbXBsZXhpdHkuLi5cbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmVsZW1lbnQucHVibGljUHJvdmlkZXJzID1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjdXJyZW50UGFyZW50LmVsZW1lbnQucHVibGljUHJvdmlkZXJzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmVsZW1lbnQuYWxsUHJvdmlkZXJzID0gY3VycmVudFBhcmVudC5lbGVtZW50LnB1YmxpY1Byb3ZpZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc1ByaXZhdGVTZXJ2aWNlID0gKG5vZGUuZmxhZ3MgJiA4MTkyIC8qIFByaXZhdGVQcm92aWRlciAqLykgIT09IDA7XG4gICAgICAgICAgICB2YXIgaXNDb21wb25lbnQgPSAobm9kZS5mbGFncyAmIDMyNzY4IC8qIENvbXBvbmVudCAqLykgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWlzUHJpdmF0ZVNlcnZpY2UgfHwgaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmVsZW1lbnQucHVibGljUHJvdmlkZXJzW3Rva2VuS2V5KG5vZGUucHJvdmlkZXIudG9rZW4pXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRFbGVtZW50SGFzUHJpdmF0ZVByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudEhhc1ByaXZhdGVQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJvdG90eXBpY2FsIGluaGVyaXRhbmNlIHRvIG5vdCBnZXQgTyhuXjIpIGNvbXBsZXhpdHkuLi5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5lbGVtZW50LmFsbFByb3ZpZGVycyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnJlbnRQYXJlbnQuZWxlbWVudC5wdWJsaWNQcm92aWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmVsZW1lbnQuYWxsUHJvdmlkZXJzW3Rva2VuS2V5KG5vZGUucHJvdmlkZXIudG9rZW4pXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmVsZW1lbnQuY29tcG9uZW50UHJvdmlkZXIgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkRmxhZ3MgfD0gbm9kZS5mbGFncztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQuZGlyZWN0Q2hpbGRGbGFncyB8PSBub2RlLmZsYWdzO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZE1hdGNoZWRRdWVyaWVzIHw9IG5vZGUubWF0Y2hlZFF1ZXJ5SWRzO1xuICAgICAgICAgICAgaWYgKG5vZGUuZWxlbWVudCAmJiBub2RlLmVsZW1lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkTWF0Y2hlZFF1ZXJpZXMgfD0gbm9kZS5lbGVtZW50LnRlbXBsYXRlLm5vZGVNYXRjaGVkUXVlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdSb290Tm9kZUZsYWdzIHw9IG5vZGUuZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgaWYgKCFpc05nQ29udGFpbmVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlbmRlclBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBjdXJyZW50IG5vZGUgaGFzIG5vIGNoaWxkcmVuLCBjaGVjayBpZiBpdCBpcyB0aGUgbGFzdCBjaGlsZHJlbiBvZiBpdHMgcGFyZW50LlxuICAgICAgICAgICAgLy8gV2hlbiBpdCBpcywgcHJvcGFnYXRlIHRoZSBmbGFncyB1cC5cbiAgICAgICAgICAgIC8vIFRoZSBsb29wIGlzIHJlcXVpcmVkIGJlY2F1c2UgYW4gZWxlbWVudCBjb3VsZCBiZSB0aGUgbGFzdCB0cmFuc2l0aXZlIGNoaWxkcmVuIG9mIHNldmVyYWxcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzLiBXZSBsb29wIHRvIGVpdGhlciB0aGUgcm9vdCBvciB0aGUgaGlnaGVzdCBvcGVuZWQgZWxlbWVudCAoPSB3aXRoIHJlbWFpbmluZ1xuICAgICAgICAgICAgLy8gY2hpbGRyZW4pXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudFBhcmVudCAmJiBpID09PSBjdXJyZW50UGFyZW50Lm5vZGVJbmRleCArIGN1cnJlbnRQYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudC5jaGlsZEZsYWdzIHw9IGN1cnJlbnRQYXJlbnQuY2hpbGRGbGFncztcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50LmNoaWxkTWF0Y2hlZFF1ZXJpZXMgfD0gY3VycmVudFBhcmVudC5jaGlsZE1hdGNoZWRRdWVyaWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byB1cGRhdGUgdGhlIHJlbmRlciBwYXJlbnQgJiBhY2NvdW50IGZvciBuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCAmJiBpc05nQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJQYXJlbnQgPSBjdXJyZW50UGFyZW50LnJlbmRlclBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJQYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAodmlldywgbm9kZUluZGV4LCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBub2Rlc1tub2RlSW5kZXhdLmVsZW1lbnQuaGFuZGxlRXZlbnQodmlldywgZXZlbnROYW1lLCBldmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBXaWxsIGJlIGZpbGxlZCBsYXRlci4uLlxuICAgICAgICBmYWN0b3J5OiBudWxsLFxuICAgICAgICBub2RlRmxhZ3M6IHZpZXdOb2RlRmxhZ3MsXG4gICAgICAgIHJvb3ROb2RlRmxhZ3M6IHZpZXdSb290Tm9kZUZsYWdzLFxuICAgICAgICBub2RlTWF0Y2hlZFF1ZXJpZXM6IHZpZXdNYXRjaGVkUXVlcmllcywgZmxhZ3M6IGZsYWdzLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHVwZGF0ZURpcmVjdGl2ZXM6IHVwZGF0ZURpcmVjdGl2ZXMgfHwgTk9PUCxcbiAgICAgICAgdXBkYXRlUmVuZGVyZXI6IHVwZGF0ZVJlbmRlcmVyIHx8IE5PT1AsIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudCxcbiAgICAgICAgYmluZGluZ0NvdW50OiB2aWV3QmluZGluZ0NvdW50LFxuICAgICAgICBvdXRwdXRDb3VudDogdmlld0Rpc3Bvc2FibGVDb3VudCwgbGFzdFJlbmRlclJvb3ROb2RlOiBsYXN0UmVuZGVyUm9vdE5vZGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNOZ0NvbnRhaW5lcihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmZsYWdzICYgMSAvKiBUeXBlRWxlbWVudCAqLykgIT09IDAgJiYgbm9kZS5lbGVtZW50Lm5hbWUgPT09IG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5vZGUocGFyZW50LCBub2RlLCBub2RlQ291bnQpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBub2RlLmVsZW1lbnQgJiYgbm9kZS5lbGVtZW50LnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoIXRlbXBsYXRlLmxhc3RSZW5kZXJSb290Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogRW1iZWRkZWQgdGVtcGxhdGVzIHdpdGhvdXQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcGxhdGUubGFzdFJlbmRlclJvb3ROb2RlICYmXG4gICAgICAgICAgICB0ZW1wbGF0ZS5sYXN0UmVuZGVyUm9vdE5vZGUuZmxhZ3MgJiAxNjc3NzIxNiAvKiBFbWJlZGRlZFZpZXdzICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBMYXN0IHJvb3Qgbm9kZSBvZiBhIHRlbXBsYXRlIGNhbid0IGhhdmUgZW1iZWRkZWQgdmlld3MsIGF0IGluZGV4IFwiICsgbm9kZS5ub2RlSW5kZXggKyBcIiFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuZmxhZ3MgJiAyMDIyNCAvKiBDYXRQcm92aWRlciAqLykge1xuICAgICAgICB2YXIgcGFyZW50RmxhZ3MgPSBwYXJlbnQgPyBwYXJlbnQuZmxhZ3MgOiAwO1xuICAgICAgICBpZiAoKHBhcmVudEZsYWdzICYgMSAvKiBUeXBlRWxlbWVudCAqLykgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IFN0YXRpY1Byb3ZpZGVyL0RpcmVjdGl2ZSBub2RlcyBuZWVkIHRvIGJlIGNoaWxkcmVuIG9mIGVsZW1lbnRzIG9yIGFuY2hvcnMsIGF0IGluZGV4IFwiICsgbm9kZS5ub2RlSW5kZXggKyBcIiFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucXVlcnkpIHtcbiAgICAgICAgaWYgKG5vZGUuZmxhZ3MgJiA2NzEwODg2NCAvKiBUeXBlQ29udGVudFF1ZXJ5ICovICYmXG4gICAgICAgICAgICAoIXBhcmVudCB8fCAocGFyZW50LmZsYWdzICYgMTYzODQgLyogVHlwZURpcmVjdGl2ZSAqLykgPT09IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBDb250ZW50IFF1ZXJ5IG5vZGVzIG5lZWQgdG8gYmUgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcywgYXQgaW5kZXggXCIgKyBub2RlLm5vZGVJbmRleCArIFwiIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5mbGFncyAmIDEzNDIxNzcyOCAvKiBUeXBlVmlld1F1ZXJ5ICovICYmIHBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogVmlldyBRdWVyeSBub2RlcyBoYXZlIHRvIGJlIHRvcCBsZXZlbCBub2RlcywgYXQgaW5kZXggXCIgKyBub2RlLm5vZGVJbmRleCArIFwiIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZENvdW50KSB7XG4gICAgICAgIHZhciBwYXJlbnRFbmQgPSBwYXJlbnQgPyBwYXJlbnQubm9kZUluZGV4ICsgcGFyZW50LmNoaWxkQ291bnQgOiBub2RlQ291bnQgLSAxO1xuICAgICAgICBpZiAobm9kZS5ub2RlSW5kZXggPD0gcGFyZW50RW5kICYmIG5vZGUubm9kZUluZGV4ICsgbm9kZS5jaGlsZENvdW50ID4gcGFyZW50RW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBjaGlsZENvdW50IG9mIG5vZGUgbGVhZHMgb3V0c2lkZSBvZiBwYXJlbnQsIGF0IGluZGV4IFwiICsgbm9kZS5ub2RlSW5kZXggKyBcIiFcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRlZFZpZXcocGFyZW50LCBhbmNob3JEZWYkJDEsIHZpZXdEZWYsIGNvbnRleHQpIHtcbiAgICAvLyBlbWJlZGRlZCB2aWV3cyBhcmUgc2VlbiBhcyBzaWJsaW5ncyB0byB0aGUgYW5jaG9yLCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZ2V0IHRoZSBwYXJlbnQgb2YgdGhlIGFuY2hvciBhbmQgdXNlIGl0IGFzIHBhcmVudEluZGV4LlxuICAgIHZhciB2aWV3ID0gY3JlYXRlVmlldyhwYXJlbnQucm9vdCwgcGFyZW50LnJlbmRlcmVyLCBwYXJlbnQsIGFuY2hvckRlZiQkMSwgdmlld0RlZik7XG4gICAgaW5pdFZpZXcodmlldywgcGFyZW50LmNvbXBvbmVudCwgY29udGV4dCk7XG4gICAgY3JlYXRlVmlld05vZGVzKHZpZXcpO1xuICAgIHJldHVybiB2aWV3O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdFZpZXcocm9vdCwgZGVmLCBjb250ZXh0KSB7XG4gICAgdmFyIHZpZXcgPSBjcmVhdGVWaWV3KHJvb3QsIHJvb3QucmVuZGVyZXIsIG51bGwsIG51bGwsIGRlZik7XG4gICAgaW5pdFZpZXcodmlldywgY29udGV4dCwgY29udGV4dCk7XG4gICAgY3JlYXRlVmlld05vZGVzKHZpZXcpO1xuICAgIHJldHVybiB2aWV3O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50VmlldyhwYXJlbnRWaWV3LCBub2RlRGVmLCB2aWV3RGVmLCBob3N0RWxlbWVudCkge1xuICAgIHZhciByZW5kZXJlclR5cGUgPSBub2RlRGVmLmVsZW1lbnQuY29tcG9uZW50UmVuZGVyZXJUeXBlO1xuICAgIHZhciBjb21wUmVuZGVyZXI7XG4gICAgaWYgKCFyZW5kZXJlclR5cGUpIHtcbiAgICAgICAgY29tcFJlbmRlcmVyID0gcGFyZW50Vmlldy5yb290LnJlbmRlcmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29tcFJlbmRlcmVyID0gcGFyZW50Vmlldy5yb290LnJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihob3N0RWxlbWVudCwgcmVuZGVyZXJUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZpZXcocGFyZW50Vmlldy5yb290LCBjb21wUmVuZGVyZXIsIHBhcmVudFZpZXcsIG5vZGVEZWYuZWxlbWVudC5jb21wb25lbnRQcm92aWRlciwgdmlld0RlZik7XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3KHJvb3QsIHJlbmRlcmVyLCBwYXJlbnQsIHBhcmVudE5vZGVEZWYsIGRlZikge1xuICAgIHZhciBub2RlcyA9IG5ldyBBcnJheShkZWYubm9kZXMubGVuZ3RoKTtcbiAgICB2YXIgZGlzcG9zYWJsZXMgPSBkZWYub3V0cHV0Q291bnQgPyBuZXcgQXJyYXkoZGVmLm91dHB1dENvdW50KSA6IG51bGw7XG4gICAgdmFyIHZpZXcgPSB7XG4gICAgICAgIGRlZjogZGVmLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgdmlld0NvbnRhaW5lclBhcmVudDogbnVsbCwgcGFyZW50Tm9kZURlZjogcGFyZW50Tm9kZURlZixcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgY29tcG9uZW50OiBudWxsLCBub2Rlczogbm9kZXMsXG4gICAgICAgIHN0YXRlOiAxMyAvKiBDYXRJbml0ICovLCByb290OiByb290LCByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgICAgIG9sZFZhbHVlczogbmV3IEFycmF5KGRlZi5iaW5kaW5nQ291bnQpLCBkaXNwb3NhYmxlczogZGlzcG9zYWJsZXMsXG4gICAgICAgIGluaXRJbmRleDogLTFcbiAgICB9O1xuICAgIHJldHVybiB2aWV3O1xufVxuZnVuY3Rpb24gaW5pdFZpZXcodmlldywgY29tcG9uZW50LCBjb250ZXh0KSB7XG4gICAgdmlldy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgdmlldy5jb250ZXh0ID0gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdOb2Rlcyh2aWV3KSB7XG4gICAgdmFyIHJlbmRlckhvc3Q7XG4gICAgaWYgKGlzQ29tcG9uZW50Vmlldyh2aWV3KSkge1xuICAgICAgICB2YXIgaG9zdERlZiA9IHZpZXcucGFyZW50Tm9kZURlZjtcbiAgICAgICAgcmVuZGVySG9zdCA9IGFzRWxlbWVudERhdGEodmlldy5wYXJlbnQsIGhvc3REZWYucGFyZW50Lm5vZGVJbmRleCkucmVuZGVyRWxlbWVudDtcbiAgICB9XG4gICAgdmFyIGRlZiA9IHZpZXcuZGVmO1xuICAgIHZhciBub2RlcyA9IHZpZXcubm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVEZWYgPSBkZWYubm9kZXNbaV07XG4gICAgICAgIFNlcnZpY2VzLnNldEN1cnJlbnROb2RlKHZpZXcsIGkpO1xuICAgICAgICB2YXIgbm9kZURhdGEgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAobm9kZURlZi5mbGFncyAmIDIwMTM0NzA2NyAvKiBUeXBlcyAqLykge1xuICAgICAgICAgICAgY2FzZSAxIC8qIFR5cGVFbGVtZW50ICovOlxuICAgICAgICAgICAgICAgIHZhciBlbCA9IGNyZWF0ZUVsZW1lbnQodmlldywgcmVuZGVySG9zdCwgbm9kZURlZik7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiAzMzU1NDQzMiAvKiBDb21wb25lbnRWaWV3ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wVmlld0RlZiA9IHJlc29sdmVEZWZpbml0aW9uKG5vZGVEZWYuZWxlbWVudC5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50VmlldyA9IFNlcnZpY2VzLmNyZWF0ZUNvbXBvbmVudFZpZXcodmlldywgbm9kZURlZiwgY29tcFZpZXdEZWYsIGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuVG9FbGVtZW50T3V0cHV0cyh2aWV3LCBjb21wb25lbnRWaWV3LCBub2RlRGVmLCBlbCk7XG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckVsZW1lbnQ6IGVsLFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRWaWV3OiBjb21wb25lbnRWaWV3LFxuICAgICAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbm9kZURlZi5lbGVtZW50LnRlbXBsYXRlID8gY3JlYXRlVGVtcGxhdGVEYXRhKHZpZXcsIG5vZGVEZWYpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDE2Nzc3MjE2IC8qIEVtYmVkZGVkVmlld3MgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZURhdGEudmlld0NvbnRhaW5lciA9IGNyZWF0ZVZpZXdDb250YWluZXJEYXRhKHZpZXcsIG5vZGVEZWYsIG5vZGVEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogVHlwZVRleHQgKi86XG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSBjcmVhdGVUZXh0KHZpZXcsIHJlbmRlckhvc3QsIG5vZGVEZWYpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1MTIgLyogVHlwZUNsYXNzUHJvdmlkZXIgKi86XG4gICAgICAgICAgICBjYXNlIDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLzpcbiAgICAgICAgICAgIGNhc2UgMjA0OCAvKiBUeXBlVXNlRXhpc3RpbmdQcm92aWRlciAqLzpcbiAgICAgICAgICAgIGNhc2UgMjU2IC8qIFR5cGVWYWx1ZVByb3ZpZGVyICovOiB7XG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVEYXRhICYmICEobm9kZURlZi5mbGFncyAmIDQwOTYgLyogTGF6eVByb3ZpZGVyICovKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVQcm92aWRlckluc3RhbmNlKHZpZXcsIG5vZGVEZWYpO1xuICAgICAgICAgICAgICAgICAgICBub2RlRGF0YSA9IHsgaW5zdGFuY2U6IGluc3RhbmNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxNiAvKiBUeXBlUGlwZSAqLzoge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZVBpcGVJbnN0YW5jZSh2aWV3LCBub2RlRGVmKTtcbiAgICAgICAgICAgICAgICBub2RlRGF0YSA9IHsgaW5zdGFuY2U6IGluc3RhbmNlIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDE2Mzg0IC8qIFR5cGVEaXJlY3RpdmUgKi86IHtcbiAgICAgICAgICAgICAgICBub2RlRGF0YSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGlyZWN0aXZlSW5zdGFuY2Uodmlldywgbm9kZURlZik7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVEYXRhID0geyBpbnN0YW5jZTogaW5zdGFuY2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiAzMjc2OCAvKiBDb21wb25lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBWaWV3ID0gYXNFbGVtZW50RGF0YSh2aWV3LCBub2RlRGVmLnBhcmVudC5ub2RlSW5kZXgpLmNvbXBvbmVudFZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGluaXRWaWV3KGNvbXBWaWV3LCBub2RlRGF0YS5pbnN0YW5jZSwgbm9kZURhdGEuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMzIgLyogVHlwZVB1cmVBcnJheSAqLzpcbiAgICAgICAgICAgIGNhc2UgNjQgLyogVHlwZVB1cmVPYmplY3QgKi86XG4gICAgICAgICAgICBjYXNlIDEyOCAvKiBUeXBlUHVyZVBpcGUgKi86XG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSBjcmVhdGVQdXJlRXhwcmVzc2lvbih2aWV3LCBub2RlRGVmKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjcxMDg4NjQgLyogVHlwZUNvbnRlbnRRdWVyeSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTM0MjE3NzI4IC8qIFR5cGVWaWV3UXVlcnkgKi86XG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSBjcmVhdGVRdWVyeSQxKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDggLyogVHlwZU5nQ29udGVudCAqLzpcbiAgICAgICAgICAgICAgICBhcHBlbmROZ0NvbnRlbnQodmlldywgcmVuZGVySG9zdCwgbm9kZURlZik7XG4gICAgICAgICAgICAgICAgLy8gbm8gcnVudGltZSBkYXRhIG5lZWRlZCBmb3IgTmdDb250ZW50Li4uXG4gICAgICAgICAgICAgICAgbm9kZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZXNbaV0gPSBub2RlRGF0YTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHRoZSBWaWV3RGF0YS5ub2RlcyBvZiBjb21wb25lbnQgdmlld3MgYWZ0ZXIgd2UgY3JlYXRlZCBldmVyeXRoaW5nIGVsc2UsXG4gICAgLy8gc28gdGhhdCBlLmcuIG5nLWNvbnRlbnQgd29ya3NcbiAgICBleGVjQ29tcG9uZW50Vmlld3NBY3Rpb24odmlldywgVmlld0FjdGlvbi5DcmVhdGVWaWV3Tm9kZXMpO1xuICAgIC8vIGZpbGwgc3RhdGljIGNvbnRlbnQgYW5kIHZpZXcgcXVlcmllc1xuICAgIGV4ZWNRdWVyaWVzQWN0aW9uKHZpZXcsIDY3MTA4ODY0IC8qIFR5cGVDb250ZW50UXVlcnkgKi8gfCAxMzQyMTc3MjggLyogVHlwZVZpZXdRdWVyeSAqLywgMjY4NDM1NDU2IC8qIFN0YXRpY1F1ZXJ5ICovLCAwIC8qIENoZWNrQW5kVXBkYXRlICovKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTm9DaGFuZ2VzVmlldyh2aWV3KSB7XG4gICAgbWFya1Byb2plY3RlZFZpZXdzRm9yQ2hlY2sodmlldyk7XG4gICAgU2VydmljZXMudXBkYXRlRGlyZWN0aXZlcyh2aWV3LCAxIC8qIENoZWNrTm9DaGFuZ2VzICovKTtcbiAgICBleGVjRW1iZWRkZWRWaWV3c0FjdGlvbih2aWV3LCBWaWV3QWN0aW9uLkNoZWNrTm9DaGFuZ2VzKTtcbiAgICBTZXJ2aWNlcy51cGRhdGVSZW5kZXJlcih2aWV3LCAxIC8qIENoZWNrTm9DaGFuZ2VzICovKTtcbiAgICBleGVjQ29tcG9uZW50Vmlld3NBY3Rpb24odmlldywgVmlld0FjdGlvbi5DaGVja05vQ2hhbmdlcyk7XG4gICAgLy8gTm90ZTogV2UgZG9uJ3QgY2hlY2sgcXVlcmllcyBmb3IgY2hhbmdlcyBhcyB3ZSBkaWRuJ3QgZG8gdGhpcyBpbiB2Mi54LlxuICAgIC8vIFRPRE8odGJvc2NoKTogaW52ZXN0aWdhdGUgaWYgd2UgY2FuIGVuYWJsZSB0aGUgY2hlY2sgYWdhaW4gaW4gdjUueCB3aXRoIGEgbmljZXIgZXJyb3IgbWVzc2FnZS5cbiAgICB2aWV3LnN0YXRlICY9IH4oNjQgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3cyAqLyB8IDMyIC8qIENoZWNrUHJvamVjdGVkVmlldyAqLyk7XG59XG5mdW5jdGlvbiBjaGVja0FuZFVwZGF0ZVZpZXcodmlldykge1xuICAgIGlmICh2aWV3LnN0YXRlICYgMSAvKiBCZWZvcmVGaXJzdENoZWNrICovKSB7XG4gICAgICAgIHZpZXcuc3RhdGUgJj0gfjEgLyogQmVmb3JlRmlyc3RDaGVjayAqLztcbiAgICAgICAgdmlldy5zdGF0ZSB8PSAyIC8qIEZpcnN0Q2hlY2sgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnN0YXRlICY9IH4yIC8qIEZpcnN0Q2hlY2sgKi87XG4gICAgfVxuICAgIHNoaWZ0SW5pdFN0YXRlKHZpZXcsIDAgLyogSW5pdFN0YXRlX0JlZm9yZUluaXQgKi8sIDI1NiAvKiBJbml0U3RhdGVfQ2FsbGluZ09uSW5pdCAqLyk7XG4gICAgbWFya1Byb2plY3RlZFZpZXdzRm9yQ2hlY2sodmlldyk7XG4gICAgU2VydmljZXMudXBkYXRlRGlyZWN0aXZlcyh2aWV3LCAwIC8qIENoZWNrQW5kVXBkYXRlICovKTtcbiAgICBleGVjRW1iZWRkZWRWaWV3c0FjdGlvbih2aWV3LCBWaWV3QWN0aW9uLkNoZWNrQW5kVXBkYXRlKTtcbiAgICBleGVjUXVlcmllc0FjdGlvbih2aWV3LCA2NzEwODg2NCAvKiBUeXBlQ29udGVudFF1ZXJ5ICovLCA1MzY4NzA5MTIgLyogRHluYW1pY1F1ZXJ5ICovLCAwIC8qIENoZWNrQW5kVXBkYXRlICovKTtcbiAgICB2YXIgY2FsbEluaXQgPSBzaGlmdEluaXRTdGF0ZSh2aWV3LCAyNTYgLyogSW5pdFN0YXRlX0NhbGxpbmdPbkluaXQgKi8sIDUxMiAvKiBJbml0U3RhdGVfQ2FsbGluZ0FmdGVyQ29udGVudEluaXQgKi8pO1xuICAgIGNhbGxMaWZlY3ljbGVIb29rc0NoaWxkcmVuRmlyc3QodmlldywgMjA5NzE1MiAvKiBBZnRlckNvbnRlbnRDaGVja2VkICovIHwgKGNhbGxJbml0ID8gMTA0ODU3NiAvKiBBZnRlckNvbnRlbnRJbml0ICovIDogMCkpO1xuICAgIFNlcnZpY2VzLnVwZGF0ZVJlbmRlcmVyKHZpZXcsIDAgLyogQ2hlY2tBbmRVcGRhdGUgKi8pO1xuICAgIGV4ZWNDb21wb25lbnRWaWV3c0FjdGlvbih2aWV3LCBWaWV3QWN0aW9uLkNoZWNrQW5kVXBkYXRlKTtcbiAgICBleGVjUXVlcmllc0FjdGlvbih2aWV3LCAxMzQyMTc3MjggLyogVHlwZVZpZXdRdWVyeSAqLywgNTM2ODcwOTEyIC8qIER5bmFtaWNRdWVyeSAqLywgMCAvKiBDaGVja0FuZFVwZGF0ZSAqLyk7XG4gICAgY2FsbEluaXQgPSBzaGlmdEluaXRTdGF0ZSh2aWV3LCA1MTIgLyogSW5pdFN0YXRlX0NhbGxpbmdBZnRlckNvbnRlbnRJbml0ICovLCA3NjggLyogSW5pdFN0YXRlX0NhbGxpbmdBZnRlclZpZXdJbml0ICovKTtcbiAgICBjYWxsTGlmZWN5Y2xlSG9va3NDaGlsZHJlbkZpcnN0KHZpZXcsIDgzODg2MDggLyogQWZ0ZXJWaWV3Q2hlY2tlZCAqLyB8IChjYWxsSW5pdCA/IDQxOTQzMDQgLyogQWZ0ZXJWaWV3SW5pdCAqLyA6IDApKTtcbiAgICBpZiAodmlldy5kZWYuZmxhZ3MgJiAyIC8qIE9uUHVzaCAqLykge1xuICAgICAgICB2aWV3LnN0YXRlICY9IH44IC8qIENoZWNrc0VuYWJsZWQgKi87XG4gICAgfVxuICAgIHZpZXcuc3RhdGUgJj0gfig2NCAvKiBDaGVja1Byb2plY3RlZFZpZXdzICovIHwgMzIgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3ICovKTtcbiAgICBzaGlmdEluaXRTdGF0ZSh2aWV3LCA3NjggLyogSW5pdFN0YXRlX0NhbGxpbmdBZnRlclZpZXdJbml0ICovLCAxMDI0IC8qIEluaXRTdGF0ZV9BZnRlckluaXQgKi8pO1xufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVOb2RlKHZpZXcsIG5vZGVEZWYsIGFyZ1N0eWxlLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSkge1xuICAgIGlmIChhcmdTdHlsZSA9PT0gMCAvKiBJbmxpbmUgKi8pIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQW5kVXBkYXRlTm9kZUlubGluZSh2aWV3LCBub2RlRGVmLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hlY2tBbmRVcGRhdGVOb2RlRHluYW1pYyh2aWV3LCBub2RlRGVmLCB2MCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya1Byb2plY3RlZFZpZXdzRm9yQ2hlY2sodmlldykge1xuICAgIHZhciBkZWYgPSB2aWV3LmRlZjtcbiAgICBpZiAoIShkZWYubm9kZUZsYWdzICYgNCAvKiBQcm9qZWN0ZWRUZW1wbGF0ZSAqLykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZURlZiA9IGRlZi5ub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiA0IC8qIFByb2plY3RlZFRlbXBsYXRlICovKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkVmlld3MgPSBhc0VsZW1lbnREYXRhKHZpZXcsIGkpLnRlbXBsYXRlLl9wcm9qZWN0ZWRWaWV3cztcbiAgICAgICAgICAgIGlmIChwcm9qZWN0ZWRWaWV3cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IHByb2plY3RlZFZpZXdzLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZFZpZXcgPSBwcm9qZWN0ZWRWaWV3c1tpXzFdO1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0ZWRWaWV3LnN0YXRlIHw9IDMyIC8qIENoZWNrUHJvamVjdGVkVmlldyAqLztcbiAgICAgICAgICAgICAgICAgICAgbWFya1BhcmVudFZpZXdzRm9yQ2hlY2tQcm9qZWN0ZWRWaWV3cyhwcm9qZWN0ZWRWaWV3LCB2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG5vZGVEZWYuY2hpbGRGbGFncyAmIDQgLyogUHJvamVjdGVkVGVtcGxhdGUgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAvLyBhIHBhcmVudCB3aXRoIGxlYWZzXG4gICAgICAgICAgICAvLyBubyBjaGlsZCBpcyBhIGNvbXBvbmVudCxcbiAgICAgICAgICAgIC8vIHRoZW4gc2tpcCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tBbmRVcGRhdGVOb2RlSW5saW5lKHZpZXcsIG5vZGVEZWYsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KSB7XG4gICAgc3dpdGNoIChub2RlRGVmLmZsYWdzICYgMjAxMzQ3MDY3IC8qIFR5cGVzICovKSB7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlRWxlbWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0FuZFVwZGF0ZUVsZW1lbnRJbmxpbmUodmlldywgbm9kZURlZiwgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpO1xuICAgICAgICBjYXNlIDIgLyogVHlwZVRleHQgKi86XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tBbmRVcGRhdGVUZXh0SW5saW5lKHZpZXcsIG5vZGVEZWYsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KTtcbiAgICAgICAgY2FzZSAxNjM4NCAvKiBUeXBlRGlyZWN0aXZlICovOlxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrQW5kVXBkYXRlRGlyZWN0aXZlSW5saW5lKHZpZXcsIG5vZGVEZWYsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KTtcbiAgICAgICAgY2FzZSAzMiAvKiBUeXBlUHVyZUFycmF5ICovOlxuICAgICAgICBjYXNlIDY0IC8qIFR5cGVQdXJlT2JqZWN0ICovOlxuICAgICAgICBjYXNlIDEyOCAvKiBUeXBlUHVyZVBpcGUgKi86XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tBbmRVcGRhdGVQdXJlRXhwcmVzc2lvbklubGluZSh2aWV3LCBub2RlRGVmLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAndW5yZWFjaGFibGUnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQW5kVXBkYXRlTm9kZUR5bmFtaWModmlldywgbm9kZURlZiwgdmFsdWVzKSB7XG4gICAgc3dpdGNoIChub2RlRGVmLmZsYWdzICYgMjAxMzQ3MDY3IC8qIFR5cGVzICovKSB7XG4gICAgICAgIGNhc2UgMSAvKiBUeXBlRWxlbWVudCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0FuZFVwZGF0ZUVsZW1lbnREeW5hbWljKHZpZXcsIG5vZGVEZWYsIHZhbHVlcyk7XG4gICAgICAgIGNhc2UgMiAvKiBUeXBlVGV4dCAqLzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0FuZFVwZGF0ZVRleHREeW5hbWljKHZpZXcsIG5vZGVEZWYsIHZhbHVlcyk7XG4gICAgICAgIGNhc2UgMTYzODQgLyogVHlwZURpcmVjdGl2ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiBjaGVja0FuZFVwZGF0ZURpcmVjdGl2ZUR5bmFtaWModmlldywgbm9kZURlZiwgdmFsdWVzKTtcbiAgICAgICAgY2FzZSAzMiAvKiBUeXBlUHVyZUFycmF5ICovOlxuICAgICAgICBjYXNlIDY0IC8qIFR5cGVQdXJlT2JqZWN0ICovOlxuICAgICAgICBjYXNlIDEyOCAvKiBUeXBlUHVyZVBpcGUgKi86XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tBbmRVcGRhdGVQdXJlRXhwcmVzc2lvbkR5bmFtaWModmlldywgbm9kZURlZiwgdmFsdWVzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICd1bnJlYWNoYWJsZSc7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0NoYW5nZXNOb2RlKHZpZXcsIG5vZGVEZWYsIGFyZ1N0eWxlLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSkge1xuICAgIGlmIChhcmdTdHlsZSA9PT0gMCAvKiBJbmxpbmUgKi8pIHtcbiAgICAgICAgY2hlY2tOb0NoYW5nZXNOb2RlSW5saW5lKHZpZXcsIG5vZGVEZWYsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoZWNrTm9DaGFuZ2VzTm9kZUR5bmFtaWModmlldywgbm9kZURlZiwgdjApO1xuICAgIH1cbiAgICAvLyBSZXR1cm5pbmcgZmFsc2UgaXMgb2sgaGVyZSBhcyB3ZSB3b3VsZCBoYXZlIHRocm93biBpbiBjYXNlIG9mIGEgY2hhbmdlLlxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrTm9DaGFuZ2VzTm9kZUlubGluZSh2aWV3LCBub2RlRGVmLCB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSkge1xuICAgIHZhciBiaW5kTGVuID0gbm9kZURlZi5iaW5kaW5ncy5sZW5ndGg7XG4gICAgaWYgKGJpbmRMZW4gPiAwKVxuICAgICAgICBjaGVja0JpbmRpbmdOb0NoYW5nZXModmlldywgbm9kZURlZiwgMCwgdjApO1xuICAgIGlmIChiaW5kTGVuID4gMSlcbiAgICAgICAgY2hlY2tCaW5kaW5nTm9DaGFuZ2VzKHZpZXcsIG5vZGVEZWYsIDEsIHYxKTtcbiAgICBpZiAoYmluZExlbiA+IDIpXG4gICAgICAgIGNoZWNrQmluZGluZ05vQ2hhbmdlcyh2aWV3LCBub2RlRGVmLCAyLCB2Mik7XG4gICAgaWYgKGJpbmRMZW4gPiAzKVxuICAgICAgICBjaGVja0JpbmRpbmdOb0NoYW5nZXModmlldywgbm9kZURlZiwgMywgdjMpO1xuICAgIGlmIChiaW5kTGVuID4gNClcbiAgICAgICAgY2hlY2tCaW5kaW5nTm9DaGFuZ2VzKHZpZXcsIG5vZGVEZWYsIDQsIHY0KTtcbiAgICBpZiAoYmluZExlbiA+IDUpXG4gICAgICAgIGNoZWNrQmluZGluZ05vQ2hhbmdlcyh2aWV3LCBub2RlRGVmLCA1LCB2NSk7XG4gICAgaWYgKGJpbmRMZW4gPiA2KVxuICAgICAgICBjaGVja0JpbmRpbmdOb0NoYW5nZXModmlldywgbm9kZURlZiwgNiwgdjYpO1xuICAgIGlmIChiaW5kTGVuID4gNylcbiAgICAgICAgY2hlY2tCaW5kaW5nTm9DaGFuZ2VzKHZpZXcsIG5vZGVEZWYsIDcsIHY3KTtcbiAgICBpZiAoYmluZExlbiA+IDgpXG4gICAgICAgIGNoZWNrQmluZGluZ05vQ2hhbmdlcyh2aWV3LCBub2RlRGVmLCA4LCB2OCk7XG4gICAgaWYgKGJpbmRMZW4gPiA5KVxuICAgICAgICBjaGVja0JpbmRpbmdOb0NoYW5nZXModmlldywgbm9kZURlZiwgOSwgdjkpO1xufVxuZnVuY3Rpb24gY2hlY2tOb0NoYW5nZXNOb2RlRHluYW1pYyh2aWV3LCBub2RlRGVmLCB2YWx1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja0JpbmRpbmdOb0NoYW5nZXModmlldywgbm9kZURlZiwgaSwgdmFsdWVzW2ldKTtcbiAgICB9XG59XG4vKipcbiAqIFdvcmthcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvdHNpY2tsZS9pc3N1ZXMvNDk3XG4gKiBAc3VwcHJlc3Mge21pc3BsYWNlZFR5cGVBbm5vdGF0aW9ufVxuICovXG5mdW5jdGlvbiBjaGVja05vQ2hhbmdlc1F1ZXJ5KHZpZXcsIG5vZGVEZWYpIHtcbiAgICB2YXIgcXVlcnlMaXN0ID0gYXNRdWVyeUxpc3Qodmlldywgbm9kZURlZi5ub2RlSW5kZXgpO1xuICAgIGlmIChxdWVyeUxpc3QuZGlydHkpIHtcbiAgICAgICAgdGhyb3cgZXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcihTZXJ2aWNlcy5jcmVhdGVEZWJ1Z0NvbnRleHQodmlldywgbm9kZURlZi5ub2RlSW5kZXgpLCBcIlF1ZXJ5IFwiICsgbm9kZURlZi5xdWVyeS5pZCArIFwiIG5vdCBkaXJ0eVwiLCBcIlF1ZXJ5IFwiICsgbm9kZURlZi5xdWVyeS5pZCArIFwiIGRpcnR5XCIsICh2aWV3LnN0YXRlICYgMSAvKiBCZWZvcmVGaXJzdENoZWNrICovKSAhPT0gMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzdHJveVZpZXcodmlldykge1xuICAgIGlmICh2aWV3LnN0YXRlICYgMTI4IC8qIERlc3Ryb3llZCAqLykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGV4ZWNFbWJlZGRlZFZpZXdzQWN0aW9uKHZpZXcsIFZpZXdBY3Rpb24uRGVzdHJveSk7XG4gICAgZXhlY0NvbXBvbmVudFZpZXdzQWN0aW9uKHZpZXcsIFZpZXdBY3Rpb24uRGVzdHJveSk7XG4gICAgY2FsbExpZmVjeWNsZUhvb2tzQ2hpbGRyZW5GaXJzdCh2aWV3LCAxMzEwNzIgLyogT25EZXN0cm95ICovKTtcbiAgICBpZiAodmlldy5kaXNwb3NhYmxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcuZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcG9zYWJsZXNbaV0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXRhY2hQcm9qZWN0ZWRWaWV3KHZpZXcpO1xuICAgIGlmICh2aWV3LnJlbmRlcmVyLmRlc3Ryb3lOb2RlKSB7XG4gICAgICAgIGRlc3Ryb3lWaWV3Tm9kZXModmlldyk7XG4gICAgfVxuICAgIGlmIChpc0NvbXBvbmVudFZpZXcodmlldykpIHtcbiAgICAgICAgdmlldy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHZpZXcuc3RhdGUgfD0gMTI4IC8qIERlc3Ryb3llZCAqLztcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lWaWV3Tm9kZXModmlldykge1xuICAgIHZhciBsZW4gPSB2aWV3LmRlZi5ub2Rlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZGVmID0gdmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgIGlmIChkZWYuZmxhZ3MgJiAxIC8qIFR5cGVFbGVtZW50ICovKSB7XG4gICAgICAgICAgICB2aWV3LnJlbmRlcmVyLmRlc3Ryb3lOb2RlKGFzRWxlbWVudERhdGEodmlldywgaSkucmVuZGVyRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVmLmZsYWdzICYgMiAvKiBUeXBlVGV4dCAqLykge1xuICAgICAgICAgICAgdmlldy5yZW5kZXJlci5kZXN0cm95Tm9kZShhc1RleHREYXRhKHZpZXcsIGkpLnJlbmRlclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlZi5mbGFncyAmIDY3MTA4ODY0IC8qIFR5cGVDb250ZW50UXVlcnkgKi8gfHwgZGVmLmZsYWdzICYgMTM0MjE3NzI4IC8qIFR5cGVWaWV3UXVlcnkgKi8pIHtcbiAgICAgICAgICAgIGFzUXVlcnlMaXN0KHZpZXcsIGkpLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBWaWV3QWN0aW9uO1xuKGZ1bmN0aW9uIChWaWV3QWN0aW9uKSB7XG4gICAgVmlld0FjdGlvbltWaWV3QWN0aW9uW1wiQ3JlYXRlVmlld05vZGVzXCJdID0gMF0gPSBcIkNyZWF0ZVZpZXdOb2Rlc1wiO1xuICAgIFZpZXdBY3Rpb25bVmlld0FjdGlvbltcIkNoZWNrTm9DaGFuZ2VzXCJdID0gMV0gPSBcIkNoZWNrTm9DaGFuZ2VzXCI7XG4gICAgVmlld0FjdGlvbltWaWV3QWN0aW9uW1wiQ2hlY2tOb0NoYW5nZXNQcm9qZWN0ZWRWaWV3c1wiXSA9IDJdID0gXCJDaGVja05vQ2hhbmdlc1Byb2plY3RlZFZpZXdzXCI7XG4gICAgVmlld0FjdGlvbltWaWV3QWN0aW9uW1wiQ2hlY2tBbmRVcGRhdGVcIl0gPSAzXSA9IFwiQ2hlY2tBbmRVcGRhdGVcIjtcbiAgICBWaWV3QWN0aW9uW1ZpZXdBY3Rpb25bXCJDaGVja0FuZFVwZGF0ZVByb2plY3RlZFZpZXdzXCJdID0gNF0gPSBcIkNoZWNrQW5kVXBkYXRlUHJvamVjdGVkVmlld3NcIjtcbiAgICBWaWV3QWN0aW9uW1ZpZXdBY3Rpb25bXCJEZXN0cm95XCJdID0gNV0gPSBcIkRlc3Ryb3lcIjtcbn0pKFZpZXdBY3Rpb24gfHwgKFZpZXdBY3Rpb24gPSB7fSkpO1xuZnVuY3Rpb24gZXhlY0NvbXBvbmVudFZpZXdzQWN0aW9uKHZpZXcsIGFjdGlvbikge1xuICAgIHZhciBkZWYgPSB2aWV3LmRlZjtcbiAgICBpZiAoIShkZWYubm9kZUZsYWdzICYgMzM1NTQ0MzIgLyogQ29tcG9uZW50VmlldyAqLykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZURlZiA9IGRlZi5ub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGVEZWYuZmxhZ3MgJiAzMzU1NDQzMiAvKiBDb21wb25lbnRWaWV3ICovKSB7XG4gICAgICAgICAgICAvLyBhIGxlYWZcbiAgICAgICAgICAgIGNhbGxWaWV3QWN0aW9uKGFzRWxlbWVudERhdGEodmlldywgaSkuY29tcG9uZW50VmlldywgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobm9kZURlZi5jaGlsZEZsYWdzICYgMzM1NTQ0MzIgLyogQ29tcG9uZW50VmlldyAqLykgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGEgcGFyZW50IHdpdGggbGVhZnNcbiAgICAgICAgICAgIC8vIG5vIGNoaWxkIGlzIGEgY29tcG9uZW50LFxuICAgICAgICAgICAgLy8gdGhlbiBza2lwIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgaSArPSBub2RlRGVmLmNoaWxkQ291bnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBleGVjRW1iZWRkZWRWaWV3c0FjdGlvbih2aWV3LCBhY3Rpb24pIHtcbiAgICB2YXIgZGVmID0gdmlldy5kZWY7XG4gICAgaWYgKCEoZGVmLm5vZGVGbGFncyAmIDE2Nzc3MjE2IC8qIEVtYmVkZGVkVmlld3MgKi8pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWYubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVEZWYgPSBkZWYubm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgMTY3NzcyMTYgLyogRW1iZWRkZWRWaWV3cyAqLykge1xuICAgICAgICAgICAgLy8gYSBsZWFmXG4gICAgICAgICAgICB2YXIgZW1iZWRkZWRWaWV3cyA9IGFzRWxlbWVudERhdGEodmlldywgaSkudmlld0NvbnRhaW5lci5fZW1iZWRkZWRWaWV3cztcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZW1iZWRkZWRWaWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGNhbGxWaWV3QWN0aW9uKGVtYmVkZGVkVmlld3Nba10sIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG5vZGVEZWYuY2hpbGRGbGFncyAmIDE2Nzc3MjE2IC8qIEVtYmVkZGVkVmlld3MgKi8pID09PSAwKSB7XG4gICAgICAgICAgICAvLyBhIHBhcmVudCB3aXRoIGxlYWZzXG4gICAgICAgICAgICAvLyBubyBjaGlsZCBpcyBhIGNvbXBvbmVudCxcbiAgICAgICAgICAgIC8vIHRoZW4gc2tpcCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGkgKz0gbm9kZURlZi5jaGlsZENvdW50O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbFZpZXdBY3Rpb24odmlldywgYWN0aW9uKSB7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgY2FzZSBWaWV3QWN0aW9uLkNoZWNrTm9DaGFuZ2VzOlxuICAgICAgICAgICAgaWYgKCh2aWV3U3RhdGUgJiAxMjggLyogRGVzdHJveWVkICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgodmlld1N0YXRlICYgMTIgLyogQ2F0RGV0ZWN0Q2hhbmdlcyAqLykgPT09IDEyIC8qIENhdERldGVjdENoYW5nZXMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb0NoYW5nZXNWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3U3RhdGUgJiA2NCAvKiBDaGVja1Byb2plY3RlZFZpZXdzICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNQcm9qZWN0ZWRWaWV3c0FjdGlvbih2aWV3LCBWaWV3QWN0aW9uLkNoZWNrTm9DaGFuZ2VzUHJvamVjdGVkVmlld3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZpZXdBY3Rpb24uQ2hlY2tOb0NoYW5nZXNQcm9qZWN0ZWRWaWV3czpcbiAgICAgICAgICAgIGlmICgodmlld1N0YXRlICYgMTI4IC8qIERlc3Ryb3llZCAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld1N0YXRlICYgMzIgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTm9DaGFuZ2VzVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmlld1N0YXRlICYgNjQgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3cyAqLykge1xuICAgICAgICAgICAgICAgICAgICBleGVjUHJvamVjdGVkVmlld3NBY3Rpb24odmlldywgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWaWV3QWN0aW9uLkNoZWNrQW5kVXBkYXRlOlxuICAgICAgICAgICAgaWYgKCh2aWV3U3RhdGUgJiAxMjggLyogRGVzdHJveWVkICovKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgodmlld1N0YXRlICYgMTIgLyogQ2F0RGV0ZWN0Q2hhbmdlcyAqLykgPT09IDEyIC8qIENhdERldGVjdENoYW5nZXMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbmRVcGRhdGVWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3U3RhdGUgJiA2NCAvKiBDaGVja1Byb2plY3RlZFZpZXdzICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNQcm9qZWN0ZWRWaWV3c0FjdGlvbih2aWV3LCBWaWV3QWN0aW9uLkNoZWNrQW5kVXBkYXRlUHJvamVjdGVkVmlld3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZpZXdBY3Rpb24uQ2hlY2tBbmRVcGRhdGVQcm9qZWN0ZWRWaWV3czpcbiAgICAgICAgICAgIGlmICgodmlld1N0YXRlICYgMTI4IC8qIERlc3Ryb3llZCAqLykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld1N0YXRlICYgMzIgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW5kVXBkYXRlVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmlld1N0YXRlICYgNjQgLyogQ2hlY2tQcm9qZWN0ZWRWaWV3cyAqLykge1xuICAgICAgICAgICAgICAgICAgICBleGVjUHJvamVjdGVkVmlld3NBY3Rpb24odmlldywgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWaWV3QWN0aW9uLkRlc3Ryb3k6XG4gICAgICAgICAgICAvLyBOb3RlOiBkZXN0cm95VmlldyByZWN1cnNlcyBvdmVyIGFsbCB2aWV3cyxcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gc3BlY2lhbCBjYXNlIHByb2plY3RlZCB2aWV3cyBoZXJlLlxuICAgICAgICAgICAgZGVzdHJveVZpZXcodmlldyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWaWV3QWN0aW9uLkNyZWF0ZVZpZXdOb2RlczpcbiAgICAgICAgICAgIGNyZWF0ZVZpZXdOb2Rlcyh2aWV3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4ZWNQcm9qZWN0ZWRWaWV3c0FjdGlvbih2aWV3LCBhY3Rpb24pIHtcbiAgICBleGVjRW1iZWRkZWRWaWV3c0FjdGlvbih2aWV3LCBhY3Rpb24pO1xuICAgIGV4ZWNDb21wb25lbnRWaWV3c0FjdGlvbih2aWV3LCBhY3Rpb24pO1xufVxuZnVuY3Rpb24gZXhlY1F1ZXJpZXNBY3Rpb24odmlldywgcXVlcnlGbGFncywgc3RhdGljRHluYW1pY1F1ZXJ5RmxhZywgY2hlY2tUeXBlKSB7XG4gICAgaWYgKCEodmlldy5kZWYubm9kZUZsYWdzICYgcXVlcnlGbGFncykgfHwgISh2aWV3LmRlZi5ub2RlRmxhZ3MgJiBzdGF0aWNEeW5hbWljUXVlcnlGbGFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlQ291bnQgPSB2aWV3LmRlZi5ub2Rlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgbm9kZURlZiA9IHZpZXcuZGVmLm5vZGVzW2ldO1xuICAgICAgICBpZiAoKG5vZGVEZWYuZmxhZ3MgJiBxdWVyeUZsYWdzKSAmJiAobm9kZURlZi5mbGFncyAmIHN0YXRpY0R5bmFtaWNRdWVyeUZsYWcpKSB7XG4gICAgICAgICAgICBTZXJ2aWNlcy5zZXRDdXJyZW50Tm9kZSh2aWV3LCBub2RlRGVmLm5vZGVJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoZWNrVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBDaGVja0FuZFVwZGF0ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBbmRVcGRhdGVRdWVyeSh2aWV3LCBub2RlRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIENoZWNrTm9DaGFuZ2VzICovOlxuICAgICAgICAgICAgICAgICAgICBjaGVja05vQ2hhbmdlc1F1ZXJ5KHZpZXcsIG5vZGVEZWYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIShub2RlRGVmLmNoaWxkRmxhZ3MgJiBxdWVyeUZsYWdzKSB8fCAhKG5vZGVEZWYuY2hpbGRGbGFncyAmIHN0YXRpY0R5bmFtaWNRdWVyeUZsYWcpKSB7XG4gICAgICAgICAgICAvLyBubyBjaGlsZCBoYXMgYSBtYXRjaGluZyBxdWVyeVxuICAgICAgICAgICAgLy8gdGhlbiBza2lwIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgaSArPSBub2RlRGVmLmNoaWxkQ291bnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdFNlcnZpY2VzSWZOZWVkZWQoKSB7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBzZXJ2aWNlcyA9IGlzRGV2TW9kZSgpID8gY3JlYXRlRGVidWdTZXJ2aWNlcygpIDogY3JlYXRlUHJvZFNlcnZpY2VzKCk7XG4gICAgU2VydmljZXMuc2V0Q3VycmVudE5vZGUgPSBzZXJ2aWNlcy5zZXRDdXJyZW50Tm9kZTtcbiAgICBTZXJ2aWNlcy5jcmVhdGVSb290VmlldyA9IHNlcnZpY2VzLmNyZWF0ZVJvb3RWaWV3O1xuICAgIFNlcnZpY2VzLmNyZWF0ZUVtYmVkZGVkVmlldyA9IHNlcnZpY2VzLmNyZWF0ZUVtYmVkZGVkVmlldztcbiAgICBTZXJ2aWNlcy5jcmVhdGVDb21wb25lbnRWaWV3ID0gc2VydmljZXMuY3JlYXRlQ29tcG9uZW50VmlldztcbiAgICBTZXJ2aWNlcy5jcmVhdGVOZ01vZHVsZVJlZiA9IHNlcnZpY2VzLmNyZWF0ZU5nTW9kdWxlUmVmO1xuICAgIFNlcnZpY2VzLm92ZXJyaWRlUHJvdmlkZXIgPSBzZXJ2aWNlcy5vdmVycmlkZVByb3ZpZGVyO1xuICAgIFNlcnZpY2VzLm92ZXJyaWRlQ29tcG9uZW50VmlldyA9IHNlcnZpY2VzLm92ZXJyaWRlQ29tcG9uZW50VmlldztcbiAgICBTZXJ2aWNlcy5jbGVhck92ZXJyaWRlcyA9IHNlcnZpY2VzLmNsZWFyT3ZlcnJpZGVzO1xuICAgIFNlcnZpY2VzLmNoZWNrQW5kVXBkYXRlVmlldyA9IHNlcnZpY2VzLmNoZWNrQW5kVXBkYXRlVmlldztcbiAgICBTZXJ2aWNlcy5jaGVja05vQ2hhbmdlc1ZpZXcgPSBzZXJ2aWNlcy5jaGVja05vQ2hhbmdlc1ZpZXc7XG4gICAgU2VydmljZXMuZGVzdHJveVZpZXcgPSBzZXJ2aWNlcy5kZXN0cm95VmlldztcbiAgICBTZXJ2aWNlcy5yZXNvbHZlRGVwID0gcmVzb2x2ZURlcDtcbiAgICBTZXJ2aWNlcy5jcmVhdGVEZWJ1Z0NvbnRleHQgPSBzZXJ2aWNlcy5jcmVhdGVEZWJ1Z0NvbnRleHQ7XG4gICAgU2VydmljZXMuaGFuZGxlRXZlbnQgPSBzZXJ2aWNlcy5oYW5kbGVFdmVudDtcbiAgICBTZXJ2aWNlcy51cGRhdGVEaXJlY3RpdmVzID0gc2VydmljZXMudXBkYXRlRGlyZWN0aXZlcztcbiAgICBTZXJ2aWNlcy51cGRhdGVSZW5kZXJlciA9IHNlcnZpY2VzLnVwZGF0ZVJlbmRlcmVyO1xuICAgIFNlcnZpY2VzLmRpcnR5UGFyZW50UXVlcmllcyA9IGRpcnR5UGFyZW50UXVlcmllcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2RTZXJ2aWNlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRDdXJyZW50Tm9kZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBjcmVhdGVSb290VmlldzogY3JlYXRlUHJvZFJvb3RWaWV3LFxuICAgICAgICBjcmVhdGVFbWJlZGRlZFZpZXc6IGNyZWF0ZUVtYmVkZGVkVmlldyxcbiAgICAgICAgY3JlYXRlQ29tcG9uZW50VmlldzogY3JlYXRlQ29tcG9uZW50VmlldyxcbiAgICAgICAgY3JlYXRlTmdNb2R1bGVSZWY6IGNyZWF0ZU5nTW9kdWxlUmVmLFxuICAgICAgICBvdmVycmlkZVByb3ZpZGVyOiBOT09QLFxuICAgICAgICBvdmVycmlkZUNvbXBvbmVudFZpZXc6IE5PT1AsXG4gICAgICAgIGNsZWFyT3ZlcnJpZGVzOiBOT09QLFxuICAgICAgICBjaGVja0FuZFVwZGF0ZVZpZXc6IGNoZWNrQW5kVXBkYXRlVmlldyxcbiAgICAgICAgY2hlY2tOb0NoYW5nZXNWaWV3OiBjaGVja05vQ2hhbmdlc1ZpZXcsXG4gICAgICAgIGRlc3Ryb3lWaWV3OiBkZXN0cm95VmlldyxcbiAgICAgICAgY3JlYXRlRGVidWdDb250ZXh0OiBmdW5jdGlvbiAodmlldywgbm9kZUluZGV4KSB7IHJldHVybiBuZXcgRGVidWdDb250ZXh0Xyh2aWV3LCBub2RlSW5kZXgpOyB9LFxuICAgICAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24gKHZpZXcsIG5vZGVJbmRleCwgZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZGVmLmhhbmRsZUV2ZW50KHZpZXcsIG5vZGVJbmRleCwgZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZURpcmVjdGl2ZXM6IGZ1bmN0aW9uICh2aWV3LCBjaGVja1R5cGUpIHsgcmV0dXJuIHZpZXcuZGVmLnVwZGF0ZURpcmVjdGl2ZXMoY2hlY2tUeXBlID09PSAwIC8qIENoZWNrQW5kVXBkYXRlICovID8gcHJvZENoZWNrQW5kVXBkYXRlTm9kZSA6XG4gICAgICAgICAgICBwcm9kQ2hlY2tOb0NoYW5nZXNOb2RlLCB2aWV3KTsgfSxcbiAgICAgICAgdXBkYXRlUmVuZGVyZXI6IGZ1bmN0aW9uICh2aWV3LCBjaGVja1R5cGUpIHsgcmV0dXJuIHZpZXcuZGVmLnVwZGF0ZVJlbmRlcmVyKGNoZWNrVHlwZSA9PT0gMCAvKiBDaGVja0FuZFVwZGF0ZSAqLyA/IHByb2RDaGVja0FuZFVwZGF0ZU5vZGUgOlxuICAgICAgICAgICAgcHJvZENoZWNrTm9DaGFuZ2VzTm9kZSwgdmlldyk7IH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnU2VydmljZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0Q3VycmVudE5vZGU6IGRlYnVnU2V0Q3VycmVudE5vZGUsXG4gICAgICAgIGNyZWF0ZVJvb3RWaWV3OiBkZWJ1Z0NyZWF0ZVJvb3RWaWV3LFxuICAgICAgICBjcmVhdGVFbWJlZGRlZFZpZXc6IGRlYnVnQ3JlYXRlRW1iZWRkZWRWaWV3LFxuICAgICAgICBjcmVhdGVDb21wb25lbnRWaWV3OiBkZWJ1Z0NyZWF0ZUNvbXBvbmVudFZpZXcsXG4gICAgICAgIGNyZWF0ZU5nTW9kdWxlUmVmOiBkZWJ1Z0NyZWF0ZU5nTW9kdWxlUmVmLFxuICAgICAgICBvdmVycmlkZVByb3ZpZGVyOiBkZWJ1Z092ZXJyaWRlUHJvdmlkZXIsXG4gICAgICAgIG92ZXJyaWRlQ29tcG9uZW50VmlldzogZGVidWdPdmVycmlkZUNvbXBvbmVudFZpZXcsXG4gICAgICAgIGNsZWFyT3ZlcnJpZGVzOiBkZWJ1Z0NsZWFyT3ZlcnJpZGVzLFxuICAgICAgICBjaGVja0FuZFVwZGF0ZVZpZXc6IGRlYnVnQ2hlY2tBbmRVcGRhdGVWaWV3LFxuICAgICAgICBjaGVja05vQ2hhbmdlc1ZpZXc6IGRlYnVnQ2hlY2tOb0NoYW5nZXNWaWV3LFxuICAgICAgICBkZXN0cm95VmlldzogZGVidWdEZXN0cm95VmlldyxcbiAgICAgICAgY3JlYXRlRGVidWdDb250ZXh0OiBmdW5jdGlvbiAodmlldywgbm9kZUluZGV4KSB7IHJldHVybiBuZXcgRGVidWdDb250ZXh0Xyh2aWV3LCBub2RlSW5kZXgpOyB9LFxuICAgICAgICBoYW5kbGVFdmVudDogZGVidWdIYW5kbGVFdmVudCxcbiAgICAgICAgdXBkYXRlRGlyZWN0aXZlczogZGVidWdVcGRhdGVEaXJlY3RpdmVzLFxuICAgICAgICB1cGRhdGVSZW5kZXJlcjogZGVidWdVcGRhdGVSZW5kZXJlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZFJvb3RWaWV3KGVsSW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVmLCBuZ01vZHVsZSwgY29udGV4dCkge1xuICAgIHZhciByZW5kZXJlckZhY3RvcnkgPSBuZ01vZHVsZS5pbmplY3Rvci5nZXQoUmVuZGVyZXJGYWN0b3J5Mik7XG4gICAgcmV0dXJuIGNyZWF0ZVJvb3RWaWV3KGNyZWF0ZVJvb3REYXRhKGVsSW5qZWN0b3IsIG5nTW9kdWxlLCByZW5kZXJlckZhY3RvcnksIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSksIGRlZiwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBkZWJ1Z0NyZWF0ZVJvb3RWaWV3KGVsSW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVmLCBuZ01vZHVsZSwgY29udGV4dCkge1xuICAgIHZhciByZW5kZXJlckZhY3RvcnkgPSBuZ01vZHVsZS5pbmplY3Rvci5nZXQoUmVuZGVyZXJGYWN0b3J5Mik7XG4gICAgdmFyIHJvb3QgPSBjcmVhdGVSb290RGF0YShlbEluamVjdG9yLCBuZ01vZHVsZSwgbmV3IERlYnVnUmVuZGVyZXJGYWN0b3J5MihyZW5kZXJlckZhY3RvcnkpLCBwcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpO1xuICAgIHZhciBkZWZXaXRoT3ZlcnJpZGUgPSBhcHBseVByb3ZpZGVyT3ZlcnJpZGVzVG9WaWV3KGRlZik7XG4gICAgcmV0dXJuIGNhbGxXaXRoRGVidWdDb250ZXh0KERlYnVnQWN0aW9uLmNyZWF0ZSwgY3JlYXRlUm9vdFZpZXcsIG51bGwsIFtyb290LCBkZWZXaXRoT3ZlcnJpZGUsIGNvbnRleHRdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3REYXRhKGVsSW5qZWN0b3IsIG5nTW9kdWxlLCByZW5kZXJlckZhY3RvcnksIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgIHZhciBzYW5pdGl6ZXIgPSBuZ01vZHVsZS5pbmplY3Rvci5nZXQoU2FuaXRpemVyKTtcbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gbmdNb2R1bGUuaW5qZWN0b3IuZ2V0KEVycm9ySGFuZGxlcik7XG4gICAgdmFyIHJlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5nTW9kdWxlOiBuZ01vZHVsZSxcbiAgICAgICAgaW5qZWN0b3I6IGVsSW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXM6IHByb2plY3RhYmxlTm9kZXMsXG4gICAgICAgIHNlbGVjdG9yT3JOb2RlOiByb290U2VsZWN0b3JPck5vZGUsIHNhbml0aXplcjogc2FuaXRpemVyLCByZW5kZXJlckZhY3Rvcnk6IHJlbmRlcmVyRmFjdG9yeSwgcmVuZGVyZXI6IHJlbmRlcmVyLCBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlclxuICAgIH07XG59XG5mdW5jdGlvbiBkZWJ1Z0NyZWF0ZUVtYmVkZGVkVmlldyhwYXJlbnRWaWV3LCBhbmNob3JEZWYsIHZpZXdEZWYkJDEsIGNvbnRleHQpIHtcbiAgICB2YXIgZGVmV2l0aE92ZXJyaWRlID0gYXBwbHlQcm92aWRlck92ZXJyaWRlc1RvVmlldyh2aWV3RGVmJCQxKTtcbiAgICByZXR1cm4gY2FsbFdpdGhEZWJ1Z0NvbnRleHQoRGVidWdBY3Rpb24uY3JlYXRlLCBjcmVhdGVFbWJlZGRlZFZpZXcsIG51bGwsIFtwYXJlbnRWaWV3LCBhbmNob3JEZWYsIGRlZldpdGhPdmVycmlkZSwgY29udGV4dF0pO1xufVxuZnVuY3Rpb24gZGVidWdDcmVhdGVDb21wb25lbnRWaWV3KHBhcmVudFZpZXcsIG5vZGVEZWYsIHZpZXdEZWYkJDEsIGhvc3RFbGVtZW50KSB7XG4gICAgdmFyIG92ZXJyaWRlQ29tcG9uZW50VmlldyA9IHZpZXdEZWZPdmVycmlkZXMuZ2V0KG5vZGVEZWYuZWxlbWVudC5jb21wb25lbnRQcm92aWRlci5wcm92aWRlci50b2tlbik7XG4gICAgaWYgKG92ZXJyaWRlQ29tcG9uZW50Vmlldykge1xuICAgICAgICB2aWV3RGVmJCQxID0gb3ZlcnJpZGVDb21wb25lbnRWaWV3O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlld0RlZiQkMSA9IGFwcGx5UHJvdmlkZXJPdmVycmlkZXNUb1ZpZXcodmlld0RlZiQkMSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsV2l0aERlYnVnQ29udGV4dChEZWJ1Z0FjdGlvbi5jcmVhdGUsIGNyZWF0ZUNvbXBvbmVudFZpZXcsIG51bGwsIFtwYXJlbnRWaWV3LCBub2RlRGVmLCB2aWV3RGVmJCQxLCBob3N0RWxlbWVudF0pO1xufVxuZnVuY3Rpb24gZGVidWdDcmVhdGVOZ01vZHVsZVJlZihtb2R1bGVUeXBlLCBwYXJlbnRJbmplY3RvciwgYm9vdHN0cmFwQ29tcG9uZW50cywgZGVmKSB7XG4gICAgdmFyIGRlZldpdGhPdmVycmlkZSA9IGFwcGx5UHJvdmlkZXJPdmVycmlkZXNUb05nTW9kdWxlKGRlZik7XG4gICAgcmV0dXJuIGNyZWF0ZU5nTW9kdWxlUmVmKG1vZHVsZVR5cGUsIHBhcmVudEluamVjdG9yLCBib290c3RyYXBDb21wb25lbnRzLCBkZWZXaXRoT3ZlcnJpZGUpO1xufVxudmFyIHByb3ZpZGVyT3ZlcnJpZGVzID0gbmV3IE1hcCgpO1xudmFyIHByb3ZpZGVyT3ZlcnJpZGVzV2l0aFNjb3BlID0gbmV3IE1hcCgpO1xudmFyIHZpZXdEZWZPdmVycmlkZXMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBkZWJ1Z092ZXJyaWRlUHJvdmlkZXIob3ZlcnJpZGUpIHtcbiAgICBwcm92aWRlck92ZXJyaWRlcy5zZXQob3ZlcnJpZGUudG9rZW4sIG92ZXJyaWRlKTtcbiAgICB2YXIgaW5qZWN0YWJsZURlZjtcbiAgICBpZiAodHlwZW9mIG92ZXJyaWRlLnRva2VuID09PSAnZnVuY3Rpb24nICYmIChpbmplY3RhYmxlRGVmID0gZ2V0SW5qZWN0YWJsZURlZihvdmVycmlkZS50b2tlbikpICYmXG4gICAgICAgIHR5cGVvZiBpbmplY3RhYmxlRGVmLnByb3ZpZGVkSW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvdmlkZXJPdmVycmlkZXNXaXRoU2NvcGUuc2V0KG92ZXJyaWRlLnRva2VuLCBvdmVycmlkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVidWdPdmVycmlkZUNvbXBvbmVudFZpZXcoY29tcCwgY29tcEZhY3RvcnkpIHtcbiAgICB2YXIgaG9zdFZpZXdEZWYgPSByZXNvbHZlRGVmaW5pdGlvbihnZXRDb21wb25lbnRWaWV3RGVmaW5pdGlvbkZhY3RvcnkoY29tcEZhY3RvcnkpKTtcbiAgICB2YXIgY29tcFZpZXdEZWYgPSByZXNvbHZlRGVmaW5pdGlvbihob3N0Vmlld0RlZi5ub2Rlc1swXS5lbGVtZW50LmNvbXBvbmVudFZpZXcpO1xuICAgIHZpZXdEZWZPdmVycmlkZXMuc2V0KGNvbXAsIGNvbXBWaWV3RGVmKTtcbn1cbmZ1bmN0aW9uIGRlYnVnQ2xlYXJPdmVycmlkZXMoKSB7XG4gICAgcHJvdmlkZXJPdmVycmlkZXMuY2xlYXIoKTtcbiAgICBwcm92aWRlck92ZXJyaWRlc1dpdGhTY29wZS5jbGVhcigpO1xuICAgIHZpZXdEZWZPdmVycmlkZXMuY2xlYXIoKTtcbn1cbi8vIE5vdGVzIGFib3V0IHRoZSBhbGdvcml0aG06XG4vLyAxKSBMb2NhdGUgdGhlIHByb3ZpZGVycyBvZiBhbiBlbGVtZW50IGFuZCBjaGVjayBpZiBvbmUgb2YgdGhlbSB3YXMgb3ZlcndyaXR0ZW5cbi8vIDIpIENoYW5nZSB0aGUgcHJvdmlkZXJzIG9mIHRoYXQgZWxlbWVudFxuLy9cbi8vIFdlIG9ubHkgY3JlYXRlIG5ldyBkYXRhc3RydWN0dXJlcyBpZiB3ZSBuZWVkIHRvLCB0byBrZWVwIHBlcmYgaW1wYWN0XG4vLyByZWFzb25hYmxlLlxuZnVuY3Rpb24gYXBwbHlQcm92aWRlck92ZXJyaWRlc1RvVmlldyhkZWYpIHtcbiAgICBpZiAocHJvdmlkZXJPdmVycmlkZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudEluZGljZXNXaXRoT3ZlcndyaXR0ZW5Qcm92aWRlcnMgPSBmaW5kRWxlbWVudEluZGljZXNXaXRoT3ZlcndyaXR0ZW5Qcm92aWRlcnMoZGVmKTtcbiAgICBpZiAoZWxlbWVudEluZGljZXNXaXRoT3ZlcndyaXR0ZW5Qcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICAgIC8vIGNsb25lIHRoZSB3aG9sZSB2aWV3IGRlZmluaXRpb24sXG4gICAgLy8gYXMgaXQgbWFpbnRhaW5zIHJlZmVyZW5jZXMgYmV0d2VlbiB0aGUgbm9kZXMgdGhhdCBhcmUgaGFyZCB0byB1cGRhdGUuXG4gICAgZGVmID0gZGVmLmZhY3RvcnkoZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9PUDsgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50SW5kaWNlc1dpdGhPdmVyd3JpdHRlblByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcHBseVByb3ZpZGVyT3ZlcnJpZGVzVG9FbGVtZW50KGRlZiwgZWxlbWVudEluZGljZXNXaXRoT3ZlcndyaXR0ZW5Qcm92aWRlcnNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xuICAgIGZ1bmN0aW9uIGZpbmRFbGVtZW50SW5kaWNlc1dpdGhPdmVyd3JpdHRlblByb3ZpZGVycyhkZWYpIHtcbiAgICAgICAgdmFyIGVsSW5kaWNlc1dpdGhPdmVyd3JpdHRlblByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgbGFzdEVsZW1lbnREZWYgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZi5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGVEZWYgPSBkZWYubm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDEgLyogVHlwZUVsZW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudERlZiA9IG5vZGVEZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdEVsZW1lbnREZWYgJiYgbm9kZURlZi5mbGFncyAmIDM4NDAgLyogQ2F0UHJvdmlkZXJOb0RpcmVjdGl2ZSAqLyAmJlxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3ZlcnJpZGVzLmhhcyhub2RlRGVmLnByb3ZpZGVyLnRva2VuKSkge1xuICAgICAgICAgICAgICAgIGVsSW5kaWNlc1dpdGhPdmVyd3JpdHRlblByb3ZpZGVycy5wdXNoKGxhc3RFbGVtZW50RGVmLm5vZGVJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnREZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbEluZGljZXNXaXRoT3ZlcndyaXR0ZW5Qcm92aWRlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UHJvdmlkZXJPdmVycmlkZXNUb0VsZW1lbnQodmlld0RlZiQkMSwgZWxJbmRleCkge1xuICAgICAgICBmb3IgKHZhciBpID0gZWxJbmRleCArIDE7IGkgPCB2aWV3RGVmJCQxLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZURlZiA9IHZpZXdEZWYkJDEubm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDEgLyogVHlwZUVsZW1lbnQgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGF0IHRoZSBuZXh0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDM4NDAgLyogQ2F0UHJvdmlkZXJOb0RpcmVjdGl2ZSAqLykge1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5vZGVEZWYucHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gcHJvdmlkZXJPdmVycmlkZXMuZ2V0KHByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZURlZi5mbGFncyA9IChub2RlRGVmLmZsYWdzICYgfjM4NDAgLyogQ2F0UHJvdmlkZXJOb0RpcmVjdGl2ZSAqLykgfCBvdmVycmlkZS5mbGFncztcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIuZGVwcyA9IHNwbGl0RGVwc0RzbChvdmVycmlkZS5kZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIudmFsdWUgPSBvdmVycmlkZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBOb3RlcyBhYm91dCB0aGUgYWxnb3JpdGhtOlxuLy8gV2Ugb25seSBjcmVhdGUgbmV3IGRhdGFzdHJ1Y3R1cmVzIGlmIHdlIG5lZWQgdG8sIHRvIGtlZXAgcGVyZiBpbXBhY3Rcbi8vIHJlYXNvbmFibGUuXG5mdW5jdGlvbiBhcHBseVByb3ZpZGVyT3ZlcnJpZGVzVG9OZ01vZHVsZShkZWYpIHtcbiAgICB2YXIgX2EgPSBjYWxjSGFzT3ZlcnJpZGVzKGRlZiksIGhhc092ZXJyaWRlcyA9IF9hLmhhc092ZXJyaWRlcywgaGFzRGVwcmVjYXRlZE92ZXJyaWRlcyA9IF9hLmhhc0RlcHJlY2F0ZWRPdmVycmlkZXM7XG4gICAgaWYgKCFoYXNPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgLy8gY2xvbmUgdGhlIHdob2xlIHZpZXcgZGVmaW5pdGlvbixcbiAgICAvLyBhcyBpdCBtYWludGFpbnMgcmVmZXJlbmNlcyBiZXR3ZWVuIHRoZSBub2RlcyB0aGF0IGFyZSBoYXJkIHRvIHVwZGF0ZS5cbiAgICBkZWYgPSBkZWYuZmFjdG9yeShmdW5jdGlvbiAoKSB7IHJldHVybiBOT09QOyB9KTtcbiAgICBhcHBseVByb3ZpZGVyT3ZlcnJpZGVzKGRlZik7XG4gICAgcmV0dXJuIGRlZjtcbiAgICBmdW5jdGlvbiBjYWxjSGFzT3ZlcnJpZGVzKGRlZikge1xuICAgICAgICB2YXIgaGFzT3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNEZXByZWNhdGVkT3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm92aWRlck92ZXJyaWRlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBoYXNPdmVycmlkZXM6IGhhc092ZXJyaWRlcywgaGFzRGVwcmVjYXRlZE92ZXJyaWRlczogaGFzRGVwcmVjYXRlZE92ZXJyaWRlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZi5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gcHJvdmlkZXJPdmVycmlkZXMuZ2V0KG5vZGUudG9rZW4pO1xuICAgICAgICAgICAgaWYgKChub2RlLmZsYWdzICYgMzg0MCAvKiBDYXRQcm92aWRlck5vRGlyZWN0aXZlICovKSAmJiBvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGhhc092ZXJyaWRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzRGVwcmVjYXRlZE92ZXJyaWRlcyA9IGhhc0RlcHJlY2F0ZWRPdmVycmlkZXMgfHwgb3ZlcnJpZGUuZGVwcmVjYXRlZEJlaGF2aW9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICBwcm92aWRlck92ZXJyaWRlc1dpdGhTY29wZS5mb3JFYWNoKGZ1bmN0aW9uIChvdmVycmlkZSwgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5qZWN0YWJsZURlZih0b2tlbikucHJvdmlkZWRJbiA9PT0gbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc092ZXJyaWRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0RlcHJlY2F0ZWRPdmVycmlkZXMgPSBoYXNEZXByZWNhdGVkT3ZlcnJpZGVzIHx8IG92ZXJyaWRlLmRlcHJlY2F0ZWRCZWhhdmlvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGhhc092ZXJyaWRlczogaGFzT3ZlcnJpZGVzLCBoYXNEZXByZWNhdGVkT3ZlcnJpZGVzOiBoYXNEZXByZWNhdGVkT3ZlcnJpZGVzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UHJvdmlkZXJPdmVycmlkZXMoZGVmKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmLnByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZGVmLnByb3ZpZGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChoYXNEZXByZWNhdGVkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGFkIGEgYnVnIHdoZXJlIG1lIG1hZGVcbiAgICAgICAgICAgICAgICAvLyBhbGwgcHJvdmlkZXJzIGxhenkuIEtlZXAgdGhpcyBsb2dpYyBiZWhpbmQgYSBmbGFnXG4gICAgICAgICAgICAgICAgLy8gZm9yIG1pZ3JhdGluZyBleGlzdGluZyB1c2Vycy5cbiAgICAgICAgICAgICAgICBwcm92aWRlci5mbGFncyB8PSA0MDk2IC8qIExhenlQcm92aWRlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IHByb3ZpZGVyT3ZlcnJpZGVzLmdldChwcm92aWRlci50b2tlbik7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5mbGFncyA9IChwcm92aWRlci5mbGFncyAmIH4zODQwIC8qIENhdFByb3ZpZGVyTm9EaXJlY3RpdmUgKi8pIHwgb3ZlcnJpZGUuZmxhZ3M7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuZGVwcyA9IHNwbGl0RGVwc0RzbChvdmVycmlkZS5kZXBzKTtcbiAgICAgICAgICAgICAgICBwcm92aWRlci52YWx1ZSA9IG92ZXJyaWRlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlck92ZXJyaWRlc1dpdGhTY29wZS5zaXplID4gMCkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZVNldF8xID0gbmV3IFNldChkZWYubW9kdWxlcyk7XG4gICAgICAgICAgICBwcm92aWRlck92ZXJyaWRlc1dpdGhTY29wZS5mb3JFYWNoKGZ1bmN0aW9uIChvdmVycmlkZSwgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlU2V0XzEuaGFzKGdldEluamVjdGFibGVEZWYodG9rZW4pLnByb3ZpZGVkSW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzOiBvdmVycmlkZS5mbGFncyB8IChoYXNEZXByZWNhdGVkT3ZlcnJpZGVzID8gNDA5NiAvKiBMYXp5UHJvdmlkZXIgKi8gOiAwIC8qIE5vbmUgKi8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogc3BsaXREZXBzRHNsKG92ZXJyaWRlLmRlcHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGRlZi5wcm92aWRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkZWYucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWYucHJvdmlkZXJzQnlLZXlbdG9rZW5LZXkodG9rZW4pXSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvZENoZWNrQW5kVXBkYXRlTm9kZSh2aWV3LCBjaGVja0luZGV4LCBhcmdTdHlsZSwgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpIHtcbiAgICB2YXIgbm9kZURlZiA9IHZpZXcuZGVmLm5vZGVzW2NoZWNrSW5kZXhdO1xuICAgIGNoZWNrQW5kVXBkYXRlTm9kZSh2aWV3LCBub2RlRGVmLCBhcmdTdHlsZSwgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjkpO1xuICAgIHJldHVybiAobm9kZURlZi5mbGFncyAmIDIyNCAvKiBDYXRQdXJlRXhwcmVzc2lvbiAqLykgP1xuICAgICAgICBhc1B1cmVFeHByZXNzaW9uRGF0YSh2aWV3LCBjaGVja0luZGV4KS52YWx1ZSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHByb2RDaGVja05vQ2hhbmdlc05vZGUodmlldywgY2hlY2tJbmRleCwgYXJnU3R5bGUsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KSB7XG4gICAgdmFyIG5vZGVEZWYgPSB2aWV3LmRlZi5ub2Rlc1tjaGVja0luZGV4XTtcbiAgICBjaGVja05vQ2hhbmdlc05vZGUodmlldywgbm9kZURlZiwgYXJnU3R5bGUsIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5KTtcbiAgICByZXR1cm4gKG5vZGVEZWYuZmxhZ3MgJiAyMjQgLyogQ2F0UHVyZUV4cHJlc3Npb24gKi8pID9cbiAgICAgICAgYXNQdXJlRXhwcmVzc2lvbkRhdGEodmlldywgY2hlY2tJbmRleCkudmFsdWUgOlxuICAgICAgICB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkZWJ1Z0NoZWNrQW5kVXBkYXRlVmlldyh2aWV3KSB7XG4gICAgcmV0dXJuIGNhbGxXaXRoRGVidWdDb250ZXh0KERlYnVnQWN0aW9uLmRldGVjdENoYW5nZXMsIGNoZWNrQW5kVXBkYXRlVmlldywgbnVsbCwgW3ZpZXddKTtcbn1cbmZ1bmN0aW9uIGRlYnVnQ2hlY2tOb0NoYW5nZXNWaWV3KHZpZXcpIHtcbiAgICByZXR1cm4gY2FsbFdpdGhEZWJ1Z0NvbnRleHQoRGVidWdBY3Rpb24uY2hlY2tOb0NoYW5nZXMsIGNoZWNrTm9DaGFuZ2VzVmlldywgbnVsbCwgW3ZpZXddKTtcbn1cbmZ1bmN0aW9uIGRlYnVnRGVzdHJveVZpZXcodmlldykge1xuICAgIHJldHVybiBjYWxsV2l0aERlYnVnQ29udGV4dChEZWJ1Z0FjdGlvbi5kZXN0cm95LCBkZXN0cm95VmlldywgbnVsbCwgW3ZpZXddKTtcbn1cbnZhciBEZWJ1Z0FjdGlvbjtcbihmdW5jdGlvbiAoRGVidWdBY3Rpb24pIHtcbiAgICBEZWJ1Z0FjdGlvbltEZWJ1Z0FjdGlvbltcImNyZWF0ZVwiXSA9IDBdID0gXCJjcmVhdGVcIjtcbiAgICBEZWJ1Z0FjdGlvbltEZWJ1Z0FjdGlvbltcImRldGVjdENoYW5nZXNcIl0gPSAxXSA9IFwiZGV0ZWN0Q2hhbmdlc1wiO1xuICAgIERlYnVnQWN0aW9uW0RlYnVnQWN0aW9uW1wiY2hlY2tOb0NoYW5nZXNcIl0gPSAyXSA9IFwiY2hlY2tOb0NoYW5nZXNcIjtcbiAgICBEZWJ1Z0FjdGlvbltEZWJ1Z0FjdGlvbltcImRlc3Ryb3lcIl0gPSAzXSA9IFwiZGVzdHJveVwiO1xuICAgIERlYnVnQWN0aW9uW0RlYnVnQWN0aW9uW1wiaGFuZGxlRXZlbnRcIl0gPSA0XSA9IFwiaGFuZGxlRXZlbnRcIjtcbn0pKERlYnVnQWN0aW9uIHx8IChEZWJ1Z0FjdGlvbiA9IHt9KSk7XG52YXIgX2N1cnJlbnRBY3Rpb247XG52YXIgX2N1cnJlbnRWaWV3O1xudmFyIF9jdXJyZW50Tm9kZUluZGV4O1xuZnVuY3Rpb24gZGVidWdTZXRDdXJyZW50Tm9kZSh2aWV3LCBub2RlSW5kZXgpIHtcbiAgICBfY3VycmVudFZpZXcgPSB2aWV3O1xuICAgIF9jdXJyZW50Tm9kZUluZGV4ID0gbm9kZUluZGV4O1xufVxuZnVuY3Rpb24gZGVidWdIYW5kbGVFdmVudCh2aWV3LCBub2RlSW5kZXgsIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICBkZWJ1Z1NldEN1cnJlbnROb2RlKHZpZXcsIG5vZGVJbmRleCk7XG4gICAgcmV0dXJuIGNhbGxXaXRoRGVidWdDb250ZXh0KERlYnVnQWN0aW9uLmhhbmRsZUV2ZW50LCB2aWV3LmRlZi5oYW5kbGVFdmVudCwgbnVsbCwgW3ZpZXcsIG5vZGVJbmRleCwgZXZlbnROYW1lLCBldmVudF0pO1xufVxuZnVuY3Rpb24gZGVidWdVcGRhdGVEaXJlY3RpdmVzKHZpZXcsIGNoZWNrVHlwZSkge1xuICAgIGlmICh2aWV3LnN0YXRlICYgMTI4IC8qIERlc3Ryb3llZCAqLykge1xuICAgICAgICB0aHJvdyB2aWV3RGVzdHJveWVkRXJyb3IoRGVidWdBY3Rpb25bX2N1cnJlbnRBY3Rpb25dKTtcbiAgICB9XG4gICAgZGVidWdTZXRDdXJyZW50Tm9kZSh2aWV3LCBuZXh0RGlyZWN0aXZlV2l0aEJpbmRpbmcodmlldywgMCkpO1xuICAgIHJldHVybiB2aWV3LmRlZi51cGRhdGVEaXJlY3RpdmVzKGRlYnVnQ2hlY2tEaXJlY3RpdmVzRm4sIHZpZXcpO1xuICAgIGZ1bmN0aW9uIGRlYnVnQ2hlY2tEaXJlY3RpdmVzRm4odmlldywgbm9kZUluZGV4LCBhcmdTdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVEZWYgPSB2aWV3LmRlZi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgICAgICBpZiAoY2hlY2tUeXBlID09PSAwIC8qIENoZWNrQW5kVXBkYXRlICovKSB7XG4gICAgICAgICAgICBkZWJ1Z0NoZWNrQW5kVXBkYXRlTm9kZSh2aWV3LCBub2RlRGVmLCBhcmdTdHlsZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnQ2hlY2tOb0NoYW5nZXNOb2RlKHZpZXcsIG5vZGVEZWYsIGFyZ1N0eWxlLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgMTYzODQgLyogVHlwZURpcmVjdGl2ZSAqLykge1xuICAgICAgICAgICAgZGVidWdTZXRDdXJyZW50Tm9kZSh2aWV3LCBuZXh0RGlyZWN0aXZlV2l0aEJpbmRpbmcodmlldywgbm9kZUluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChub2RlRGVmLmZsYWdzICYgMjI0IC8qIENhdFB1cmVFeHByZXNzaW9uICovKSA/XG4gICAgICAgICAgICBhc1B1cmVFeHByZXNzaW9uRGF0YSh2aWV3LCBub2RlRGVmLm5vZGVJbmRleCkudmFsdWUgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlYnVnVXBkYXRlUmVuZGVyZXIodmlldywgY2hlY2tUeXBlKSB7XG4gICAgaWYgKHZpZXcuc3RhdGUgJiAxMjggLyogRGVzdHJveWVkICovKSB7XG4gICAgICAgIHRocm93IHZpZXdEZXN0cm95ZWRFcnJvcihEZWJ1Z0FjdGlvbltfY3VycmVudEFjdGlvbl0pO1xuICAgIH1cbiAgICBkZWJ1Z1NldEN1cnJlbnROb2RlKHZpZXcsIG5leHRSZW5kZXJOb2RlV2l0aEJpbmRpbmcodmlldywgMCkpO1xuICAgIHJldHVybiB2aWV3LmRlZi51cGRhdGVSZW5kZXJlcihkZWJ1Z0NoZWNrUmVuZGVyTm9kZUZuLCB2aWV3KTtcbiAgICBmdW5jdGlvbiBkZWJ1Z0NoZWNrUmVuZGVyTm9kZUZuKHZpZXcsIG5vZGVJbmRleCwgYXJnU3R5bGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFsdWVzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlRGVmID0gdmlldy5kZWYubm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgaWYgKGNoZWNrVHlwZSA9PT0gMCAvKiBDaGVja0FuZFVwZGF0ZSAqLykge1xuICAgICAgICAgICAgZGVidWdDaGVja0FuZFVwZGF0ZU5vZGUodmlldywgbm9kZURlZiwgYXJnU3R5bGUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1Z0NoZWNrTm9DaGFuZ2VzTm9kZSh2aWV3LCBub2RlRGVmLCBhcmdTdHlsZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLykge1xuICAgICAgICAgICAgZGVidWdTZXRDdXJyZW50Tm9kZSh2aWV3LCBuZXh0UmVuZGVyTm9kZVdpdGhCaW5kaW5nKHZpZXcsIG5vZGVJbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobm9kZURlZi5mbGFncyAmIDIyNCAvKiBDYXRQdXJlRXhwcmVzc2lvbiAqLykgP1xuICAgICAgICAgICAgYXNQdXJlRXhwcmVzc2lvbkRhdGEodmlldywgbm9kZURlZi5ub2RlSW5kZXgpLnZhbHVlIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWJ1Z0NoZWNrQW5kVXBkYXRlTm9kZSh2aWV3LCBub2RlRGVmLCBhcmdTdHlsZSwgZ2l2ZW5WYWx1ZXMpIHtcbiAgICB2YXIgY2hhbmdlZCA9IGNoZWNrQW5kVXBkYXRlTm9kZS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFt2aWV3LCBub2RlRGVmLCBhcmdTdHlsZV0sIGdpdmVuVmFsdWVzKSk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGFyZ1N0eWxlID09PSAxIC8qIER5bmFtaWMgKi8gPyBnaXZlblZhbHVlc1swXSA6IGdpdmVuVmFsdWVzO1xuICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDE2Mzg0IC8qIFR5cGVEaXJlY3RpdmUgKi8pIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nVmFsdWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVEZWYuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IG5vZGVEZWYuYmluZGluZ3NbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nLmZsYWdzICYgOCAvKiBUeXBlUHJvcGVydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ1ZhbHVlc1tub3JtYWxpemVEZWJ1Z0JpbmRpbmdOYW1lKGJpbmRpbmcubm9uTWluaWZpZWROYW1lKV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplRGVidWdCaW5kaW5nVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbERlZiA9IG5vZGVEZWYucGFyZW50O1xuICAgICAgICAgICAgdmFyIGVsID0gYXNFbGVtZW50RGF0YSh2aWV3LCBlbERlZi5ub2RlSW5kZXgpLnJlbmRlckVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIWVsRGVmLmVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIGEgY29tbWVudC5cbiAgICAgICAgICAgICAgICB2aWV3LnJlbmRlcmVyLnNldFZhbHVlKGVsLCBcImJpbmRpbmdzPVwiICsgSlNPTi5zdHJpbmdpZnkoYmluZGluZ1ZhbHVlcywgbnVsbCwgMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYSByZWd1bGFyIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBiaW5kaW5nVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJpbmRpbmdWYWx1ZXNbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbCwgYXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVidWdDaGVja05vQ2hhbmdlc05vZGUodmlldywgbm9kZURlZiwgYXJnU3R5bGUsIHZhbHVlcykge1xuICAgIGNoZWNrTm9DaGFuZ2VzTm9kZS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFt2aWV3LCBub2RlRGVmLCBhcmdTdHlsZV0sIHZhbHVlcykpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRGVidWdCaW5kaW5nTmFtZShuYW1lKSB7XG4gICAgLy8gQXR0cmlidXRlIG5hbWVzIHdpdGggYCRgIChlZyBgeC15JGApIGFyZSB2YWxpZCBwZXIgc3BlYywgYnV0IHVuc3VwcG9ydGVkIGJ5IHNvbWUgYnJvd3NlcnNcbiAgICBuYW1lID0gY2FtZWxDYXNlVG9EYXNoQ2FzZShuYW1lLnJlcGxhY2UoL1skQF0vZywgJ18nKSk7XG4gICAgcmV0dXJuIFwibmctcmVmbGVjdC1cIiArIG5hbWU7XG59XG52YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSAvKFtBLVpdKS9nO1xuZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKENBTUVMX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlYnVnQmluZGluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gTGltaXQgdGhlIHNpemUgb2YgdGhlIHZhbHVlIGFzIG90aGVyd2lzZSB0aGUgRE9NIGp1c3QgZ2V0cyBwb2xsdXRlZC5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpLnNsaWNlKDAsIDMwKSA6IHZhbHVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gJ1tFUlJPUl0gRXhjZXB0aW9uIHdoaWxlIHRyeWluZyB0byBzZXJpYWxpemUgdGhlIHZhbHVlJztcbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0RGlyZWN0aXZlV2l0aEJpbmRpbmcodmlldywgbm9kZUluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVJbmRleDsgaSA8IHZpZXcuZGVmLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlRGVmID0gdmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlRGVmLmZsYWdzICYgMTYzODQgLyogVHlwZURpcmVjdGl2ZSAqLyAmJiBub2RlRGVmLmJpbmRpbmdzICYmIG5vZGVEZWYuYmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5leHRSZW5kZXJOb2RlV2l0aEJpbmRpbmcodmlldywgbm9kZUluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVJbmRleDsgaSA8IHZpZXcuZGVmLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlRGVmID0gdmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgIGlmICgobm9kZURlZi5mbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLykgJiYgbm9kZURlZi5iaW5kaW5ncyAmJiBub2RlRGVmLmJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgRGVidWdDb250ZXh0XyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHRfKHZpZXcsIG5vZGVJbmRleCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgaWYgKG5vZGVJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRGVmID0gdmlldy5kZWYubm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgdmFyIGVsRGVmID0gdGhpcy5ub2RlRGVmO1xuICAgICAgICB2YXIgZWxWaWV3ID0gdmlldztcbiAgICAgICAgd2hpbGUgKGVsRGVmICYmIChlbERlZi5mbGFncyAmIDEgLyogVHlwZUVsZW1lbnQgKi8pID09PSAwKSB7XG4gICAgICAgICAgICBlbERlZiA9IGVsRGVmLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsRGVmKSB7XG4gICAgICAgICAgICB3aGlsZSAoIWVsRGVmICYmIGVsVmlldykge1xuICAgICAgICAgICAgICAgIGVsRGVmID0gdmlld1BhcmVudEVsKGVsVmlldyk7XG4gICAgICAgICAgICAgICAgZWxWaWV3ID0gZWxWaWV3LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsRGVmID0gZWxEZWY7XG4gICAgICAgIHRoaXMuZWxWaWV3ID0gZWxWaWV3O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0Xy5wcm90b3R5cGUsIFwiZWxPckNvbXBWaWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIYXMgdG8gYmUgZG9uZSBsYXppbHkgYXMgd2UgdXNlIHRoZSBEZWJ1Z0NvbnRleHQgYWxzbyBkdXJpbmcgY3JlYXRpb24gb2YgZWxlbWVudHMuLi5cbiAgICAgICAgICAgIHJldHVybiBhc0VsZW1lbnREYXRhKHRoaXMuZWxWaWV3LCB0aGlzLmVsRGVmLm5vZGVJbmRleCkuY29tcG9uZW50VmlldyB8fCB0aGlzLnZpZXc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHRfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlSW5qZWN0b3IkMSh0aGlzLmVsVmlldywgdGhpcy5lbERlZik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHRfLnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWxPckNvbXBWaWV3LmNvbXBvbmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dF8ucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZWxPckNvbXBWaWV3LmNvbnRleHQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHRfLnByb3RvdHlwZSwgXCJwcm92aWRlclRva2Vuc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxEZWYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5lbERlZi5ub2RlSW5kZXggKyAxOyBpIDw9IHRoaXMuZWxEZWYubm9kZUluZGV4ICsgdGhpcy5lbERlZi5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkRGVmID0gdGhpcy5lbFZpZXcuZGVmLm5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGREZWYuZmxhZ3MgJiAyMDIyNCAvKiBDYXRQcm92aWRlciAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY2hpbGREZWYucHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY2hpbGREZWYuY2hpbGRDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0Xy5wcm90b3R5cGUsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsRGVmKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdFJlZmVyZW5jZXModGhpcy5lbFZpZXcsIHRoaXMuZWxEZWYsIHJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmVsRGVmLm5vZGVJbmRleCArIDE7IGkgPD0gdGhpcy5lbERlZi5ub2RlSW5kZXggKyB0aGlzLmVsRGVmLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGREZWYgPSB0aGlzLmVsVmlldy5kZWYubm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZERlZi5mbGFncyAmIDIwMjI0IC8qIENhdFByb3ZpZGVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0UmVmZXJlbmNlcyh0aGlzLmVsVmlldywgY2hpbGREZWYsIHJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY2hpbGREZWYuY2hpbGRDb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dF8ucHJvdG90eXBlLCBcImNvbXBvbmVudFJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbERhdGEgPSBmaW5kSG9zdEVsZW1lbnQodGhpcy5lbE9yQ29tcFZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIGVsRGF0YSA/IGVsRGF0YS5yZW5kZXJFbGVtZW50IDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0Xy5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZURlZi5mbGFncyAmIDIgLyogVHlwZVRleHQgKi8gPyByZW5kZXJOb2RlKHRoaXMudmlldywgdGhpcy5ub2RlRGVmKSA6XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZSh0aGlzLmVsVmlldywgdGhpcy5lbERlZik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERlYnVnQ29udGV4dF8ucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGNvbnNvbGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2dWaWV3RGVmO1xuICAgICAgICB2YXIgbG9nTm9kZUluZGV4O1xuICAgICAgICBpZiAodGhpcy5ub2RlRGVmLmZsYWdzICYgMiAvKiBUeXBlVGV4dCAqLykge1xuICAgICAgICAgICAgbG9nVmlld0RlZiA9IHRoaXMudmlldy5kZWY7XG4gICAgICAgICAgICBsb2dOb2RlSW5kZXggPSB0aGlzLm5vZGVEZWYubm9kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nVmlld0RlZiA9IHRoaXMuZWxWaWV3LmRlZjtcbiAgICAgICAgICAgIGxvZ05vZGVJbmRleCA9IHRoaXMuZWxEZWYubm9kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHdlIG9ubHkgZ2VuZXJhdGUgYSBsb2cgZnVuY3Rpb24gZm9yIHRleHQgYW5kIGVsZW1lbnQgbm9kZXNcbiAgICAgICAgLy8gdG8gbWFrZSB0aGUgZ2VuZXJhdGVkIGNvZGUgYXMgc21hbGwgYXMgcG9zc2libGUuXG4gICAgICAgIHZhciByZW5kZXJOb2RlSW5kZXggPSBnZXRSZW5kZXJOb2RlSW5kZXgobG9nVmlld0RlZiwgbG9nTm9kZUluZGV4KTtcbiAgICAgICAgdmFyIGN1cnJSZW5kZXJOb2RlSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG5vZGVMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjdXJyUmVuZGVyTm9kZUluZGV4Kys7XG4gICAgICAgICAgICBpZiAoY3VyclJlbmRlck5vZGVJbmRleCA9PT0gcmVuZGVyTm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGNvbnNvbGUuZXJyb3IpLmJpbmQuYXBwbHkoX2EsIF9fc3ByZWFkKFtjb25zb2xlXSwgdmFsdWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTk9PUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9nVmlld0RlZi5mYWN0b3J5KG5vZGVMb2dnZXIpO1xuICAgICAgICBpZiAoY3VyclJlbmRlck5vZGVJbmRleCA8IHJlbmRlck5vZGVJbmRleCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSWxsZWdhbCBzdGF0ZTogdGhlIFZpZXdEZWZpbml0aW9uRmFjdG9yeSBkaWQgbm90IGNhbGwgdGhlIGxvZ2dlciEnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJ1Z0NvbnRleHRfO1xufSgpKTtcbmZ1bmN0aW9uIGdldFJlbmRlck5vZGVJbmRleCh2aWV3RGVmJCQxLCBub2RlSW5kZXgpIHtcbiAgICB2YXIgcmVuZGVyTm9kZUluZGV4ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZUluZGV4OyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVEZWYgPSB2aWV3RGVmJCQxLm5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZURlZi5mbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLykge1xuICAgICAgICAgICAgcmVuZGVyTm9kZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlck5vZGVJbmRleDtcbn1cbmZ1bmN0aW9uIGZpbmRIb3N0RWxlbWVudCh2aWV3KSB7XG4gICAgd2hpbGUgKHZpZXcgJiYgIWlzQ29tcG9uZW50Vmlldyh2aWV3KSkge1xuICAgICAgICB2aWV3ID0gdmlldy5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICh2aWV3LnBhcmVudCkge1xuICAgICAgICByZXR1cm4gYXNFbGVtZW50RGF0YSh2aWV3LnBhcmVudCwgdmlld1BhcmVudEVsKHZpZXcpLm5vZGVJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29sbGVjdFJlZmVyZW5jZXModmlldywgbm9kZURlZiwgcmVmZXJlbmNlcykge1xuICAgIGZvciAodmFyIHJlZk5hbWUgaW4gbm9kZURlZi5yZWZlcmVuY2VzKSB7XG4gICAgICAgIHJlZmVyZW5jZXNbcmVmTmFtZV0gPSBnZXRRdWVyeVZhbHVlKHZpZXcsIG5vZGVEZWYsIG5vZGVEZWYucmVmZXJlbmNlc1tyZWZOYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbFdpdGhEZWJ1Z0NvbnRleHQoYWN0aW9uLCBmbiwgc2VsZiwgYXJncykge1xuICAgIHZhciBvbGRBY3Rpb24gPSBfY3VycmVudEFjdGlvbjtcbiAgICB2YXIgb2xkVmlldyA9IF9jdXJyZW50VmlldztcbiAgICB2YXIgb2xkTm9kZUluZGV4ID0gX2N1cnJlbnROb2RlSW5kZXg7XG4gICAgdHJ5IHtcbiAgICAgICAgX2N1cnJlbnRBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgX2N1cnJlbnRWaWV3ID0gb2xkVmlldztcbiAgICAgICAgX2N1cnJlbnROb2RlSW5kZXggPSBvbGROb2RlSW5kZXg7XG4gICAgICAgIF9jdXJyZW50QWN0aW9uID0gb2xkQWN0aW9uO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNWaWV3RGVidWdFcnJvcihlKSB8fCAhX2N1cnJlbnRWaWV3KSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHZpZXdXcmFwcGVkRGVidWdFcnJvcihlLCBnZXRDdXJyZW50RGVidWdDb250ZXh0KCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREZWJ1Z0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIF9jdXJyZW50VmlldyA/IG5ldyBEZWJ1Z0NvbnRleHRfKF9jdXJyZW50VmlldywgX2N1cnJlbnROb2RlSW5kZXgpIDogbnVsbDtcbn1cbnZhciBEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVidWdSZW5kZXJlckZhY3RvcnkyKGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB9XG4gICAgRGVidWdSZW5kZXJlckZhY3RvcnkyLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uIChlbGVtZW50LCByZW5kZXJEYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVidWdSZW5kZXJlcjIodGhpcy5kZWxlZ2F0ZS5jcmVhdGVSZW5kZXJlcihlbGVtZW50LCByZW5kZXJEYXRhKSk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5iZWdpbikge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iZWdpbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIucHJvdG90eXBlLndoZW5SZW5kZXJpbmdEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS53aGVuUmVuZGVyaW5nRG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUud2hlblJlbmRlcmluZ0RvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYnVnUmVuZGVyZXJGYWN0b3J5Mjtcbn0oKSk7XG52YXIgRGVidWdSZW5kZXJlcjIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVidWdSZW5kZXJlcjIoZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmFjdG9yeSBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIGBEZWJ1Z0NvbnRleHRgIHdoZW4gYSBub2RlIGlzIGNyZWF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgRGVidWdDb250ZXh0YCBhbGxvd3MgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG5vZGVzIHRoYXQgYXJlIHVzZWZ1bCBpbiB0ZXN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZhY3RvcnkgaXMgY29uZmlndXJhYmxlIHNvIHRoYXQgdGhlIGBEZWJ1Z1JlbmRlcmVyMmAgY291bGQgaW5zdGFudGlhdGUgZWl0aGVyIGEgVmlldyBFbmdpbmVcbiAgICAgICAgICogb3IgYSBSZW5kZXIgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVidWdDb250ZXh0RmFjdG9yeSA9IGdldEN1cnJlbnREZWJ1Z0NvbnRleHQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGVsZWdhdGUuZGF0YTtcbiAgICB9XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZURlYnVnQ29udGV4dCA9IGZ1bmN0aW9uIChuYXRpdmVFbGVtZW50KSB7IHJldHVybiB0aGlzLmRlYnVnQ29udGV4dEZhY3RvcnkobmF0aXZlRWxlbWVudCk7IH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLmRlc3Ryb3lOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmVtb3ZlRGVidWdOb2RlRnJvbUluZGV4KGdldERlYnVnTm9kZShub2RlKSk7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmRlc3Ryb3lOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kZWxlZ2F0ZS5kZXN0cm95KCk7IH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZGVsZWdhdGUuY3JlYXRlRWxlbWVudChuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgZGVidWdDdHggPSB0aGlzLmNyZWF0ZURlYnVnQ29udGV4dChlbCk7XG4gICAgICAgIGlmIChkZWJ1Z0N0eCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBuZXcgRGVidWdFbGVtZW50KGVsLCBudWxsLCBkZWJ1Z0N0eCk7XG4gICAgICAgICAgICBkZWJ1Z0VsLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZUNvbW1lbnQodmFsdWUpO1xuICAgICAgICB2YXIgZGVidWdDdHggPSB0aGlzLmNyZWF0ZURlYnVnQ29udGV4dChjb21tZW50KTtcbiAgICAgICAgaWYgKGRlYnVnQ3R4KSB7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShuZXcgRGVidWdOb2RlKGNvbW1lbnQsIG51bGwsIGRlYnVnQ3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZGVsZWdhdGUuY3JlYXRlVGV4dCh2YWx1ZSk7XG4gICAgICAgIHZhciBkZWJ1Z0N0eCA9IHRoaXMuY3JlYXRlRGVidWdDb250ZXh0KHRleHQpO1xuICAgICAgICBpZiAoZGVidWdDdHgpIHtcbiAgICAgICAgICAgIGluZGV4RGVidWdOb2RlKG5ldyBEZWJ1Z05vZGUodGV4dCwgbnVsbCwgZGVidWdDdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIERlYnVnUmVuZGVyZXIyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIG5ld0NoaWxkKSB7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBkZWJ1Z0NoaWxkRWwgPSBnZXREZWJ1Z05vZGUobmV3Q2hpbGQpO1xuICAgICAgICBpZiAoZGVidWdFbCAmJiBkZWJ1Z0NoaWxkRWwgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgZGVidWdFbC5hZGRDaGlsZChkZWJ1Z0NoaWxkRWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdDaGlsZCk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkKSB7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBkZWJ1Z0NoaWxkRWwgPSBnZXREZWJ1Z05vZGUobmV3Q2hpbGQpO1xuICAgICAgICB2YXIgZGVidWdSZWZFbCA9IGdldERlYnVnTm9kZShyZWZDaGlsZCk7XG4gICAgICAgIGlmIChkZWJ1Z0VsICYmIGRlYnVnQ2hpbGRFbCAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBkZWJ1Z0VsLmluc2VydEJlZm9yZShkZWJ1Z1JlZkVsLCBkZWJ1Z0NoaWxkRWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuaW5zZXJ0QmVmb3JlKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkKTtcbiAgICB9O1xuICAgIERlYnVnUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnQsIG9sZENoaWxkKSB7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBkZWJ1Z0NoaWxkRWwgPSBnZXREZWJ1Z05vZGUob2xkQ2hpbGQpO1xuICAgICAgICBpZiAoZGVidWdFbCAmJiBkZWJ1Z0NoaWxkRWwgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgZGVidWdFbC5yZW1vdmVDaGlsZChkZWJ1Z0NoaWxkRWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlQ2hpbGQocGFyZW50LCBvbGRDaGlsZCk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIHByZXNlcnZlQ29udGVudCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmRlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBwcmVzZXJ2ZUNvbnRlbnQpO1xuICAgICAgICB2YXIgZGVidWdDdHggPSBnZXRDdXJyZW50RGVidWdDb250ZXh0KCkgfHwgKGl2eUVuYWJsZWQkMSA/IHRoaXMuY3JlYXRlRGVidWdDb250ZXh0KGVsKSA6IG51bGwpO1xuICAgICAgICBpZiAoZGVidWdDdHgpIHtcbiAgICAgICAgICAgIGluZGV4RGVidWdOb2RlKG5ldyBEZWJ1Z0VsZW1lbnQoZWwsIG51bGwsIGRlYnVnQ3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShlbCk7XG4gICAgICAgIGlmIChkZWJ1Z0VsICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBmdWxsTmFtZSA9IG5hbWVzcGFjZSA/IG5hbWVzcGFjZSArICc6JyArIG5hbWUgOiBuYW1lO1xuICAgICAgICAgICAgZGVidWdFbC5hdHRyaWJ1dGVzW2Z1bGxOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0QXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9O1xuICAgIERlYnVnUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShlbCk7XG4gICAgICAgIGlmIChkZWJ1Z0VsICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBmdWxsTmFtZSA9IG5hbWVzcGFjZSA/IG5hbWVzcGFjZSArICc6JyArIG5hbWUgOiBuYW1lO1xuICAgICAgICAgICAgZGVidWdFbC5hdHRyaWJ1dGVzW2Z1bGxOYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVBdHRyaWJ1dGUoZWwsIG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcbiAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUoZWwpO1xuICAgICAgICBpZiAoZGVidWdFbCAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBkZWJ1Z0VsLmNsYXNzZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYWRkQ2xhc3MoZWwsIG5hbWUpO1xuICAgIH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKGVsKTtcbiAgICAgICAgaWYgKGRlYnVnRWwgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgZGVidWdFbC5jbGFzc2VzW25hbWVdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVDbGFzcyhlbCwgbmFtZSk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlLCB2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUoZWwpO1xuICAgICAgICBpZiAoZGVidWdFbCAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBkZWJ1Z0VsLnN0eWxlc1tzdHlsZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKTtcbiAgICB9O1xuICAgIERlYnVnUmVuZGVyZXIyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIGZsYWdzKSB7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKGVsKTtcbiAgICAgICAgaWYgKGRlYnVnRWwgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgZGVidWdFbC5zdHlsZXNbc3R5bGVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGVnYXRlLnJlbW92ZVN0eWxlKGVsLCBzdHlsZSwgZmxhZ3MpO1xuICAgIH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShlbCk7XG4gICAgICAgIGlmIChkZWJ1Z0VsICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGRlYnVnRWwucHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIERlYnVnUmVuZGVyZXIyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChkZWJ1Z0VsKSB7XG4gICAgICAgICAgICAgICAgZGVidWdFbC5saXN0ZW5lcnMucHVzaChuZXcgRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBEZWJ1Z1JlbmRlcmVyMi5wcm90b3R5cGUucGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLnBhcmVudE5vZGUobm9kZSk7IH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUubmV4dFNpYmxpbmcobm9kZSk7IH07XG4gICAgRGVidWdSZW5kZXJlcjIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlLnNldFZhbHVlKG5vZGUsIHZhbHVlKTsgfTtcbiAgICByZXR1cm4gRGVidWdSZW5kZXJlcjI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBvdmVycmlkZVByb3ZpZGVyKG92ZXJyaWRlKSB7XG4gICAgaW5pdFNlcnZpY2VzSWZOZWVkZWQoKTtcbiAgICByZXR1cm4gU2VydmljZXMub3ZlcnJpZGVQcm92aWRlcihvdmVycmlkZSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNvbXBvbmVudFZpZXcoY29tcCwgY29tcG9uZW50RmFjdG9yeSkge1xuICAgIGluaXRTZXJ2aWNlc0lmTmVlZGVkKCk7XG4gICAgcmV0dXJuIFNlcnZpY2VzLm92ZXJyaWRlQ29tcG9uZW50Vmlldyhjb21wLCBjb21wb25lbnRGYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyT3ZlcnJpZGVzKCkge1xuICAgIGluaXRTZXJ2aWNlc0lmTmVlZGVkKCk7XG4gICAgcmV0dXJuIFNlcnZpY2VzLmNsZWFyT3ZlcnJpZGVzKCk7XG59XG4vLyBBdHRlbnRpb246IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFzIHRvcCBsZXZlbCBmdW5jdGlvbi5cbi8vIFB1dHRpbmcgYW55IGxvZ2ljIGluIGhlcmUgd2lsbCBkZXN0cm95IGNsb3N1cmUgdHJlZSBzaGFraW5nIVxuZnVuY3Rpb24gY3JlYXRlTmdNb2R1bGVGYWN0b3J5KG5nTW9kdWxlVHlwZSwgYm9vdHN0cmFwQ29tcG9uZW50cywgZGVmRmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgTmdNb2R1bGVGYWN0b3J5XyhuZ01vZHVsZVR5cGUsIGJvb3RzdHJhcENvbXBvbmVudHMsIGRlZkZhY3RvcnkpO1xufVxuZnVuY3Rpb24gY2xvbmVOZ01vZHVsZURlZmluaXRpb24oZGVmKSB7XG4gICAgdmFyIHByb3ZpZGVycyA9IEFycmF5LmZyb20oZGVmLnByb3ZpZGVycyk7XG4gICAgdmFyIG1vZHVsZXMgPSBBcnJheS5mcm9tKGRlZi5tb2R1bGVzKTtcbiAgICB2YXIgcHJvdmlkZXJzQnlLZXkgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmLnByb3ZpZGVyc0J5S2V5KSB7XG4gICAgICAgIHByb3ZpZGVyc0J5S2V5W2tleV0gPSBkZWYucHJvdmlkZXJzQnlLZXlba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmFjdG9yeTogZGVmLmZhY3RvcnksXG4gICAgICAgIGlzUm9vdDogZGVmLmlzUm9vdCwgcHJvdmlkZXJzOiBwcm92aWRlcnMsIG1vZHVsZXM6IG1vZHVsZXMsIHByb3ZpZGVyc0J5S2V5OiBwcm92aWRlcnNCeUtleSxcbiAgICB9O1xufVxudmFyIE5nTW9kdWxlRmFjdG9yeV8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5nTW9kdWxlRmFjdG9yeV8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmdNb2R1bGVGYWN0b3J5Xyhtb2R1bGVUeXBlLCBfYm9vdHN0cmFwQ29tcG9uZW50cywgX25nTW9kdWxlRGVmRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gQXR0ZW50aW9uOiB0aGlzIGN0b3IgaXMgY2FsbGVkIGFzIHRvcCBsZXZlbCBmdW5jdGlvbi5cbiAgICAgICAgLy8gUHV0dGluZyBhbnkgbG9naWMgaW4gaGVyZSB3aWxsIGRlc3Ryb3kgY2xvc3VyZSB0cmVlIHNoYWtpbmchXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vZHVsZVR5cGUgPSBtb2R1bGVUeXBlO1xuICAgICAgICBfdGhpcy5fYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ib290c3RyYXBDb21wb25lbnRzO1xuICAgICAgICBfdGhpcy5fbmdNb2R1bGVEZWZGYWN0b3J5ID0gX25nTW9kdWxlRGVmRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOZ01vZHVsZUZhY3RvcnlfLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgaW5pdFNlcnZpY2VzSWZOZWVkZWQoKTtcbiAgICAgICAgLy8gQ2xvbmUgdGhlIE5nTW9kdWxlRGVmaW5pdGlvbiBzbyB0aGF0IGFueSB0cmVlIHNoYWtlYWJsZSBwcm92aWRlciBkZWZpbml0aW9uXG4gICAgICAgIC8vIGFkZGVkIHRvIHRoaXMgaW5zdGFuY2Ugb2YgdGhlIE5nTW9kdWxlUmVmIGRvZXNuJ3QgYWZmZWN0IHRoZSBjYWNoZWQgY29weS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI1MDE4LlxuICAgICAgICB2YXIgZGVmID0gY2xvbmVOZ01vZHVsZURlZmluaXRpb24ocmVzb2x2ZURlZmluaXRpb24odGhpcy5fbmdNb2R1bGVEZWZGYWN0b3J5KSk7XG4gICAgICAgIHJldHVybiBTZXJ2aWNlcy5jcmVhdGVOZ01vZHVsZVJlZih0aGlzLm1vZHVsZVR5cGUsIHBhcmVudEluamVjdG9yIHx8IEluamVjdG9yLk5VTEwsIHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudHMsIGRlZik7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVGYWN0b3J5Xztcbn0oTmdNb2R1bGVGYWN0b3J5KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGhvc3QgY29tcG9uZW50IGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdGFyZ2V0LlxuICpcbiAqIFRoaXMgd2lsbCBvbmx5IHJldHVybiBhIGNvbXBvbmVudCBpbnN0YW5jZSBvZiB0aGUgRE9NIG5vZGVcbiAqIGNvbnRhaW5zIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IG9uIGl0LlxuICovXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50KHRhcmdldCkge1xuICAgIHZhciBjb250ZXh0ID0gbG9hZENvbnRleHQodGFyZ2V0KTtcbiAgICB2YXIgdE5vZGUgPSBjb250ZXh0LmxWaWV3RGF0YVtUVklFV10uZGF0YVtjb250ZXh0Lm5vZGVJbmRleF07XG4gICAgaWYgKHROb2RlLmZsYWdzICYgNDA5NiAvKiBpc0NvbXBvbmVudCAqLykge1xuICAgICAgICB2YXIgY29tcG9uZW50VmlldyA9IGdldENvbXBvbmVudFZpZXdCeUluZGV4KGNvbnRleHQubm9kZUluZGV4LCBjb250ZXh0LmxWaWV3RGF0YSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRWaWV3W0NPTlRFWFRdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgYFJvb3RDb250ZXh0YCBpbnN0YW5jZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aFxuICogdGhlIGFwcGxpY2F0aW9uIHdoZXJlIHRoZSB0YXJnZXQgaXMgc2l0dWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RDb250ZXh0JDIodGFyZ2V0KSB7XG4gICAgdmFyIGxWaWV3RGF0YSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IGxvYWRDb250ZXh0KHRhcmdldCkubFZpZXdEYXRhO1xuICAgIHZhciByb290TFZpZXdEYXRhID0gZ2V0Um9vdFZpZXckMShsVmlld0RhdGEpO1xuICAgIHJldHVybiByb290TFZpZXdEYXRhW0NPTlRFWFRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmplY3RvciBpbnN0YW5jZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aFxuICogdGhlIGVsZW1lbnQsIGNvbXBvbmVudCBvciBkaXJlY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIGdldEluamVjdG9yKHRhcmdldCkge1xuICAgIHZhciBjb250ZXh0ID0gbG9hZENvbnRleHQodGFyZ2V0KTtcbiAgICB2YXIgdE5vZGUgPSBjb250ZXh0LmxWaWV3RGF0YVtUVklFV10uZGF0YVtjb250ZXh0Lm5vZGVJbmRleF07XG4gICAgcmV0dXJuIG5ldyBOb2RlSW5qZWN0b3IodE5vZGUsIGNvbnRleHQubFZpZXdEYXRhKTtcbn1cbi8qKlxuICogUmV0dXJucyBMQ29udGV4dCBhc3NvY2lhdGVkIHdpdGggYSB0YXJnZXQgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICogVGhyb3dzIGlmIGEgZ2l2ZW4gdGFyZ2V0IGRvZXNuJ3QgaGF2ZSBhc3NvY2lhdGVkIExDb250ZXh0LlxuICovXG5mdW5jdGlvbiBsb2FkQ29udGV4dCh0YXJnZXQpIHtcbiAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHQodGFyZ2V0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5nRGV2TW9kZSA/ICdVbmFibGUgdG8gZmluZCB0aGUgZ2l2ZW4gY29udGV4dCBkYXRhIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0JyA6XG4gICAgICAgICAgICAnSW52YWxpZCBuZyB0YXJnZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG4vKipcbiAqIFJldHJpZXZlIHRoZSByb290IHZpZXcgZnJvbSBhbnkgY29tcG9uZW50IGJ5IHdhbGtpbmcgdGhlIHBhcmVudCBgTFZpZXdEYXRhYCB1bnRpbFxuICogcmVhY2hpbmcgdGhlIHJvb3QgYExWaWV3RGF0YWAuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudE9yVmlldyBhbnkgY29tcG9uZW50IG9yIHZpZXdcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdFZpZXckMShjb21wb25lbnRPclZpZXcpIHtcbiAgICB2YXIgbFZpZXdEYXRhO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudE9yVmlldykpIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGFzc2VydERlZmluZWQoY29tcG9uZW50T3JWaWV3LCAnbFZpZXdEYXRhJyk7XG4gICAgICAgIGxWaWV3RGF0YSA9IGNvbXBvbmVudE9yVmlldztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBhc3NlcnREZWZpbmVkKGNvbXBvbmVudE9yVmlldywgJ2NvbXBvbmVudCcpO1xuICAgICAgICBsVmlld0RhdGEgPSByZWFkUGF0Y2hlZExWaWV3RGF0YShjb21wb25lbnRPclZpZXcpO1xuICAgIH1cbiAgICB3aGlsZSAobFZpZXdEYXRhICYmICEobFZpZXdEYXRhW0ZMQUdTXSAmIDY0IC8qIElzUm9vdCAqLykpIHtcbiAgICAgICAgbFZpZXdEYXRhID0gbFZpZXdEYXRhW1BBUkVOVF07XG4gICAgfVxuICAgIHJldHVybiBsVmlld0RhdGE7XG59XG4vKipcbiAqICBSZXRyaWV2ZSBtYXAgb2YgbG9jYWwgcmVmZXJlbmNlcyAobG9jYWwgcmVmZXJlbmNlIG5hbWUgPT4gZWxlbWVudCBvciBkaXJlY3RpdmUgaW5zdGFuY2UpLlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFJlZnModGFyZ2V0KSB7XG4gICAgdmFyIGNvbnRleHQgPSBsb2FkQ29udGV4dCh0YXJnZXQpO1xuICAgIGlmIChjb250ZXh0LmxvY2FsUmVmcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQubG9jYWxSZWZzID0gZGlzY292ZXJMb2NhbFJlZnMoY29udGV4dC5sVmlld0RhdGEsIGNvbnRleHQubm9kZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQubG9jYWxSZWZzIHx8IHt9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFkYXB0cyB0aGUgRGVidWdSZW5kZXJlckZhY3RvcnkyIHRvIGNyZWF0ZSBhIERlYnVnUmVuZGVyZXIyIHNwZWNpZmljIGZvciBJVlkuXG4gKlxuICogVGhlIGNyZWF0ZWQgRGVidWdSZW5kZXJlciBrbm93IGhvdyB0byBjcmVhdGUgYSBEZWJ1ZyBDb250ZXh0IHNwZWNpZmljIHRvIElWWS5cbiAqL1xudmFyIFJlbmRlcjNEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcjNEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVuZGVyM0RlYnVnUmVuZGVyZXJGYWN0b3J5MigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW5kZXIzRGVidWdSZW5kZXJlckZhY3RvcnkyLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uIChlbGVtZW50LCByZW5kZXJEYXRhKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IF9zdXBlci5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIuY2FsbCh0aGlzLCBlbGVtZW50LCByZW5kZXJEYXRhKTtcbiAgICAgICAgcmVuZGVyZXIuZGVidWdDb250ZXh0RmFjdG9yeSA9IGZ1bmN0aW9uIChuYXRpdmVFbGVtZW50KSB7IHJldHVybiBuZXcgUmVuZGVyM0RlYnVnQ29udGV4dChuYXRpdmVFbGVtZW50KTsgfTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcjNEZWJ1Z1JlbmRlcmVyRmFjdG9yeTI7XG59KERlYnVnUmVuZGVyZXJGYWN0b3J5MikpO1xuLyoqXG4gKiBTdG9yZXMgY29udGV4dCBpbmZvcm1hdGlvbiBhYm91dCB2aWV3IG5vZGVzLlxuICpcbiAqIFVzZWQgaW4gdGVzdHMgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gdGhvc2Ugbm9kZXMuXG4gKi9cbnZhciBSZW5kZXIzRGVidWdDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcjNEZWJ1Z0NvbnRleHQoX25hdGl2ZU5vZGUpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlTm9kZSA9IF9uYXRpdmVOb2RlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyM0RlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwibm9kZUluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkQ29udGV4dCh0aGlzLl9uYXRpdmVOb2RlKS5ub2RlSW5kZXg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXIzRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkQ29udGV4dCh0aGlzLl9uYXRpdmVOb2RlKS5sVmlld0RhdGE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXIzRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW5qZWN0b3IodGhpcy5fbmF0aXZlTm9kZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXIzRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEhvc3RDb21wb25lbnQodGhpcy5fbmF0aXZlTm9kZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXIzRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJwcm92aWRlclRva2Vuc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxEZWJ1Z0N0eCA9IGxvYWRDb250ZXh0KHRoaXMuX25hdGl2ZU5vZGUpO1xuICAgICAgICAgICAgdmFyIGxWaWV3RGF0YSA9IGxEZWJ1Z0N0eC5sVmlld0RhdGE7XG4gICAgICAgICAgICB2YXIgdE5vZGUgPSBsVmlld0RhdGFbVFZJRVddLmRhdGFbbERlYnVnQ3R4Lm5vZGVJbmRleF07XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlc0NvdW50ID0gdE5vZGUuZmxhZ3MgJiA0MDk1IC8qIERpcmVjdGl2ZUNvdW50TWFzayAqLztcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUlkeFN0YXJ0ID0gdE5vZGUuZmxhZ3MgPj4gMTUgLyogRGlyZWN0aXZlU3RhcnRpbmdJbmRleFNoaWZ0ICovO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJZHhFbmQgPSBkaXJlY3RpdmVJZHhTdGFydCArIGRpcmVjdGl2ZXNDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgdmlld0RpcmVjdGl2ZURlZnMgPSB0aGlzLnZpZXdbVFZJRVddLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZURlZnMgPSB2aWV3RGlyZWN0aXZlRGVmcy5zbGljZShkaXJlY3RpdmVJZHhTdGFydCwgZGlyZWN0aXZlSWR4RW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlRGVmcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZURlZikgeyByZXR1cm4gZGlyZWN0aXZlRGVmLnR5cGU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyM0RlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TG9jYWxSZWZzKHRoaXMuX25hdGl2ZU5vZGUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyM0RlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgIC8vIFRPRE8ocGspOiBjaGVjayBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbiBhbmQgcmUtaW1wbGVtZW50XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCBpbiBpdnknKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlcjNEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAvLyBUT0RPKHBrKTogY2hlY2sgcHJldmlvdXMgaW1wbGVtZW50YXRpb24gYW5kIHJlLWltcGxlbWVudFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgaW4gaXZ5Jyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXIzRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZW5kZXJOb2RlXCIsIHtcbiAgICAgICAgLy8gVE9ETyhwayk6IGNoZWNrIHByZXZpb3VzIGltcGxlbWVudGF0aW9uIGFuZCByZS1pbXBsZW1lbnRcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIGluIGl2eScpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBUT0RPKHBrKTogY2hlY2sgcHJldmlvdXMgaW1wbGVtZW50YXRpb24gYW5kIHJlLWltcGxlbWVudFxuICAgIFJlbmRlcjNEZWJ1Z0NvbnRleHQucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGNvbnNvbGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyM0RlYnVnQ29udGV4dDtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQWRkcyBhIHBsYXllciB0byBhbiBlbGVtZW50LCBkaXJlY3RpdmUgb3IgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgd2lsbCBsYXRlciBiZVxuICogYW5pbWF0ZWQgb25jZSBjaGFuZ2UgZGV0ZWN0aW9uIGhhcyBwYXNzZWQuXG4gKlxuICogV2hlbiBhIHBsYXllciBpcyBhZGRlZCB0byBhIHJlZmVyZW5jZSBpdCB3aWxsIHN0YXkgYWN0aXZlIHVudGlsIGBwbGF5ZXIuZGVzdHJveSgpYFxuICogaXMgY2FsbGVkLiBPbmNlIGNhbGxlZCB0aGVuIHRoZSBwbGF5ZXIgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGFjdGl2ZSBwbGF5ZXJzXG4gKiBwcmVzZW50IG9uIHRoZSBhc3NvY2lhdGVkIHJlZiBpbnN0YW5jZS5cbiAqXG4gKiBUbyBnZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWN0aXZlIHBsYXllcnMgb24gYW4gZWxlbWVudCBzZWUgW2dldFBsYXllcnNdLlxuICpcbiAqIEBwYXJhbSByZWYgVGhlIGVsZW1lbnQsIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgdGhhdCB0aGUgcGxheWVyIHdpbGwgYmUgcGxhY2VkIG9uLlxuICogQHBhcmFtIHBsYXllciBUaGUgcGxheWVyIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgdG8gcGxheSBvbmNlIGNoYW5nZSBkZXRlY3Rpb24gaGFzIHJ1bi5cbiAqL1xuZnVuY3Rpb24gYWRkUGxheWVyKHJlZiwgcGxheWVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0KHJlZik7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiB0aHJvd0ludmFsaWRSZWZFcnJvcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbGVtZW50JCQxID0gY29udGV4dC5uYXRpdmU7XG4gICAgdmFyIGxWaWV3RGF0YSA9IGNvbnRleHQubFZpZXdEYXRhO1xuICAgIHZhciBwbGF5ZXJDb250ZXh0ID0gZ2V0T3JDcmVhdGVQbGF5ZXJDb250ZXh0KGVsZW1lbnQkJDEsIGNvbnRleHQpO1xuICAgIHZhciByb290Q29udGV4dCA9IGdldFJvb3RDb250ZXh0JDIobFZpZXdEYXRhKTtcbiAgICBhZGRQbGF5ZXJJbnRlcm5hbChwbGF5ZXJDb250ZXh0LCByb290Q29udGV4dCwgZWxlbWVudCQkMSwgcGxheWVyLCAwLCByZWYpO1xuICAgIHNjaGVkdWxlVGljayhyb290Q29udGV4dCwgMiAvKiBGbHVzaFBsYXllcnMgKi8pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGFjdGl2ZSBwbGF5ZXJzIHByZXNlbnQgb24gdGhlIHByb3ZpZGVkIHJlZiBpbnN0YW5jZSAod2hpY2ggY2FuXG4gKiBiZSBhbiBpbnN0YW5jZSBvZiBhIGRpcmVjdGl2ZSwgY29tcG9uZW50IG9yIGVsZW1lbnQpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IHJldHVybiBwbGF5ZXJzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSByZWYgaW5zdGFuY2UgdXNpbmdcbiAqIGBhZGRQbGF5ZXJgIG9yIGFueSBwbGF5ZXJzIHRoYXQgYXJlIGFjdGl2ZSB0aHJvdWdoIGFueSB0ZW1wbGF0ZSBzdHlsaW5nIGJpbmRpbmdzXG4gKiAoYFtzdHlsZV1gLCBgW3N0eWxlLnByb3BdYCwgYFtjbGFzc11gIGFuZCBgW2NsYXNzLm5hbWVdYCkuXG4gKi9cbmZ1bmN0aW9uIGdldFBsYXllcnMocmVmKSB7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0KHJlZik7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiB0aHJvd0ludmFsaWRSZWZFcnJvcigpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBzdHlsaW5nQ29udGV4dCA9IGdldFN0eWxpbmdDb250ZXh0KGNvbnRleHQubm9kZUluZGV4IC0gSEVBREVSX09GRlNFVCwgY29udGV4dC5sVmlld0RhdGEpO1xuICAgIHZhciBwbGF5ZXJDb250ZXh0ID0gc3R5bGluZ0NvbnRleHQgPyBnZXRQbGF5ZXJDb250ZXh0KHN0eWxpbmdDb250ZXh0KSA6IG51bGw7XG4gICAgcmV0dXJuIHBsYXllckNvbnRleHQgPyBnZXRQbGF5ZXJzSW50ZXJuYWwocGxheWVyQ29udGV4dCkgOiBbXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gY2xhbmctZm9ybWF0IG9uXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQVBQTElDQVRJT05fTU9EVUxFX1BST1ZJREVSUyBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2wsIF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfaSwgX2tleVZhbHVlRGlmZmVyc0ZhY3RvcnkgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9qLCBfbG9jYWxlRmFjdG9yeSBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2ssIF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2YsIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9nLCBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfaCwgUmVmbGVjdGl2ZUluamVjdG9yXyBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2MsIFJlZmxlY3RpdmVEZXBlbmRlbmN5IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfZCwgcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9lLCB3dGZFbmFibGVkIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfbSwgY3JlYXRlU2NvcGUgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9vLCBkZXRlY3RXVEYgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9uLCBlbmRUaW1lUmFuZ2UgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9yLCBsZWF2ZSBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX3AsIHN0YXJ0VGltZVJhbmdlIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfcSwgTkdfSU5KRUNUQUJMRV9ERUYgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9iZCwgX2dldFZpZXdEYXRhIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfdywgYmluZGluZ1VwZGF0ZWQgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV94LCBnZXRQcmV2aW91c09yUGFyZW50VE5vZGUgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV92LCBCb3VuZFBsYXllckZhY3RvcnkgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV96LCBsb2FkSW50ZXJuYWwgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2NvcmVfY29yZV9iZywgY3JlYXRlRWxlbWVudFJlZiBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2JhLCBjcmVhdGVUZW1wbGF0ZVJlZiBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2JiLCBjcmVhdGVWaWV3UmVmIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfYmMsIG1ha2VQYXJhbURlY29yYXRvciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2EsIG1ha2VQcm9wRGVjb3JhdG9yIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfYiwgZ2V0Q2xvc3VyZVNhZmVQcm9wZXJ0eSBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfY29yZV9jb3JlX2JlLCBfZGVmIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfcywgRGVidWdSZW5kZXJlckZhY3RvcnkyIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfdCwgRGVidWdDb250ZXh0IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19jb3JlX2NvcmVfdSwgY3JlYXRlUGxhdGZvcm0sIGFzc2VydFBsYXRmb3JtLCBkZXN0cm95UGxhdGZvcm0sIGdldFBsYXRmb3JtLCBQbGF0Zm9ybVJlZiwgQXBwbGljYXRpb25SZWYsIGNyZWF0ZVBsYXRmb3JtRmFjdG9yeSwgTmdQcm9iZVRva2VuLCBlbmFibGVQcm9kTW9kZSwgaXNEZXZNb2RlLCBBUFBfSUQsIFBBQ0tBR0VfUk9PVF9VUkwsIFBMQVRGT1JNX0lOSVRJQUxJWkVSLCBQTEFURk9STV9JRCwgQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgQVBQX0lOSVRJQUxJWkVSLCBBcHBsaWNhdGlvbkluaXRTdGF0dXMsIERlYnVnRWxlbWVudCwgRGVidWdOb2RlLCBhc05hdGl2ZUVsZW1lbnRzLCBnZXREZWJ1Z05vZGUsIFRlc3RhYmlsaXR5LCBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCBzZXRUZXN0YWJpbGl0eUdldHRlciwgVFJBTlNMQVRJT05TLCBUUkFOU0xBVElPTlNfRk9STUFULCBMT0NBTEVfSUQsIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBBcHBsaWNhdGlvbk1vZHVsZSwgd3RmQ3JlYXRlU2NvcGUsIHd0ZkxlYXZlLCB3dGZTdGFydFRpbWVSYW5nZSwgd3RmRW5kVGltZVJhbmdlLCBUeXBlLCBFdmVudEVtaXR0ZXIsIEVycm9ySGFuZGxlciwgU2FuaXRpemVyLCBTZWN1cml0eUNvbnRleHQsIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIEF0dHJpYnV0ZSwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5LCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgQ29tcG9uZW50LCBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQsIFBpcGUsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIE5PX0VSUk9SU19TQ0hFTUEsIE5nTW9kdWxlLCBWaWV3RW5jYXBzdWxhdGlvbiwgVmVyc2lvbiwgVkVSU0lPTiwgZGVmaW5lSW5qZWN0YWJsZSwgZGVmaW5lSW5qZWN0b3IsIGZvcndhcmRSZWYsIHJlc29sdmVGb3J3YXJkUmVmLCBJbmplY3RhYmxlLCBpbmplY3QsIElOSkVDVE9SLCBJbmplY3RvciwgUmVmbGVjdGl2ZUluamVjdG9yLCBjcmVhdGVJbmplY3RvciwgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSwgUmVmbGVjdGl2ZUtleSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgT3B0aW9uYWwsIFNlbGYsIFNraXBTZWxmLCBIb3N0LCBOZ1pvbmUsIE5vb3BOZ1pvbmUgYXMgybVOb29wTmdab25lLCBSZW5kZXJDb21wb25lbnRUeXBlLCBSZW5kZXJlciwgUmVuZGVyZXIyLCBSZW5kZXJlckZhY3RvcnkyLCBSZW5kZXJlclN0eWxlRmxhZ3MyLCBSb290UmVuZGVyZXIsIENPTVBJTEVSX09QVElPTlMsIENvbXBpbGVyLCBDb21waWxlckZhY3RvcnksIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMsIENvbXBvbmVudEZhY3RvcnksIENvbXBvbmVudFJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBFbGVtZW50UmVmLCBOZ01vZHVsZUZhY3RvcnksIE5nTW9kdWxlUmVmLCBOZ01vZHVsZUZhY3RvcnlMb2FkZXIsIGdldE1vZHVsZUZhY3RvcnksIFF1ZXJ5TGlzdCQxIGFzIFF1ZXJ5TGlzdCwgU3lzdGVtSnNOZ01vZHVsZUxvYWRlciwgU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZywgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYsIEVtYmVkZGVkVmlld1JlZiwgVmlld1JlZiQxIGFzIFZpZXdSZWYsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgU2ltcGxlQ2hhbmdlLCBXcmFwcGVkVmFsdWUsIHBsYXRmb3JtQ29yZSwgQUxMT1dfTVVMVElQTEVfUExBVEZPUk1TIGFzIMm1QUxMT1dfTVVMVElQTEVfUExBVEZPUk1TLCBBUFBfSURfUkFORE9NX1BST1ZJREVSIGFzIMm1QVBQX0lEX1JBTkRPTV9QUk9WSURFUiwgZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyBhcyDJtWRlZmF1bHRJdGVyYWJsZURpZmZlcnMsIGRlZmF1bHRLZXlWYWx1ZURpZmZlcnMgYXMgybVkZWZhdWx0S2V5VmFsdWVEaWZmZXJzLCBkZXZNb2RlRXF1YWwgYXMgybVkZXZNb2RlRXF1YWwsIGlzTGlzdExpa2VJdGVyYWJsZSBhcyDJtWlzTGlzdExpa2VJdGVyYWJsZSwgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgYXMgybVDaGFuZ2VEZXRlY3RvclN0YXR1cywgaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgYXMgybVpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29uc29sZSBhcyDJtUNvbnNvbGUsIGdldEluamVjdGFibGVEZWYgYXMgybVnZXRJbmplY3RhYmxlRGVmLCBpbmplY3QgYXMgybVpbmplY3QsIHNldEN1cnJlbnRJbmplY3RvciBhcyDJtXNldEN1cnJlbnRJbmplY3RvciwgQVBQX1JPT1QgYXMgybVBUFBfUk9PVCwgaXZ5RW5hYmxlZCQxIGFzIMm1aXZ5RW5hYmxlZCwgQ29tcG9uZW50RmFjdG9yeSBhcyDJtUNvbXBvbmVudEZhY3RvcnksIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgYXMgybVDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCByZXNvbHZlQ29tcG9uZW50UmVzb3VyY2VzIGFzIMm1cmVzb2x2ZUNvbXBvbmVudFJlc291cmNlcywgUmVmbGVjdGlvbkNhcGFiaWxpdGllcyBhcyDJtVJlZmxlY3Rpb25DYXBhYmlsaXRpZXMsIFJlbmRlckRlYnVnSW5mbyBhcyDJtVJlbmRlckRlYnVnSW5mbywgX3Nhbml0aXplSHRtbCBhcyDJtV9zYW5pdGl6ZUh0bWwsIF9zYW5pdGl6ZVN0eWxlIGFzIMm1X3Nhbml0aXplU3R5bGUsIF9zYW5pdGl6ZVVybCBhcyDJtV9zYW5pdGl6ZVVybCwgX2dsb2JhbCBhcyDJtWdsb2JhbCwgbG9vc2VJZGVudGljYWwgYXMgybVsb29zZUlkZW50aWNhbCwgc3RyaW5naWZ5IGFzIMm1c3RyaW5naWZ5LCBtYWtlRGVjb3JhdG9yIGFzIMm1bWFrZURlY29yYXRvciwgaXNPYnNlcnZhYmxlIGFzIMm1aXNPYnNlcnZhYmxlLCBpc1Byb21pc2UgYXMgybVpc1Byb21pc2UsIGNsZWFyT3ZlcnJpZGVzIGFzIMm1Y2xlYXJPdmVycmlkZXMsIGluaXRTZXJ2aWNlc0lmTmVlZGVkIGFzIMm1aW5pdFNlcnZpY2VzSWZOZWVkZWQsIG92ZXJyaWRlQ29tcG9uZW50VmlldyBhcyDJtW92ZXJyaWRlQ29tcG9uZW50Vmlldywgb3ZlcnJpZGVQcm92aWRlciBhcyDJtW92ZXJyaWRlUHJvdmlkZXIsIE5PVF9GT1VORF9DSEVDS19PTkxZX0VMRU1FTlRfSU5KRUNUT1IgYXMgybVOT1RfRk9VTkRfQ0hFQ0tfT05MWV9FTEVNRU5UX0lOSkVDVE9SLCBkZWZpbmVCYXNlIGFzIMm1ZGVmaW5lQmFzZSwgZGVmaW5lQ29tcG9uZW50IGFzIMm1ZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVEaXJlY3RpdmUgYXMgybVkZWZpbmVEaXJlY3RpdmUsIGRlZmluZVBpcGUgYXMgybVkZWZpbmVQaXBlLCBkZWZpbmVOZ01vZHVsZSBhcyDJtWRlZmluZU5nTW9kdWxlLCBkZXRlY3RDaGFuZ2VzIGFzIMm1ZGV0ZWN0Q2hhbmdlcywgcmVuZGVyQ29tcG9uZW50IGFzIMm1cmVuZGVyQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5JDEgYXMgybVSZW5kZXIzQ29tcG9uZW50RmFjdG9yeSwgQ29tcG9uZW50UmVmJDEgYXMgybVSZW5kZXIzQ29tcG9uZW50UmVmLCBkaXJlY3RpdmVJbmplY3QgYXMgybVkaXJlY3RpdmVJbmplY3QsIGluamVjdEF0dHJpYnV0ZSBhcyDJtWluamVjdEF0dHJpYnV0ZSwgZ2V0RmFjdG9yeU9mIGFzIMm1Z2V0RmFjdG9yeU9mLCBnZXRJbmhlcml0ZWRGYWN0b3J5IGFzIMm1Z2V0SW5oZXJpdGVkRmFjdG9yeSwgdGVtcGxhdGVSZWZFeHRyYWN0b3IgYXMgybV0ZW1wbGF0ZVJlZkV4dHJhY3RvciwgUHVibGljRmVhdHVyZSBhcyDJtVB1YmxpY0ZlYXR1cmUsIEluaGVyaXREZWZpbml0aW9uRmVhdHVyZSBhcyDJtUluaGVyaXREZWZpbml0aW9uRmVhdHVyZSwgTmdPbkNoYW5nZXNGZWF0dXJlIGFzIMm1TmdPbkNoYW5nZXNGZWF0dXJlLCBOZ01vZHVsZVJlZiQxIGFzIMm1UmVuZGVyM05nTW9kdWxlUmVmLCBtYXJrRGlydHkgYXMgybVtYXJrRGlydHksIE5nTW9kdWxlRmFjdG9yeSQxIGFzIMm1TmdNb2R1bGVGYWN0b3J5LCBOT19DSEFOR0UgYXMgybVOT19DSEFOR0UsIGNvbnRhaW5lciBhcyDJtWNvbnRhaW5lciwgbmV4dENvbnRleHQgYXMgybVuZXh0Q29udGV4dCwgZWxlbWVudFN0YXJ0IGFzIMm1ZWxlbWVudFN0YXJ0LCBuYW1lc3BhY2VIVE1MIGFzIMm1bmFtZXNwYWNlSFRNTCwgbmFtZXNwYWNlTWF0aE1MIGFzIMm1bmFtZXNwYWNlTWF0aE1MLCBuYW1lc3BhY2VTVkcgYXMgybVuYW1lc3BhY2VTVkcsIGVsZW1lbnQgYXMgybVlbGVtZW50LCBsaXN0ZW5lciBhcyDJtWxpc3RlbmVyLCB0ZXh0IGFzIMm1dGV4dCwgZW1iZWRkZWRWaWV3U3RhcnQgYXMgybVlbWJlZGRlZFZpZXdTdGFydCwgcXVlcnkgYXMgybVxdWVyeSwgcmVnaXN0ZXJDb250ZW50UXVlcnkgYXMgybVyZWdpc3RlckNvbnRlbnRRdWVyeSwgcHJvamVjdGlvbiBhcyDJtXByb2plY3Rpb24sIGJpbmQgYXMgybViaW5kLCBpbnRlcnBvbGF0aW9uMSBhcyDJtWludGVycG9sYXRpb24xLCBpbnRlcnBvbGF0aW9uMiBhcyDJtWludGVycG9sYXRpb24yLCBpbnRlcnBvbGF0aW9uMyBhcyDJtWludGVycG9sYXRpb24zLCBpbnRlcnBvbGF0aW9uNCBhcyDJtWludGVycG9sYXRpb240LCBpbnRlcnBvbGF0aW9uNSBhcyDJtWludGVycG9sYXRpb241LCBpbnRlcnBvbGF0aW9uNiBhcyDJtWludGVycG9sYXRpb242LCBpbnRlcnBvbGF0aW9uNyBhcyDJtWludGVycG9sYXRpb243LCBpbnRlcnBvbGF0aW9uOCBhcyDJtWludGVycG9sYXRpb244LCBpbnRlcnBvbGF0aW9uViBhcyDJtWludGVycG9sYXRpb25WLCBwaXBlQmluZDEgYXMgybVwaXBlQmluZDEsIHBpcGVCaW5kMiBhcyDJtXBpcGVCaW5kMiwgcGlwZUJpbmQzIGFzIMm1cGlwZUJpbmQzLCBwaXBlQmluZDQgYXMgybVwaXBlQmluZDQsIHBpcGVCaW5kViBhcyDJtXBpcGVCaW5kViwgcHVyZUZ1bmN0aW9uMCBhcyDJtXB1cmVGdW5jdGlvbjAsIHB1cmVGdW5jdGlvbjEgYXMgybVwdXJlRnVuY3Rpb24xLCBwdXJlRnVuY3Rpb24yIGFzIMm1cHVyZUZ1bmN0aW9uMiwgcHVyZUZ1bmN0aW9uMyBhcyDJtXB1cmVGdW5jdGlvbjMsIHB1cmVGdW5jdGlvbjQgYXMgybVwdXJlRnVuY3Rpb240LCBwdXJlRnVuY3Rpb241IGFzIMm1cHVyZUZ1bmN0aW9uNSwgcHVyZUZ1bmN0aW9uNiBhcyDJtXB1cmVGdW5jdGlvbjYsIHB1cmVGdW5jdGlvbjcgYXMgybVwdXJlRnVuY3Rpb243LCBwdXJlRnVuY3Rpb244IGFzIMm1cHVyZUZ1bmN0aW9uOCwgcHVyZUZ1bmN0aW9uViBhcyDJtXB1cmVGdW5jdGlvblYsIGdldEN1cnJlbnRWaWV3IGFzIMm1Z2V0Q3VycmVudFZpZXcsIHJlc3RvcmVWaWV3IGFzIMm1cmVzdG9yZVZpZXcsIGNvbnRhaW5lclJlZnJlc2hTdGFydCBhcyDJtWNvbnRhaW5lclJlZnJlc2hTdGFydCwgY29udGFpbmVyUmVmcmVzaEVuZCBhcyDJtWNvbnRhaW5lclJlZnJlc2hFbmQsIHF1ZXJ5UmVmcmVzaCBhcyDJtXF1ZXJ5UmVmcmVzaCwgbG9hZFF1ZXJ5TGlzdCBhcyDJtWxvYWRRdWVyeUxpc3QsIGVsZW1lbnRFbmQgYXMgybVlbGVtZW50RW5kLCBlbGVtZW50UHJvcGVydHkgYXMgybVlbGVtZW50UHJvcGVydHksIHByb2plY3Rpb25EZWYgYXMgybVwcm9qZWN0aW9uRGVmLCByZWZlcmVuY2UgYXMgybVyZWZlcmVuY2UsIGVuYWJsZUJpbmRpbmdzIGFzIMm1ZW5hYmxlQmluZGluZ3MsIGRpc2FibGVCaW5kaW5ncyBhcyDJtWRpc2FibGVCaW5kaW5ncywgZWxlbWVudEF0dHJpYnV0ZSBhcyDJtWVsZW1lbnRBdHRyaWJ1dGUsIGVsZW1lbnRTdHlsaW5nIGFzIMm1ZWxlbWVudFN0eWxpbmcsIGVsZW1lbnRTdHlsaW5nTWFwIGFzIMm1ZWxlbWVudFN0eWxpbmdNYXAsIGVsZW1lbnRTdHlsZVByb3AgYXMgybVlbGVtZW50U3R5bGVQcm9wLCBlbGVtZW50U3R5bGluZ0FwcGx5IGFzIMm1ZWxlbWVudFN0eWxpbmdBcHBseSwgZWxlbWVudENsYXNzUHJvcCBhcyDJtWVsZW1lbnRDbGFzc1Byb3AsIHRleHRCaW5kaW5nIGFzIMm1dGV4dEJpbmRpbmcsIHRlbXBsYXRlIGFzIMm1dGVtcGxhdGUsIGVtYmVkZGVkVmlld0VuZCBhcyDJtWVtYmVkZGVkVmlld0VuZCwgc3RvcmUgYXMgybVzdG9yZSwgbG9hZCBhcyDJtWxvYWQsIHBpcGUgYXMgybVwaXBlLCB3aGVuUmVuZGVyZWQgYXMgybV3aGVuUmVuZGVyZWQsIGkxOG5BdHRyaWJ1dGUgYXMgybVpMThuQXR0cmlidXRlLCBpMThuRXhwIGFzIMm1aTE4bkV4cCwgaTE4blN0YXJ0IGFzIMm1aTE4blN0YXJ0LCBpMThuRW5kIGFzIMm1aTE4bkVuZCwgaTE4bkFwcGx5IGFzIMm1aTE4bkFwcGx5LCBpMThuRXhwTWFwcGluZyBhcyDJtWkxOG5FeHBNYXBwaW5nLCBpMThuSW50ZXJwb2xhdGlvbjEgYXMgybVpMThuSW50ZXJwb2xhdGlvbjEsIGkxOG5JbnRlcnBvbGF0aW9uMiBhcyDJtWkxOG5JbnRlcnBvbGF0aW9uMiwgaTE4bkludGVycG9sYXRpb24zIGFzIMm1aTE4bkludGVycG9sYXRpb24zLCBpMThuSW50ZXJwb2xhdGlvbjQgYXMgybVpMThuSW50ZXJwb2xhdGlvbjQsIGkxOG5JbnRlcnBvbGF0aW9uNSBhcyDJtWkxOG5JbnRlcnBvbGF0aW9uNSwgaTE4bkludGVycG9sYXRpb242IGFzIMm1aTE4bkludGVycG9sYXRpb242LCBpMThuSW50ZXJwb2xhdGlvbjcgYXMgybVpMThuSW50ZXJwb2xhdGlvbjcsIGkxOG5JbnRlcnBvbGF0aW9uOCBhcyDJtWkxOG5JbnRlcnBvbGF0aW9uOCwgaTE4bkludGVycG9sYXRpb25WIGFzIMm1aTE4bkludGVycG9sYXRpb25WLCBpMThuTWFwcGluZyBhcyDJtWkxOG5NYXBwaW5nLCBXUkFQX1JFTkRFUkVSX0ZBQ1RPUlkyIGFzIMm1V1JBUF9SRU5ERVJFUl9GQUNUT1JZMiwgUmVuZGVyM0RlYnVnUmVuZGVyZXJGYWN0b3J5MiBhcyDJtVJlbmRlcjNEZWJ1Z1JlbmRlcmVyRmFjdG9yeTIsIFIzX0NPTVBJTEVfTkdNT0RVTEVfREVGUyBhcyDJtWNvbXBpbGVOZ01vZHVsZURlZnMsIFIzX1BBVENIX0NPTVBPTkVOVF9ERUZfV1RJSF9TQ09QRSBhcyDJtXBhdGNoQ29tcG9uZW50RGVmV2l0aFNjb3BlLCBSM19DT01QSUxFX0NPTVBPTkVOVCBhcyDJtWNvbXBpbGVDb21wb25lbnQsIFIzX0NPTVBJTEVfRElSRUNUSVZFIGFzIMm1Y29tcGlsZURpcmVjdGl2ZSwgUjNfQ09NUElMRV9QSVBFIGFzIMm1Y29tcGlsZVBpcGUsIHNhbml0aXplSHRtbCBhcyDJtXNhbml0aXplSHRtbCwgc2FuaXRpemVTdHlsZSBhcyDJtXNhbml0aXplU3R5bGUsIHNhbml0aXplVXJsIGFzIMm1c2FuaXRpemVVcmwsIHNhbml0aXplUmVzb3VyY2VVcmwgYXMgybVzYW5pdGl6ZVJlc291cmNlVXJsLCBieXBhc3NTYW5pdGl6YXRpb25UcnVzdEh0bWwgYXMgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdEh0bWwsIGJ5cGFzc1Nhbml0aXphdGlvblRydXN0U3R5bGUgYXMgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdFN0eWxlLCBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFNjcmlwdCBhcyDJtWJ5cGFzc1Nhbml0aXphdGlvblRydXN0U2NyaXB0LCBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFVybCBhcyDJtWJ5cGFzc1Nhbml0aXphdGlvblRydXN0VXJsLCBieXBhc3NTYW5pdGl6YXRpb25UcnVzdFJlc291cmNlVXJsIGFzIMm1YnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RSZXNvdXJjZVVybCwgZ2V0Q29udGV4dCBhcyDJtWdldENvbnRleHQsIGJpbmRQbGF5ZXJGYWN0b3J5IGFzIMm1YmluZFBsYXllckZhY3RvcnksIGFkZFBsYXllciBhcyDJtWFkZFBsYXllciwgZ2V0UGxheWVycyBhcyDJtWdldFBsYXllcnMsIGNvbXBpbGVOZ01vZHVsZUZhY3RvcnlfX1BPU1RfTkdDQ19fIGFzIMm1Y29tcGlsZU5nTW9kdWxlRmFjdG9yeV9fUE9TVF9OR0NDX18sIFIzX0NPTVBJTEVfQ09NUE9ORU5UX19QT1NUX05HQ0NfXyBhcyDJtVIzX0NPTVBJTEVfQ09NUE9ORU5UX19QT1NUX05HQ0NfXywgUjNfQ09NUElMRV9ESVJFQ1RJVkVfX1BPU1RfTkdDQ19fIGFzIMm1UjNfQ09NUElMRV9ESVJFQ1RJVkVfX1BPU1RfTkdDQ19fLCBSM19DT01QSUxFX0lOSkVDVEFCTEVfX1BPU1RfTkdDQ19fIGFzIMm1UjNfQ09NUElMRV9JTkpFQ1RBQkxFX19QT1NUX05HQ0NfXywgUjNfQ09NUElMRV9OR01PRFVMRV9fUE9TVF9OR0NDX18gYXMgybVSM19DT01QSUxFX05HTU9EVUxFX19QT1NUX05HQ0NfXywgUjNfQ09NUElMRV9QSVBFX19QT1NUX05HQ0NfXyBhcyDJtVIzX0NPTVBJTEVfUElQRV9fUE9TVF9OR0NDX18sIGl2eUVuYWJsZV9fUE9TVF9OR0NDX18gYXMgybVpdnlFbmFibGVfX1BPU1RfTkdDQ19fLCBSM19FTEVNRU5UX1JFRl9GQUNUT1JZX19QT1NUX05HQ0NfXyBhcyDJtVIzX0VMRU1FTlRfUkVGX0ZBQ1RPUllfX1BPU1RfTkdDQ19fLCBSM19URU1QTEFURV9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18gYXMgybVSM19URU1QTEFURV9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18sIFIzX0NIQU5HRV9ERVRFQ1RPUl9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18gYXMgybVSM19DSEFOR0VfREVURUNUT1JfUkVGX0ZBQ1RPUllfX1BPU1RfTkdDQ19fLCBSM19WSUVXX0NPTlRBSU5FUl9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18gYXMgybVSM19WSUVXX0NPTlRBSU5FUl9SRUZfRkFDVE9SWV9fUE9TVF9OR0NDX18sIFIzX1JFTkRFUkVSMl9GQUNUT1JZX19QT1NUX05HQ0NfXyBhcyDJtVIzX1JFTkRFUkVSMl9GQUNUT1JZX19QT1NUX05HQ0NfXywgcmVnaXN0ZXJNb2R1bGVGYWN0b3J5IGFzIMm1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5LCBFTVBUWV9BUlJBWSQ0IGFzIMm1RU1QVFlfQVJSQVksIEVNUFRZX01BUCBhcyDJtUVNUFRZX01BUCwgYW5jaG9yRGVmIGFzIMm1YW5kLCBjcmVhdGVDb21wb25lbnRGYWN0b3J5IGFzIMm1Y2NmLCBjcmVhdGVOZ01vZHVsZUZhY3RvcnkgYXMgybVjbWYsIGNyZWF0ZVJlbmRlcmVyVHlwZTIgYXMgybVjcnQsIGRpcmVjdGl2ZURlZiBhcyDJtWRpZCwgZWxlbWVudERlZiBhcyDJtWVsZCwgZWxlbWVudEV2ZW50RnVsbE5hbWUgYXMgybVlbGVtZW50RXZlbnRGdWxsTmFtZSwgZ2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5IGFzIMm1Z2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5LCBpbmxpbmVJbnRlcnBvbGF0ZSBhcyDJtWlubGluZUludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSBhcyDJtWludGVycG9sYXRlLCBtb2R1bGVEZWYgYXMgybVtb2QsIG1vZHVsZVByb3ZpZGVEZWYgYXMgybVtcGQsIG5nQ29udGVudERlZiBhcyDJtW5jZCwgbm9kZVZhbHVlIGFzIMm1bm92LCBwaXBlRGVmIGFzIMm1cGlkLCBwcm92aWRlckRlZiBhcyDJtXByZCwgcHVyZUFycmF5RGVmIGFzIMm1cGFkLCBwdXJlT2JqZWN0RGVmIGFzIMm1cG9kLCBwdXJlUGlwZURlZiBhcyDJtXBwZCwgcXVlcnlEZWYgYXMgybVxdWQsIHRleHREZWYgYXMgybV0ZWQsIHVud3JhcFZhbHVlIGFzIMm1dW52LCB2aWV3RGVmIGFzIMm1dmlkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1\\n\")},100:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isPromise; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction isPromise(value) {\\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\\n}\\n//# sourceMappingURL=isPromise.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanM/ZmQ2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Byb21pc2UuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///100\\n\")},101:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return subscribeToPromise; });\\n/* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);\\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\\n\\nvar subscribeToPromise = function (promise) {\\n    return function (subscriber) {\\n        promise.then(function (value) {\\n            if (!subscriber.closed) {\\n                subscriber.next(value);\\n                subscriber.complete();\\n            }\\n        }, function (err) { return subscriber.error(err); })\\n            .then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__[/* hostReportError */ \"a\"]);\\n        return subscriber;\\n    };\\n};\\n//# sourceMappingURL=subscribeToPromise.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvdXRpbC9zdWJzY3JpYmVUb1Byb21pc2UuanM/NGI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgaG9zdFJlcG9ydEVycm9yIH0gZnJvbSAnLi9ob3N0UmVwb3J0RXJyb3InO1xuZXhwb3J0IHZhciBzdWJzY3JpYmVUb1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSlcbiAgICAgICAgICAgIC50aGVuKG51bGwsIGhvc3RSZXBvcnRFcnJvcik7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlVG9Qcm9taXNlLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///101\\n')},102:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return subscribeToIterable; });\\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);\\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\\n\\nvar subscribeToIterable = function (iterable) {\\n    return function (subscriber) {\\n        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__[/* iterator */ \"a\"]]();\\n        do {\\n            var item = iterator.next();\\n            if (item.done) {\\n                subscriber.complete();\\n                break;\\n            }\\n            subscriber.next(item.value);\\n            if (subscriber.closed) {\\n                break;\\n            }\\n        } while (true);\\n        if (typeof iterator.return === \\'function\\') {\\n            subscriber.add(function () {\\n                if (iterator.return) {\\n                    iterator.return();\\n                }\\n            });\\n        }\\n        return subscriber;\\n    };\\n};\\n//# sourceMappingURL=subscribeToIterable.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvdXRpbC9zdWJzY3JpYmVUb0l0ZXJhYmxlLmpzP2JiYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX2l0ZXJhdG9yIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IGl0ZXJhdG9yIGFzIFN5bWJvbF9pdGVyYXRvciB9IGZyb20gJy4uL3N5bWJvbC9pdGVyYXRvcic7XG5leHBvcnQgdmFyIHN1YnNjcmliZVRvSXRlcmFibGUgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sX2l0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvSXRlcmFibGUuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///102\\n')},103:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return refCount; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction refCount() {\\n    return function refCountOperatorFunction(source) {\\n        return source.lift(new RefCountOperator(source));\\n    };\\n}\\nvar RefCountOperator = /*@__PURE__*/ (function () {\\n    function RefCountOperator(connectable) {\\n        this.connectable = connectable;\\n    }\\n    RefCountOperator.prototype.call = function (subscriber, source) {\\n        var connectable = this.connectable;\\n        connectable._refCount++;\\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\\n        var subscription = source.subscribe(refCounter);\\n        if (!refCounter.closed) {\\n            refCounter.connection = connectable.connect();\\n        }\\n        return subscription;\\n    };\\n    return RefCountOperator;\\n}());\\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](RefCountSubscriber, _super);\\n    function RefCountSubscriber(destination, connectable) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.connectable = connectable;\\n        return _this;\\n    }\\n    RefCountSubscriber.prototype._unsubscribe = function () {\\n        var connectable = this.connectable;\\n        if (!connectable) {\\n            this.connection = null;\\n            return;\\n        }\\n        this.connectable = null;\\n        var refCount = connectable._refCount;\\n        if (refCount <= 0) {\\n            this.connection = null;\\n            return;\\n        }\\n        connectable._refCount = refCount - 1;\\n        if (refCount > 1) {\\n            this.connection = null;\\n            return;\\n        }\\n        var connection = this.connection;\\n        var sharedConnection = connectable._connection;\\n        this.connection = null;\\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\\n            sharedConnection.unsubscribe();\\n        }\\n    };\\n    return RefCountSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ \"a\"]));\\n//# sourceMappingURL=refCount.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZkNvdW50LmpzP2M4NjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZkNvdW50KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiByZWZDb3VudE9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgUmVmQ291bnRPcGVyYXRvcihzb3VyY2UpKTtcbiAgICB9O1xufVxudmFyIFJlZkNvdW50T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPcGVyYXRvcihjb25uZWN0YWJsZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCsrO1xuICAgICAgICB2YXIgcmVmQ291bnRlciA9IG5ldyBSZWZDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29ubmVjdGFibGUpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShyZWZDb3VudGVyKTtcbiAgICAgICAgaWYgKCFyZWZDb3VudGVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmVmQ291bnRlci5jb25uZWN0aW9uID0gY29ubmVjdGFibGUuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRPcGVyYXRvcjtcbn0oKSk7XG52YXIgUmVmQ291bnRTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlZkNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZkNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoIWNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSBjb25uZWN0YWJsZS5fcmVmQ291bnQ7XG4gICAgICAgIGlmIChyZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IHJlZkNvdW50IC0gMTtcbiAgICAgICAgaWYgKHJlZkNvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZkNvdW50LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///103\\n')},129:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return merge; });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\\n/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);\\n/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94);\\n/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);\\n/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction merge() {\\n    var observables = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        observables[_i] = arguments[_i];\\n    }\\n    var concurrent = Number.POSITIVE_INFINITY;\\n    var scheduler = null;\\n    var last = observables[observables.length - 1];\\n    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ \"a\"])(last)) {\\n        scheduler = observables.pop();\\n        if (observables.length > 1 && typeof observables[observables.length - 1] === \\'number\\') {\\n            concurrent = observables.pop();\\n        }\\n    }\\n    else if (typeof last === \\'number\\') {\\n        concurrent = observables.pop();\\n    }\\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"]) {\\n        return observables[0];\\n    }\\n    return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__[/* mergeAll */ \"a\"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__[/* fromArray */ \"a\"])(observables, scheduler));\\n}\\n//# sourceMappingURL=merge.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9tZXJnZS5qcz9hNzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX3V0aWxfaXNTY2hlZHVsZXIsX29wZXJhdG9yc19tZXJnZUFsbCxfZnJvbUFycmF5IFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5pbXBvcnQgeyBtZXJnZUFsbCB9IGZyb20gJy4uL29wZXJhdG9ycy9tZXJnZUFsbCc7XG5pbXBvcnQgeyBmcm9tQXJyYXkgfSBmcm9tICcuL2Zyb21BcnJheSc7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgdmFyIGxhc3QgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNTY2hlZHVsZXIobGFzdCkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPiAxICYmIHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBvYnNlcnZhYmxlc1swXSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VBbGwoY29uY3VycmVudCkoZnJvbUFycmF5KG9ic2VydmFibGVzLCBzY2hlZHVsZXIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///129\\n')},13:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isArray; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\\n//# sourceMappingURL=isArray.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzQXJyYXkuanM/OGFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///13\\n\")},17:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isScheduler; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction isScheduler(value) {\\n    return value && typeof value.schedule === 'function';\\n}\\n//# sourceMappingURL=isScheduler.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzU2NoZWR1bGVyLmpzPzllNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///17\\n\")},19:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return config; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\\nvar config = {\\n    Promise: undefined,\\n    set useDeprecatedSynchronousErrorHandling(value) {\\n        if (value) {\\n            var error = /*@__PURE__*/ new Error();\\n            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\\\n' + error.stack);\\n        }\\n        else if (_enable_super_gross_mode_that_will_cause_bad_things) {\\n            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');\\n        }\\n        _enable_super_gross_mode_that_will_cause_bad_things = value;\\n    },\\n    get useDeprecatedSynchronousErrorHandling() {\\n        return _enable_super_gross_mode_that_will_cause_bad_things;\\n    },\\n};\\n//# sourceMappingURL=config.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9jb25maWcuanM/ODhiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG52YXIgX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzID0gZmFsc2U7XG5leHBvcnQgdmFyIGNvbmZpZyA9IHtcbiAgICBQcm9taXNlOiB1bmRlZmluZWQsXG4gICAgc2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAvKkBfX1BVUkVfXyovIG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgLypAX19QVVJFX18qLyBjb25zb2xlLndhcm4oJ0RFUFJFQ0FURUQhIFJ4SlMgd2FzIHNldCB0byB1c2UgZGVwcmVjYXRlZCBzeW5jaHJvbm91cyBlcnJvciBoYW5kbGluZyBiZWhhdmlvciBieSBjb2RlIGF0OiBcXG4nICsgZXJyb3Iuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncykge1xuICAgICAgICAgICAgLypAX19QVVJFX18qLyBjb25zb2xlLmxvZygnUnhKUzogQmFjayB0byBhIGJldHRlciBlcnJvciBiZWhhdmlvci4gVGhhbmsgeW91LiA8MycpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmFibGVfc3VwZXJfZ3Jvc3NfbW9kZV90aGF0X3dpbGxfY2F1c2VfYmFkX3RoaW5ncyA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3M7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///19\\n\")},20:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return SubjectSubscriber; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Subject; });\\n/* unused harmony export AnonymousSubject */\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);\\n/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(93);\\n/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(65);\\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\nvar SubjectSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](SubjectSubscriber, _super);\\n    function SubjectSubscriber(destination) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.destination = destination;\\n        return _this;\\n    }\\n    return SubjectSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__[/* Subscriber */ \"a\"]));\\n\\nvar Subject = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](Subject, _super);\\n    function Subject() {\\n        var _this = _super.call(this) || this;\\n        _this.observers = [];\\n        _this.closed = false;\\n        _this.isStopped = false;\\n        _this.hasError = false;\\n        _this.thrownError = null;\\n        return _this;\\n    }\\n    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__[/* rxSubscriber */ \"a\"]] = function () {\\n        return new SubjectSubscriber(this);\\n    };\\n    Subject.prototype.lift = function (operator) {\\n        var subject = new AnonymousSubject(this, this);\\n        subject.operator = operator;\\n        return subject;\\n    };\\n    Subject.prototype.next = function (value) {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        if (!this.isStopped) {\\n            var observers = this.observers;\\n            var len = observers.length;\\n            var copy = observers.slice();\\n            for (var i = 0; i < len; i++) {\\n                copy[i].next(value);\\n            }\\n        }\\n    };\\n    Subject.prototype.error = function (err) {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        this.hasError = true;\\n        this.thrownError = err;\\n        this.isStopped = true;\\n        var observers = this.observers;\\n        var len = observers.length;\\n        var copy = observers.slice();\\n        for (var i = 0; i < len; i++) {\\n            copy[i].error(err);\\n        }\\n        this.observers.length = 0;\\n    };\\n    Subject.prototype.complete = function () {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        this.isStopped = true;\\n        var observers = this.observers;\\n        var len = observers.length;\\n        var copy = observers.slice();\\n        for (var i = 0; i < len; i++) {\\n            copy[i].complete();\\n        }\\n        this.observers.length = 0;\\n    };\\n    Subject.prototype.unsubscribe = function () {\\n        this.isStopped = true;\\n        this.closed = true;\\n        this.observers = null;\\n    };\\n    Subject.prototype._trySubscribe = function (subscriber) {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        else {\\n            return _super.prototype._trySubscribe.call(this, subscriber);\\n        }\\n    };\\n    Subject.prototype._subscribe = function (subscriber) {\\n        if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        else if (this.hasError) {\\n            subscriber.error(this.thrownError);\\n            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ \"a\"].EMPTY;\\n        }\\n        else if (this.isStopped) {\\n            subscriber.complete();\\n            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ \"a\"].EMPTY;\\n        }\\n        else {\\n            this.observers.push(subscriber);\\n            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__[/* SubjectSubscription */ \"a\"](this, subscriber);\\n        }\\n    };\\n    Subject.prototype.asObservable = function () {\\n        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ \"a\"]();\\n        observable.source = this;\\n        return observable;\\n    };\\n    Subject.create = function (destination, source) {\\n        return new AnonymousSubject(destination, source);\\n    };\\n    return Subject;\\n}(_Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ \"a\"]));\\n\\nvar AnonymousSubject = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](AnonymousSubject, _super);\\n    function AnonymousSubject(destination, source) {\\n        var _this = _super.call(this) || this;\\n        _this.destination = destination;\\n        _this.source = source;\\n        return _this;\\n    }\\n    AnonymousSubject.prototype.next = function (value) {\\n        var destination = this.destination;\\n        if (destination && destination.next) {\\n            destination.next(value);\\n        }\\n    };\\n    AnonymousSubject.prototype.error = function (err) {\\n        var destination = this.destination;\\n        if (destination && destination.error) {\\n            this.destination.error(err);\\n        }\\n    };\\n    AnonymousSubject.prototype.complete = function () {\\n        var destination = this.destination;\\n        if (destination && destination.complete) {\\n            this.destination.complete();\\n        }\\n    };\\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\\n        var source = this.source;\\n        if (source) {\\n            return this.source.subscribe(subscriber);\\n        }\\n        else {\\n            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ \"a\"].EMPTY;\\n        }\\n    };\\n    return AnonymousSubject;\\n}(Subject));\\n\\n//# sourceMappingURL=Subject.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9TdWJqZWN0LmpzPzJiZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfT2JzZXJ2YWJsZSxfU3Vic2NyaWJlcixfU3Vic2NyaXB0aW9uLF91dGlsX09iamVjdFVuc3Vic2NyaWJlZEVycm9yLF9TdWJqZWN0U3Vic2NyaXB0aW9uLF9pbnRlcm5hbF9zeW1ib2xfcnhTdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgfSBmcm9tICcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuaW1wb3J0IHsgU3ViamVjdFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3ViamVjdFN1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyByeFN1YnNjcmliZXIgYXMgcnhTdWJzY3JpYmVyU3ltYm9sIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3ltYm9sL3J4U3Vic2NyaWJlcic7XG52YXIgU3ViamVjdFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBTdWJqZWN0U3Vic2NyaWJlciB9O1xudmFyIFN1YmplY3QgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFN1YmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3Q7XG59KE9ic2VydmFibGUpKTtcbmV4cG9ydCB7IFN1YmplY3QgfTtcbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5uZXh0KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5vbnltb3VzU3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0IHsgQW5vbnltb3VzU3ViamVjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///20\\n')},21:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return noop; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction noop() { }\\n//# sourceMappingURL=noop.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL25vb3AuanM/ZmFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///21\\n')},22:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 1 modules\\nvar Observable = __webpack_require__(4);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js\\nvar isPromise = __webpack_require__(100);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js\\nvar isArrayLike = __webpack_require__(98);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js\\nvar symbol_observable = __webpack_require__(32);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js\\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\\n\\nfunction isInteropObservable(input) {\\n    return input && typeof input[symbol_observable[\"a\" /* observable */]] === \\'function\\';\\n}\\n//# sourceMappingURL=isInteropObservable.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js\\nvar symbol_iterator = __webpack_require__(28);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js\\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\\n\\nfunction isIterable(input) {\\n    return input && typeof input[symbol_iterator[\"a\" /* iterator */]] === \\'function\\';\\n}\\n//# sourceMappingURL=isIterable.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js\\nvar fromArray = __webpack_require__(27);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 2 modules\\nvar Subscription = __webpack_require__(6);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js\\nvar subscribeToPromise = __webpack_require__(101);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromPromise.js\\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */\\n\\n\\n\\nfunction fromPromise(input, scheduler) {\\n    if (!scheduler) {\\n        return new Observable[\"a\" /* Observable */](Object(subscribeToPromise[\"a\" /* subscribeToPromise */])(input));\\n    }\\n    else {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var sub = new Subscription[\"a\" /* Subscription */]();\\n            sub.add(scheduler.schedule(function () {\\n                return input.then(function (value) {\\n                    sub.add(scheduler.schedule(function () {\\n                        subscriber.next(value);\\n                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));\\n                    }));\\n                }, function (err) {\\n                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));\\n                });\\n            }));\\n            return sub;\\n        });\\n    }\\n}\\n//# sourceMappingURL=fromPromise.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js\\nvar subscribeToIterable = __webpack_require__(102);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromIterable.js\\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction fromIterable(input, scheduler) {\\n    if (!input) {\\n        throw new Error(\\'Iterable cannot be null\\');\\n    }\\n    if (!scheduler) {\\n        return new Observable[\"a\" /* Observable */](Object(subscribeToIterable[\"a\" /* subscribeToIterable */])(input));\\n    }\\n    else {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var sub = new Subscription[\"a\" /* Subscription */]();\\n            var iterator;\\n            sub.add(function () {\\n                if (iterator && typeof iterator.return === \\'function\\') {\\n                    iterator.return();\\n                }\\n            });\\n            sub.add(scheduler.schedule(function () {\\n                iterator = input[symbol_iterator[\"a\" /* iterator */]]();\\n                sub.add(scheduler.schedule(function () {\\n                    if (subscriber.closed) {\\n                        return;\\n                    }\\n                    var value;\\n                    var done;\\n                    try {\\n                        var result = iterator.next();\\n                        value = result.value;\\n                        done = result.done;\\n                    }\\n                    catch (err) {\\n                        subscriber.error(err);\\n                        return;\\n                    }\\n                    if (done) {\\n                        subscriber.complete();\\n                    }\\n                    else {\\n                        subscriber.next(value);\\n                        this.schedule();\\n                    }\\n                }));\\n            }));\\n            return sub;\\n        });\\n    }\\n}\\n//# sourceMappingURL=fromIterable.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js\\nvar subscribeToObservable = __webpack_require__(97);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromObservable.js\\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction fromObservable(input, scheduler) {\\n    if (!scheduler) {\\n        return new Observable[\"a\" /* Observable */](Object(subscribeToObservable[\"a\" /* subscribeToObservable */])(input));\\n    }\\n    else {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var sub = new Subscription[\"a\" /* Subscription */]();\\n            sub.add(scheduler.schedule(function () {\\n                var observable = input[symbol_observable[\"a\" /* observable */]]();\\n                sub.add(observable.subscribe({\\n                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },\\n                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },\\n                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },\\n                }));\\n            }));\\n            return sub;\\n        });\\n    }\\n}\\n//# sourceMappingURL=fromObservable.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js\\nvar subscribeTo = __webpack_require__(96);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return from; });\\n/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction from(input, scheduler) {\\n    if (!scheduler) {\\n        if (input instanceof Observable[\"a\" /* Observable */]) {\\n            return input;\\n        }\\n        return new Observable[\"a\" /* Observable */](Object(subscribeTo[\"a\" /* subscribeTo */])(input));\\n    }\\n    if (input != null) {\\n        if (isInteropObservable(input)) {\\n            return fromObservable(input, scheduler);\\n        }\\n        else if (Object(isPromise[\"a\" /* isPromise */])(input)) {\\n            return fromPromise(input, scheduler);\\n        }\\n        else if (Object(isArrayLike[\"a\" /* isArrayLike */])(input)) {\\n            return Object(fromArray[\"a\" /* fromArray */])(input, scheduler);\\n        }\\n        else if (isIterable(input) || typeof input === \\'string\\') {\\n            return fromIterable(input, scheduler);\\n        }\\n    }\\n    throw new TypeError((input !== null && typeof input || input) + \\' is not observable\\');\\n}\\n//# sourceMappingURL=from.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUuanM/ZjFjYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanM/OGM3NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlLmpzPzYzOTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tSXRlcmFibGUuanM/NmM0ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21PYnNlcnZhYmxlLmpzPzk0MDkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tLmpzP2QzZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX29ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgb2JzZXJ2YWJsZSBhcyBTeW1ib2xfb2JzZXJ2YWJsZSB9IGZyb20gJy4uL3N5bWJvbC9vYnNlcnZhYmxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVyb3BPYnNlcnZhYmxlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ICYmIHR5cGVvZiBpbnB1dFtTeW1ib2xfb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0ludGVyb3BPYnNlcnZhYmxlLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX2l0ZXJhdG9yIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IGl0ZXJhdG9yIGFzIFN5bWJvbF9pdGVyYXRvciB9IGZyb20gJy4uL3N5bWJvbC9pdGVyYXRvcic7XG5leHBvcnQgZnVuY3Rpb24gaXNJdGVyYWJsZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCAmJiB0eXBlb2YgaW5wdXRbU3ltYm9sX2l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzSXRlcmFibGUuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9TdWJzY3JpcHRpb24sX3V0aWxfc3Vic2NyaWJlVG9Qcm9taXNlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Byb21pc2UgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUHJvbWlzZSc7XG5leHBvcnQgZnVuY3Rpb24gZnJvbVByb21pc2UoaW5wdXQsIHNjaGVkdWxlcikge1xuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUb1Byb21pc2UoaW5wdXQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7IH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21Qcm9taXNlLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfU3Vic2NyaXB0aW9uLF9zeW1ib2xfaXRlcmF0b3IsX3V0aWxfc3Vic2NyaWJlVG9JdGVyYWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgaXRlcmF0b3IgYXMgU3ltYm9sX2l0ZXJhdG9yIH0gZnJvbSAnLi4vc3ltYm9sL2l0ZXJhdG9yJztcbmltcG9ydCB7IHN1YnNjcmliZVRvSXRlcmFibGUgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvSXRlcmFibGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21JdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZXJhYmxlIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgfVxuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUb0l0ZXJhYmxlKGlucHV0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3I7XG4gICAgICAgICAgICBzdWIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IgJiYgdHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGlucHV0W1N5bWJvbF9pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gcmVzdWx0LmRvbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUl0ZXJhYmxlLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfU3Vic2NyaXB0aW9uLF9zeW1ib2xfb2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUb09ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IG9ic2VydmFibGUgYXMgU3ltYm9sX29ic2VydmFibGUgfSBmcm9tICcuLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb09ic2VydmFibGUgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvT2JzZXJ2YWJsZSc7XG5leHBvcnQgZnVuY3Rpb24gZnJvbU9ic2VydmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUb09ic2VydmFibGUoaW5wdXQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IGlucHV0W1N5bWJvbF9vYnNlcnZhYmxlXSgpO1xuICAgICAgICAgICAgICAgIHN1Yi5hZGQob2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSkpOyB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7IH0pKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KSk7IH0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbU9ic2VydmFibGUuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF91dGlsX2lzUHJvbWlzZSxfdXRpbF9pc0FycmF5TGlrZSxfdXRpbF9pc0ludGVyb3BPYnNlcnZhYmxlLF91dGlsX2lzSXRlcmFibGUsX2Zyb21BcnJheSxfZnJvbVByb21pc2UsX2Zyb21JdGVyYWJsZSxfZnJvbU9ic2VydmFibGUsX3V0aWxfc3Vic2NyaWJlVG8gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9pc1Byb21pc2UnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UgfSBmcm9tICcuLi91dGlsL2lzQXJyYXlMaWtlJztcbmltcG9ydCB7IGlzSW50ZXJvcE9ic2VydmFibGUgfSBmcm9tICcuLi91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNJdGVyYWJsZSB9IGZyb20gJy4uL3V0aWwvaXNJdGVyYWJsZSc7XG5pbXBvcnQgeyBmcm9tQXJyYXkgfSBmcm9tICcuL2Zyb21BcnJheSc7XG5pbXBvcnQgeyBmcm9tUHJvbWlzZSB9IGZyb20gJy4vZnJvbVByb21pc2UnO1xuaW1wb3J0IHsgZnJvbUl0ZXJhYmxlIH0gZnJvbSAnLi9mcm9tSXRlcmFibGUnO1xuaW1wb3J0IHsgZnJvbU9ic2VydmFibGUgfSBmcm9tICcuL2Zyb21PYnNlcnZhYmxlJztcbmltcG9ydCB7IHN1YnNjcmliZVRvIH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUbyc7XG5leHBvcnQgZnVuY3Rpb24gZnJvbShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUbyhpbnB1dCkpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNJbnRlcm9wT2JzZXJ2YWJsZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tT2JzZXJ2YWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1Byb21pc2UoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVByb21pc2UoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2UoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFycmF5KGlucHV0LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSXRlcmFibGUoaW5wdXQpIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0IHx8IGlucHV0KSArICcgaXMgbm90IG9ic2VydmFibGUnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///22\\n')},23:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return map; });\\n/* unused harmony export MapOperator */\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction map(project, thisArg) {\\n    return function mapOperation(source) {\\n        if (typeof project !== \\'function\\') {\\n            throw new TypeError(\\'argument is not a function. Are you looking for `mapTo()`?\\');\\n        }\\n        return source.lift(new MapOperator(project, thisArg));\\n    };\\n}\\nvar MapOperator = /*@__PURE__*/ (function () {\\n    function MapOperator(project, thisArg) {\\n        this.project = project;\\n        this.thisArg = thisArg;\\n    }\\n    MapOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\\n    };\\n    return MapOperator;\\n}());\\n\\nvar MapSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](MapSubscriber, _super);\\n    function MapSubscriber(destination, project, thisArg) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.project = project;\\n        _this.count = 0;\\n        _this.thisArg = thisArg || _this;\\n        return _this;\\n    }\\n    MapSubscriber.prototype._next = function (value) {\\n        var result;\\n        try {\\n            result = this.project.call(this.thisArg, value, this.count++);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.destination.next(result);\\n    };\\n    return MapSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ \"a\"]));\\n//# sourceMappingURL=map.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzP2ViYjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcE9wZXJhdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSk7XG4gICAgfTtcbn1cbnZhciBNYXBPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydCB7IE1hcE9wZXJhdG9yIH07XG52YXIgTWFwU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IF90aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///23\\n')},24:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return subscribeToResult; });\\n/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);\\n/* harmony import */ var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96);\\n/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */\\n\\n\\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {\\n    if (destination === void 0) {\\n        destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__[/* InnerSubscriber */ \"a\"](outerSubscriber, outerValue, outerIndex);\\n    }\\n    if (destination.closed) {\\n        return;\\n    }\\n    return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__[/* subscribeTo */ \"a\"])(result)(destination);\\n}\\n//# sourceMappingURL=subscribeToResult.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzP2NlOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfSW5uZXJTdWJzY3JpYmVyLF9zdWJzY3JpYmVUbyBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG8gfSBmcm9tICcuL3N1YnNjcmliZVRvJztcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVUb1Jlc3VsdChvdXRlclN1YnNjcmliZXIsIHJlc3VsdCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IG5ldyBJbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KTtcbiAgICB9XG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpYmVUbyhyZXN1bHQpKGRlc3RpbmF0aW9uKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvUmVzdWx0LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///24\\n')},25:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return OuterSubscriber; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nvar OuterSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](OuterSubscriber, _super);\\n    function OuterSubscriber() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        this.destination.next(innerValue);\\n    };\\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\\n        this.destination.error(error);\\n    };\\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\\n        this.destination.complete();\\n    };\\n    return OuterSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ \"a\"]));\\n\\n//# sourceMappingURL=OuterSubscriber.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9PdXRlclN1YnNjcmliZXIuanM/MzA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbnZhciBPdXRlclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IE91dGVyU3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///25\\n')},27:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return fromArray; });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\\n/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);\\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */\\n\\n\\n\\nfunction fromArray(input, scheduler) {\\n    if (!scheduler) {\\n        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__[/* subscribeToArray */ \"a\"])(input));\\n    }\\n    else {\\n        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"](function (subscriber) {\\n            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ \"a\"]();\\n            var i = 0;\\n            sub.add(scheduler.schedule(function () {\\n                if (i === input.length) {\\n                    subscriber.complete();\\n                    return;\\n                }\\n                subscriber.next(input[i++]);\\n                if (!subscriber.closed) {\\n                    sub.add(this.schedule());\\n                }\\n            }));\\n            return sub;\\n        });\\n    }\\n}\\n//# sourceMappingURL=fromArray.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21BcnJheS5qcz8yMTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX1N1YnNjcmlwdGlvbixfdXRpbF9zdWJzY3JpYmVUb0FycmF5IFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb0FycmF5IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb0FycmF5JztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkoaW5wdXQsIHNjaGVkdWxlcikge1xuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUb0FycmF5KGlucHV0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGlucHV0W2krK10pO1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLmFkZCh0aGlzLnNjaGVkdWxlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21BcnJheS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///27\\n')},28:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* unused harmony export getSymbolIterator */\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return iterator; });\\n/* unused harmony export $$iterator */\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction getSymbolIterator() {\\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\\n        return '@@iterator';\\n    }\\n    return Symbol.iterator;\\n}\\nvar iterator = /*@__PURE__*/ getSymbolIterator();\\nvar $$iterator = iterator;\\n//# sourceMappingURL=iterator.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zeW1ib2wvaXRlcmF0b3IuanM/MTI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ltYm9sSXRlcmF0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbiAgICByZXR1cm4gU3ltYm9sLml0ZXJhdG9yO1xufVxuZXhwb3J0IHZhciBpdGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gZ2V0U3ltYm9sSXRlcmF0b3IoKTtcbmV4cG9ydCB2YXIgJCRpdGVyYXRvciA9IGl0ZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///28\\n\")},32:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return observable; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\\n//# sourceMappingURL=observable.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zeW1ib2wvb2JzZXJ2YWJsZS5qcz9jNTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cbmV4cG9ydCB2YXIgb2JzZXJ2YWJsZSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///32\\n\")},33:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ObjectUnsubscribedError; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction ObjectUnsubscribedErrorImpl() {\\n    Error.call(this);\\n    this.message = 'object unsubscribed';\\n    this.name = 'ObjectUnsubscribedError';\\n    return this;\\n}\\nObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\\nvar ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzP2YyMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZnVuY3Rpb24gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JJbXBsKCkge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tZXNzYWdlID0gJ29iamVjdCB1bnN1YnNjcmliZWQnO1xuICAgIHRoaXMubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5PYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qLyBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5leHBvcnQgdmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///33\\n\")},355:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js\\nvar ConnectableObservable = __webpack_require__(91);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js\\n/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */\\n\\nfunction multicast(subjectOrSubjectFactory, selector) {\\n    return function multicastOperatorFunction(source) {\\n        var subjectFactory;\\n        if (typeof subjectOrSubjectFactory === \\'function\\') {\\n            subjectFactory = subjectOrSubjectFactory;\\n        }\\n        else {\\n            subjectFactory = function subjectFactory() {\\n                return subjectOrSubjectFactory;\\n            };\\n        }\\n        if (typeof selector === \\'function\\') {\\n            return source.lift(new MulticastOperator(subjectFactory, selector));\\n        }\\n        var connectable = Object.create(source, ConnectableObservable[\"b\" /* connectableObservableDescriptor */]);\\n        connectable.source = source;\\n        connectable.subjectFactory = subjectFactory;\\n        return connectable;\\n    };\\n}\\nvar MulticastOperator = /*@__PURE__*/ (function () {\\n    function MulticastOperator(subjectFactory, selector) {\\n        this.subjectFactory = subjectFactory;\\n        this.selector = selector;\\n    }\\n    MulticastOperator.prototype.call = function (subscriber, source) {\\n        var selector = this.selector;\\n        var subject = this.subjectFactory();\\n        var subscription = selector(subject).subscribe(subscriber);\\n        subscription.add(source.subscribe(subject));\\n        return subscription;\\n    };\\n    return MulticastOperator;\\n}());\\n\\n//# sourceMappingURL=multicast.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js\\nvar refCount = __webpack_require__(103);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js\\nvar Subject = __webpack_require__(20);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return share; });\\n/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */\\n\\n\\n\\nfunction shareSubjectFactory() {\\n    return new Subject[\"a\" /* Subject */]();\\n}\\nfunction share() {\\n    return function (source) { return Object(refCount[\"a\" /* refCount */])()(multicast(shareSubjectFactory)(source)); };\\n}\\n//# sourceMappingURL=share.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL211bHRpY2FzdC5qcz9jNjUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qcz80YjU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX29ic2VydmFibGVfQ29ubmVjdGFibGVPYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IGNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZSc7XG5leHBvcnQgZnVuY3Rpb24gbXVsdGljYXN0KHN1YmplY3RPclN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBtdWx0aWNhc3RPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3ViamVjdE9yU3ViamVjdEZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN1YmplY3RGYWN0b3J5ID0gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIHN1YmplY3RGYWN0b3J5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSBPYmplY3QuY3JlYXRlKHNvdXJjZSwgY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvcik7XG4gICAgICAgIGNvbm5lY3RhYmxlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgY29ubmVjdGFibGUuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RhYmxlO1xuICAgIH07XG59XG52YXIgTXVsdGljYXN0T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0T3BlcmF0b3Ioc3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBNdWx0aWNhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZWxlY3RvcihzdWJqZWN0KS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoc291cmNlLnN1YnNjcmliZShzdWJqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0IHsgTXVsdGljYXN0T3BlcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX211bHRpY2FzdCxfcmVmQ291bnQsX1N1YmplY3QgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgbXVsdGljYXN0IH0gZnJvbSAnLi9tdWx0aWNhc3QnO1xuaW1wb3J0IHsgcmVmQ291bnQgfSBmcm9tICcuL3JlZkNvdW50JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmZ1bmN0aW9uIHNoYXJlU3ViamVjdEZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJqZWN0KCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhcmUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHJlZkNvdW50KCkobXVsdGljYXN0KHNoYXJlU3ViamVjdEZhY3RvcnkpKHNvdXJjZSkpOyB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwXG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDckNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///355\\n')},36:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return identity; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction identity(x) {\\n    return x;\\n}\\n//# sourceMappingURL=identity.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzPzk4MjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///36\\n')},37:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isFunction; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction isFunction(x) {\\n    return typeof x === 'function';\\n}\\n//# sourceMappingURL=isFunction.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanM/ZDgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///37\\n\")},4:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js\\nvar canReportError = __webpack_require__(73);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js\\nvar Subscriber = __webpack_require__(5);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js\\nvar rxSubscriber = __webpack_require__(65);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js\\nvar Observer = __webpack_require__(74);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js\\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\\n\\n\\n\\nfunction toSubscriber(nextOrObserver, error, complete) {\\n    if (nextOrObserver) {\\n        if (nextOrObserver instanceof Subscriber[\"a\" /* Subscriber */]) {\\n            return nextOrObserver;\\n        }\\n        if (nextOrObserver[rxSubscriber[\"a\" /* rxSubscriber */]]) {\\n            return nextOrObserver[rxSubscriber[\"a\" /* rxSubscriber */]]();\\n        }\\n    }\\n    if (!nextOrObserver && !error && !complete) {\\n        return new Subscriber[\"a\" /* Subscriber */](Observer[\"a\" /* empty */]);\\n    }\\n    return new Subscriber[\"a\" /* Subscriber */](nextOrObserver, error, complete);\\n}\\n//# sourceMappingURL=toSubscriber.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js\\nvar observable = __webpack_require__(32);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js\\nvar pipe = __webpack_require__(63);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js\\nvar config = __webpack_require__(19);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Observable_Observable; });\\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\nvar Observable_Observable = /*@__PURE__*/ (function () {\\n    function Observable(subscribe) {\\n        this._isScalar = false;\\n        if (subscribe) {\\n            this._subscribe = subscribe;\\n        }\\n    }\\n    Observable.prototype.lift = function (operator) {\\n        var observable = new Observable();\\n        observable.source = this;\\n        observable.operator = operator;\\n        return observable;\\n    };\\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\\n        var operator = this.operator;\\n        var sink = toSubscriber(observerOrNext, error, complete);\\n        if (operator) {\\n            operator.call(sink, this.source);\\n        }\\n        else {\\n            sink.add(this.source || (config[\"a\" /* config */].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\\n                this._subscribe(sink) :\\n                this._trySubscribe(sink));\\n        }\\n        if (config[\"a\" /* config */].useDeprecatedSynchronousErrorHandling) {\\n            if (sink.syncErrorThrowable) {\\n                sink.syncErrorThrowable = false;\\n                if (sink.syncErrorThrown) {\\n                    throw sink.syncErrorValue;\\n                }\\n            }\\n        }\\n        return sink;\\n    };\\n    Observable.prototype._trySubscribe = function (sink) {\\n        try {\\n            return this._subscribe(sink);\\n        }\\n        catch (err) {\\n            if (config[\"a\" /* config */].useDeprecatedSynchronousErrorHandling) {\\n                sink.syncErrorThrown = true;\\n                sink.syncErrorValue = err;\\n            }\\n            if (Object(canReportError[\"a\" /* canReportError */])(sink)) {\\n                sink.error(err);\\n            }\\n            else {\\n                console.warn(err);\\n            }\\n        }\\n    };\\n    Observable.prototype.forEach = function (next, promiseCtor) {\\n        var _this = this;\\n        promiseCtor = getPromiseCtor(promiseCtor);\\n        return new promiseCtor(function (resolve, reject) {\\n            var subscription;\\n            subscription = _this.subscribe(function (value) {\\n                try {\\n                    next(value);\\n                }\\n                catch (err) {\\n                    reject(err);\\n                    if (subscription) {\\n                        subscription.unsubscribe();\\n                    }\\n                }\\n            }, reject, resolve);\\n        });\\n    };\\n    Observable.prototype._subscribe = function (subscriber) {\\n        var source = this.source;\\n        return source && source.subscribe(subscriber);\\n    };\\n    Observable.prototype[observable[\"a\" /* observable */]] = function () {\\n        return this;\\n    };\\n    Observable.prototype.pipe = function () {\\n        var operations = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            operations[_i] = arguments[_i];\\n        }\\n        if (operations.length === 0) {\\n            return this;\\n        }\\n        return Object(pipe[\"b\" /* pipeFromArray */])(operations)(this);\\n    };\\n    Observable.prototype.toPromise = function (promiseCtor) {\\n        var _this = this;\\n        promiseCtor = getPromiseCtor(promiseCtor);\\n        return new promiseCtor(function (resolve, reject) {\\n            var value;\\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\\n        });\\n    };\\n    Observable.create = function (subscribe) {\\n        return new Observable(subscribe);\\n    };\\n    return Observable;\\n}());\\n\\nfunction getPromiseCtor(promiseCtor) {\\n    if (!promiseCtor) {\\n        promiseCtor = config[\"a\" /* config */].Promise || Promise;\\n    }\\n    if (!promiseCtor) {\\n        throw new Error(\\'no Promise impl found\\');\\n    }\\n    return promiseCtor;\\n}\\n//# sourceMappingURL=Observable.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL3V0aWwvdG9TdWJzY3JpYmVyLmpzPzNkZTgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qcz9lOWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX1N1YnNjcmliZXIsX3N5bWJvbF9yeFN1YnNjcmliZXIsX09ic2VydmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IHJ4U3Vic2NyaWJlciBhcyByeFN1YnNjcmliZXJTeW1ib2wgfSBmcm9tICcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJztcbmltcG9ydCB7IGVtcHR5IGFzIGVtcHR5T2JzZXJ2ZXIgfSBmcm9tICcuLi9PYnNlcnZlcic7XG5leHBvcnQgZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJTeW1ib2xdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZXIoZW1wdHlPYnNlcnZlcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvU3Vic2NyaWJlci5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3V0aWxfY2FuUmVwb3J0RXJyb3IsX3V0aWxfdG9TdWJzY3JpYmVyLF9pbnRlcm5hbF9zeW1ib2xfb2JzZXJ2YWJsZSxfdXRpbF9waXBlLF9jb25maWcgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgY2FuUmVwb3J0RXJyb3IgfSBmcm9tICcuL3V0aWwvY2FuUmVwb3J0RXJyb3InO1xuaW1wb3J0IHsgdG9TdWJzY3JpYmVyIH0gZnJvbSAnLi91dGlsL3RvU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBvYnNlcnZhYmxlIGFzIFN5bWJvbF9vYnNlcnZhYmxlIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUnO1xuaW1wb3J0IHsgcGlwZUZyb21BcnJheSB9IGZyb20gJy4vdXRpbC9waXBlJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcbnZhciBPYnNlcnZhYmxlID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgdmFyIHNpbmsgPSB0b1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgb3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW5rLmFkZCh0aGlzLnNvdXJjZSB8fCAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgJiYgIXNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKHNpbmspIDpcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlTdWJzY3JpYmUoc2luaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbms7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuUmVwb3J0RXJyb3Ioc2luaykpIHtcbiAgICAgICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBwcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbU3ltYm9sX29ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZUZyb21BcnJheShvcGVyYXRpb25zKSh0aGlzKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHZhbHVlID0geDsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUodmFsdWUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKHN1YnNjcmliZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKSk7XG5leHBvcnQgeyBPYnNlcnZhYmxlIH07XG5mdW5jdGlvbiBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcikge1xuICAgIGlmICghcHJvbWlzZUN0b3IpIHtcbiAgICAgICAgcHJvbWlzZUN0b3IgPSBjb25maWcuUHJvbWlzZSB8fCBQcm9taXNlO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2VDdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlQ3Rvcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///4\\n')},5:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Subscriber; });\\n/* unused harmony export SafeSubscriber */\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);\\n/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\\n/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65);\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);\\n/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);\\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\nvar Subscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](Subscriber, _super);\\n    function Subscriber(destinationOrNext, error, complete) {\\n        var _this = _super.call(this) || this;\\n        _this.syncErrorValue = null;\\n        _this.syncErrorThrown = false;\\n        _this.syncErrorThrowable = false;\\n        _this.isStopped = false;\\n        _this._parentSubscription = null;\\n        switch (arguments.length) {\\n            case 0:\\n                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ \"a\"];\\n                break;\\n            case 1:\\n                if (!destinationOrNext) {\\n                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ \"a\"];\\n                    break;\\n                }\\n                if (typeof destinationOrNext === \\'object\\') {\\n                    if (destinationOrNext instanceof Subscriber) {\\n                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\\n                        _this.destination = destinationOrNext;\\n                        destinationOrNext.add(_this);\\n                    }\\n                    else {\\n                        _this.syncErrorThrowable = true;\\n                        _this.destination = new SafeSubscriber(_this, destinationOrNext);\\n                    }\\n                    break;\\n                }\\n            default:\\n                _this.syncErrorThrowable = true;\\n                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\\n                break;\\n        }\\n        return _this;\\n    }\\n    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__[/* rxSubscriber */ \"a\"]] = function () { return this; };\\n    Subscriber.create = function (next, error, complete) {\\n        var subscriber = new Subscriber(next, error, complete);\\n        subscriber.syncErrorThrowable = false;\\n        return subscriber;\\n    };\\n    Subscriber.prototype.next = function (value) {\\n        if (!this.isStopped) {\\n            this._next(value);\\n        }\\n    };\\n    Subscriber.prototype.error = function (err) {\\n        if (!this.isStopped) {\\n            this.isStopped = true;\\n            this._error(err);\\n        }\\n    };\\n    Subscriber.prototype.complete = function () {\\n        if (!this.isStopped) {\\n            this.isStopped = true;\\n            this._complete();\\n        }\\n    };\\n    Subscriber.prototype.unsubscribe = function () {\\n        if (this.closed) {\\n            return;\\n        }\\n        this.isStopped = true;\\n        _super.prototype.unsubscribe.call(this);\\n    };\\n    Subscriber.prototype._next = function (value) {\\n        this.destination.next(value);\\n    };\\n    Subscriber.prototype._error = function (err) {\\n        this.destination.error(err);\\n        this.unsubscribe();\\n    };\\n    Subscriber.prototype._complete = function () {\\n        this.destination.complete();\\n        this.unsubscribe();\\n    };\\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\\n        this._parent = null;\\n        this._parents = null;\\n        this.unsubscribe();\\n        this.closed = false;\\n        this.isStopped = false;\\n        this._parent = _parent;\\n        this._parents = _parents;\\n        this._parentSubscription = null;\\n        return this;\\n    };\\n    return Subscriber;\\n}(_Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ \"a\"]));\\n\\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](SafeSubscriber, _super);\\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\\n        var _this = _super.call(this) || this;\\n        _this._parentSubscriber = _parentSubscriber;\\n        var next;\\n        var context = _this;\\n        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ \"a\"])(observerOrNext)) {\\n            next = observerOrNext;\\n        }\\n        else if (observerOrNext) {\\n            next = observerOrNext.next;\\n            error = observerOrNext.error;\\n            complete = observerOrNext.complete;\\n            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ \"a\"]) {\\n                context = Object.create(observerOrNext);\\n                if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ \"a\"])(context.unsubscribe)) {\\n                    _this.add(context.unsubscribe.bind(context));\\n                }\\n                context.unsubscribe = _this.unsubscribe.bind(_this);\\n            }\\n        }\\n        _this._context = context;\\n        _this._next = next;\\n        _this._error = error;\\n        _this._complete = complete;\\n        return _this;\\n    }\\n    SafeSubscriber.prototype.next = function (value) {\\n        if (!this.isStopped && this._next) {\\n            var _parentSubscriber = this._parentSubscriber;\\n            if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\\n                this.__tryOrUnsub(this._next, value);\\n            }\\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\\n                this.unsubscribe();\\n            }\\n        }\\n    };\\n    SafeSubscriber.prototype.error = function (err) {\\n        if (!this.isStopped) {\\n            var _parentSubscriber = this._parentSubscriber;\\n            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling;\\n            if (this._error) {\\n                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\\n                    this.__tryOrUnsub(this._error, err);\\n                    this.unsubscribe();\\n                }\\n                else {\\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\\n                    this.unsubscribe();\\n                }\\n            }\\n            else if (!_parentSubscriber.syncErrorThrowable) {\\n                this.unsubscribe();\\n                if (useDeprecatedSynchronousErrorHandling) {\\n                    throw err;\\n                }\\n                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ \"a\"])(err);\\n            }\\n            else {\\n                if (useDeprecatedSynchronousErrorHandling) {\\n                    _parentSubscriber.syncErrorValue = err;\\n                    _parentSubscriber.syncErrorThrown = true;\\n                }\\n                else {\\n                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ \"a\"])(err);\\n                }\\n                this.unsubscribe();\\n            }\\n        }\\n    };\\n    SafeSubscriber.prototype.complete = function () {\\n        var _this = this;\\n        if (!this.isStopped) {\\n            var _parentSubscriber = this._parentSubscriber;\\n            if (this._complete) {\\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\\n                if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\\n                    this.__tryOrUnsub(wrappedComplete);\\n                    this.unsubscribe();\\n                }\\n                else {\\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\\n                    this.unsubscribe();\\n                }\\n            }\\n            else {\\n                this.unsubscribe();\\n            }\\n        }\\n    };\\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\\n        try {\\n            fn.call(this._context, value);\\n        }\\n        catch (err) {\\n            this.unsubscribe();\\n            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling) {\\n                throw err;\\n            }\\n            else {\\n                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ \"a\"])(err);\\n            }\\n        }\\n    };\\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\\n        if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling) {\\n            throw new Error(\\'bad call\\');\\n        }\\n        try {\\n            fn.call(this._context, value);\\n        }\\n        catch (err) {\\n            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling) {\\n                parent.syncErrorValue = err;\\n                parent.syncErrorThrown = true;\\n                return true;\\n            }\\n            else {\\n                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ \"a\"])(err);\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    SafeSubscriber.prototype._unsubscribe = function () {\\n        var _parentSubscriber = this._parentSubscriber;\\n        this._context = null;\\n        this._parentSubscriber = null;\\n        _parentSubscriber.unsubscribe();\\n    };\\n    return SafeSubscriber;\\n}(Subscriber));\\n\\n//# sourceMappingURL=Subscriber.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL1N1YnNjcmliZXIuanM/MTQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF91dGlsX2lzRnVuY3Rpb24sX09ic2VydmVyLF9TdWJzY3JpcHRpb24sX2ludGVybmFsX3N5bWJvbF9yeFN1YnNjcmliZXIsX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBlbXB0eSBhcyBlbXB0eU9ic2VydmVyIH0gZnJvbSAnLi9PYnNlcnZlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyByeFN1YnNjcmliZXIgYXMgcnhTdWJzY3JpYmVyU3ltYm9sIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3ltYm9sL3J4U3Vic2NyaWJlcic7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBob3N0UmVwb3J0RXJyb3IgfSBmcm9tICcuL3V0aWwvaG9zdFJlcG9ydEVycm9yJztcbnZhciBTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3BhcmVudFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZW1wdHlPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZW1wdHlPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGRlc3RpbmF0aW9uT3JOZXh0LnN5bmNFcnJvclRocm93YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb25Pck5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbk9yTmV4dC5hZGQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKF90aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKF90aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb24pKTtcbmV4cG9ydCB7IFN1YnNjcmliZXIgfTtcbnZhciBTYWZlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU3Vic2NyaWJlcihfcGFyZW50U3Vic2NyaWJlciwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcGFyZW50U3Vic2NyaWJlciA9IF9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dC5uZXh0O1xuICAgICAgICAgICAgZXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvcjtcbiAgICAgICAgICAgIGNvbXBsZXRlID0gb2JzZXJ2ZXJPck5leHQuY29tcGxldGU7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZXJPck5leHQgIT09IGVtcHR5T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSBfdGhpcy51bnN1YnNjcmliZS5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIF90aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgX3RoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIF90aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIHZhciB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nID0gY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmc7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZENvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NvbXBsZXRlLmNhbGwoX3RoaXMuX2NvbnRleHQpOyB9O1xuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih3cmFwcGVkQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgd3JhcHBlZENvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JVbnN1YiA9IGZ1bmN0aW9uIChmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlcG9ydEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBTYWZlU3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///5\\n')},50:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return hostReportError; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction hostReportError(err) {\\n    setTimeout(function () { throw err; });\\n}\\n//# sourceMappingURL=hostReportError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2hvc3RSZXBvcnRFcnJvci5qcz8wY2E0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cbmV4cG9ydCBmdW5jdGlvbiBob3N0UmVwb3J0RXJyb3IoZXJyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0UmVwb3J0RXJyb3IuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///50\\n')},55:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InnerSubscriber; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nvar InnerSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](InnerSubscriber, _super);\\n    function InnerSubscriber(parent, outerValue, outerIndex) {\\n        var _this = _super.call(this) || this;\\n        _this.parent = parent;\\n        _this.outerValue = outerValue;\\n        _this.outerIndex = outerIndex;\\n        _this.index = 0;\\n        return _this;\\n    }\\n    InnerSubscriber.prototype._next = function (value) {\\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\\n    };\\n    InnerSubscriber.prototype._error = function (error) {\\n        this.parent.notifyError(error, this);\\n        this.unsubscribe();\\n    };\\n    InnerSubscriber.prototype._complete = function () {\\n        this.parent.notifyComplete(this);\\n        this.unsubscribe();\\n    };\\n    return InnerSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ \"a\"]));\\n\\n//# sourceMappingURL=InnerSubscriber.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9Jbm5lclN1YnNjcmliZXIuanM/YWNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbnZhciBJbm5lclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBfdGhpcy5vdXRlclZhbHVlID0gb3V0ZXJWYWx1ZTtcbiAgICAgICAgX3RoaXMub3V0ZXJJbmRleCA9IG91dGVySW5kZXg7XG4gICAgICAgIF90aGlzLmluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodGhpcy5vdXRlclZhbHVlLCB2YWx1ZSwgdGhpcy5vdXRlckluZGV4LCB0aGlzLmluZGV4KyssIHRoaXMpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IElubmVyU3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZXJTdWJzY3JpYmVyLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///55\\n')},6:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js\\nvar isArray = __webpack_require__(13);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js\\nvar isObject = __webpack_require__(92);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js\\nvar isFunction = __webpack_require__(37);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/errorObject.js\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar errorObject = { e: {} };\\n//# sourceMappingURL=errorObject.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/tryCatch.js\\n/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */\\n\\nvar tryCatchTarget;\\nfunction tryCatcher() {\\n    try {\\n        return tryCatchTarget.apply(this, arguments);\\n    }\\n    catch (e) {\\n        errorObject.e = e;\\n        return errorObject;\\n    }\\n}\\nfunction tryCatch(fn) {\\n    tryCatchTarget = fn;\\n    return tryCatcher;\\n}\\n//# sourceMappingURL=tryCatch.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js\\nvar UnsubscriptionError = __webpack_require__(64);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Subscription_Subscription; });\\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nvar Subscription_Subscription = /*@__PURE__*/ (function () {\\n    function Subscription(unsubscribe) {\\n        this.closed = false;\\n        this._parent = null;\\n        this._parents = null;\\n        this._subscriptions = null;\\n        if (unsubscribe) {\\n            this._unsubscribe = unsubscribe;\\n        }\\n    }\\n    Subscription.prototype.unsubscribe = function () {\\n        var hasErrors = false;\\n        var errors;\\n        if (this.closed) {\\n            return;\\n        }\\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\\n        this.closed = true;\\n        this._parent = null;\\n        this._parents = null;\\n        this._subscriptions = null;\\n        var index = -1;\\n        var len = _parents ? _parents.length : 0;\\n        while (_parent) {\\n            _parent.remove(this);\\n            _parent = ++index < len && _parents[index] || null;\\n        }\\n        if (Object(isFunction[\"a\" /* isFunction */])(_unsubscribe)) {\\n            var trial = tryCatch(_unsubscribe).call(this);\\n            if (trial === errorObject) {\\n                hasErrors = true;\\n                errors = errors || (errorObject.e instanceof UnsubscriptionError[\"a\" /* UnsubscriptionError */] ?\\n                    flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);\\n            }\\n        }\\n        if (Object(isArray[\"a\" /* isArray */])(_subscriptions)) {\\n            index = -1;\\n            len = _subscriptions.length;\\n            while (++index < len) {\\n                var sub = _subscriptions[index];\\n                if (Object(isObject[\"a\" /* isObject */])(sub)) {\\n                    var trial = tryCatch(sub.unsubscribe).call(sub);\\n                    if (trial === errorObject) {\\n                        hasErrors = true;\\n                        errors = errors || [];\\n                        var err = errorObject.e;\\n                        if (err instanceof UnsubscriptionError[\"a\" /* UnsubscriptionError */]) {\\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\\n                        }\\n                        else {\\n                            errors.push(err);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (hasErrors) {\\n            throw new UnsubscriptionError[\"a\" /* UnsubscriptionError */](errors);\\n        }\\n    };\\n    Subscription.prototype.add = function (teardown) {\\n        if (!teardown || (teardown === Subscription.EMPTY)) {\\n            return Subscription.EMPTY;\\n        }\\n        if (teardown === this) {\\n            return this;\\n        }\\n        var subscription = teardown;\\n        switch (typeof teardown) {\\n            case \\'function\\':\\n                subscription = new Subscription(teardown);\\n            case \\'object\\':\\n                if (subscription.closed || typeof subscription.unsubscribe !== \\'function\\') {\\n                    return subscription;\\n                }\\n                else if (this.closed) {\\n                    subscription.unsubscribe();\\n                    return subscription;\\n                }\\n                else if (typeof subscription._addParent !== \\'function\\') {\\n                    var tmp = subscription;\\n                    subscription = new Subscription();\\n                    subscription._subscriptions = [tmp];\\n                }\\n                break;\\n            default:\\n                throw new Error(\\'unrecognized teardown \\' + teardown + \\' added to Subscription.\\');\\n        }\\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\\n        subscriptions.push(subscription);\\n        subscription._addParent(this);\\n        return subscription;\\n    };\\n    Subscription.prototype.remove = function (subscription) {\\n        var subscriptions = this._subscriptions;\\n        if (subscriptions) {\\n            var subscriptionIndex = subscriptions.indexOf(subscription);\\n            if (subscriptionIndex !== -1) {\\n                subscriptions.splice(subscriptionIndex, 1);\\n            }\\n        }\\n    };\\n    Subscription.prototype._addParent = function (parent) {\\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\\n        if (!_parent || _parent === parent) {\\n            this._parent = parent;\\n        }\\n        else if (!_parents) {\\n            this._parents = [parent];\\n        }\\n        else if (_parents.indexOf(parent) === -1) {\\n            _parents.push(parent);\\n        }\\n    };\\n    Subscription.EMPTY = (function (empty) {\\n        empty.closed = true;\\n        return empty;\\n    }(new Subscription()));\\n    return Subscription;\\n}());\\n\\nfunction flattenUnsubscriptionErrors(errors) {\\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError[\"a\" /* UnsubscriptionError */]) ? err.errors : err); }, []);\\n}\\n//# sourceMappingURL=Subscription.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL3V0aWwvZXJyb3JPYmplY3QuanM/N2EyOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3RyeUNhdGNoLmpzPzEyMTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzP2E2ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IHZhciBlcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfZXJyb3JPYmplY3QgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgZXJyb3JPYmplY3QgfSBmcm9tICcuL2Vycm9yT2JqZWN0JztcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9pc0FycmF5LF91dGlsX2lzT2JqZWN0LF91dGlsX2lzRnVuY3Rpb24sX3V0aWxfdHJ5Q2F0Y2gsX3V0aWxfZXJyb3JPYmplY3QsX3V0aWxfVW5zdWJzY3JpcHRpb25FcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuL3V0aWwvaXNPYmplY3QnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi91dGlsL2Vycm9yT2JqZWN0JztcbmltcG9ydCB7IFVuc3Vic2NyaXB0aW9uRXJyb3IgfSBmcm9tICcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcic7XG52YXIgU3Vic2NyaXB0aW9uID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzLCBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IF9wYXJlbnRzID8gX3BhcmVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgd2hpbGUgKF9wYXJlbnQpIHtcbiAgICAgICAgICAgIF9wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgX3BhcmVudCA9ICsraW5kZXggPCBsZW4gJiYgX3BhcmVudHNbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2goX3Vuc3Vic2NyaWJlKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdC5lIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdC5lLmVycm9ycykgOiBbZXJyb3JPYmplY3QuZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KF9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNsb3NlZCB8fCB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKTtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgaWYgKCFfcGFyZW50IHx8IF9wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFfcGFyZW50cykge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIF9wYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgICAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiB9O1xuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHsgcmV0dXJuIGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yKSA/IGVyci5lcnJvcnMgOiBlcnIpOyB9LCBbXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///6\\n')},63:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return pipe; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return pipeFromArray; });\\n/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);\\n/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */\\n\\nfunction pipe() {\\n    var fns = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        fns[_i] = arguments[_i];\\n    }\\n    return pipeFromArray(fns);\\n}\\nfunction pipeFromArray(fns) {\\n    if (!fns) {\\n        return _noop__WEBPACK_IMPORTED_MODULE_0__[/* noop */ \"a\"];\\n    }\\n    if (fns.length === 1) {\\n        return fns[0];\\n    }\\n    return function piped(input) {\\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\\n    };\\n}\\n//# sourceMappingURL=pipe.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3BpcGUuanM/Y2I3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9ub29wIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuL25vb3AnO1xuZXhwb3J0IGZ1bmN0aW9uIHBpcGUoKSB7XG4gICAgdmFyIGZucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZUZyb21BcnJheShmbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpcGVGcm9tQXJyYXkoZm5zKSB7XG4gICAgaWYgKCFmbnMpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwaXBlZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZm4pIHsgcmV0dXJuIGZuKHByZXYpOyB9LCBpbnB1dCk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGUuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///63\\n')},64:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return UnsubscriptionError; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction UnsubscriptionErrorImpl(errors) {\\n    Error.call(this);\\n    this.message = errors ?\\n        errors.length + \\\" errors occurred during unsubscription:\\\\n\\\" + errors.map(function (err, i) { return i + 1 + \\\") \\\" + err.toString(); }).join('\\\\n  ') : '';\\n    this.name = 'UnsubscriptionError';\\n    this.errors = errors;\\n    return this;\\n}\\nUnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\\n//# sourceMappingURL=UnsubscriptionError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanM/NmIwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5mdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbChlcnJvcnMpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9IGVycm9ycyA/XG4gICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiBpICsgMSArIFwiKSBcIiArIGVyci50b1N0cmluZygpOyB9KS5qb2luKCdcXG4gICcpIDogJyc7XG4gICAgdGhpcy5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHJldHVybiB0aGlzO1xufVxuVW5zdWJzY3JpcHRpb25FcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qLyBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5leHBvcnQgdmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///64\\n\")},65:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return rxSubscriber; });\\n/* unused harmony export $$rxSubscriber */\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar rxSubscriber = typeof Symbol === 'function'\\n    ? /*@__PURE__*/ Symbol('rxSubscriber')\\n    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();\\nvar $$rxSubscriber = rxSubscriber;\\n//# sourceMappingURL=rxSubscriber.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzPzJmZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IHZhciByeFN1YnNjcmliZXIgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nXG4gICAgPyAvKkBfX1BVUkVfXyovIFN5bWJvbCgncnhTdWJzY3JpYmVyJylcbiAgICA6ICdAQHJ4U3Vic2NyaWJlcl8nICsgLypAX19QVVJFX18qLyBNYXRoLnJhbmRvbSgpO1xuZXhwb3J0IHZhciAkJHJ4U3Vic2NyaWJlciA9IHJ4U3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///65\\n\")},73:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return canReportError; });\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\\n\\nfunction canReportError(observer) {\\n    while (observer) {\\n        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;\\n        if (closed_1 || isStopped) {\\n            return false;\\n        }\\n        else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__[/* Subscriber */ \"a\"]) {\\n            observer = destination;\\n        }\\n        else {\\n            observer = null;\\n        }\\n    }\\n    return true;\\n}\\n//# sourceMappingURL=canReportError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2NhblJlcG9ydEVycm9yLmpzP2Q1ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gY2FuUmVwb3J0RXJyb3Iob2JzZXJ2ZXIpIHtcbiAgICB3aGlsZSAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF9hID0gb2JzZXJ2ZXIsIGNsb3NlZF8xID0gX2EuY2xvc2VkLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XG4gICAgICAgIGlmIChjbG9zZWRfMSB8fCBpc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gZGVzdGluYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5SZXBvcnRFcnJvci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///73\\n')},74:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return empty; });\\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);\\n/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);\\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\\n\\n\\nvar empty = {\\n    closed: true,\\n    next: function (value) { },\\n    error: function (err) {\\n        if (_config__WEBPACK_IMPORTED_MODULE_0__[/* config */ \"a\"].useDeprecatedSynchronousErrorHandling) {\\n            throw err;\\n        }\\n        else {\\n            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__[/* hostReportError */ \"a\"])(err);\\n        }\\n    },\\n    complete: function () { }\\n};\\n//# sourceMappingURL=Observer.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9PYnNlcnZlci5qcz9lOWE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgaG9zdFJlcG9ydEVycm9yIH0gZnJvbSAnLi91dGlsL2hvc3RSZXBvcnRFcnJvcic7XG5leHBvcnQgdmFyIGVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///74\\n')},91:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ConnectableObservable; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return connectableObservableDescriptor; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\\n/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);\\n/* harmony import */ var _operators_refCount__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(103);\\n/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nvar ConnectableObservable = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](ConnectableObservable, _super);\\n    function ConnectableObservable(source, subjectFactory) {\\n        var _this = _super.call(this) || this;\\n        _this.source = source;\\n        _this.subjectFactory = subjectFactory;\\n        _this._refCount = 0;\\n        _this._isComplete = false;\\n        return _this;\\n    }\\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\\n        return this.getSubject().subscribe(subscriber);\\n    };\\n    ConnectableObservable.prototype.getSubject = function () {\\n        var subject = this._subject;\\n        if (!subject || subject.isStopped) {\\n            this._subject = this.subjectFactory();\\n        }\\n        return this._subject;\\n    };\\n    ConnectableObservable.prototype.connect = function () {\\n        var connection = this._connection;\\n        if (!connection) {\\n            this._isComplete = false;\\n            connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_4__[/* Subscription */ \"a\"]();\\n            connection.add(this.source\\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\\n            if (connection.closed) {\\n                this._connection = null;\\n                connection = _Subscription__WEBPACK_IMPORTED_MODULE_4__[/* Subscription */ \"a\"].EMPTY;\\n            }\\n            else {\\n                this._connection = connection;\\n            }\\n        }\\n        return connection;\\n    };\\n    ConnectableObservable.prototype.refCount = function () {\\n        return Object(_operators_refCount__WEBPACK_IMPORTED_MODULE_5__[/* refCount */ \"a\"])()(this);\\n    };\\n    return ConnectableObservable;\\n}(_Observable__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ \"a\"]));\\n\\nvar connectableProto = ConnectableObservable.prototype;\\nvar connectableObservableDescriptor = {\\n    operator: { value: null },\\n    _refCount: { value: 0, writable: true },\\n    _subject: { value: null, writable: true },\\n    _connection: { value: null, writable: true },\\n    _subscribe: { value: connectableProto._subscribe },\\n    _isComplete: { value: connectableProto._isComplete, writable: true },\\n    getSubject: { value: connectableProto.getSubject },\\n    connect: { value: connectableProto.connect },\\n    refCount: { value: connectableProto.refCount }\\n};\\nvar ConnectableSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](ConnectableSubscriber, _super);\\n    function ConnectableSubscriber(destination, connectable) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.connectable = connectable;\\n        return _this;\\n    }\\n    ConnectableSubscriber.prototype._error = function (err) {\\n        this._unsubscribe();\\n        _super.prototype._error.call(this, err);\\n    };\\n    ConnectableSubscriber.prototype._complete = function () {\\n        this.connectable._isComplete = true;\\n        this._unsubscribe();\\n        _super.prototype._complete.call(this);\\n    };\\n    ConnectableSubscriber.prototype._unsubscribe = function () {\\n        var connectable = this.connectable;\\n        if (connectable) {\\n            this.connectable = null;\\n            var connection = connectable._connection;\\n            connectable._refCount = 0;\\n            connectable._subject = null;\\n            connectable._connection = null;\\n            if (connection) {\\n                connection.unsubscribe();\\n            }\\n        }\\n    };\\n    return ConnectableSubscriber;\\n}(_Subject__WEBPACK_IMPORTED_MODULE_1__[/* SubjectSubscriber */ \"b\"]));\\nvar RefCountOperator = /*@__PURE__*/ (function () {\\n    function RefCountOperator(connectable) {\\n        this.connectable = connectable;\\n    }\\n    RefCountOperator.prototype.call = function (subscriber, source) {\\n        var connectable = this.connectable;\\n        connectable._refCount++;\\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\\n        var subscription = source.subscribe(refCounter);\\n        if (!refCounter.closed) {\\n            refCounter.connection = connectable.connect();\\n        }\\n        return subscription;\\n    };\\n    return RefCountOperator;\\n}());\\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](RefCountSubscriber, _super);\\n    function RefCountSubscriber(destination, connectable) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.connectable = connectable;\\n        return _this;\\n    }\\n    RefCountSubscriber.prototype._unsubscribe = function () {\\n        var connectable = this.connectable;\\n        if (!connectable) {\\n            this.connection = null;\\n            return;\\n        }\\n        this.connectable = null;\\n        var refCount = connectable._refCount;\\n        if (refCount <= 0) {\\n            this.connection = null;\\n            return;\\n        }\\n        connectable._refCount = refCount - 1;\\n        if (refCount > 1) {\\n            this.connection = null;\\n            return;\\n        }\\n        var connection = this.connection;\\n        var sharedConnection = connectable._connection;\\n        this.connection = null;\\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\\n            sharedConnection.unsubscribe();\\n        }\\n    };\\n    return RefCountSubscriber;\\n}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__[/* Subscriber */ \"a\"]));\\n//# sourceMappingURL=ConnectableObservable.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcz8yYTExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YmplY3QsX09ic2VydmFibGUsX1N1YnNjcmliZXIsX1N1YnNjcmlwdGlvbixfb3BlcmF0b3JzX3JlZkNvdW50IFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJqZWN0U3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHJlZkNvdW50IGFzIGhpZ2hlck9yZGVyUmVmQ291bnQgfSBmcm9tICcuLi9vcGVyYXRvcnMvcmVmQ291bnQnO1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdEZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBfdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICBfdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgICAgICBfdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdDtcbiAgICAgICAgaWYgKCFzdWJqZWN0IHx8IHN1YmplY3QuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5zdWJqZWN0RmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0O1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmFkZCh0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUobmV3IENvbm5lY3RhYmxlU3Vic2NyaWJlcih0aGlzLmdldFN1YmplY3QoKSwgdGhpcykpKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoaWdoZXJPcmRlclJlZkNvdW50KCkodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlKSk7XG5leHBvcnQgeyBDb25uZWN0YWJsZU9ic2VydmFibGUgfTtcbnZhciBjb25uZWN0YWJsZVByb3RvID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3ViamVjdDogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfY29ubmVjdGlvbjogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLl9zdWJzY3JpYmUgfSxcbiAgICBfaXNDb21wbGV0ZTogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5faXNDb21wbGV0ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBjb25uZWN0YWJsZVByb3RvLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogY29ubmVjdGFibGVQcm90by5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25uZWN0YWJsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUuX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0U3Vic2NyaWJlcikpO1xudmFyIFJlZkNvdW50T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPcGVyYXRvcihjb25uZWN0YWJsZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCsrO1xuICAgICAgICB2YXIgcmVmQ291bnRlciA9IG5ldyBSZWZDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29ubmVjdGFibGUpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShyZWZDb3VudGVyKTtcbiAgICAgICAgaWYgKCFyZWZDb3VudGVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmVmQ291bnRlci5jb25uZWN0aW9uID0gY29ubmVjdGFibGUuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRPcGVyYXRvcjtcbn0oKSk7XG52YXIgUmVmQ291bnRTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlZkNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZkNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoIWNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSBjb25uZWN0YWJsZS5fcmVmQ291bnQ7XG4gICAgICAgIGlmIChyZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IHJlZkNvdW50IC0gMTtcbiAgICAgICAgaWYgKHJlZkNvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///91\\n')},92:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isObject; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction isObject(x) {\\n    return x != null && typeof x === 'object';\\n}\\n//# sourceMappingURL=isObject.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzT2JqZWN0LmpzPzMxYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///92\\n\")},93:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SubjectSubscription; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\\n\\n\\nvar SubjectSubscription = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](SubjectSubscription, _super);\\n    function SubjectSubscription(subject, subscriber) {\\n        var _this = _super.call(this) || this;\\n        _this.subject = subject;\\n        _this.subscriber = subscriber;\\n        _this.closed = false;\\n        return _this;\\n    }\\n    SubjectSubscription.prototype.unsubscribe = function () {\\n        if (this.closed) {\\n            return;\\n        }\\n        this.closed = true;\\n        var subject = this.subject;\\n        var observers = subject.observers;\\n        this.subject = null;\\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\\n            return;\\n        }\\n        var subscriberIndex = observers.indexOf(this.subscriber);\\n        if (subscriberIndex !== -1) {\\n            observers.splice(subscriberIndex, 1);\\n        }\\n    };\\n    return SubjectSubscription;\\n}(_Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ \"a\"]));\\n\\n//# sourceMappingURL=SubjectSubscription.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9TdWJqZWN0U3Vic2NyaXB0aW9uLmpzP2I4YzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgX3RoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIF90aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbikpO1xuZXhwb3J0IHsgU3ViamVjdFN1YnNjcmlwdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdFN1YnNjcmlwdGlvbi5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///93\\n')},94:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return mergeAll; });\\n/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);\\n/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);\\n/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */\\n\\n\\nfunction mergeAll(concurrent) {\\n    if (concurrent === void 0) {\\n        concurrent = Number.POSITIVE_INFINITY;\\n    }\\n    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ \"a\"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__[/* identity */ \"a\"], concurrent);\\n}\\n//# sourceMappingURL=mergeAll.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VBbGwuanM/NjY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9tZXJnZU1hcCxfdXRpbF9pZGVudGl0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBtZXJnZU1hcCB9IGZyb20gJy4vbWVyZ2VNYXAnO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuLi91dGlsL2lkZW50aXR5JztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFsbChjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VNYXAoaWRlbnRpdHksIGNvbmN1cnJlbnQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///94\\n')},95:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return mergeMap; });\\n/* unused harmony export MergeMapOperator */\\n/* unused harmony export MergeMapSubscriber */\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);\\n/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\\n/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);\\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);\\n/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);\\n/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction mergeMap(project, resultSelector, concurrent) {\\n    if (concurrent === void 0) {\\n        concurrent = Number.POSITIVE_INFINITY;\\n    }\\n    if (typeof resultSelector === \\'function\\') {\\n        return function (source) { return source.pipe(mergeMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__[/* from */ \"a\"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__[/* map */ \"a\"])(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };\\n    }\\n    else if (typeof resultSelector === \\'number\\') {\\n        concurrent = resultSelector;\\n    }\\n    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };\\n}\\nvar MergeMapOperator = /*@__PURE__*/ (function () {\\n    function MergeMapOperator(project, concurrent) {\\n        if (concurrent === void 0) {\\n            concurrent = Number.POSITIVE_INFINITY;\\n        }\\n        this.project = project;\\n        this.concurrent = concurrent;\\n    }\\n    MergeMapOperator.prototype.call = function (observer, source) {\\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));\\n    };\\n    return MergeMapOperator;\\n}());\\n\\nvar MergeMapSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](MergeMapSubscriber, _super);\\n    function MergeMapSubscriber(destination, project, concurrent) {\\n        if (concurrent === void 0) {\\n            concurrent = Number.POSITIVE_INFINITY;\\n        }\\n        var _this = _super.call(this, destination) || this;\\n        _this.project = project;\\n        _this.concurrent = concurrent;\\n        _this.hasCompleted = false;\\n        _this.buffer = [];\\n        _this.active = 0;\\n        _this.index = 0;\\n        return _this;\\n    }\\n    MergeMapSubscriber.prototype._next = function (value) {\\n        if (this.active < this.concurrent) {\\n            this._tryNext(value);\\n        }\\n        else {\\n            this.buffer.push(value);\\n        }\\n    };\\n    MergeMapSubscriber.prototype._tryNext = function (value) {\\n        var result;\\n        var index = this.index++;\\n        try {\\n            result = this.project(value, index);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.active++;\\n        this._innerSub(result, value, index);\\n    };\\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\\n        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* InnerSubscriber */ \"a\"](this, undefined, undefined);\\n        var destination = this.destination;\\n        destination.add(innerSubscriber);\\n        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__[/* subscribeToResult */ \"a\"])(this, ish, value, index, innerSubscriber);\\n    };\\n    MergeMapSubscriber.prototype._complete = function () {\\n        this.hasCompleted = true;\\n        if (this.active === 0 && this.buffer.length === 0) {\\n            this.destination.complete();\\n        }\\n        this.unsubscribe();\\n    };\\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        this.destination.next(innerValue);\\n    };\\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\\n        var buffer = this.buffer;\\n        this.remove(innerSub);\\n        this.active--;\\n        if (buffer.length > 0) {\\n            this._next(buffer.shift());\\n        }\\n        else if (this.active === 0 && this.hasCompleted) {\\n            this.destination.complete();\\n        }\\n    };\\n    return MergeMapSubscriber;\\n}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__[/* OuterSubscriber */ \"a\"]));\\n\\n//# sourceMappingURL=mergeMap.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAuanM/YTZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF91dGlsX3N1YnNjcmliZVRvUmVzdWx0LF9PdXRlclN1YnNjcmliZXIsX0lubmVyU3Vic2NyaWJlcixfbWFwLF9vYnNlcnZhYmxlX2Zyb20gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vbWFwJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICcuLi9vYnNlcnZhYmxlL2Zyb20nO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UucGlwZShtZXJnZU1hcChmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gZnJvbShwcm9qZWN0KGEsIGkpKS5waXBlKG1hcChmdW5jdGlvbiAoYiwgaWkpIHsgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKGEsIGIsIGksIGlpKTsgfSkpOyB9LCBjb25jdXJyZW50KSk7IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgY29uY3VycmVudCkpOyB9O1xufVxudmFyIE1lcmdlTWFwT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZU1hcFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJvamVjdCwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnQgeyBNZXJnZU1hcE9wZXJhdG9yIH07XG52YXIgTWVyZ2VNYXBTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1lcmdlTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIF90aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICBfdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYnVmZmVyID0gW107XG4gICAgICAgIF90aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIF90aGlzLmluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaWJlciA9IG5ldyBJbm5lclN1YnNjcmliZXIodGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5hZGQoaW5uZXJTdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgsIGlubmVyU3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBNZXJnZU1hcFN1YnNjcmliZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///95\\n')},96:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return subscribeTo; });\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\\n/* harmony import */ var _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99);\\n/* harmony import */ var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);\\n/* harmony import */ var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(102);\\n/* harmony import */ var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);\\n/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);\\n/* harmony import */ var _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(100);\\n/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(92);\\n/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(28);\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(32);\\n/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar subscribeTo = function (result) {\\n    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"]) {\\n        return function (subscriber) {\\n            if (result._isScalar) {\\n                subscriber.next(result.value);\\n                subscriber.complete();\\n                return undefined;\\n            }\\n            else {\\n                return result.subscribe(subscriber);\\n            }\\n        };\\n    }\\n    else if (result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__[/* observable */ \"a\"]] === \\'function\\') {\\n        return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__[/* subscribeToObservable */ \"a\"])(result);\\n    }\\n    else if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__[/* isArrayLike */ \"a\"])(result)) {\\n        return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__[/* subscribeToArray */ \"a\"])(result);\\n    }\\n    else if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__[/* isPromise */ \"a\"])(result)) {\\n        return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__[/* subscribeToPromise */ \"a\"])(result);\\n    }\\n    else if (result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__[/* iterator */ \"a\"]] === \\'function\\') {\\n        return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__[/* subscribeToIterable */ \"a\"])(result);\\n    }\\n    else {\\n        var value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__[/* isObject */ \"a\"])(result) ? \\'an invalid object\\' : \"\\'\" + result + \"\\'\";\\n        var msg = \"You provided \" + value + \" where a stream was expected.\"\\n            + \\' You can provide an Observable, Promise, Array, or Iterable.\\';\\n        throw new TypeError(msg);\\n    }\\n};\\n//# sourceMappingURL=subscribeTo.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3N1YnNjcmliZVRvLmpzPzE3MTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfc3Vic2NyaWJlVG9BcnJheSxfc3Vic2NyaWJlVG9Qcm9taXNlLF9zdWJzY3JpYmVUb0l0ZXJhYmxlLF9zdWJzY3JpYmVUb09ic2VydmFibGUsX2lzQXJyYXlMaWtlLF9pc1Byb21pc2UsX2lzT2JqZWN0LF9zeW1ib2xfaXRlcmF0b3IsX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHN1YnNjcmliZVRvQXJyYXkgfSBmcm9tICcuL3N1YnNjcmliZVRvQXJyYXknO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9Qcm9taXNlIH0gZnJvbSAnLi9zdWJzY3JpYmVUb1Byb21pc2UnO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9JdGVyYWJsZSB9IGZyb20gJy4vc3Vic2NyaWJlVG9JdGVyYWJsZSc7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb09ic2VydmFibGUgfSBmcm9tICcuL3N1YnNjcmliZVRvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FycmF5TGlrZSB9IGZyb20gJy4vaXNBcnJheUxpa2UnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi9pc1Byb21pc2UnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuL2lzT2JqZWN0JztcbmltcG9ydCB7IGl0ZXJhdG9yIGFzIFN5bWJvbF9pdGVyYXRvciB9IGZyb20gJy4uL3N5bWJvbC9pdGVyYXRvcic7XG5pbXBvcnQgeyBvYnNlcnZhYmxlIGFzIFN5bWJvbF9vYnNlcnZhYmxlIH0gZnJvbSAnLi4vc3ltYm9sL29ic2VydmFibGUnO1xuZXhwb3J0IHZhciBzdWJzY3JpYmVUbyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHRbU3ltYm9sX29ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb09ic2VydmFibGUocmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2UocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9BcnJheShyZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9Qcm9taXNlKHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W1N5bWJvbF9pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvSXRlcmFibGUocmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXCInXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICAgICAgdmFyIG1zZyA9IFwiWW91IHByb3ZpZGVkIFwiICsgdmFsdWUgKyBcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuXCJcbiAgICAgICAgICAgICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlVG8uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///96\\n')},97:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return subscribeToObservable; });\\n/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);\\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\\n\\nvar subscribeToObservable = function (obj) {\\n    return function (subscriber) {\\n        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* observable */ \\\"a\\\"]]();\\n        if (typeof obs.subscribe !== 'function') {\\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\\n        }\\n        else {\\n            return obs.subscribe(subscriber);\\n        }\\n    };\\n};\\n//# sourceMappingURL=subscribeToObservable.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3N1YnNjcmliZVRvT2JzZXJ2YWJsZS5qcz8yNWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IG9ic2VydmFibGUgYXMgU3ltYm9sX29ic2VydmFibGUgfSBmcm9tICcuLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5leHBvcnQgdmFyIHN1YnNjcmliZVRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIG9icyA9IG9ialtTeW1ib2xfb2JzZXJ2YWJsZV0oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnMuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvT2JzZXJ2YWJsZS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///97\\n\")},98:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return isArrayLike; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\\n//# sourceMappingURL=isArrayLike.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL2lzQXJyYXlMaWtlLmpzP2Q5ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IHZhciBpc0FycmF5TGlrZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXlMaWtlLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///98\\n\")},99:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return subscribeToArray; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar subscribeToArray = function (array) {\\n    return function (subscriber) {\\n        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\\n            subscriber.next(array[i]);\\n        }\\n        if (!subscriber.closed) {\\n            subscriber.complete();\\n        }\\n    };\\n};\\n//# sourceMappingURL=subscribeToArray.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL3N1YnNjcmliZVRvQXJyYXkuanM/ZmFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5leHBvcnQgdmFyIHN1YnNjcmliZVRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbiAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvQXJyYXkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///99\\n')}}]);","extractedComments":[]}