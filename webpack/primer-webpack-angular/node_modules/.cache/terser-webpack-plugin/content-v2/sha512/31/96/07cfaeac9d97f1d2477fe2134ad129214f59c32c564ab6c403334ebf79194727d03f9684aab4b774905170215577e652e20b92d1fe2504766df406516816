{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"webpackJsonpCallback\",\"data\",\"moduleId\",\"chunkId\",\"chunkIds\",\"moreModules\",\"executeModules\",\"i\",\"resolves\",\"length\",\"installedChunks\",\"push\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"modules\",\"parentJsonpFunction\",\"shift\",\"deferredModules\",\"apply\",\"checkDeferredModules\",\"result\",\"deferredModule\",\"fulfilled\",\"j\",\"depId\",\"splice\",\"__webpack_require__\",\"s\",\"installedModules\",\"4\",\"exports\",\"module\",\"l\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"p\",\"jsonpArray\",\"window\",\"oldJsonpFunction\",\"slice\"],\"mappings\":\"aACA,SAAAA,EAAAC,GAQA,IAPA,IAMAC,EAAAC,EANAC,EAAAH,EAAA,GACAI,EAAAJ,EAAA,GACAK,EAAAL,EAAA,GAIAM,EAAA,EAAAC,EAAA,GACQD,EAAAH,EAAAK,OAAoBF,IAC5BJ,EAAAC,EAAAG,GACAG,EAAAP,IACAK,EAAAG,KAAAD,EAAAP,GAAA,IAEAO,EAAAP,GAAA,EAEA,IAAAD,KAAAG,EACAO,OAAAC,UAAAC,eAAAC,KAAAV,EAAAH,KACAc,EAAAd,GAAAG,EAAAH,IAKA,IAFAe,GAAAA,EAAAhB,GAEAO,EAAAC,QACAD,EAAAU,OAAAV,GAOA,OAHAW,EAAAR,KAAAS,MAAAD,EAAAb,GAAA,IAGAe,IAEA,SAAAA,IAEA,IADA,IAAAC,EACAf,EAAA,EAAiBA,EAAAY,EAAAV,OAA4BF,IAAA,CAG7C,IAFA,IAAAgB,EAAAJ,EAAAZ,GACAiB,GAAA,EACAC,EAAA,EAAkBA,EAAAF,EAAAd,OAA2BgB,IAAA,CAC7C,IAAAC,EAAAH,EAAAE,GACA,IAAAf,EAAAgB,KAAAF,GAAA,GAEAA,IACAL,EAAAQ,OAAApB,IAAA,GACAe,EAAAM,EAAAA,EAAAC,EAAAN,EAAA,KAGA,OAAAD,EAIA,IAAAQ,EAAA,GAKApB,EAAA,CACAqB,EAAA,GAGAZ,EAAA,GAGA,SAAAS,EAAA1B,GAGA,GAAA4B,EAAA5B,GACA,OAAA4B,EAAA5B,GAAA8B,QAGA,IAAAC,EAAAH,EAAA5B,GAAA,CACAK,EAAAL,EACAgC,GAAA,EACAF,QAAA,IAUA,OANAhB,EAAAd,GAAAa,KAAAkB,EAAAD,QAAAC,EAAAA,EAAAD,QAAAJ,GAGAK,EAAAC,GAAA,EAGAD,EAAAD,QAKAJ,EAAAO,EAAAnB,EAGAY,EAAAQ,EAAAN,EAGAF,EAAAS,EAAA,SAAAL,EAAAM,EAAAC,GACAX,EAAAY,EAAAR,EAAAM,IACA1B,OAAA6B,eAAAT,EAAAM,EAAA,CAA0CI,YAAA,EAAAC,IAAAJ,KAK1CX,EAAAgB,EAAA,SAAAZ,GACA,oBAAAa,QAAAA,OAAAC,aACAlC,OAAA6B,eAAAT,EAAAa,OAAAC,YAAA,CAAwDC,MAAA,WAExDnC,OAAA6B,eAAAT,EAAA,aAAA,CAAiDe,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,GAAA,EAAAE,GAAA,iBAAAF,GAAAA,GAAAA,EAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAvC,OAAAwC,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAvC,OAAA6B,eAAAU,EAAA,UAAA,CAAyCT,YAAA,EAAAK,MAAAA,IACzC,EAAAE,GAAA,iBAAAF,EAAA,IAAA,IAAAM,KAAAN,EAAAnB,EAAAS,EAAAc,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAtB,GACA,IAAAM,EAAAN,GAAAA,EAAAiB,WACA,WAA2B,OAAAjB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAL,EAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAgB,EAAAC,GAAsD,OAAA7C,OAAAC,UAAAC,eAAAC,KAAAyC,EAAAC,IAGtD7B,EAAA8B,EAAA,IAEA,IAAAC,EAAAC,OAAA,aAAAA,OAAA,cAAA,GACAC,EAAAF,EAAAhD,KAAA2C,KAAAK,GACAA,EAAAhD,KAAAX,EACA2D,EAAAA,EAAAG,QACA,IAAA,IAAAvD,EAAA,EAAgBA,EAAAoD,EAAAlD,OAAuBF,IAAAP,EAAA2D,EAAApD,IACvC,IAAAU,EAAA4C,EAIA1C,EAAAR,KAAA,CAAA,IAAA,EAAA,IAEAU\",\"sourcesContent\":[\" \\t// install a JSONP callback for chunk loading\\n \\tfunction webpackJsonpCallback(data) {\\n \\t\\tvar chunkIds = data[0];\\n \\t\\tvar moreModules = data[1];\\n \\t\\tvar executeModules = data[2];\\n\\n \\t\\t// add \\\"moreModules\\\" to the modules object,\\n \\t\\t// then flag all \\\"chunkIds\\\" as loaded and fire callback\\n \\t\\tvar moduleId, chunkId, i = 0, resolves = [];\\n \\t\\tfor(;i < chunkIds.length; i++) {\\n \\t\\t\\tchunkId = chunkIds[i];\\n \\t\\t\\tif(installedChunks[chunkId]) {\\n \\t\\t\\t\\tresolves.push(installedChunks[chunkId][0]);\\n \\t\\t\\t}\\n \\t\\t\\tinstalledChunks[chunkId] = 0;\\n \\t\\t}\\n \\t\\tfor(moduleId in moreModules) {\\n \\t\\t\\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\\n \\t\\t\\t\\tmodules[moduleId] = moreModules[moduleId];\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\tif(parentJsonpFunction) parentJsonpFunction(data);\\n\\n \\t\\twhile(resolves.length) {\\n \\t\\t\\tresolves.shift()();\\n \\t\\t}\\n\\n \\t\\t// add entry modules from loaded chunk to deferred list\\n \\t\\tdeferredModules.push.apply(deferredModules, executeModules || []);\\n\\n \\t\\t// run deferred modules when all chunks ready\\n \\t\\treturn checkDeferredModules();\\n \\t};\\n \\tfunction checkDeferredModules() {\\n \\t\\tvar result;\\n \\t\\tfor(var i = 0; i < deferredModules.length; i++) {\\n \\t\\t\\tvar deferredModule = deferredModules[i];\\n \\t\\t\\tvar fulfilled = true;\\n \\t\\t\\tfor(var j = 1; j < deferredModule.length; j++) {\\n \\t\\t\\t\\tvar depId = deferredModule[j];\\n \\t\\t\\t\\tif(installedChunks[depId] !== 0) fulfilled = false;\\n \\t\\t\\t}\\n \\t\\t\\tif(fulfilled) {\\n \\t\\t\\t\\tdeferredModules.splice(i--, 1);\\n \\t\\t\\t\\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\\n \\t\\t\\t}\\n \\t\\t}\\n \\t\\treturn result;\\n \\t}\\n\\n \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// object to store loaded and loading chunks\\n \\t// undefined = chunk not loaded, null = chunk preloaded/prefetched\\n \\t// Promise = chunk loading, 0 = chunk loaded\\n \\tvar installedChunks = {\\n \\t\\t4: 0\\n \\t};\\n\\n \\tvar deferredModules = [];\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"/\\\";\\n\\n \\tvar jsonpArray = window[\\\"webpackJsonp\\\"] = window[\\\"webpackJsonp\\\"] || [];\\n \\tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\\n \\tjsonpArray.push = webpackJsonpCallback;\\n \\tjsonpArray = jsonpArray.slice();\\n \\tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\\n \\tvar parentJsonpFunction = oldJsonpFunction;\\n\\n\\n \\t// add entry module to deferred list\\n \\tdeferredModules.push([346,0,1]);\\n \\t// run deferred modules when ready\\n \\treturn checkDeferredModules();\\n\"]}","code":"!function(g){function I(I){for(var e,C,l=I[0],i=I[1],B=I[2],b=0,u=[];b<l.length;b++)C=l[b],t[C]&&u.push(t[C][0]),t[C]=0;for(e in i)Object.prototype.hasOwnProperty.call(i,e)&&(g[e]=i[e]);for(A&&A(I);u.length;)u.shift()();return c.push.apply(c,B||[]),n()}function n(){for(var g,I=0;I<c.length;I++){for(var n=c[I],e=!0,l=1;l<n.length;l++){var i=n[l];0!==t[i]&&(e=!1)}e&&(c.splice(I--,1),g=C(C.s=n[0]))}return g}var e={},t={4:0},c=[];function C(I){if(e[I])return e[I].exports;var n=e[I]={i:I,l:!1,exports:{}};return g[I].call(n.exports,n,n.exports,C),n.l=!0,n.exports}C.m=g,C.c=e,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(g,\"__esModule\",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&\"object\"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:g}),2&I&&\"string\"!=typeof g)for(var e in g)C.d(n,e,function(I){return g[I]}.bind(null,e));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,\"a\",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p=\"/\";var l=window.webpackJsonp=window.webpackJsonp||[],i=l.push.bind(l);l.push=I,l=l.slice();for(var B=0;B<l.length;B++)I(l[B]);var A=i;c.push([346,0,1]),n()}({105:function(module,exports,__webpack_require__){eval('var map = {\\n\\t\"./log\": 106\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\treturn __webpack_require__(id);\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\"Cannot find module \\'\" + req + \"\\'\");\\n\\t\\te.code = \\'MODULE_NOT_FOUND\\';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = 105;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3Qgc3luYyBub25yZWN1cnNpdmUgXlxcLlxcL2xvZyQ/MWMzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDEwNlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgeyAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gaWQ7XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMTA1OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///105\\n')},11:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return EMPTY; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return empty; });\\n/* unused harmony export emptyScheduled */\\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\\n\\nvar EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"](function (subscriber) { return subscriber.complete(); });\\nfunction empty(scheduler) {\\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\\n}\\nfunction emptyScheduled(scheduler) {\\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ \"a\"](function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\\n}\\n//# sourceMappingURL=empty.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzPzFiOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5leHBvcnQgdmFyIEVNUFRZID0gLypAX19QVVJFX18qLyBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTtcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IEVNUFRZO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5U2NoZWR1bGVkKHNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSk7IH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///11\\n')},128:function(module,exports){eval(\"function webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = function() { return []; };\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nmodule.exports = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = 128;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvZmVzbTUgbGF6eSBuYW1lc3BhY2Ugb2JqZWN0P2MzODAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2VicGFja0VtcHR5QXN5bmNDb250ZXh0KHJlcSkge1xuXHQvLyBIZXJlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBpcyB1c2VkIGluc3RlYWQgb2YgbmV3IFByb21pc2UoKSB0byBwcmV2ZW50XG5cdC8vIHVuY2F1Z2h0IGV4Y2VwdGlvbiBwb3BwaW5nIHVwIGluIGRldnRvb2xzXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fSk7XG59XG53ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUFzeW5jQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5QXN5bmNDb250ZXh0O1xud2VicGFja0VtcHR5QXN5bmNDb250ZXh0LmlkID0gMTI4OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///128\\n\")},162:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BehaviorSubject; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);\\n/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);\\n/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\\n\\n\\n\\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\\n    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"](BehaviorSubject, _super);\\n    function BehaviorSubject(_value) {\\n        var _this = _super.call(this) || this;\\n        _this._value = _value;\\n        return _this;\\n    }\\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\\n        get: function () {\\n            return this.getValue();\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\\n        if (subscription && !subscription.closed) {\\n            subscriber.next(this._value);\\n        }\\n        return subscription;\\n    };\\n    BehaviorSubject.prototype.getValue = function () {\\n        if (this.hasError) {\\n            throw this.thrownError;\\n        }\\n        else if (this.closed) {\\n            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__[/* ObjectUnsubscribedError */ \"a\"]();\\n        }\\n        else {\\n            return this._value;\\n        }\\n    };\\n    BehaviorSubject.prototype.next = function (value) {\\n        _super.prototype.next.call(this, this._value = value);\\n    };\\n    return BehaviorSubject;\\n}(_Subject__WEBPACK_IMPORTED_MODULE_1__[/* Subject */ \"a\"]));\\n\\n//# sourceMappingURL=BehaviorSubject.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvQmVoYXZpb3JTdWJqZWN0LmpzP2RiYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3ViamVjdCxfdXRpbF9PYmplY3RVbnN1YnNjcmliZWRFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4vU3ViamVjdCc7XG5pbXBvcnQgeyBPYmplY3RVbnN1YnNjcmliZWRFcnJvciB9IGZyb20gJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG52YXIgQmVoYXZpb3JTdWJqZWN0ID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJlaGF2aW9yU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCZWhhdmlvclN1YmplY3QoX3ZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uICYmICFzdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy5fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy50aHJvd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSA9IHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmVoYXZpb3JTdWJqZWN0LmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///162\\n')},163:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return concatAll; });\\n/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);\\n/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */\\n\\nfunction concatAll() {\\n    return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__[/* mergeAll */ \"a\"])(1);\\n}\\n//# sourceMappingURL=concatAll.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdEFsbC5qcz80ZjE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX21lcmdlQWxsIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IG1lcmdlQWxsIH0gZnJvbSAnLi9tZXJnZUFsbCc7XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0QWxsKCkge1xuICAgIHJldHVybiBtZXJnZUFsbCgxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdEFsbC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///163\\n')},346:function(g,I,n){n(104),g.exports=n(347)},347:function(module,exports,__webpack_require__){\"use strict\";eval('\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\n// Angular\\n__webpack_require__(62);\\n__webpack_require__(348);\\n__webpack_require__(1);\\n__webpack_require__(14);\\n__webpack_require__(349);\\n__webpack_require__(354);\\n// RxJS\\n__webpack_require__(90);\\n// Other vendors for example jQuery, Lodash or Bootstrap\\n// You can import js, ts, css, sass, ...\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3ZlbmRvci50cz8zZmQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFuZ3VsYXJcclxuaW1wb3J0ICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcclxuaW1wb3J0ICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xyXG5pbXBvcnQgJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCAnQGFuZ3VsYXIvaHR0cCc7XHJcbmltcG9ydCAnQGFuZ3VsYXIvcm91dGVyJztcclxuXHJcbi8vIFJ4SlNcclxuaW1wb3J0ICdyeGpzJztcclxuXHJcbi8vIE90aGVyIHZlbmRvcnMgZm9yIGV4YW1wbGUgalF1ZXJ5LCBMb2Rhc2ggb3IgQm9vdHN0cmFwXHJcbi8vIFlvdSBjYW4gaW1wb3J0IGpzLCB0cywgY3NzLCBzYXNzLCAuLi4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///347\\n')},349:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_http_http_e\\\", function() { return BrowserJsonp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_http_http_f\\\", function() { return Body; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_http_http_a\\\", function() { return _createDefaultCookieXSRFStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_http_http_b\\\", function() { return httpFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ɵangular_packages_http_http_c\\\", function() { return jsonpFactory; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BrowserXhr\\\", function() { return BrowserXhr; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JSONPBackend\\\", function() { return JSONPBackend; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JSONPConnection\\\", function() { return JSONPConnection; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"CookieXSRFStrategy\\\", function() { return CookieXSRFStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"XHRBackend\\\", function() { return XHRBackend; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"XHRConnection\\\", function() { return XHRConnection; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BaseRequestOptions\\\", function() { return BaseRequestOptions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RequestOptions\\\", function() { return RequestOptions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"BaseResponseOptions\\\", function() { return BaseResponseOptions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ResponseOptions\\\", function() { return ResponseOptions; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ReadyState\\\", function() { return ReadyState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RequestMethod\\\", function() { return RequestMethod; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ResponseContentType\\\", function() { return ResponseContentType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ResponseType\\\", function() { return ResponseType; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Headers\\\", function() { return Headers; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Http\\\", function() { return Http; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Jsonp\\\", function() { return Jsonp; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"HttpModule\\\", function() { return HttpModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"JsonpModule\\\", function() { return JsonpModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Connection\\\", function() { return Connection; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"ConnectionBackend\\\", function() { return ConnectionBackend; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"XSRFStrategy\\\", function() { return XSRFStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Request\\\", function() { return Request; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"Response\\\", function() { return Response; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"QueryEncoder\\\", function() { return QueryEncoder; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"URLSearchParams\\\", function() { return URLSearchParams; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"VERSION\\\", function() { return VERSION; });\\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\\n/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);\\n/**\\n * @license Angular v7.0.4\\n * (c) 2010-2018 Google, Inc. https://angular.io/\\n * License: MIT\\n */\\n\\n\\n\\n\\n\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * A backend for http that uses the `XMLHttpRequest` browser API.\\n *\\n * Take care not to evaluate this in non-browser contexts.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar BrowserXhr = /** @class */ (function () {\\n    function BrowserXhr() {\\n    }\\n    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };\\n    BrowserXhr = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [])\\n    ], BrowserXhr);\\n    return BrowserXhr;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Supported http methods.\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar RequestMethod;\\n(function (RequestMethod) {\\n    RequestMethod[RequestMethod[\\\"Get\\\"] = 0] = \\\"Get\\\";\\n    RequestMethod[RequestMethod[\\\"Post\\\"] = 1] = \\\"Post\\\";\\n    RequestMethod[RequestMethod[\\\"Put\\\"] = 2] = \\\"Put\\\";\\n    RequestMethod[RequestMethod[\\\"Delete\\\"] = 3] = \\\"Delete\\\";\\n    RequestMethod[RequestMethod[\\\"Options\\\"] = 4] = \\\"Options\\\";\\n    RequestMethod[RequestMethod[\\\"Head\\\"] = 5] = \\\"Head\\\";\\n    RequestMethod[RequestMethod[\\\"Patch\\\"] = 6] = \\\"Patch\\\";\\n})(RequestMethod || (RequestMethod = {}));\\n/**\\n * All possible states in which a connection can be, based on\\n * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an\\n * additional \\\"CANCELLED\\\" state.\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar ReadyState;\\n(function (ReadyState) {\\n    ReadyState[ReadyState[\\\"Unsent\\\"] = 0] = \\\"Unsent\\\";\\n    ReadyState[ReadyState[\\\"Open\\\"] = 1] = \\\"Open\\\";\\n    ReadyState[ReadyState[\\\"HeadersReceived\\\"] = 2] = \\\"HeadersReceived\\\";\\n    ReadyState[ReadyState[\\\"Loading\\\"] = 3] = \\\"Loading\\\";\\n    ReadyState[ReadyState[\\\"Done\\\"] = 4] = \\\"Done\\\";\\n    ReadyState[ReadyState[\\\"Cancelled\\\"] = 5] = \\\"Cancelled\\\";\\n})(ReadyState || (ReadyState = {}));\\n/**\\n * Acceptable response types to be associated with a {@link Response}, based on\\n * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar ResponseType;\\n(function (ResponseType) {\\n    ResponseType[ResponseType[\\\"Basic\\\"] = 0] = \\\"Basic\\\";\\n    ResponseType[ResponseType[\\\"Cors\\\"] = 1] = \\\"Cors\\\";\\n    ResponseType[ResponseType[\\\"Default\\\"] = 2] = \\\"Default\\\";\\n    ResponseType[ResponseType[\\\"Error\\\"] = 3] = \\\"Error\\\";\\n    ResponseType[ResponseType[\\\"Opaque\\\"] = 4] = \\\"Opaque\\\";\\n})(ResponseType || (ResponseType = {}));\\n/**\\n * Supported content type to be automatically associated with a {@link Request}.\\n * @deprecated see https://angular.io/guide/http\\n */\\nvar ContentType;\\n(function (ContentType) {\\n    ContentType[ContentType[\\\"NONE\\\"] = 0] = \\\"NONE\\\";\\n    ContentType[ContentType[\\\"JSON\\\"] = 1] = \\\"JSON\\\";\\n    ContentType[ContentType[\\\"FORM\\\"] = 2] = \\\"FORM\\\";\\n    ContentType[ContentType[\\\"FORM_DATA\\\"] = 3] = \\\"FORM_DATA\\\";\\n    ContentType[ContentType[\\\"TEXT\\\"] = 4] = \\\"TEXT\\\";\\n    ContentType[ContentType[\\\"BLOB\\\"] = 5] = \\\"BLOB\\\";\\n    ContentType[ContentType[\\\"ARRAY_BUFFER\\\"] = 6] = \\\"ARRAY_BUFFER\\\";\\n})(ContentType || (ContentType = {}));\\n/**\\n * Define which buffer to use to store the response\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar ResponseContentType;\\n(function (ResponseContentType) {\\n    ResponseContentType[ResponseContentType[\\\"Text\\\"] = 0] = \\\"Text\\\";\\n    ResponseContentType[ResponseContentType[\\\"Json\\\"] = 1] = \\\"Json\\\";\\n    ResponseContentType[ResponseContentType[\\\"ArrayBuffer\\\"] = 2] = \\\"ArrayBuffer\\\";\\n    ResponseContentType[ResponseContentType[\\\"Blob\\\"] = 3] = \\\"Blob\\\";\\n})(ResponseContentType || (ResponseContentType = {}));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as\\n * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).\\n *\\n * The only known difference between this `Headers` implementation and the spec is the\\n * lack of an `entries` method.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * import {Headers} from '@angular/http';\\n *\\n * var firstHeaders = new Headers();\\n * firstHeaders.append('Content-Type', 'image/jpeg');\\n * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'\\n *\\n * // Create headers from Plain Old JavaScript Object\\n * var secondHeaders = new Headers({\\n *   'X-My-Custom-Header': 'Angular'\\n * });\\n * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'\\n *\\n * var thirdHeaders = new Headers(secondHeaders);\\n * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Headers = /** @class */ (function () {\\n    // TODO(vicb): any -> string|string[]\\n    function Headers(headers) {\\n        var _this = this;\\n        /** @internal header names are lower case */\\n        this._headers = new Map();\\n        /** @internal map lower case names to actual names */\\n        this._normalizedNames = new Map();\\n        if (!headers) {\\n            return;\\n        }\\n        if (headers instanceof Headers) {\\n            headers.forEach(function (values, name) {\\n                values.forEach(function (value) { return _this.append(name, value); });\\n            });\\n            return;\\n        }\\n        Object.keys(headers).forEach(function (name) {\\n            var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];\\n            _this.delete(name);\\n            values.forEach(function (value) { return _this.append(name, value); });\\n        });\\n    }\\n    /**\\n     * Returns a new Headers instance from the given DOMString of Response Headers\\n     */\\n    Headers.fromResponseHeaderString = function (headersString) {\\n        var headers = new Headers();\\n        headersString.split('\\\\n').forEach(function (line) {\\n            var index = line.indexOf(':');\\n            if (index > 0) {\\n                var name_1 = line.slice(0, index);\\n                var value = line.slice(index + 1).trim();\\n                headers.set(name_1, value);\\n            }\\n        });\\n        return headers;\\n    };\\n    /**\\n     * Appends a header to existing list of header values for a given header name.\\n     */\\n    Headers.prototype.append = function (name, value) {\\n        var values = this.getAll(name);\\n        if (values === null) {\\n            this.set(name, value);\\n        }\\n        else {\\n            values.push(value);\\n        }\\n    };\\n    /**\\n     * Deletes all header values for the given name.\\n     */\\n    Headers.prototype.delete = function (name) {\\n        var lcName = name.toLowerCase();\\n        this._normalizedNames.delete(lcName);\\n        this._headers.delete(lcName);\\n    };\\n    Headers.prototype.forEach = function (fn) {\\n        var _this = this;\\n        this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });\\n    };\\n    /**\\n     * Returns first header that matches given name.\\n     */\\n    Headers.prototype.get = function (name) {\\n        var values = this.getAll(name);\\n        if (values === null) {\\n            return null;\\n        }\\n        return values.length > 0 ? values[0] : null;\\n    };\\n    /**\\n     * Checks for existence of header by given name.\\n     */\\n    Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };\\n    /**\\n     * Returns the names of the headers\\n     */\\n    Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };\\n    /**\\n     * Sets or overrides header value for given name.\\n     */\\n    Headers.prototype.set = function (name, value) {\\n        if (Array.isArray(value)) {\\n            if (value.length) {\\n                this._headers.set(name.toLowerCase(), [value.join(',')]);\\n            }\\n        }\\n        else {\\n            this._headers.set(name.toLowerCase(), [value]);\\n        }\\n        this.mayBeSetNormalizedName(name);\\n    };\\n    /**\\n     * Returns values of all headers.\\n     */\\n    Headers.prototype.values = function () { return Array.from(this._headers.values()); };\\n    /**\\n     * Returns string of all headers.\\n     */\\n    // TODO(vicb): returns {[name: string]: string[]}\\n    Headers.prototype.toJSON = function () {\\n        var _this = this;\\n        var serialized = {};\\n        this._headers.forEach(function (values, name) {\\n            var split = [];\\n            values.forEach(function (v) { return split.push.apply(split, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \\\"g\\\"])(v.split(','))); });\\n            serialized[_this._normalizedNames.get(name)] = split;\\n        });\\n        return serialized;\\n    };\\n    /**\\n     * Returns list of header values for a given name.\\n     */\\n    Headers.prototype.getAll = function (name) {\\n        return this.has(name) ? this._headers.get(name.toLowerCase()) || null : null;\\n    };\\n    /**\\n     * This method is not implemented.\\n     */\\n    Headers.prototype.entries = function () { throw new Error('\\\"entries\\\" method is not implemented on Headers class'); };\\n    Headers.prototype.mayBeSetNormalizedName = function (name) {\\n        var lcName = name.toLowerCase();\\n        if (!this._normalizedNames.has(lcName)) {\\n            this._normalizedNames.set(lcName, name);\\n        }\\n    };\\n    return Headers;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Creates a response options object to be optionally provided when instantiating a\\n * {@link Response}.\\n *\\n * This class is based on the `ResponseInit` description in the [Fetch\\n * Spec](https://fetch.spec.whatwg.org/#responseinit).\\n *\\n * All values are null by default. Typical defaults can be found in the\\n * {@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.\\n *\\n * This class may be used in tests to build {@link Response Responses} for\\n * mock responses (see {@link MockBackend}).\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import {ResponseOptions, Response} from '@angular/http';\\n *\\n * var options = new ResponseOptions({\\n *   body: '{\\\"name\\\":\\\"Jeff\\\"}'\\n * });\\n * var res = new Response(options);\\n *\\n * console.log('res.json():', res.json()); // Object {name: \\\"Jeff\\\"}\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar ResponseOptions = /** @class */ (function () {\\n    function ResponseOptions(opts) {\\n        if (opts === void 0) { opts = {}; }\\n        var body = opts.body, status = opts.status, headers = opts.headers, statusText = opts.statusText, type = opts.type, url = opts.url;\\n        this.body = body != null ? body : null;\\n        this.status = status != null ? status : null;\\n        this.headers = headers != null ? headers : null;\\n        this.statusText = statusText != null ? statusText : null;\\n        this.type = type != null ? type : null;\\n        this.url = url != null ? url : null;\\n    }\\n    /**\\n     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to\\n     * override\\n     * existing values. This method will not change the values of the instance on which it is being\\n     * called.\\n     *\\n     * This may be useful when sharing a base `ResponseOptions` object inside tests,\\n     * where certain properties may change from test to test.\\n     *\\n     * @usageNotes\\n     * ### Example\\n     *\\n     * ```typescript\\n     * import {ResponseOptions, Response} from '@angular/http';\\n     *\\n     * var options = new ResponseOptions({\\n     *   body: {name: 'Jeff'}\\n     * });\\n     * var res = new Response(options.merge({\\n     *   url: 'https://google.com'\\n     * }));\\n     * console.log('options.url:', options.url); // null\\n     * console.log('res.json():', res.json()); // Object {name: \\\"Jeff\\\"}\\n     * console.log('res.url:', res.url); // https://google.com\\n     * ```\\n     */\\n    ResponseOptions.prototype.merge = function (options) {\\n        return new ResponseOptions({\\n            body: options && options.body != null ? options.body : this.body,\\n            status: options && options.status != null ? options.status : this.status,\\n            headers: options && options.headers != null ? options.headers : this.headers,\\n            statusText: options && options.statusText != null ? options.statusText : this.statusText,\\n            type: options && options.type != null ? options.type : this.type,\\n            url: options && options.url != null ? options.url : this.url,\\n        });\\n    };\\n    return ResponseOptions;\\n}());\\n/**\\n * Subclass of {@link ResponseOptions}, with default values.\\n *\\n * Default values:\\n *  * status: 200\\n *  * headers: empty {@link Headers} object\\n *\\n * This class could be extended and bound to the {@link ResponseOptions} class\\n * when configuring an {@link Injector}, in order to override the default options\\n * used by {@link Http} to create {@link Response Responses}.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import {provide} from '@angular/core';\\n * import {bootstrap} from '@angular/platform-browser/browser';\\n * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from\\n * '@angular/http';\\n * import {App} from './myapp';\\n *\\n * class MyOptions extends BaseResponseOptions {\\n *   headers:Headers = new Headers({network: 'github'});\\n * }\\n *\\n * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);\\n * ```\\n *\\n * The options could also be extended when manually creating a {@link Response}\\n * object.\\n *\\n * ### Example\\n *\\n * ```\\n * import {BaseResponseOptions, Response} from '@angular/http';\\n *\\n * var options = new BaseResponseOptions();\\n * var res = new Response(options.merge({\\n *   body: 'Angular',\\n *   headers: new Headers({framework: 'angular'})\\n * }));\\n * console.log('res.headers.get(\\\"framework\\\"):', res.headers.get('framework')); // angular\\n * console.log('res.text():', res.text()); // Angular;\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar BaseResponseOptions = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(BaseResponseOptions, _super);\\n    function BaseResponseOptions() {\\n        return _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() }) || this;\\n    }\\n    BaseResponseOptions = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [])\\n    ], BaseResponseOptions);\\n    return BaseResponseOptions;\\n}(ResponseOptions));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Abstract class from which real backends are derived.\\n *\\n * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given\\n * {@link Request}.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar ConnectionBackend = /** @class */ (function () {\\n    function ConnectionBackend() {\\n    }\\n    return ConnectionBackend;\\n}());\\n/**\\n * Abstract class from which real connections are derived.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Connection = /** @class */ (function () {\\n    function Connection() {\\n    }\\n    return Connection;\\n}());\\n/**\\n * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar XSRFStrategy = /** @class */ (function () {\\n    function XSRFStrategy() {\\n    }\\n    return XSRFStrategy;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction normalizeMethodName(method) {\\n    if (typeof method !== 'string')\\n        return method;\\n    switch (method.toUpperCase()) {\\n        case 'GET':\\n            return RequestMethod.Get;\\n        case 'POST':\\n            return RequestMethod.Post;\\n        case 'PUT':\\n            return RequestMethod.Put;\\n        case 'DELETE':\\n            return RequestMethod.Delete;\\n        case 'OPTIONS':\\n            return RequestMethod.Options;\\n        case 'HEAD':\\n            return RequestMethod.Head;\\n        case 'PATCH':\\n            return RequestMethod.Patch;\\n    }\\n    throw new Error(\\\"Invalid request method. The method \\\\\\\"\\\" + method + \\\"\\\\\\\" is not supported.\\\");\\n}\\nvar isSuccess = function (status) { return (status >= 200 && status < 300); };\\nfunction getResponseURL(xhr) {\\n    if ('responseURL' in xhr) {\\n        return xhr.responseURL;\\n    }\\n    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\\n        return xhr.getResponseHeader('X-Request-URL');\\n    }\\n    return null;\\n}\\nfunction stringToArrayBuffer(input) {\\n    var view = new Uint16Array(input.length);\\n    for (var i = 0, strLen = input.length; i < strLen; i++) {\\n        view[i] = input.charCodeAt(i);\\n    }\\n    return view.buffer;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction paramParser(rawParams) {\\n    if (rawParams === void 0) { rawParams = ''; }\\n    var map = new Map();\\n    if (rawParams.length > 0) {\\n        var params = rawParams.split('&');\\n        params.forEach(function (param) {\\n            var eqIdx = param.indexOf('=');\\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __read */ \\\"f\\\"])(eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], 2), key = _a[0], val = _a[1];\\n            var list = map.get(key) || [];\\n            list.push(val);\\n            map.set(key, list);\\n        });\\n    }\\n    return map;\\n}\\n/**\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n **/\\nvar QueryEncoder = /** @class */ (function () {\\n    function QueryEncoder() {\\n    }\\n    QueryEncoder.prototype.encodeKey = function (key) { return standardEncoding(key); };\\n    QueryEncoder.prototype.encodeValue = function (value) { return standardEncoding(value); };\\n    return QueryEncoder;\\n}());\\nfunction standardEncoding(v) {\\n    return encodeURIComponent(v)\\n        .replace(/%40/gi, '@')\\n        .replace(/%3A/gi, ':')\\n        .replace(/%24/gi, '$')\\n        .replace(/%2C/gi, ',')\\n        .replace(/%3B/gi, ';')\\n        .replace(/%2B/gi, '+')\\n        .replace(/%3D/gi, '=')\\n        .replace(/%3F/gi, '?')\\n        .replace(/%2F/gi, '/');\\n}\\n/**\\n * Map-like representation of url search parameters, based on\\n * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,\\n * with several extensions for merging URLSearchParams objects:\\n *   - setAll()\\n *   - appendAll()\\n *   - replaceAll()\\n *\\n * This class accepts an optional second parameter of ${@link QueryEncoder},\\n * which is used to serialize parameters before making a request. By default,\\n * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,\\n * and then un-encodes certain characters that are allowed to be part of the query\\n * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.\\n *\\n * These are the characters that are not encoded: `! $ \\\\' ( ) * + , ; A 9 - . _ ~ ? /`\\n *\\n * If the set of allowed query characters is not acceptable for a particular backend,\\n * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.\\n *\\n * ```\\n * import {URLSearchParams, QueryEncoder} from '@angular/http';\\n * class MyQueryEncoder extends QueryEncoder {\\n *   encodeKey(k: string): string {\\n *     return myEncodingFunction(k);\\n *   }\\n *\\n *   encodeValue(v: string): string {\\n *     return myEncodingFunction(v);\\n *   }\\n * }\\n *\\n * let params = new URLSearchParams('', new MyQueryEncoder());\\n * ```\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar URLSearchParams = /** @class */ (function () {\\n    function URLSearchParams(rawParams, queryEncoder) {\\n        if (rawParams === void 0) { rawParams = ''; }\\n        if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }\\n        this.rawParams = rawParams;\\n        this.queryEncoder = queryEncoder;\\n        this.paramsMap = paramParser(rawParams);\\n    }\\n    URLSearchParams.prototype.clone = function () {\\n        var clone = new URLSearchParams('', this.queryEncoder);\\n        clone.appendAll(this);\\n        return clone;\\n    };\\n    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };\\n    URLSearchParams.prototype.get = function (param) {\\n        var storedParam = this.paramsMap.get(param);\\n        return Array.isArray(storedParam) ? storedParam[0] : null;\\n    };\\n    URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };\\n    URLSearchParams.prototype.set = function (param, val) {\\n        if (val === void 0 || val === null) {\\n            this.delete(param);\\n            return;\\n        }\\n        var list = this.paramsMap.get(param) || [];\\n        list.length = 0;\\n        list.push(val);\\n        this.paramsMap.set(param, list);\\n    };\\n    // A merge operation\\n    // For each name-values pair in `searchParams`, perform `set(name, values[0])`\\n    //\\n    // E.g: \\\"a=[1,2,3], c=[8]\\\" + \\\"a=[4,5,6], b=[7]\\\" = \\\"a=[4], c=[8], b=[7]\\\"\\n    //\\n    // TODO(@caitp): document this better\\n    URLSearchParams.prototype.setAll = function (searchParams) {\\n        var _this = this;\\n        searchParams.paramsMap.forEach(function (value, param) {\\n            var list = _this.paramsMap.get(param) || [];\\n            list.length = 0;\\n            list.push(value[0]);\\n            _this.paramsMap.set(param, list);\\n        });\\n    };\\n    URLSearchParams.prototype.append = function (param, val) {\\n        if (val === void 0 || val === null)\\n            return;\\n        var list = this.paramsMap.get(param) || [];\\n        list.push(val);\\n        this.paramsMap.set(param, list);\\n    };\\n    // A merge operation\\n    // For each name-values pair in `searchParams`, perform `append(name, value)`\\n    // for each value in `values`.\\n    //\\n    // E.g: \\\"a=[1,2], c=[8]\\\" + \\\"a=[3,4], b=[7]\\\" = \\\"a=[1,2,3,4], c=[8], b=[7]\\\"\\n    //\\n    // TODO(@caitp): document this better\\n    URLSearchParams.prototype.appendAll = function (searchParams) {\\n        var _this = this;\\n        searchParams.paramsMap.forEach(function (value, param) {\\n            var list = _this.paramsMap.get(param) || [];\\n            for (var i = 0; i < value.length; ++i) {\\n                list.push(value[i]);\\n            }\\n            _this.paramsMap.set(param, list);\\n        });\\n    };\\n    // A merge operation\\n    // For each name-values pair in `searchParams`, perform `delete(name)`,\\n    // followed by `set(name, values)`\\n    //\\n    // E.g: \\\"a=[1,2,3], c=[8]\\\" + \\\"a=[4,5,6], b=[7]\\\" = \\\"a=[4,5,6], c=[8], b=[7]\\\"\\n    //\\n    // TODO(@caitp): document this better\\n    URLSearchParams.prototype.replaceAll = function (searchParams) {\\n        var _this = this;\\n        searchParams.paramsMap.forEach(function (value, param) {\\n            var list = _this.paramsMap.get(param) || [];\\n            list.length = 0;\\n            for (var i = 0; i < value.length; ++i) {\\n                list.push(value[i]);\\n            }\\n            _this.paramsMap.set(param, list);\\n        });\\n    };\\n    URLSearchParams.prototype.toString = function () {\\n        var _this = this;\\n        var paramsList = [];\\n        this.paramsMap.forEach(function (values, k) {\\n            values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });\\n        });\\n        return paramsList.join('&');\\n    };\\n    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };\\n    return URLSearchParams;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * HTTP request body used by both {@link Request} and {@link Response}\\n * https://fetch.spec.whatwg.org/#body\\n */\\nvar Body = /** @class */ (function () {\\n    function Body() {\\n    }\\n    /**\\n     * Attempts to return body as parsed `JSON` object, or raises an exception.\\n     */\\n    Body.prototype.json = function () {\\n        if (typeof this._body === 'string') {\\n            return JSON.parse(this._body);\\n        }\\n        if (this._body instanceof ArrayBuffer) {\\n            return JSON.parse(this.text());\\n        }\\n        return this._body;\\n    };\\n    /**\\n     * Returns the body as a string, presuming `toString()` can be called on the response body.\\n     *\\n     * When decoding an `ArrayBuffer`, the optional `encodingHint` parameter determines how the\\n     * bytes in the buffer will be interpreted. Valid values are:\\n     *\\n     * - `legacy` - incorrectly interpret the bytes as UTF-16 (technically, UCS-2). Only characters\\n     *   in the Basic Multilingual Plane are supported, surrogate pairs are not handled correctly.\\n     *   In addition, the endianness of the 16-bit octet pairs in the `ArrayBuffer` is not taken\\n     *   into consideration. This is the default behavior to avoid breaking apps, but should be\\n     *   considered deprecated.\\n     *\\n     * - `iso-8859` - interpret the bytes as ISO-8859 (which can be used for ASCII encoded text).\\n     */\\n    Body.prototype.text = function (encodingHint) {\\n        if (encodingHint === void 0) { encodingHint = 'legacy'; }\\n        if (this._body instanceof URLSearchParams) {\\n            return this._body.toString();\\n        }\\n        if (this._body instanceof ArrayBuffer) {\\n            switch (encodingHint) {\\n                case 'legacy':\\n                    return String.fromCharCode.apply(null, new Uint16Array(this._body));\\n                case 'iso-8859':\\n                    return String.fromCharCode.apply(null, new Uint8Array(this._body));\\n                default:\\n                    throw new Error(\\\"Invalid value for encodingHint: \\\" + encodingHint);\\n            }\\n        }\\n        if (this._body == null) {\\n            return '';\\n        }\\n        if (typeof this._body === 'object') {\\n            return JSON.stringify(this._body, null, 2);\\n        }\\n        return this._body.toString();\\n    };\\n    /**\\n     * Return the body as an ArrayBuffer\\n     */\\n    Body.prototype.arrayBuffer = function () {\\n        if (this._body instanceof ArrayBuffer) {\\n            return this._body;\\n        }\\n        return stringToArrayBuffer(this.text());\\n    };\\n    /**\\n      * Returns the request's body as a Blob, assuming that body exists.\\n      */\\n    Body.prototype.blob = function () {\\n        if (this._body instanceof Blob) {\\n            return this._body;\\n        }\\n        if (this._body instanceof ArrayBuffer) {\\n            return new Blob([this._body]);\\n        }\\n        throw new Error('The request body isn\\\\'t either a blob or an array buffer');\\n    };\\n    return Body;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Creates `Response` instances from provided values.\\n *\\n * Though this object isn't\\n * usually instantiated by end-users, it is the primary object interacted with when it comes time to\\n * add data to a view.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * http.request('my-friends.txt').subscribe(response => this.friends = response.text());\\n * ```\\n *\\n * The Response's interface is inspired by the Response constructor defined in the [Fetch\\n * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body\\n * can be accessed many times. There are other differences in the implementation, but this is the\\n * most significant.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Response = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(Response, _super);\\n    function Response(responseOptions) {\\n        var _this = _super.call(this) || this;\\n        _this._body = responseOptions.body;\\n        _this.status = responseOptions.status;\\n        _this.ok = (_this.status >= 200 && _this.status <= 299);\\n        _this.statusText = responseOptions.statusText;\\n        _this.headers = responseOptions.headers;\\n        _this.type = responseOptions.type;\\n        _this.url = responseOptions.url;\\n        return _this;\\n    }\\n    Response.prototype.toString = function () {\\n        return \\\"Response with status: \\\" + this.status + \\\" \\\" + this.statusText + \\\" for URL: \\\" + this.url;\\n    };\\n    return Response;\\n}(Body));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar _nextRequestId = 0;\\nvar JSONP_HOME = '__ng_jsonp__';\\nvar _jsonpConnections = null;\\nfunction _getJsonpConnections() {\\n    var w = typeof window == 'object' ? window : {};\\n    if (_jsonpConnections === null) {\\n        _jsonpConnections = w[JSONP_HOME] = {};\\n    }\\n    return _jsonpConnections;\\n}\\n// Make sure not to evaluate this in a non-browser environment!\\nvar BrowserJsonp = /** @class */ (function () {\\n    function BrowserJsonp() {\\n    }\\n    // Construct a <script> element with the specified URL\\n    BrowserJsonp.prototype.build = function (url) {\\n        var node = document.createElement('script');\\n        node.src = url;\\n        return node;\\n    };\\n    BrowserJsonp.prototype.nextRequestID = function () { return \\\"__req\\\" + _nextRequestId++; };\\n    BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + \\\".\\\" + id + \\\".finished\\\"; };\\n    BrowserJsonp.prototype.exposeConnection = function (id, connection) {\\n        var connections = _getJsonpConnections();\\n        connections[id] = connection;\\n    };\\n    BrowserJsonp.prototype.removeConnection = function (id) {\\n        var connections = _getJsonpConnections();\\n        connections[id] = null;\\n    };\\n    // Attach the <script> element to the DOM\\n    BrowserJsonp.prototype.send = function (node) { document.body.appendChild((node)); };\\n    // Remove <script> element from the DOM\\n    BrowserJsonp.prototype.cleanup = function (node) {\\n        if (node.parentNode) {\\n            node.parentNode.removeChild((node));\\n        }\\n    };\\n    BrowserJsonp = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])()\\n    ], BrowserJsonp);\\n    return BrowserJsonp;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\\nvar JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';\\n/**\\n * Base class for an in-flight JSONP request.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar JSONPConnection = /** @class */ (function () {\\n    /** @internal */\\n    function JSONPConnection(req, _dom, baseResponseOptions) {\\n        var _this = this;\\n        this._dom = _dom;\\n        this.baseResponseOptions = baseResponseOptions;\\n        this._finished = false;\\n        if (req.method !== RequestMethod.Get) {\\n            throw new TypeError(JSONP_ERR_WRONG_METHOD);\\n        }\\n        this.request = req;\\n        this.response = new rxjs__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ \\\"a\\\"](function (responseObserver) {\\n            _this.readyState = ReadyState.Loading;\\n            var id = _this._id = _dom.nextRequestID();\\n            _dom.exposeConnection(id, _this);\\n            // Workaround Dart\\n            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);\\n            var callback = _dom.requestCallback(_this._id);\\n            var url = req.url;\\n            if (url.indexOf('=JSONP_CALLBACK&') > -1) {\\n                url = url.replace('=JSONP_CALLBACK&', \\\"=\\\" + callback + \\\"&\\\");\\n            }\\n            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {\\n                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + (\\\"=\\\" + callback);\\n            }\\n            var script = _this._script = _dom.build(url);\\n            var onLoad = function (event) {\\n                if (_this.readyState === ReadyState.Cancelled)\\n                    return;\\n                _this.readyState = ReadyState.Done;\\n                _dom.cleanup(script);\\n                if (!_this._finished) {\\n                    var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });\\n                    if (baseResponseOptions) {\\n                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);\\n                    }\\n                    responseObserver.error(new Response(responseOptions_1));\\n                    return;\\n                }\\n                var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });\\n                if (_this.baseResponseOptions) {\\n                    responseOptions = _this.baseResponseOptions.merge(responseOptions);\\n                }\\n                responseObserver.next(new Response(responseOptions));\\n                responseObserver.complete();\\n            };\\n            var onError = function (error) {\\n                if (_this.readyState === ReadyState.Cancelled)\\n                    return;\\n                _this.readyState = ReadyState.Done;\\n                _dom.cleanup(script);\\n                var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });\\n                if (baseResponseOptions) {\\n                    responseOptions = baseResponseOptions.merge(responseOptions);\\n                }\\n                responseObserver.error(new Response(responseOptions));\\n            };\\n            script.addEventListener('load', onLoad);\\n            script.addEventListener('error', onError);\\n            _dom.send(script);\\n            return function () {\\n                _this.readyState = ReadyState.Cancelled;\\n                script.removeEventListener('load', onLoad);\\n                script.removeEventListener('error', onError);\\n                _this._dom.cleanup(script);\\n            };\\n        });\\n    }\\n    /**\\n     * Callback called when the JSONP request completes, to notify the application\\n     * of the new data.\\n     */\\n    JSONPConnection.prototype.finished = function (data) {\\n        // Don't leak connections\\n        this._finished = true;\\n        this._dom.removeConnection(this._id);\\n        if (this.readyState === ReadyState.Cancelled)\\n            return;\\n        this._responseData = data;\\n    };\\n    return JSONPConnection;\\n}());\\n/**\\n * A {@link ConnectionBackend} that uses the JSONP strategy of making requests.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar JSONPBackend = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(JSONPBackend, _super);\\n    /** @internal */\\n    function JSONPBackend(_browserJSONP, _baseResponseOptions) {\\n        var _this = _super.call(this) || this;\\n        _this._browserJSONP = _browserJSONP;\\n        _this._baseResponseOptions = _baseResponseOptions;\\n        return _this;\\n    }\\n    JSONPBackend.prototype.createConnection = function (request) {\\n        return new JSONPConnection(request, this._browserJSONP, this._baseResponseOptions);\\n    };\\n    JSONPBackend = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [BrowserJsonp, ResponseOptions])\\n    ], JSONPBackend);\\n    return JSONPBackend;\\n}(ConnectionBackend));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar XSSI_PREFIX = /^\\\\)\\\\]\\\\}',?\\\\n/;\\n/**\\n * Creates connections using `XMLHttpRequest`. Given a fully-qualified\\n * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the\\n * request.\\n *\\n * This class would typically not be created or interacted with directly inside applications, though\\n * the {@link MockConnection} may be interacted with in tests.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar XHRConnection = /** @class */ (function () {\\n    function XHRConnection(req, browserXHR, baseResponseOptions) {\\n        var _this = this;\\n        this.request = req;\\n        this.response = new rxjs__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ \\\"a\\\"](function (responseObserver) {\\n            var _xhr = browserXHR.build();\\n            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);\\n            if (req.withCredentials != null) {\\n                _xhr.withCredentials = req.withCredentials;\\n            }\\n            // load event handler\\n            var onLoad = function () {\\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\\n                var status = _xhr.status === 1223 ? 204 : _xhr.status;\\n                var body = null;\\n                // HTTP 204 means no content\\n                if (status !== 204) {\\n                    // responseText is the old-school way of retrieving response (supported by IE8 & 9)\\n                    // response/responseType properties were introduced in ResourceLoader Level2 spec\\n                    // (supported by IE10)\\n                    body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;\\n                    // Implicitly strip a potential XSSI prefix.\\n                    if (typeof body === 'string') {\\n                        body = body.replace(XSSI_PREFIX, '');\\n                    }\\n                }\\n                // fix status code when it is 0 (0 status is undocumented).\\n                // Occurs when accessing file resources or on Android 4.1 stock browser\\n                // while retrieving files from application cache.\\n                if (status === 0) {\\n                    status = body ? 200 : 0;\\n                }\\n                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());\\n                // IE 9 does not provide the way to get URL of response\\n                var url = getResponseURL(_xhr) || req.url;\\n                var statusText = _xhr.statusText || 'OK';\\n                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });\\n                if (baseResponseOptions != null) {\\n                    responseOptions = baseResponseOptions.merge(responseOptions);\\n                }\\n                var response = new Response(responseOptions);\\n                response.ok = isSuccess(status);\\n                if (response.ok) {\\n                    responseObserver.next(response);\\n                    // TODO(gdi2290): defer complete if array buffer until done\\n                    responseObserver.complete();\\n                    return;\\n                }\\n                responseObserver.error(response);\\n            };\\n            // error event handler\\n            var onError = function (err) {\\n                var responseOptions = new ResponseOptions({\\n                    body: err,\\n                    type: ResponseType.Error,\\n                    status: _xhr.status,\\n                    statusText: _xhr.statusText,\\n                });\\n                if (baseResponseOptions != null) {\\n                    responseOptions = baseResponseOptions.merge(responseOptions);\\n                }\\n                responseObserver.error(new Response(responseOptions));\\n            };\\n            _this.setDetectedContentType(req, _xhr);\\n            if (req.headers == null) {\\n                req.headers = new Headers();\\n            }\\n            if (!req.headers.has('Accept')) {\\n                req.headers.append('Accept', 'application/json, text/plain, */*');\\n            }\\n            req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });\\n            // Select the correct buffer type to store the response\\n            if (req.responseType != null && _xhr.responseType != null) {\\n                switch (req.responseType) {\\n                    case ResponseContentType.ArrayBuffer:\\n                        _xhr.responseType = 'arraybuffer';\\n                        break;\\n                    case ResponseContentType.Json:\\n                        _xhr.responseType = 'json';\\n                        break;\\n                    case ResponseContentType.Text:\\n                        _xhr.responseType = 'text';\\n                        break;\\n                    case ResponseContentType.Blob:\\n                        _xhr.responseType = 'blob';\\n                        break;\\n                    default:\\n                        throw new Error('The selected responseType is not supported');\\n                }\\n            }\\n            _xhr.addEventListener('load', onLoad);\\n            _xhr.addEventListener('error', onError);\\n            _xhr.send(_this.request.getBody());\\n            return function () {\\n                _xhr.removeEventListener('load', onLoad);\\n                _xhr.removeEventListener('error', onError);\\n                _xhr.abort();\\n            };\\n        });\\n    }\\n    XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {\\n        // Skip if a custom Content-Type header is provided\\n        if (req.headers != null && req.headers.get('Content-Type') != null) {\\n            return;\\n        }\\n        // Set the detected content type\\n        switch (req.contentType) {\\n            case ContentType.NONE:\\n                break;\\n            case ContentType.JSON:\\n                _xhr.setRequestHeader('content-type', 'application/json');\\n                break;\\n            case ContentType.FORM:\\n                _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\\n                break;\\n            case ContentType.TEXT:\\n                _xhr.setRequestHeader('content-type', 'text/plain');\\n                break;\\n            case ContentType.BLOB:\\n                var blob = req.blob();\\n                if (blob.type) {\\n                    _xhr.setRequestHeader('content-type', blob.type);\\n                }\\n                break;\\n        }\\n    };\\n    return XHRConnection;\\n}());\\n/**\\n * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application\\n * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)\\n * for more information on XSRF.\\n *\\n * Applications can configure custom cookie and header names by binding an instance of this class\\n * with different `cookieName` and `headerName` values. See the main HTTP documentation for more\\n * details.\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar CookieXSRFStrategy = /** @class */ (function () {\\n    function CookieXSRFStrategy(_cookieName, _headerName) {\\n        if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }\\n        if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }\\n        this._cookieName = _cookieName;\\n        this._headerName = _headerName;\\n    }\\n    CookieXSRFStrategy.prototype.configureRequest = function (req) {\\n        var xsrfToken = Object(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__[\\\"ɵgetDOM\\\"])().getCookie(this._cookieName);\\n        if (xsrfToken) {\\n            req.headers.set(this._headerName, xsrfToken);\\n        }\\n    };\\n    return CookieXSRFStrategy;\\n}());\\n/**\\n * Creates {@link XHRConnection} instances.\\n *\\n * This class would typically not be used by end users, but could be\\n * overridden if a different backend implementation should be used,\\n * such as in a node backend.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '@angular/http';\\n * @Component({\\n *   viewProviders: [\\n *     HTTP_PROVIDERS,\\n *     {provide: Http, useFactory: (backend, options) => {\\n *       return new Http(backend, options);\\n *     }, deps: [MyNodeBackend, BaseRequestOptions]}]\\n * })\\n * class MyComponent {\\n *   constructor(http:Http) {\\n *     http.request('people.json').subscribe(res => this.people = res.json());\\n *   }\\n * }\\n * ```\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar XHRBackend = /** @class */ (function () {\\n    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {\\n        this._browserXHR = _browserXHR;\\n        this._baseResponseOptions = _baseResponseOptions;\\n        this._xsrfStrategy = _xsrfStrategy;\\n    }\\n    XHRBackend.prototype.createConnection = function (request) {\\n        this._xsrfStrategy.configureRequest(request);\\n        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);\\n    };\\n    XHRBackend = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [BrowserXhr, ResponseOptions,\\n            XSRFStrategy])\\n    ], XHRBackend);\\n    return XHRBackend;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Creates a request options object to be optionally provided when instantiating a\\n * {@link Request}.\\n *\\n * This class is based on the `RequestInit` description in the [Fetch\\n * Spec](https://fetch.spec.whatwg.org/#requestinit).\\n *\\n * All values are null by default. Typical defaults can be found in the {@link BaseRequestOptions}\\n * class, which sub-classes `RequestOptions`.\\n *\\n * ```typescript\\n * import {RequestOptions, Request, RequestMethod} from '@angular/http';\\n *\\n * const options = new RequestOptions({\\n *   method: RequestMethod.Post,\\n *   url: 'https://google.com'\\n * });\\n * const req = new Request(options);\\n * console.log('req.method:', RequestMethod[req.method]); // Post\\n * console.log('options.url:', options.url); // https://google.com\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar RequestOptions = /** @class */ (function () {\\n    // TODO(Dzmitry): remove search when this.search is removed\\n    function RequestOptions(opts) {\\n        if (opts === void 0) { opts = {}; }\\n        var method = opts.method, headers = opts.headers, body = opts.body, url = opts.url, search = opts.search, params = opts.params, withCredentials = opts.withCredentials, responseType = opts.responseType;\\n        this.method = method != null ? normalizeMethodName(method) : null;\\n        this.headers = headers != null ? headers : null;\\n        this.body = body != null ? body : null;\\n        this.url = url != null ? url : null;\\n        this.params = this._mergeSearchParams(params || search);\\n        this.withCredentials = withCredentials != null ? withCredentials : null;\\n        this.responseType = responseType != null ? responseType : null;\\n    }\\n    Object.defineProperty(RequestOptions.prototype, \\\"search\\\", {\\n        /**\\n         * @deprecated from 4.0.0. Use params instead.\\n         */\\n        get: function () { return this.params; },\\n        /**\\n         * @deprecated from 4.0.0. Use params instead.\\n         */\\n        set: function (params) { this.params = params; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override\\n     * existing values. This method will not change the values of the instance on which it is being\\n     * called.\\n     *\\n     * Note that `headers` and `search` will override existing values completely if present in\\n     * the `options` object. If these values should be merged, it should be done prior to calling\\n     * `merge` on the `RequestOptions` instance.\\n     *\\n     * ```typescript\\n     * import {RequestOptions, Request, RequestMethod} from '@angular/http';\\n     *\\n     * const options = new RequestOptions({\\n     *   method: RequestMethod.Post\\n     * });\\n     * const req = new Request(options.merge({\\n     *   url: 'https://google.com'\\n     * }));\\n     * console.log('req.method:', RequestMethod[req.method]); // Post\\n     * console.log('options.url:', options.url); // null\\n     * console.log('req.url:', req.url); // https://google.com\\n     * ```\\n     */\\n    RequestOptions.prototype.merge = function (options) {\\n        return new RequestOptions({\\n            method: options && options.method != null ? options.method : this.method,\\n            headers: options && options.headers != null ? options.headers : new Headers(this.headers),\\n            body: options && options.body != null ? options.body : this.body,\\n            url: options && options.url != null ? options.url : this.url,\\n            params: options && this._mergeSearchParams(options.params || options.search),\\n            withCredentials: options && options.withCredentials != null ? options.withCredentials :\\n                this.withCredentials,\\n            responseType: options && options.responseType != null ? options.responseType :\\n                this.responseType\\n        });\\n    };\\n    RequestOptions.prototype._mergeSearchParams = function (params) {\\n        if (!params)\\n            return this.params;\\n        if (params instanceof URLSearchParams) {\\n            return params.clone();\\n        }\\n        if (typeof params === 'string') {\\n            return new URLSearchParams(params);\\n        }\\n        return this._parseParams(params);\\n    };\\n    RequestOptions.prototype._parseParams = function (objParams) {\\n        var _this = this;\\n        if (objParams === void 0) { objParams = {}; }\\n        var params = new URLSearchParams();\\n        Object.keys(objParams).forEach(function (key) {\\n            var value = objParams[key];\\n            if (Array.isArray(value)) {\\n                value.forEach(function (item) { return _this._appendParam(key, item, params); });\\n            }\\n            else {\\n                _this._appendParam(key, value, params);\\n            }\\n        });\\n        return params;\\n    };\\n    RequestOptions.prototype._appendParam = function (key, value, params) {\\n        if (typeof value !== 'string') {\\n            value = JSON.stringify(value);\\n        }\\n        params.append(key, value);\\n    };\\n    return RequestOptions;\\n}());\\n/**\\n * Subclass of {@link RequestOptions}, with default values.\\n *\\n * Default values:\\n *  * method: {@link RequestMethod RequestMethod.Get}\\n *  * headers: empty {@link Headers} object\\n *\\n * This class could be extended and bound to the {@link RequestOptions} class\\n * when configuring an {@link Injector}, in order to override the default options\\n * used by {@link Http} to create and send {@link Request Requests}.\\n *\\n * ```typescript\\n * import {BaseRequestOptions, RequestOptions} from '@angular/http';\\n *\\n * class MyOptions extends BaseRequestOptions {\\n *   search: string = 'coreTeam=true';\\n * }\\n *\\n * {provide: RequestOptions, useClass: MyOptions};\\n * ```\\n *\\n * The options could also be extended when manually creating a {@link Request}\\n * object.\\n *\\n * ```\\n * import {BaseRequestOptions, Request, RequestMethod} from '@angular/http';\\n *\\n * const options = new BaseRequestOptions();\\n * const req = new Request(options.merge({\\n *   method: RequestMethod.Post,\\n *   url: 'https://google.com'\\n * }));\\n * console.log('req.method:', RequestMethod[req.method]); // Post\\n * console.log('options.url:', options.url); // null\\n * console.log('req.url:', req.url); // https://google.com\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar BaseRequestOptions = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(BaseRequestOptions, _super);\\n    function BaseRequestOptions() {\\n        return _super.call(this, { method: RequestMethod.Get, headers: new Headers() }) || this;\\n    }\\n    BaseRequestOptions = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [])\\n    ], BaseRequestOptions);\\n    return BaseRequestOptions;\\n}(RequestOptions));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// TODO(jeffbcross): properly implement body accessors\\n/**\\n * Creates `Request` instances from provided values.\\n *\\n * The Request's interface is inspired by the Request constructor defined in the [Fetch\\n * Spec](https://fetch.spec.whatwg.org/#request-class),\\n * but is considered a static value whose body can be accessed many times. There are other\\n * differences in the implementation, but this is the most significant.\\n *\\n * `Request` instances are typically created by higher-level classes, like {@link Http} and\\n * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.\\n * One such example is when creating services that wrap higher-level services, like {@link Http},\\n * where it may be useful to generate a `Request` with arbitrary headers and search params.\\n *\\n * ```typescript\\n * import {Injectable, Injector} from '@angular/core';\\n * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';\\n *\\n * @Injectable()\\n * class AutoAuthenticator {\\n *   constructor(public http:Http) {}\\n *   request(url:string) {\\n *     return this.http.request(new Request({\\n *       method: RequestMethod.Get,\\n *       url: url,\\n *       search: 'password=123'\\n *     }));\\n *   }\\n * }\\n *\\n * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);\\n * var authenticator = injector.get(AutoAuthenticator);\\n * authenticator.request('people.json').subscribe(res => {\\n *   //URL should have included '?password=123'\\n *   console.log('people', res.json());\\n * });\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Request = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(Request, _super);\\n    function Request(requestOptions) {\\n        var _this = _super.call(this) || this;\\n        // TODO: assert that url is present\\n        var url = requestOptions.url;\\n        _this.url = requestOptions.url;\\n        var paramsArg = requestOptions.params || requestOptions.search;\\n        if (paramsArg) {\\n            var params = void 0;\\n            if (typeof paramsArg === 'object' && !(paramsArg instanceof URLSearchParams)) {\\n                params = urlEncodeParams(paramsArg).toString();\\n            }\\n            else {\\n                params = paramsArg.toString();\\n            }\\n            if (params.length > 0) {\\n                var prefix = '?';\\n                if (_this.url.indexOf('?') != -1) {\\n                    prefix = (_this.url[_this.url.length - 1] == '&') ? '' : '&';\\n                }\\n                // TODO: just delete search-query-looking string in url?\\n                _this.url = url + prefix + params;\\n            }\\n        }\\n        _this._body = requestOptions.body;\\n        _this.method = normalizeMethodName(requestOptions.method);\\n        // TODO(jeffbcross): implement behavior\\n        // Defaults to 'omit', consistent with browser\\n        _this.headers = new Headers(requestOptions.headers);\\n        _this.contentType = _this.detectContentType();\\n        _this.withCredentials = requestOptions.withCredentials;\\n        _this.responseType = requestOptions.responseType;\\n        return _this;\\n    }\\n    /**\\n     * Returns the content type enum based on header options.\\n     */\\n    Request.prototype.detectContentType = function () {\\n        switch (this.headers.get('content-type')) {\\n            case 'application/json':\\n                return ContentType.JSON;\\n            case 'application/x-www-form-urlencoded':\\n                return ContentType.FORM;\\n            case 'multipart/form-data':\\n                return ContentType.FORM_DATA;\\n            case 'text/plain':\\n            case 'text/html':\\n                return ContentType.TEXT;\\n            case 'application/octet-stream':\\n                return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;\\n            default:\\n                return this.detectContentTypeFromBody();\\n        }\\n    };\\n    /**\\n     * Returns the content type of request's body based on its type.\\n     */\\n    Request.prototype.detectContentTypeFromBody = function () {\\n        if (this._body == null) {\\n            return ContentType.NONE;\\n        }\\n        else if (this._body instanceof URLSearchParams) {\\n            return ContentType.FORM;\\n        }\\n        else if (this._body instanceof FormData) {\\n            return ContentType.FORM_DATA;\\n        }\\n        else if (this._body instanceof Blob$1) {\\n            return ContentType.BLOB;\\n        }\\n        else if (this._body instanceof ArrayBuffer$1) {\\n            return ContentType.ARRAY_BUFFER;\\n        }\\n        else if (this._body && typeof this._body === 'object') {\\n            return ContentType.JSON;\\n        }\\n        else {\\n            return ContentType.TEXT;\\n        }\\n    };\\n    /**\\n     * Returns the request's body according to its type. If body is undefined, return\\n     * null.\\n     */\\n    Request.prototype.getBody = function () {\\n        switch (this.contentType) {\\n            case ContentType.JSON:\\n                return this.text();\\n            case ContentType.FORM:\\n                return this.text();\\n            case ContentType.FORM_DATA:\\n                return this._body;\\n            case ContentType.TEXT:\\n                return this.text();\\n            case ContentType.BLOB:\\n                return this.blob();\\n            case ContentType.ARRAY_BUFFER:\\n                return this.arrayBuffer();\\n            default:\\n                return null;\\n        }\\n    };\\n    return Request;\\n}(Body));\\nfunction urlEncodeParams(params) {\\n    var searchParams = new URLSearchParams();\\n    Object.keys(params).forEach(function (key) {\\n        var value = params[key];\\n        if (value && Array.isArray(value)) {\\n            value.forEach(function (element) { return searchParams.append(key, element.toString()); });\\n        }\\n        else {\\n            searchParams.append(key, value.toString());\\n        }\\n    });\\n    return searchParams;\\n}\\nvar noop = function () { };\\nvar w = typeof window == 'object' ? window : noop;\\nvar FormData = w /** TODO #9100 */['FormData'] || noop;\\nvar Blob$1 = w /** TODO #9100 */['Blob'] || noop;\\nvar ArrayBuffer$1 = w /** TODO #9100 */['ArrayBuffer'] || noop;\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction httpRequest(backend, request) {\\n    return backend.createConnection(request).response;\\n}\\nfunction mergeOptions(defaultOpts, providedOpts, method, url) {\\n    var newOptions = defaultOpts;\\n    if (providedOpts) {\\n        // Hack so Dart can used named parameters\\n        return newOptions.merge(new RequestOptions({\\n            method: providedOpts.method || method,\\n            url: providedOpts.url || url,\\n            search: providedOpts.search,\\n            params: providedOpts.params,\\n            headers: providedOpts.headers,\\n            body: providedOpts.body,\\n            withCredentials: providedOpts.withCredentials,\\n            responseType: providedOpts.responseType\\n        }));\\n    }\\n    return newOptions.merge(new RequestOptions({ method: method, url: url }));\\n}\\n/**\\n * Performs http requests using `XMLHttpRequest` as the default backend.\\n *\\n * `Http` is available as an injectable class, with methods to perform http requests. Calling\\n * `request` returns an `Observable` which will emit a single {@link Response} when a\\n * response is received.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```typescript\\n * import {Http, HTTP_PROVIDERS} from '@angular/http';\\n * import {map} from 'rxjs/operators';\\n *\\n * @Component({\\n *   selector: 'http-app',\\n *   viewProviders: [HTTP_PROVIDERS],\\n *   templateUrl: 'people.html'\\n * })\\n * class PeopleComponent {\\n *   constructor(http: Http) {\\n *     http.get('people.json')\\n *       // Call map on the response observable to get the parsed people object\\n *       .pipe(map(res => res.json()))\\n *       // Subscribe to the observable to get the parsed people object and attach it to the\\n *       // component\\n *       .subscribe(people => this.people = people);\\n *   }\\n * }\\n * ```\\n *\\n *\\n * ### Example\\n *\\n * ```\\n * http.get('people.json').subscribe((res:Response) => this.people = res.json());\\n * ```\\n *\\n * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a \\\"Backend\\\" (\\n * {@link XHRBackend} in this case), which could be mocked with dependency injection by replacing\\n * the {@link XHRBackend} provider, as in the following example:\\n *\\n * ### Example\\n *\\n * ```typescript\\n * import {BaseRequestOptions, Http} from '@angular/http';\\n * import {MockBackend} from '@angular/http/testing';\\n * var injector = Injector.resolveAndCreate([\\n *   BaseRequestOptions,\\n *   MockBackend,\\n *   {provide: Http, useFactory:\\n *       function(backend, defaultOptions) {\\n *         return new Http(backend, defaultOptions);\\n *       },\\n *       deps: [MockBackend, BaseRequestOptions]}\\n * ]);\\n * var http = injector.get(Http);\\n * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));\\n * ```\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Http = /** @class */ (function () {\\n    function Http(_backend, _defaultOptions) {\\n        this._backend = _backend;\\n        this._defaultOptions = _defaultOptions;\\n    }\\n    /**\\n     * Performs any type of http request. First argument is required, and can either be a url or\\n     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}\\n     * object can be provided as the 2nd argument. The options object will be merged with the values\\n     * of {@link BaseRequestOptions} before performing the request.\\n     */\\n    Http.prototype.request = function (url, options) {\\n        var responseObservable;\\n        if (typeof url === 'string') {\\n            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));\\n        }\\n        else if (url instanceof Request) {\\n            responseObservable = httpRequest(this._backend, url);\\n        }\\n        else {\\n            throw new Error('First argument must be a url string or Request instance.');\\n        }\\n        return responseObservable;\\n    };\\n    /**\\n     * Performs a request with `get` http method.\\n     */\\n    Http.prototype.get = function (url, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));\\n    };\\n    /**\\n     * Performs a request with `post` http method.\\n     */\\n    Http.prototype.post = function (url, body, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));\\n    };\\n    /**\\n     * Performs a request with `put` http method.\\n     */\\n    Http.prototype.put = function (url, body, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));\\n    };\\n    /**\\n     * Performs a request with `delete` http method.\\n     */\\n    Http.prototype.delete = function (url, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));\\n    };\\n    /**\\n     * Performs a request with `patch` http method.\\n     */\\n    Http.prototype.patch = function (url, body, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));\\n    };\\n    /**\\n     * Performs a request with `head` http method.\\n     */\\n    Http.prototype.head = function (url, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));\\n    };\\n    /**\\n     * Performs a request with `options` http method.\\n     */\\n    Http.prototype.options = function (url, options) {\\n        return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));\\n    };\\n    Http = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [ConnectionBackend, RequestOptions])\\n    ], Http);\\n    return Http;\\n}());\\n/**\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar Jsonp = /** @class */ (function (_super) {\\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \\\"c\\\"])(Jsonp, _super);\\n    function Jsonp(backend, defaultOptions) {\\n        return _super.call(this, backend, defaultOptions) || this;\\n    }\\n    /**\\n     * Performs any type of http request. First argument is required, and can either be a url or\\n     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}\\n     * object can be provided as the 2nd argument. The options object will be merged with the values\\n     * of {@link BaseRequestOptions} before performing the request.\\n     *\\n     * @security Regular XHR is the safest alternative to JSONP for most applications, and is\\n     * supported by all current browsers. Because JSONP creates a `<script>` element with\\n     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted\\n     * source could expose your application to XSS risks. Data exposed by JSONP may also be\\n     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for\\n     * future security issues (e.g. content sniffing).  For more detail, see the\\n     * [Security Guide](http://g.co/ng/security).\\n     */\\n    Jsonp.prototype.request = function (url, options) {\\n        var responseObservable;\\n        if (typeof url === 'string') {\\n            url =\\n                new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url));\\n        }\\n        if (url instanceof Request) {\\n            if (url.method !== RequestMethod.Get) {\\n                throw new Error('JSONP requests must use GET request method.');\\n            }\\n            responseObservable = httpRequest(this._backend, url);\\n        }\\n        else {\\n            throw new Error('First argument must be a url string or Request instance.');\\n        }\\n        return responseObservable;\\n    };\\n    Jsonp = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Injectable\\\"])(),\\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __metadata */ \\\"d\\\"])(\\\"design:paramtypes\\\", [ConnectionBackend, RequestOptions])\\n    ], Jsonp);\\n    return Jsonp;\\n}(Http));\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction _createDefaultCookieXSRFStrategy() {\\n    return new CookieXSRFStrategy();\\n}\\nfunction httpFactory(xhrBackend, requestOptions) {\\n    return new Http(xhrBackend, requestOptions);\\n}\\nfunction jsonpFactory(jsonpBackend, requestOptions) {\\n    return new Jsonp(jsonpBackend, requestOptions);\\n}\\n/**\\n * The module that includes http's providers\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar HttpModule = /** @class */ (function () {\\n    function HttpModule() {\\n    }\\n    HttpModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"NgModule\\\"])({\\n            providers: [\\n                // TODO(pascal): use factory type annotations once supported in DI\\n                // issue: https://github.com/angular/angular/issues/3183\\n                { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },\\n                BrowserXhr,\\n                { provide: RequestOptions, useClass: BaseRequestOptions },\\n                { provide: ResponseOptions, useClass: BaseResponseOptions },\\n                XHRBackend,\\n                { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },\\n            ],\\n        })\\n    ], HttpModule);\\n    return HttpModule;\\n}());\\n/**\\n * The module that includes jsonp's providers\\n *\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar JsonpModule = /** @class */ (function () {\\n    function JsonpModule() {\\n    }\\n    JsonpModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ \\\"b\\\"])([\\n        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"NgModule\\\"])({\\n            providers: [\\n                // TODO(pascal): use factory type annotations once supported in DI\\n                // issue: https://github.com/angular/angular/issues/3183\\n                { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },\\n                BrowserJsonp,\\n                { provide: RequestOptions, useClass: BaseRequestOptions },\\n                { provide: ResponseOptions, useClass: BaseResponseOptions },\\n                JSONPBackend,\\n            ],\\n        })\\n    ], JsonpModule);\\n    return JsonpModule;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @deprecated see https://angular.io/guide/http\\n * @publicApi\\n */\\nvar VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\\\"Version\\\"]('7.0.4');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// This file only reexports content of the `src` folder. Keep it that way.\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n\\n//# sourceMappingURL=http.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvZmVzbTUvaHR0cC5qcz9iMDRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Ny4wLjRcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fZXh0ZW5kcywgX19yZWFkLCBfX3NwcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEluamVjdGFibGUsIE5nTW9kdWxlLCBWZXJzaW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyDJtWdldERPTSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgYmFja2VuZCBmb3IgaHR0cCB0aGF0IHVzZXMgdGhlIGBYTUxIdHRwUmVxdWVzdGAgYnJvd3NlciBBUEkuXG4gKlxuICogVGFrZSBjYXJlIG5vdCB0byBldmFsdWF0ZSB0aGlzIGluIG5vbi1icm93c2VyIGNvbnRleHRzLlxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQnJvd3NlclhociA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyWGhyKCkge1xuICAgIH1cbiAgICBCcm93c2VyWGhyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChuZXcgWE1MSHR0cFJlcXVlc3QoKSk7IH07XG4gICAgQnJvd3NlclhociA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbiAgICBdLCBCcm93c2VyWGhyKTtcbiAgICByZXR1cm4gQnJvd3Nlclhocjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogU3VwcG9ydGVkIGh0dHAgbWV0aG9kcy5cbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVxdWVzdE1ldGhvZDtcbihmdW5jdGlvbiAoUmVxdWVzdE1ldGhvZCkge1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIkdldFwiXSA9IDBdID0gXCJHZXRcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2RbXCJQb3N0XCJdID0gMV0gPSBcIlBvc3RcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2RbXCJQdXRcIl0gPSAyXSA9IFwiUHV0XCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kW1wiRGVsZXRlXCJdID0gM10gPSBcIkRlbGV0ZVwiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIk9wdGlvbnNcIl0gPSA0XSA9IFwiT3B0aW9uc1wiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIkhlYWRcIl0gPSA1XSA9IFwiSGVhZFwiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIlBhdGNoXCJdID0gNl0gPSBcIlBhdGNoXCI7XG59KShSZXF1ZXN0TWV0aG9kIHx8IChSZXF1ZXN0TWV0aG9kID0ge30pKTtcbi8qKlxuICogQWxsIHBvc3NpYmxlIHN0YXRlcyBpbiB3aGljaCBhIGNvbm5lY3Rpb24gY2FuIGJlLCBiYXNlZCBvblxuICogW1N0YXRlc10oaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3N0YXRlcykgZnJvbSB0aGUgYFhNTEh0dHBSZXF1ZXN0YCBzcGVjLCBidXQgd2l0aCBhblxuICogYWRkaXRpb25hbCBcIkNBTkNFTExFRFwiIHN0YXRlLlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZWFkeVN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkeVN0YXRlKSB7XG4gICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlW1wiVW5zZW50XCJdID0gMF0gPSBcIlVuc2VudFwiO1xuICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZVtcIk9wZW5cIl0gPSAxXSA9IFwiT3BlblwiO1xuICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZVtcIkhlYWRlcnNSZWNlaXZlZFwiXSA9IDJdID0gXCJIZWFkZXJzUmVjZWl2ZWRcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbXCJMb2FkaW5nXCJdID0gM10gPSBcIkxvYWRpbmdcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbXCJEb25lXCJdID0gNF0gPSBcIkRvbmVcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbXCJDYW5jZWxsZWRcIl0gPSA1XSA9IFwiQ2FuY2VsbGVkXCI7XG59KShSZWFkeVN0YXRlIHx8IChSZWFkeVN0YXRlID0ge30pKTtcbi8qKlxuICogQWNjZXB0YWJsZSByZXNwb25zZSB0eXBlcyB0byBiZSBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgUmVzcG9uc2V9LCBiYXNlZCBvblxuICogW1Jlc3BvbnNlVHlwZV0oaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNldHlwZSkgZnJvbSB0aGUgRmV0Y2ggc3BlYy5cbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVzcG9uc2VUeXBlO1xuKGZ1bmN0aW9uIChSZXNwb25zZVR5cGUpIHtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiQmFzaWNcIl0gPSAwXSA9IFwiQmFzaWNcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiQ29yc1wiXSA9IDFdID0gXCJDb3JzXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkRlZmF1bHRcIl0gPSAyXSA9IFwiRGVmYXVsdFwiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJPcGFxdWVcIl0gPSA0XSA9IFwiT3BhcXVlXCI7XG59KShSZXNwb25zZVR5cGUgfHwgKFJlc3BvbnNlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFN1cHBvcnRlZCBjb250ZW50IHR5cGUgdG8gYmUgYXV0b21hdGljYWxseSBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgUmVxdWVzdH0uXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcbiAqL1xudmFyIENvbnRlbnRUeXBlO1xuKGZ1bmN0aW9uIChDb250ZW50VHlwZSkge1xuICAgIENvbnRlbnRUeXBlW0NvbnRlbnRUeXBlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgQ29udGVudFR5cGVbQ29udGVudFR5cGVbXCJKU09OXCJdID0gMV0gPSBcIkpTT05cIjtcbiAgICBDb250ZW50VHlwZVtDb250ZW50VHlwZVtcIkZPUk1cIl0gPSAyXSA9IFwiRk9STVwiO1xuICAgIENvbnRlbnRUeXBlW0NvbnRlbnRUeXBlW1wiRk9STV9EQVRBXCJdID0gM10gPSBcIkZPUk1fREFUQVwiO1xuICAgIENvbnRlbnRUeXBlW0NvbnRlbnRUeXBlW1wiVEVYVFwiXSA9IDRdID0gXCJURVhUXCI7XG4gICAgQ29udGVudFR5cGVbQ29udGVudFR5cGVbXCJCTE9CXCJdID0gNV0gPSBcIkJMT0JcIjtcbiAgICBDb250ZW50VHlwZVtDb250ZW50VHlwZVtcIkFSUkFZX0JVRkZFUlwiXSA9IDZdID0gXCJBUlJBWV9CVUZGRVJcIjtcbn0pKENvbnRlbnRUeXBlIHx8IChDb250ZW50VHlwZSA9IHt9KSk7XG4vKipcbiAqIERlZmluZSB3aGljaCBidWZmZXIgdG8gdXNlIHRvIHN0b3JlIHRoZSByZXNwb25zZVxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZXNwb25zZUNvbnRlbnRUeXBlO1xuKGZ1bmN0aW9uIChSZXNwb25zZUNvbnRlbnRUeXBlKSB7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlW1wiSnNvblwiXSA9IDFdID0gXCJKc29uXCI7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlW1wiQXJyYXlCdWZmZXJcIl0gPSAyXSA9IFwiQXJyYXlCdWZmZXJcIjtcbiAgICBSZXNwb25zZUNvbnRlbnRUeXBlW1Jlc3BvbnNlQ29udGVudFR5cGVbXCJCbG9iXCJdID0gM10gPSBcIkJsb2JcIjtcbn0pKFJlc3BvbnNlQ29udGVudFR5cGUgfHwgKFJlc3BvbnNlQ29udGVudFR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFBvbHlmaWxsIGZvciBbSGVhZGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hlYWRlcnMvSGVhZGVycyksIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIFtGZXRjaCBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVycy1jbGFzcykuXG4gKlxuICogVGhlIG9ubHkga25vd24gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgYEhlYWRlcnNgIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3BlYyBpcyB0aGVcbiAqIGxhY2sgb2YgYW4gYGVudHJpZXNgIG1ldGhvZC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7SGVhZGVyc30gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG4gKlxuICogdmFyIGZpcnN0SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gKiBmaXJzdEhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnaW1hZ2UvanBlZycpO1xuICogY29uc29sZS5sb2coZmlyc3RIZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpIC8vJ2ltYWdlL2pwZWcnXG4gKlxuICogLy8gQ3JlYXRlIGhlYWRlcnMgZnJvbSBQbGFpbiBPbGQgSmF2YVNjcmlwdCBPYmplY3RcbiAqIHZhciBzZWNvbmRIZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICogICAnWC1NeS1DdXN0b20tSGVhZGVyJzogJ0FuZ3VsYXInXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHNlY29uZEhlYWRlcnMuZ2V0KCdYLU15LUN1c3RvbS1IZWFkZXInKSk7IC8vJ0FuZ3VsYXInXG4gKlxuICogdmFyIHRoaXJkSGVhZGVycyA9IG5ldyBIZWFkZXJzKHNlY29uZEhlYWRlcnMpO1xuICogY29uc29sZS5sb2codGhpcmRIZWFkZXJzLmdldCgnWC1NeS1DdXN0b20tSGVhZGVyJykpOyAvLydBbmd1bGFyJ1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBIZWFkZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8odmljYik6IGFueSAtPiBzdHJpbmd8c3RyaW5nW11cbiAgICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBoZWFkZXIgbmFtZXMgYXJlIGxvd2VyIGNhc2UgKi9cbiAgICAgICAgdGhpcy5faGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBtYXAgbG93ZXIgY2FzZSBuYW1lcyB0byBhY3R1YWwgbmFtZXMgKi9cbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZE5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGhlYWRlcnNbbmFtZV0pID8gaGVhZGVyc1tuYW1lXSA6IFtoZWFkZXJzW25hbWVdXTtcbiAgICAgICAgICAgIF90aGlzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IEhlYWRlcnMgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gRE9NU3RyaW5nIG9mIFJlc3BvbnNlIEhlYWRlcnNcbiAgICAgKi9cbiAgICBIZWFkZXJzLmZyb21SZXNwb25zZUhlYWRlclN0cmluZyA9IGZ1bmN0aW9uIChoZWFkZXJzU3RyaW5nKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVyc1N0cmluZy5zcGxpdCgnXFxuJykuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpbmUuc2xpY2UoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQobmFtZV8xLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBoZWFkZXIgdG8gZXhpc3RpbmcgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciBhIGdpdmVuIGhlYWRlciBuYW1lLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbGwgaGVhZGVyIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgSGVhZGVycy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZE5hbWVzLmRlbGV0ZShsY05hbWUpO1xuICAgICAgICB0aGlzLl9oZWFkZXJzLmRlbGV0ZShsY05hbWUpO1xuICAgIH07XG4gICAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgbGNOYW1lKSB7IHJldHVybiBmbih2YWx1ZXMsIF90aGlzLl9ub3JtYWxpemVkTmFtZXMuZ2V0KGxjTmFtZSksIF90aGlzLl9oZWFkZXJzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGhlYWRlciB0aGF0IG1hdGNoZXMgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID4gMCA/IHZhbHVlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5faGVhZGVycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVyc1xuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheS5mcm9tKHRoaXMuX25vcm1hbGl6ZWROYW1lcy52YWx1ZXMoKSk7IH07XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBvdmVycmlkZXMgaGVhZGVyIHZhbHVlIGZvciBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJzLnNldChuYW1lLnRvTG93ZXJDYXNlKCksIFt2YWx1ZS5qb2luKCcsJyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc2V0KG5hbWUudG9Mb3dlckNhc2UoKSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXlCZVNldE5vcm1hbGl6ZWROYW1lKG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMuXG4gICAgICovXG4gICAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9oZWFkZXJzLnZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyBvZiBhbGwgaGVhZGVycy5cbiAgICAgKi9cbiAgICAvLyBUT0RPKHZpY2IpOiByZXR1cm5zIHtbbmFtZTogc3RyaW5nXTogc3RyaW5nW119XG4gICAgSGVhZGVycy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IHt9O1xuICAgICAgICB0aGlzLl9oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gW107XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc3BsaXQucHVzaC5hcHBseShzcGxpdCwgX19zcHJlYWQodi5zcGxpdCgnLCcpKSk7IH0pO1xuICAgICAgICAgICAgc2VyaWFsaXplZFtfdGhpcy5fbm9ybWFsaXplZE5hbWVzLmdldChuYW1lKV0gPSBzcGxpdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIGhlYWRlciB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLl9oZWFkZXJzLmdldChuYW1lLnRvTG93ZXJDYXNlKCkpIHx8IG51bGwgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignXCJlbnRyaWVzXCIgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBIZWFkZXJzIGNsYXNzJyk7IH07XG4gICAgSGVhZGVycy5wcm90b3R5cGUubWF5QmVTZXROb3JtYWxpemVkTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBsY05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbm9ybWFsaXplZE5hbWVzLmhhcyhsY05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkTmFtZXMuc2V0KGxjTmFtZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIZWFkZXJzO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgcmVzcG9uc2Ugb3B0aW9ucyBvYmplY3QgdG8gYmUgb3B0aW9uYWxseSBwcm92aWRlZCB3aGVuIGluc3RhbnRpYXRpbmcgYVxuICoge0BsaW5rIFJlc3BvbnNlfS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGJhc2VkIG9uIHRoZSBgUmVzcG9uc2VJbml0YCBkZXNjcmlwdGlvbiBpbiB0aGUgW0ZldGNoXG4gKiBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2Vpbml0KS5cbiAqXG4gKiBBbGwgdmFsdWVzIGFyZSBudWxsIGJ5IGRlZmF1bHQuIFR5cGljYWwgZGVmYXVsdHMgY2FuIGJlIGZvdW5kIGluIHRoZVxuICoge0BsaW5rIEJhc2VSZXNwb25zZU9wdGlvbnN9IGNsYXNzLCB3aGljaCBzdWItY2xhc3NlcyBgUmVzcG9uc2VPcHRpb25zYC5cbiAqXG4gKiBUaGlzIGNsYXNzIG1heSBiZSB1c2VkIGluIHRlc3RzIHRvIGJ1aWxkIHtAbGluayBSZXNwb25zZSBSZXNwb25zZXN9IGZvclxuICogbW9jayByZXNwb25zZXMgKHNlZSB7QGxpbmsgTW9ja0JhY2tlbmR9KS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1Jlc3BvbnNlT3B0aW9ucywgUmVzcG9uc2V9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIHZhciBvcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7XG4gKiAgIGJvZHk6ICd7XCJuYW1lXCI6XCJKZWZmXCJ9J1xuICogfSk7XG4gKiB2YXIgcmVzID0gbmV3IFJlc3BvbnNlKG9wdGlvbnMpO1xuICpcbiAqIGNvbnNvbGUubG9nKCdyZXMuanNvbigpOicsIHJlcy5qc29uKCkpOyAvLyBPYmplY3Qge25hbWU6IFwiSmVmZlwifVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZXNwb25zZU9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2VPcHRpb25zKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgdmFyIGJvZHkgPSBvcHRzLmJvZHksIHN0YXR1cyA9IG9wdHMuc3RhdHVzLCBoZWFkZXJzID0gb3B0cy5oZWFkZXJzLCBzdGF0dXNUZXh0ID0gb3B0cy5zdGF0dXNUZXh0LCB0eXBlID0gb3B0cy50eXBlLCB1cmwgPSBvcHRzLnVybDtcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keSAhPSBudWxsID8gYm9keSA6IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiBudWxsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDogbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCAhPSBudWxsID8gc3RhdHVzVGV4dCA6IG51bGw7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgIT0gbnVsbCA/IHR5cGUgOiBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IHVybCAhPSBudWxsID8gdXJsIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGBSZXNwb25zZU9wdGlvbnNgIGluc3RhbmNlLCB1c2luZyB0aGUgb3B0aW9uYWwgaW5wdXQgYXMgdmFsdWVzIHRvXG4gICAgICogb3ZlcnJpZGVcbiAgICAgKiBleGlzdGluZyB2YWx1ZXMuIFRoaXMgbWV0aG9kIHdpbGwgbm90IGNoYW5nZSB0aGUgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZSBvbiB3aGljaCBpdCBpcyBiZWluZ1xuICAgICAqIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWF5IGJlIHVzZWZ1bCB3aGVuIHNoYXJpbmcgYSBiYXNlIGBSZXNwb25zZU9wdGlvbnNgIG9iamVjdCBpbnNpZGUgdGVzdHMsXG4gICAgICogd2hlcmUgY2VydGFpbiBwcm9wZXJ0aWVzIG1heSBjaGFuZ2UgZnJvbSB0ZXN0IHRvIHRlc3QuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtSZXNwb25zZU9wdGlvbnMsIFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7XG4gICAgICogICBib2R5OiB7bmFtZTogJ0plZmYnfVxuICAgICAqIH0pO1xuICAgICAqIHZhciByZXMgPSBuZXcgUmVzcG9uc2Uob3B0aW9ucy5tZXJnZSh7XG4gICAgICogICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nXG4gICAgICogfSkpO1xuICAgICAqIGNvbnNvbGUubG9nKCdvcHRpb25zLnVybDonLCBvcHRpb25zLnVybCk7IC8vIG51bGxcbiAgICAgKiBjb25zb2xlLmxvZygncmVzLmpzb24oKTonLCByZXMuanNvbigpKTsgLy8gT2JqZWN0IHtuYW1lOiBcIkplZmZcIn1cbiAgICAgKiBjb25zb2xlLmxvZygncmVzLnVybDonLCByZXMudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICogYGBgXG4gICAgICovXG4gICAgUmVzcG9uc2VPcHRpb25zLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VPcHRpb25zKHtcbiAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMgJiYgb3B0aW9ucy5ib2R5ICE9IG51bGwgPyBvcHRpb25zLmJvZHkgOiB0aGlzLmJvZHksXG4gICAgICAgICAgICBzdGF0dXM6IG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0dXMgIT0gbnVsbCA/IG9wdGlvbnMuc3RhdHVzIDogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycyAhPSBudWxsID8gb3B0aW9ucy5oZWFkZXJzIDogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogb3B0aW9ucyAmJiBvcHRpb25zLnN0YXR1c1RleHQgIT0gbnVsbCA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlICE9IG51bGwgPyBvcHRpb25zLnR5cGUgOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMgJiYgb3B0aW9ucy51cmwgIT0gbnVsbCA/IG9wdGlvbnMudXJsIDogdGhpcy51cmwsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3BvbnNlT3B0aW9ucztcbn0oKSk7XG4vKipcbiAqIFN1YmNsYXNzIG9mIHtAbGluayBSZXNwb25zZU9wdGlvbnN9LCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIERlZmF1bHQgdmFsdWVzOlxuICogICogc3RhdHVzOiAyMDBcbiAqICAqIGhlYWRlcnM6IGVtcHR5IHtAbGluayBIZWFkZXJzfSBvYmplY3RcbiAqXG4gKiBUaGlzIGNsYXNzIGNvdWxkIGJlIGV4dGVuZGVkIGFuZCBib3VuZCB0byB0aGUge0BsaW5rIFJlc3BvbnNlT3B0aW9uc30gY2xhc3NcbiAqIHdoZW4gY29uZmlndXJpbmcgYW4ge0BsaW5rIEluamVjdG9yfSwgaW4gb3JkZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogdXNlZCBieSB7QGxpbmsgSHR0cH0gdG8gY3JlYXRlIHtAbGluayBSZXNwb25zZSBSZXNwb25zZXN9LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7cHJvdmlkZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQge2Jvb3RzdHJhcH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9icm93c2VyJztcbiAqIGltcG9ydCB7SFRUUF9QUk9WSURFUlMsIEhlYWRlcnMsIEh0dHAsIEJhc2VSZXNwb25zZU9wdGlvbnMsIFJlc3BvbnNlT3B0aW9uc30gZnJvbVxuICogJ0Bhbmd1bGFyL2h0dHAnO1xuICogaW1wb3J0IHtBcHB9IGZyb20gJy4vbXlhcHAnO1xuICpcbiAqIGNsYXNzIE15T3B0aW9ucyBleHRlbmRzIEJhc2VSZXNwb25zZU9wdGlvbnMge1xuICogICBoZWFkZXJzOkhlYWRlcnMgPSBuZXcgSGVhZGVycyh7bmV0d29yazogJ2dpdGh1Yid9KTtcbiAqIH1cbiAqXG4gKiBib290c3RyYXAoQXBwLCBbSFRUUF9QUk9WSURFUlMsIHtwcm92aWRlOiBSZXNwb25zZU9wdGlvbnMsIHVzZUNsYXNzOiBNeU9wdGlvbnN9XSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgb3B0aW9ucyBjb3VsZCBhbHNvIGJlIGV4dGVuZGVkIHdoZW4gbWFudWFsbHkgY3JlYXRpbmcgYSB7QGxpbmsgUmVzcG9uc2V9XG4gKiBvYmplY3QuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7QmFzZVJlc3BvbnNlT3B0aW9ucywgUmVzcG9uc2V9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIHZhciBvcHRpb25zID0gbmV3IEJhc2VSZXNwb25zZU9wdGlvbnMoKTtcbiAqIHZhciByZXMgPSBuZXcgUmVzcG9uc2Uob3B0aW9ucy5tZXJnZSh7XG4gKiAgIGJvZHk6ICdBbmd1bGFyJyxcbiAqICAgaGVhZGVyczogbmV3IEhlYWRlcnMoe2ZyYW1ld29yazogJ2FuZ3VsYXInfSlcbiAqIH0pKTtcbiAqIGNvbnNvbGUubG9nKCdyZXMuaGVhZGVycy5nZXQoXCJmcmFtZXdvcmtcIik6JywgcmVzLmhlYWRlcnMuZ2V0KCdmcmFtZXdvcmsnKSk7IC8vIGFuZ3VsYXJcbiAqIGNvbnNvbGUubG9nKCdyZXMudGV4dCgpOicsIHJlcy50ZXh0KCkpOyAvLyBBbmd1bGFyO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBCYXNlUmVzcG9uc2VPcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlUmVzcG9uc2VPcHRpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VSZXNwb25zZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7IHN0YXR1czogMjAwLCBzdGF0dXNUZXh0OiAnT2snLCB0eXBlOiBSZXNwb25zZVR5cGUuRGVmYXVsdCwgaGVhZGVyczogbmV3IEhlYWRlcnMoKSB9KSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlUmVzcG9uc2VPcHRpb25zID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuICAgIF0sIEJhc2VSZXNwb25zZU9wdGlvbnMpO1xuICAgIHJldHVybiBCYXNlUmVzcG9uc2VPcHRpb25zO1xufShSZXNwb25zZU9wdGlvbnMpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIHJlYWwgYmFja2VuZHMgYXJlIGRlcml2ZWQuXG4gKlxuICogVGhlIHByaW1hcnkgcHVycG9zZSBvZiBhIGBDb25uZWN0aW9uQmFja2VuZGAgaXMgdG8gY3JlYXRlIG5ldyBjb25uZWN0aW9ucyB0byBmdWxmaWxsIGEgZ2l2ZW5cbiAqIHtAbGluayBSZXF1ZXN0fS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENvbm5lY3Rpb25CYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25CYWNrZW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvbkJhY2tlbmQ7XG59KCkpO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIHJlYWwgY29ubmVjdGlvbnMgYXJlIGRlcml2ZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb24oKSB7XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uO1xufSgpKTtcbi8qKlxuICogQW4gWFNSRlN0cmF0ZWd5IGNvbmZpZ3VyZXMgWFNSRiBwcm90ZWN0aW9uIChlLmcuIHZpYSBoZWFkZXJzKSBvbiBhbiBIVFRQIHJlcXVlc3QuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBYU1JGU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWFNSRlN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICByZXR1cm4gWFNSRlN0cmF0ZWd5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kTmFtZShtZXRob2QpIHtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgc3dpdGNoIChtZXRob2QudG9VcHBlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RNZXRob2QuR2V0O1xuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0TWV0aG9kLlBvc3Q7XG4gICAgICAgIGNhc2UgJ1BVVCc6XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdE1ldGhvZC5QdXQ7XG4gICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdE1ldGhvZC5EZWxldGU7XG4gICAgICAgIGNhc2UgJ09QVElPTlMnOlxuICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RNZXRob2QuT3B0aW9ucztcbiAgICAgICAgY2FzZSAnSEVBRCc6XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdE1ldGhvZC5IZWFkO1xuICAgICAgICBjYXNlICdQQVRDSCc6XG4gICAgICAgICAgICByZXR1cm4gUmVxdWVzdE1ldGhvZC5QYXRjaDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXF1ZXN0IG1ldGhvZC4gVGhlIG1ldGhvZCBcXFwiXCIgKyBtZXRob2QgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG59XG52YXIgaXNTdWNjZXNzID0gZnVuY3Rpb24gKHN0YXR1cykgeyByZXR1cm4gKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKTsgfTtcbmZ1bmN0aW9uIGdldFJlc3BvbnNlVVJMKHhocikge1xuICAgIGlmICgncmVzcG9uc2VVUkwnIGluIHhocikge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVVJMO1xuICAgIH1cbiAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUJ1ZmZlcihpbnB1dCkge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIHN0ckxlbiA9IGlucHV0Lmxlbmd0aDsgaSA8IHN0ckxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5idWZmZXI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHBhcmFtUGFyc2VyKHJhd1BhcmFtcykge1xuICAgIGlmIChyYXdQYXJhbXMgPT09IHZvaWQgMCkgeyByYXdQYXJhbXMgPSAnJzsgfVxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHJhd1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSByYXdQYXJhbXMuc3BsaXQoJyYnKTtcbiAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgZXFJZHggPSBwYXJhbS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZXFJZHggPT0gLTEgPyBbcGFyYW0sICcnXSA6IFtwYXJhbS5zbGljZSgwLCBlcUlkeCksIHBhcmFtLnNsaWNlKGVxSWR4ICsgMSldLCAyKSwga2V5ID0gX2FbMF0sIHZhbCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBtYXAuZ2V0KGtleSkgfHwgW107XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICoqL1xudmFyIFF1ZXJ5RW5jb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeUVuY29kZXIoKSB7XG4gICAgfVxuICAgIFF1ZXJ5RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc3RhbmRhcmRFbmNvZGluZyhrZXkpOyB9O1xuICAgIFF1ZXJ5RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHN0YW5kYXJkRW5jb2RpbmcodmFsdWUpOyB9O1xuICAgIHJldHVybiBRdWVyeUVuY29kZXI7XG59KCkpO1xuZnVuY3Rpb24gc3RhbmRhcmRFbmNvZGluZyh2KSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2KVxuICAgICAgICAucmVwbGFjZSgvJTQwL2dpLCAnQCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgLnJlcGxhY2UoLyUyNC9naSwgJyQnKVxuICAgICAgICAucmVwbGFjZSgvJTJDL2dpLCAnLCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0IvZ2ksICc7JylcbiAgICAgICAgLnJlcGxhY2UoLyUyQi9naSwgJysnKVxuICAgICAgICAucmVwbGFjZSgvJTNEL2dpLCAnPScpXG4gICAgICAgIC5yZXBsYWNlKC8lM0YvZ2ksICc/JylcbiAgICAgICAgLnJlcGxhY2UoLyUyRi9naSwgJy8nKTtcbn1cbi8qKlxuICogTWFwLWxpa2UgcmVwcmVzZW50YXRpb24gb2YgdXJsIHNlYXJjaCBwYXJhbWV0ZXJzLCBiYXNlZCBvblxuICogW1VSTFNlYXJjaFBhcmFtc10oaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMpIGluIHRoZSB1cmwgbGl2aW5nIHN0YW5kYXJkLFxuICogd2l0aCBzZXZlcmFsIGV4dGVuc2lvbnMgZm9yIG1lcmdpbmcgVVJMU2VhcmNoUGFyYW1zIG9iamVjdHM6XG4gKiAgIC0gc2V0QWxsKClcbiAqICAgLSBhcHBlbmRBbGwoKVxuICogICAtIHJlcGxhY2VBbGwoKVxuICpcbiAqIFRoaXMgY2xhc3MgYWNjZXB0cyBhbiBvcHRpb25hbCBzZWNvbmQgcGFyYW1ldGVyIG9mICR7QGxpbmsgUXVlcnlFbmNvZGVyfSxcbiAqIHdoaWNoIGlzIHVzZWQgdG8gc2VyaWFsaXplIHBhcmFtZXRlcnMgYmVmb3JlIG1ha2luZyBhIHJlcXVlc3QuIEJ5IGRlZmF1bHQsXG4gKiBgUXVlcnlFbmNvZGVyYCBlbmNvZGVzIGtleXMgYW5kIHZhbHVlcyBvZiBwYXJhbWV0ZXJzIHVzaW5nIGBlbmNvZGVVUklDb21wb25lbnRgLFxuICogYW5kIHRoZW4gdW4tZW5jb2RlcyBjZXJ0YWluIGNoYXJhY3RlcnMgdGhhdCBhcmUgYWxsb3dlZCB0byBiZSBwYXJ0IG9mIHRoZSBxdWVyeVxuICogYWNjb3JkaW5nIHRvIElFVEYgUkZDIDM5ODY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxuICpcbiAqIFRoZXNlIGFyZSB0aGUgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgZW5jb2RlZDogYCEgJCBcXCcgKCApICogKyAsIDsgQSA5IC0gLiBfIH4gPyAvYFxuICpcbiAqIElmIHRoZSBzZXQgb2YgYWxsb3dlZCBxdWVyeSBjaGFyYWN0ZXJzIGlzIG5vdCBhY2NlcHRhYmxlIGZvciBhIHBhcnRpY3VsYXIgYmFja2VuZCxcbiAqIGBRdWVyeUVuY29kZXJgIGNhbiBiZSBzdWJjbGFzc2VkIGFuZCBwcm92aWRlZCBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIFVSTFNlYXJjaFBhcmFtcy5cbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7VVJMU2VhcmNoUGFyYW1zLCBRdWVyeUVuY29kZXJ9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICogY2xhc3MgTXlRdWVyeUVuY29kZXIgZXh0ZW5kcyBRdWVyeUVuY29kZXIge1xuICogICBlbmNvZGVLZXkoazogc3RyaW5nKTogc3RyaW5nIHtcbiAqICAgICByZXR1cm4gbXlFbmNvZGluZ0Z1bmN0aW9uKGspO1xuICogICB9XG4gKlxuICogICBlbmNvZGVWYWx1ZSh2OiBzdHJpbmcpOiBzdHJpbmcge1xuICogICAgIHJldHVybiBteUVuY29kaW5nRnVuY3Rpb24odik7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygnJywgbmV3IE15UXVlcnlFbmNvZGVyKCkpO1xuICogYGBgXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFVSTFNlYXJjaFBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMocmF3UGFyYW1zLCBxdWVyeUVuY29kZXIpIHtcbiAgICAgICAgaWYgKHJhd1BhcmFtcyA9PT0gdm9pZCAwKSB7IHJhd1BhcmFtcyA9ICcnOyB9XG4gICAgICAgIGlmIChxdWVyeUVuY29kZXIgPT09IHZvaWQgMCkgeyBxdWVyeUVuY29kZXIgPSBuZXcgUXVlcnlFbmNvZGVyKCk7IH1cbiAgICAgICAgdGhpcy5yYXdQYXJhbXMgPSByYXdQYXJhbXM7XG4gICAgICAgIHRoaXMucXVlcnlFbmNvZGVyID0gcXVlcnlFbmNvZGVyO1xuICAgICAgICB0aGlzLnBhcmFtc01hcCA9IHBhcmFtUGFyc2VyKHJhd1BhcmFtcyk7XG4gICAgfVxuICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoJycsIHRoaXMucXVlcnlFbmNvZGVyKTtcbiAgICAgICAgY2xvbmUuYXBwZW5kQWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gdGhpcy5wYXJhbXNNYXAuaGFzKHBhcmFtKTsgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgc3RvcmVkUGFyYW0gPSB0aGlzLnBhcmFtc01hcC5nZXQocGFyYW0pO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdG9yZWRQYXJhbSkgPyBzdG9yZWRQYXJhbVswXSA6IG51bGw7XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gdGhpcy5wYXJhbXNNYXAuZ2V0KHBhcmFtKSB8fCBbXTsgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHZvaWQgMCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgbGlzdC5wdXNoKHZhbCk7XG4gICAgICAgIHRoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgfTtcbiAgICAvLyBBIG1lcmdlIG9wZXJhdGlvblxuICAgIC8vIEZvciBlYWNoIG5hbWUtdmFsdWVzIHBhaXIgaW4gYHNlYXJjaFBhcmFtc2AsIHBlcmZvcm0gYHNldChuYW1lLCB2YWx1ZXNbMF0pYFxuICAgIC8vXG4gICAgLy8gRS5nOiBcImE9WzEsMiwzXSwgYz1bOF1cIiArIFwiYT1bNCw1LDZdLCBiPVs3XVwiID0gXCJhPVs0XSwgYz1bOF0sIGI9WzddXCJcbiAgICAvL1xuICAgIC8vIFRPRE8oQGNhaXRwKTogZG9jdW1lbnQgdGhpcyBiZXR0ZXJcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnNldEFsbCA9IGZ1bmN0aW9uIChzZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2VhcmNoUGFyYW1zLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gX3RoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsdWVbMF0pO1xuICAgICAgICAgICAgX3RoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAocGFyYW0sIHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSB2b2lkIDAgfHwgdmFsID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgIGxpc3QucHVzaCh2YWwpO1xuICAgICAgICB0aGlzLnBhcmFtc01hcC5zZXQocGFyYW0sIGxpc3QpO1xuICAgIH07XG4gICAgLy8gQSBtZXJnZSBvcGVyYXRpb25cbiAgICAvLyBGb3IgZWFjaCBuYW1lLXZhbHVlcyBwYWlyIGluIGBzZWFyY2hQYXJhbXNgLCBwZXJmb3JtIGBhcHBlbmQobmFtZSwgdmFsdWUpYFxuICAgIC8vIGZvciBlYWNoIHZhbHVlIGluIGB2YWx1ZXNgLlxuICAgIC8vXG4gICAgLy8gRS5nOiBcImE9WzEsMl0sIGM9WzhdXCIgKyBcImE9WzMsNF0sIGI9WzddXCIgPSBcImE9WzEsMiwzLDRdLCBjPVs4XSwgYj1bN11cIlxuICAgIC8vXG4gICAgLy8gVE9ETyhAY2FpdHApOiBkb2N1bWVudCB0aGlzIGJldHRlclxuICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuYXBwZW5kQWxsID0gZnVuY3Rpb24gKHNlYXJjaFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZWFyY2hQYXJhbXMucGFyYW1zTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwYXJhbSkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBfdGhpcy5wYXJhbXNNYXAuZ2V0KHBhcmFtKSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gQSBtZXJnZSBvcGVyYXRpb25cbiAgICAvLyBGb3IgZWFjaCBuYW1lLXZhbHVlcyBwYWlyIGluIGBzZWFyY2hQYXJhbXNgLCBwZXJmb3JtIGBkZWxldGUobmFtZSlgLFxuICAgIC8vIGZvbGxvd2VkIGJ5IGBzZXQobmFtZSwgdmFsdWVzKWBcbiAgICAvL1xuICAgIC8vIEUuZzogXCJhPVsxLDIsM10sIGM9WzhdXCIgKyBcImE9WzQsNSw2XSwgYj1bN11cIiA9IFwiYT1bNCw1LDZdLCBjPVs4XSwgYj1bN11cIlxuICAgIC8vXG4gICAgLy8gVE9ETyhAY2FpdHApOiBkb2N1bWVudCB0aGlzIGJldHRlclxuICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2VhcmNoUGFyYW1zLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gX3RoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnBhcmFtc01hcC5zZXQocGFyYW0sIGxpc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJhbXNMaXN0ID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgaykge1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBhcmFtc0xpc3QucHVzaChfdGhpcy5xdWVyeUVuY29kZXIuZW5jb2RlS2V5KGspICsgJz0nICsgX3RoaXMucXVlcnlFbmNvZGVyLmVuY29kZVZhbHVlKHYpKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1zTGlzdC5qb2luKCcmJyk7XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChwYXJhbSkgeyB0aGlzLnBhcmFtc01hcC5kZWxldGUocGFyYW0pOyB9O1xuICAgIHJldHVybiBVUkxTZWFyY2hQYXJhbXM7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEhUVFAgcmVxdWVzdCBib2R5IHVzZWQgYnkgYm90aCB7QGxpbmsgUmVxdWVzdH0gYW5kIHtAbGluayBSZXNwb25zZX1cbiAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKi9cbnZhciBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHJldHVybiBib2R5IGFzIHBhcnNlZCBgSlNPTmAgb2JqZWN0LCBvciByYWlzZXMgYW4gZXhjZXB0aW9uLlxuICAgICAqL1xuICAgIEJvZHkucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuX2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMudGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvZHkgYXMgYSBzdHJpbmcsIHByZXN1bWluZyBgdG9TdHJpbmcoKWAgY2FuIGJlIGNhbGxlZCBvbiB0aGUgcmVzcG9uc2UgYm9keS5cbiAgICAgKlxuICAgICAqIFdoZW4gZGVjb2RpbmcgYW4gYEFycmF5QnVmZmVyYCwgdGhlIG9wdGlvbmFsIGBlbmNvZGluZ0hpbnRgIHBhcmFtZXRlciBkZXRlcm1pbmVzIGhvdyB0aGVcbiAgICAgKiBieXRlcyBpbiB0aGUgYnVmZmVyIHdpbGwgYmUgaW50ZXJwcmV0ZWQuIFZhbGlkIHZhbHVlcyBhcmU6XG4gICAgICpcbiAgICAgKiAtIGBsZWdhY3lgIC0gaW5jb3JyZWN0bHkgaW50ZXJwcmV0IHRoZSBieXRlcyBhcyBVVEYtMTYgKHRlY2huaWNhbGx5LCBVQ1MtMikuIE9ubHkgY2hhcmFjdGVyc1xuICAgICAqICAgaW4gdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSBhcmUgc3VwcG9ydGVkLCBzdXJyb2dhdGUgcGFpcnMgYXJlIG5vdCBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICAgKiAgIEluIGFkZGl0aW9uLCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgMTYtYml0IG9jdGV0IHBhaXJzIGluIHRoZSBgQXJyYXlCdWZmZXJgIGlzIG5vdCB0YWtlblxuICAgICAqICAgaW50byBjb25zaWRlcmF0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHRvIGF2b2lkIGJyZWFraW5nIGFwcHMsIGJ1dCBzaG91bGQgYmVcbiAgICAgKiAgIGNvbnNpZGVyZWQgZGVwcmVjYXRlZC5cbiAgICAgKlxuICAgICAqIC0gYGlzby04ODU5YCAtIGludGVycHJldCB0aGUgYnl0ZXMgYXMgSVNPLTg4NTkgKHdoaWNoIGNhbiBiZSB1c2VkIGZvciBBU0NJSSBlbmNvZGVkIHRleHQpLlxuICAgICAqL1xuICAgIEJvZHkucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoZW5jb2RpbmdIaW50KSB7XG4gICAgICAgIGlmIChlbmNvZGluZ0hpbnQgPT09IHZvaWQgMCkgeyBlbmNvZGluZ0hpbnQgPSAnbGVnYWN5JzsgfVxuICAgICAgICBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nSGludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheSh0aGlzLl9ib2R5KSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnaXNvLTg4NTknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLl9ib2R5KSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgZW5jb2RpbmdIaW50OiBcIiArIGVuY29kaW5nSGludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9ib2R5LCBudWxsLCAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYm9keS50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBib2R5IGFzIGFuIEFycmF5QnVmZmVyXG4gICAgICovXG4gICAgQm9keS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5QnVmZmVyKHRoaXMudGV4dCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIHRoZSByZXF1ZXN0J3MgYm9keSBhcyBhIEJsb2IsIGFzc3VtaW5nIHRoYXQgYm9keSBleGlzdHMuXG4gICAgICAqL1xuICAgIEJvZHkucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt0aGlzLl9ib2R5XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVxdWVzdCBib2R5IGlzblxcJ3QgZWl0aGVyIGEgYmxvYiBvciBhbiBhcnJheSBidWZmZXInKTtcbiAgICB9O1xuICAgIHJldHVybiBCb2R5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGBSZXNwb25zZWAgaW5zdGFuY2VzIGZyb20gcHJvdmlkZWQgdmFsdWVzLlxuICpcbiAqIFRob3VnaCB0aGlzIG9iamVjdCBpc24ndFxuICogdXN1YWxseSBpbnN0YW50aWF0ZWQgYnkgZW5kLXVzZXJzLCBpdCBpcyB0aGUgcHJpbWFyeSBvYmplY3QgaW50ZXJhY3RlZCB3aXRoIHdoZW4gaXQgY29tZXMgdGltZSB0b1xuICogYWRkIGRhdGEgdG8gYSB2aWV3LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogaHR0cC5yZXF1ZXN0KCdteS1mcmllbmRzLnR4dCcpLnN1YnNjcmliZShyZXNwb25zZSA9PiB0aGlzLmZyaWVuZHMgPSByZXNwb25zZS50ZXh0KCkpO1xuICogYGBgXG4gKlxuICogVGhlIFJlc3BvbnNlJ3MgaW50ZXJmYWNlIGlzIGluc3BpcmVkIGJ5IHRoZSBSZXNwb25zZSBjb25zdHJ1Y3RvciBkZWZpbmVkIGluIHRoZSBbRmV0Y2hcbiAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzcyksIGJ1dCBpcyBjb25zaWRlcmVkIGEgc3RhdGljIHZhbHVlIHdob3NlIGJvZHlcbiAqIGNhbiBiZSBhY2Nlc3NlZCBtYW55IHRpbWVzLiBUaGVyZSBhcmUgb3RoZXIgZGlmZmVyZW5jZXMgaW4gdGhlIGltcGxlbWVudGF0aW9uLCBidXQgdGhpcyBpcyB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZXNwb25zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9ib2R5ID0gcmVzcG9uc2VPcHRpb25zLmJvZHk7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IHJlc3BvbnNlT3B0aW9ucy5zdGF0dXM7XG4gICAgICAgIF90aGlzLm9rID0gKF90aGlzLnN0YXR1cyA+PSAyMDAgJiYgX3RoaXMuc3RhdHVzIDw9IDI5OSk7XG4gICAgICAgIF90aGlzLnN0YXR1c1RleHQgPSByZXNwb25zZU9wdGlvbnMuc3RhdHVzVGV4dDtcbiAgICAgICAgX3RoaXMuaGVhZGVycyA9IHJlc3BvbnNlT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBfdGhpcy50eXBlID0gcmVzcG9uc2VPcHRpb25zLnR5cGU7XG4gICAgICAgIF90aGlzLnVybCA9IHJlc3BvbnNlT3B0aW9ucy51cmw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzcG9uc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNwb25zZSB3aXRoIHN0YXR1czogXCIgKyB0aGlzLnN0YXR1cyArIFwiIFwiICsgdGhpcy5zdGF0dXNUZXh0ICsgXCIgZm9yIFVSTDogXCIgKyB0aGlzLnVybDtcbiAgICB9O1xuICAgIHJldHVybiBSZXNwb25zZTtcbn0oQm9keSkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX25leHRSZXF1ZXN0SWQgPSAwO1xudmFyIEpTT05QX0hPTUUgPSAnX19uZ19qc29ucF9fJztcbnZhciBfanNvbnBDb25uZWN0aW9ucyA9IG51bGw7XG5mdW5jdGlvbiBfZ2V0SnNvbnBDb25uZWN0aW9ucygpIHtcbiAgICB2YXIgdyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgPyB3aW5kb3cgOiB7fTtcbiAgICBpZiAoX2pzb25wQ29ubmVjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgX2pzb25wQ29ubmVjdGlvbnMgPSB3W0pTT05QX0hPTUVdID0ge307XG4gICAgfVxuICAgIHJldHVybiBfanNvbnBDb25uZWN0aW9ucztcbn1cbi8vIE1ha2Ugc3VyZSBub3QgdG8gZXZhbHVhdGUgdGhpcyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IVxudmFyIEJyb3dzZXJKc29ucCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySnNvbnAoKSB7XG4gICAgfVxuICAgIC8vIENvbnN0cnVjdCBhIDxzY3JpcHQ+IGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIFVSTFxuICAgIEJyb3dzZXJKc29ucC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIG5vZGUuc3JjID0gdXJsO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIEJyb3dzZXJKc29ucC5wcm90b3R5cGUubmV4dFJlcXVlc3RJRCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiX19yZXFcIiArIF9uZXh0UmVxdWVzdElkKys7IH07XG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5yZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIEpTT05QX0hPTUUgKyBcIi5cIiArIGlkICsgXCIuZmluaXNoZWRcIjsgfTtcbiAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLmV4cG9zZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoaWQsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gX2dldEpzb25wQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgY29ubmVjdGlvbnNbaWRdID0gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIEJyb3dzZXJKc29ucC5wcm90b3R5cGUucmVtb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbnMgPSBfZ2V0SnNvbnBDb25uZWN0aW9ucygpO1xuICAgICAgICBjb25uZWN0aW9uc1tpZF0gPSBudWxsO1xuICAgIH07XG4gICAgLy8gQXR0YWNoIHRoZSA8c2NyaXB0PiBlbGVtZW50IHRvIHRoZSBET01cbiAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobm9kZSkgeyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKChub2RlKSk7IH07XG4gICAgLy8gUmVtb3ZlIDxzY3JpcHQ+IGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKChub2RlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJyb3dzZXJKc29ucCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKClcbiAgICBdLCBCcm93c2VySnNvbnApO1xuICAgIHJldHVybiBCcm93c2VySnNvbnA7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSlNPTlBfRVJSX05PX0NBTExCQUNLID0gJ0pTT05QIGluamVjdGVkIHNjcmlwdCBkaWQgbm90IGludm9rZSBjYWxsYmFjay4nO1xudmFyIEpTT05QX0VSUl9XUk9OR19NRVRIT0QgPSAnSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgR0VUIHJlcXVlc3QgbWV0aG9kLic7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFuIGluLWZsaWdodCBKU09OUCByZXF1ZXN0LlxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSlNPTlBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBKU09OUENvbm5lY3Rpb24ocmVxLCBfZG9tLCBiYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuYmFzZVJlc3BvbnNlT3B0aW9ucyA9IGJhc2VSZXNwb25zZU9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXEubWV0aG9kICE9PSBSZXF1ZXN0TWV0aG9kLkdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihKU09OUF9FUlJfV1JPTkdfTUVUSE9EKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuTG9hZGluZztcbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLl9pZCA9IF9kb20ubmV4dFJlcXVlc3RJRCgpO1xuICAgICAgICAgICAgX2RvbS5leHBvc2VDb25uZWN0aW9uKGlkLCBfdGhpcyk7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIERhcnRcbiAgICAgICAgICAgIC8vIHVybCA9IHVybC5yZXBsYWNlKC89SlNPTlBfQ0FMTEJBQ0soJnwkKS8sIGBnZW5lcmF0ZWQgbWV0aG9kYCk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfZG9tLnJlcXVlc3RDYWxsYmFjayhfdGhpcy5faWQpO1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlcS51cmw7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJz1KU09OUF9DQUxMQkFDSyYnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJz1KU09OUF9DQUxMQkFDSyYnLCBcIj1cIiArIGNhbGxiYWNrICsgXCImXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXJsLmxhc3RJbmRleE9mKCc9SlNPTlBfQ0FMTEJBQ0snKSA9PT0gdXJsLmxlbmd0aCAtICc9SlNPTlBfQ0FMTEJBQ0snLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtICc9SlNPTlBfQ0FMTEJBQ0snLmxlbmd0aCkgKyAoXCI9XCIgKyBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gX3RoaXMuX3NjcmlwdCA9IF9kb20uYnVpbGQodXJsKTtcbiAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVhZHlTdGF0ZSA9PT0gUmVhZHlTdGF0ZS5DYW5jZWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5Eb25lO1xuICAgICAgICAgICAgICAgIF9kb20uY2xlYW51cChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnNfMSA9IG5ldyBSZXNwb25zZU9wdGlvbnMoeyBib2R5OiBKU09OUF9FUlJfTk9fQ0FMTEJBQ0ssIHR5cGU6IFJlc3BvbnNlVHlwZS5FcnJvciwgdXJsOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnNfMSA9IGJhc2VSZXNwb25zZU9wdGlvbnMubWVyZ2UocmVzcG9uc2VPcHRpb25zXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIuZXJyb3IobmV3IFJlc3BvbnNlKHJlc3BvbnNlT3B0aW9uc18xKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBSZXNwb25zZU9wdGlvbnMoeyBib2R5OiBfdGhpcy5fcmVzcG9uc2VEYXRhLCB1cmw6IHVybCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBfdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIubmV4dChuZXcgUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWR5U3RhdGUgPT09IFJlYWR5U3RhdGUuQ2FuY2VsbGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuRG9uZTtcbiAgICAgICAgICAgICAgICBfZG9tLmNsZWFudXAoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VPcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7IGJvZHk6IGVycm9yLm1lc3NhZ2UsIHR5cGU6IFJlc3BvbnNlVHlwZS5FcnJvciB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIuZXJyb3IobmV3IFJlc3BvbnNlKHJlc3BvbnNlT3B0aW9ucykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgX2RvbS5zZW5kKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLkNhbmNlbGxlZDtcbiAgICAgICAgICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2RvbS5jbGVhbnVwKHNjcmlwdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIEpTT05QIHJlcXVlc3QgY29tcGxldGVzLCB0byBub3RpZnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogb2YgdGhlIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIEpTT05QQ29ubmVjdGlvbi5wcm90b3R5cGUuZmluaXNoZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBEb24ndCBsZWFrIGNvbm5lY3Rpb25zXG4gICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZG9tLnJlbW92ZUNvbm5lY3Rpb24odGhpcy5faWQpO1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBSZWFkeVN0YXRlLkNhbmNlbGxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VEYXRhID0gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OUENvbm5lY3Rpb247XG59KCkpO1xuLyoqXG4gKiBBIHtAbGluayBDb25uZWN0aW9uQmFja2VuZH0gdGhhdCB1c2VzIHRoZSBKU09OUCBzdHJhdGVneSBvZiBtYWtpbmcgcmVxdWVzdHMuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBKU09OUEJhY2tlbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05QQmFja2VuZCwgX3N1cGVyKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gSlNPTlBCYWNrZW5kKF9icm93c2VySlNPTlAsIF9iYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9icm93c2VySlNPTlAgPSBfYnJvd3NlckpTT05QO1xuICAgICAgICBfdGhpcy5fYmFzZVJlc3BvbnNlT3B0aW9ucyA9IF9iYXNlUmVzcG9uc2VPcHRpb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEpTT05QQmFja2VuZC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSlNPTlBDb25uZWN0aW9uKHJlcXVlc3QsIHRoaXMuX2Jyb3dzZXJKU09OUCwgdGhpcy5fYmFzZVJlc3BvbnNlT3B0aW9ucyk7XG4gICAgfTtcbiAgICBKU09OUEJhY2tlbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jyb3dzZXJKc29ucCwgUmVzcG9uc2VPcHRpb25zXSlcbiAgICBdLCBKU09OUEJhY2tlbmQpO1xuICAgIHJldHVybiBKU09OUEJhY2tlbmQ7XG59KENvbm5lY3Rpb25CYWNrZW5kKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYU1NJX1BSRUZJWCA9IC9eXFwpXFxdXFx9Jyw/XFxuLztcbi8qKlxuICogQ3JlYXRlcyBjb25uZWN0aW9ucyB1c2luZyBgWE1MSHR0cFJlcXVlc3RgLiBHaXZlbiBhIGZ1bGx5LXF1YWxpZmllZFxuICogcmVxdWVzdCwgYW4gYFhIUkNvbm5lY3Rpb25gIHdpbGwgaW1tZWRpYXRlbHkgY3JlYXRlIGFuIGBYTUxIdHRwUmVxdWVzdGAgb2JqZWN0IGFuZCBzZW5kIHRoZVxuICogcmVxdWVzdC5cbiAqXG4gKiBUaGlzIGNsYXNzIHdvdWxkIHR5cGljYWxseSBub3QgYmUgY3JlYXRlZCBvciBpbnRlcmFjdGVkIHdpdGggZGlyZWN0bHkgaW5zaWRlIGFwcGxpY2F0aW9ucywgdGhvdWdoXG4gKiB0aGUge0BsaW5rIE1vY2tDb25uZWN0aW9ufSBtYXkgYmUgaW50ZXJhY3RlZCB3aXRoIGluIHRlc3RzLlxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgWEhSQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYSFJDb25uZWN0aW9uKHJlcSwgYnJvd3NlclhIUiwgYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIF94aHIgPSBicm93c2VyWEhSLmJ1aWxkKCk7XG4gICAgICAgICAgICBfeGhyLm9wZW4oUmVxdWVzdE1ldGhvZFtyZXEubWV0aG9kXS50b1VwcGVyQ2FzZSgpLCByZXEudXJsKTtcbiAgICAgICAgICAgIGlmIChyZXEud2l0aENyZWRlbnRpYWxzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfeGhyLndpdGhDcmVkZW50aWFscyA9IHJlcS53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb2FkIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF94aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogX3hoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEhUVFAgMjA0IG1lYW5zIG5vIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFJlc291cmNlTG9hZGVyIExldmVsMiBzcGVjXG4gICAgICAgICAgICAgICAgICAgIC8vIChzdXBwb3J0ZWQgYnkgSUUxMClcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9ICh0eXBlb2YgX3hoci5yZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpID8gX3hoci5yZXNwb25zZVRleHQgOiBfeGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbXBsaWNpdGx5IHN0cmlwIGEgcG90ZW50aWFsIFhTU0kgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKFhTU0lfUFJFRklYLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIHdoZW4gaXQgaXMgMCAoMCBzdGF0dXMgaXMgdW5kb2N1bWVudGVkKS5cbiAgICAgICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGJvZHkgPyAyMDAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IEhlYWRlcnMuZnJvbVJlc3BvbnNlSGVhZGVyU3RyaW5nKF94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgIC8vIElFIDkgZG9lcyBub3QgcHJvdmlkZSB0aGUgd2F5IHRvIGdldCBVUkwgb2YgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gZ2V0UmVzcG9uc2VVUkwoX3hocikgfHwgcmVxLnVybDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzVGV4dCA9IF94aHIuc3RhdHVzVGV4dCB8fCAnT0snO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSBuZXcgUmVzcG9uc2VPcHRpb25zKHsgYm9keTogYm9keSwgc3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IGhlYWRlcnMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zID0gYmFzZVJlc3BvbnNlT3B0aW9ucy5tZXJnZShyZXNwb25zZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vayA9IGlzU3VjY2VzcyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGdkaTIyOTApOiBkZWZlciBjb21wbGV0ZSBpZiBhcnJheSBidWZmZXIgdW50aWwgZG9uZVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXJyb3IgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBSZXNwb25zZU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBlcnIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlc3BvbnNlVHlwZS5FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogX3hoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zID0gYmFzZVJlc3BvbnNlT3B0aW9ucy5tZXJnZShyZXNwb25zZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmVycm9yKG5ldyBSZXNwb25zZShyZXNwb25zZU9wdGlvbnMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zZXREZXRlY3RlZENvbnRlbnRUeXBlKHJlcSwgX3hocik7XG4gICAgICAgICAgICBpZiAocmVxLmhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcS5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVxLmhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuICAgICAgICAgICAgICAgIHJlcS5oZWFkZXJzLmFwcGVuZCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBuYW1lKSB7IHJldHVybiBfeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWVzLmpvaW4oJywnKSk7IH0pO1xuICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBjb3JyZWN0IGJ1ZmZlciB0eXBlIHRvIHN0b3JlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUgIT0gbnVsbCAmJiBfeGhyLnJlc3BvbnNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChyZXEucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmVzcG9uc2VDb250ZW50VHlwZS5BcnJheUJ1ZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlQ29udGVudFR5cGUuSnNvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmVzcG9uc2VDb250ZW50VHlwZS5UZXh0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3hoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZUNvbnRlbnRUeXBlLkJsb2I6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VsZWN0ZWQgcmVzcG9uc2VUeXBlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgX3hoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgX3hoci5zZW5kKF90aGlzLnJlcXVlc3QuZ2V0Qm9keSgpKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICBfeGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgX3hoci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFhIUkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldERldGVjdGVkQ29udGVudFR5cGUgPSBmdW5jdGlvbiAocmVxIC8qKiBUT0RPIFJlcXVlc3QgKi8sIF94aHIgLyoqIFhNTEh0dHBSZXF1ZXN0ICovKSB7XG4gICAgICAgIC8vIFNraXAgaWYgYSBjdXN0b20gQ29udGVudC1UeXBlIGhlYWRlciBpcyBwcm92aWRlZFxuICAgICAgICBpZiAocmVxLmhlYWRlcnMgIT0gbnVsbCAmJiByZXEuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGRldGVjdGVkIGNvbnRlbnQgdHlwZVxuICAgICAgICBzd2l0Y2ggKHJlcS5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5OT05FOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5KU09OOlxuICAgICAgICAgICAgICAgIF94aHIuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuRk9STTpcbiAgICAgICAgICAgICAgICBfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5URVhUOlxuICAgICAgICAgICAgICAgIF94aHIuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuQkxPQjpcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IHJlcS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2IudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGJsb2IudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gWEhSQ29ubmVjdGlvbjtcbn0oKSk7XG4vKipcbiAqIGBYU1JGQ29uZmlndXJhdGlvbmAgc2V0cyB1cCBDcm9zcyBTaXRlIFJlcXVlc3QgRm9yZ2VyeSAoWFNSRikgcHJvdGVjdGlvbiBmb3IgdGhlIGFwcGxpY2F0aW9uXG4gKiB1c2luZyBhIGNvb2tpZS4gU2VlIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvQ3Jvc3MtU2l0ZV9SZXF1ZXN0X0ZvcmdlcnlfKENTUkYpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBYU1JGLlxuICpcbiAqIEFwcGxpY2F0aW9ucyBjYW4gY29uZmlndXJlIGN1c3RvbSBjb29raWUgYW5kIGhlYWRlciBuYW1lcyBieSBiaW5kaW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAqIHdpdGggZGlmZmVyZW50IGBjb29raWVOYW1lYCBhbmQgYGhlYWRlck5hbWVgIHZhbHVlcy4gU2VlIHRoZSBtYWluIEhUVFAgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENvb2tpZVhTUkZTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb29raWVYU1JGU3RyYXRlZ3koX2Nvb2tpZU5hbWUsIF9oZWFkZXJOYW1lKSB7XG4gICAgICAgIGlmIChfY29va2llTmFtZSA9PT0gdm9pZCAwKSB7IF9jb29raWVOYW1lID0gJ1hTUkYtVE9LRU4nOyB9XG4gICAgICAgIGlmIChfaGVhZGVyTmFtZSA9PT0gdm9pZCAwKSB7IF9oZWFkZXJOYW1lID0gJ1gtWFNSRi1UT0tFTic7IH1cbiAgICAgICAgdGhpcy5fY29va2llTmFtZSA9IF9jb29raWVOYW1lO1xuICAgICAgICB0aGlzLl9oZWFkZXJOYW1lID0gX2hlYWRlck5hbWU7XG4gICAgfVxuICAgIENvb2tpZVhTUkZTdHJhdGVneS5wcm90b3R5cGUuY29uZmlndXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgdmFyIHhzcmZUb2tlbiA9IMm1Z2V0RE9NKCkuZ2V0Q29va2llKHRoaXMuX2Nvb2tpZU5hbWUpO1xuICAgICAgICBpZiAoeHNyZlRva2VuKSB7XG4gICAgICAgICAgICByZXEuaGVhZGVycy5zZXQodGhpcy5faGVhZGVyTmFtZSwgeHNyZlRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvb2tpZVhTUkZTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIENyZWF0ZXMge0BsaW5rIFhIUkNvbm5lY3Rpb259IGluc3RhbmNlcy5cbiAqXG4gKiBUaGlzIGNsYXNzIHdvdWxkIHR5cGljYWxseSBub3QgYmUgdXNlZCBieSBlbmQgdXNlcnMsIGJ1dCBjb3VsZCBiZVxuICogb3ZlcnJpZGRlbiBpZiBhIGRpZmZlcmVudCBiYWNrZW5kIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSB1c2VkLFxuICogc3VjaCBhcyBpbiBhIG5vZGUgYmFja2VuZC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7SHR0cCwgTXlOb2RlQmFja2VuZCwgSFRUUF9QUk9WSURFUlMsIEJhc2VSZXF1ZXN0T3B0aW9uc30gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG4gKiBAQ29tcG9uZW50KHtcbiAqICAgdmlld1Byb3ZpZGVyczogW1xuICogICAgIEhUVFBfUFJPVklERVJTLFxuICogICAgIHtwcm92aWRlOiBIdHRwLCB1c2VGYWN0b3J5OiAoYmFja2VuZCwgb3B0aW9ucykgPT4ge1xuICogICAgICAgcmV0dXJuIG5ldyBIdHRwKGJhY2tlbmQsIG9wdGlvbnMpO1xuICogICAgIH0sIGRlcHM6IFtNeU5vZGVCYWNrZW5kLCBCYXNlUmVxdWVzdE9wdGlvbnNdfV1cbiAqIH0pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIGNvbnN0cnVjdG9yKGh0dHA6SHR0cCkge1xuICogICAgIGh0dHAucmVxdWVzdCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUocmVzID0+IHRoaXMucGVvcGxlID0gcmVzLmpzb24oKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBYSFJCYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhIUkJhY2tlbmQoX2Jyb3dzZXJYSFIsIF9iYXNlUmVzcG9uc2VPcHRpb25zLCBfeHNyZlN0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuX2Jyb3dzZXJYSFIgPSBfYnJvd3NlclhIUjtcbiAgICAgICAgdGhpcy5fYmFzZVJlc3BvbnNlT3B0aW9ucyA9IF9iYXNlUmVzcG9uc2VPcHRpb25zO1xuICAgICAgICB0aGlzLl94c3JmU3RyYXRlZ3kgPSBfeHNyZlN0cmF0ZWd5O1xuICAgIH1cbiAgICBYSFJCYWNrZW5kLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5feHNyZlN0cmF0ZWd5LmNvbmZpZ3VyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBuZXcgWEhSQ29ubmVjdGlvbihyZXF1ZXN0LCB0aGlzLl9icm93c2VyWEhSLCB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zKTtcbiAgICB9O1xuICAgIFhIUkJhY2tlbmQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jyb3dzZXJYaHIsIFJlc3BvbnNlT3B0aW9ucyxcbiAgICAgICAgICAgIFhTUkZTdHJhdGVneV0pXG4gICAgXSwgWEhSQmFja2VuZCk7XG4gICAgcmV0dXJuIFhIUkJhY2tlbmQ7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0IG9wdGlvbnMgb2JqZWN0IHRvIGJlIG9wdGlvbmFsbHkgcHJvdmlkZWQgd2hlbiBpbnN0YW50aWF0aW5nIGFcbiAqIHtAbGluayBSZXF1ZXN0fS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGJhc2VkIG9uIHRoZSBgUmVxdWVzdEluaXRgIGRlc2NyaXB0aW9uIGluIHRoZSBbRmV0Y2hcbiAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdCkuXG4gKlxuICogQWxsIHZhbHVlcyBhcmUgbnVsbCBieSBkZWZhdWx0LiBUeXBpY2FsIGRlZmF1bHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUge0BsaW5rIEJhc2VSZXF1ZXN0T3B0aW9uc31cbiAqIGNsYXNzLCB3aGljaCBzdWItY2xhc3NlcyBgUmVxdWVzdE9wdGlvbnNgLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7UmVxdWVzdE9wdGlvbnMsIFJlcXVlc3QsIFJlcXVlc3RNZXRob2R9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIGNvbnN0IG9wdGlvbnMgPSBuZXcgUmVxdWVzdE9wdGlvbnMoe1xuICogICBtZXRob2Q6IFJlcXVlc3RNZXRob2QuUG9zdCxcbiAqICAgdXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICogfSk7XG4gKiBjb25zdCByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zKTtcbiAqIGNvbnNvbGUubG9nKCdyZXEubWV0aG9kOicsIFJlcXVlc3RNZXRob2RbcmVxLm1ldGhvZF0pOyAvLyBQb3N0XG4gKiBjb25zb2xlLmxvZygnb3B0aW9ucy51cmw6Jywgb3B0aW9ucy51cmwpOyAvLyBodHRwczovL2dvb2dsZS5jb21cbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUmVxdWVzdE9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhEem1pdHJ5KTogcmVtb3ZlIHNlYXJjaCB3aGVuIHRoaXMuc2VhcmNoIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBSZXF1ZXN0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRzLm1ldGhvZCwgaGVhZGVycyA9IG9wdHMuaGVhZGVycywgYm9keSA9IG9wdHMuYm9keSwgdXJsID0gb3B0cy51cmwsIHNlYXJjaCA9IG9wdHMuc2VhcmNoLCBwYXJhbXMgPSBvcHRzLnBhcmFtcywgd2l0aENyZWRlbnRpYWxzID0gb3B0cy53aXRoQ3JlZGVudGlhbHMsIHJlc3BvbnNlVHlwZSA9IG9wdHMucmVzcG9uc2VUeXBlO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZCAhPSBudWxsID8gbm9ybWFsaXplTWV0aG9kTmFtZShtZXRob2QpIDogbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IG51bGw7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHkgIT0gbnVsbCA/IGJvZHkgOiBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IHVybCAhPSBudWxsID8gdXJsIDogbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9tZXJnZVNlYXJjaFBhcmFtcyhwYXJhbXMgfHwgc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgIT0gbnVsbCA/IHdpdGhDcmVkZW50aWFscyA6IG51bGw7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlICE9IG51bGwgPyByZXNwb25zZVR5cGUgOiBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWVzdE9wdGlvbnMucHJvdG90eXBlLCBcInNlYXJjaFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBmcm9tIDQuMC4wLiBVc2UgcGFyYW1zIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyYW1zOyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgZnJvbSA0LjAuMC4gVXNlIHBhcmFtcyBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFyYW1zKSB7IHRoaXMucGFyYW1zID0gcGFyYW1zOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYFJlcXVlc3RPcHRpb25zYCBpbnN0YW5jZSwgdXNpbmcgdGhlIG9wdGlvbmFsIGlucHV0IGFzIHZhbHVlcyB0byBvdmVycmlkZVxuICAgICAqIGV4aXN0aW5nIHZhbHVlcy4gVGhpcyBtZXRob2Qgd2lsbCBub3QgY2hhbmdlIHRoZSB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlIG9uIHdoaWNoIGl0IGlzIGJlaW5nXG4gICAgICogY2FsbGVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGBoZWFkZXJzYCBhbmQgYHNlYXJjaGAgd2lsbCBvdmVycmlkZSBleGlzdGluZyB2YWx1ZXMgY29tcGxldGVseSBpZiBwcmVzZW50IGluXG4gICAgICogdGhlIGBvcHRpb25zYCBvYmplY3QuIElmIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgbWVyZ2VkLCBpdCBzaG91bGQgYmUgZG9uZSBwcmlvciB0byBjYWxsaW5nXG4gICAgICogYG1lcmdlYCBvbiB0aGUgYFJlcXVlc3RPcHRpb25zYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQge1JlcXVlc3RPcHRpb25zLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIGNvbnN0IG9wdGlvbnMgPSBuZXcgUmVxdWVzdE9wdGlvbnMoe1xuICAgICAqICAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kLlBvc3RcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zdCByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zLm1lcmdlKHtcbiAgICAgKiAgIHVybDogJ2h0dHBzOi8vZ29vZ2xlLmNvbSdcbiAgICAgKiB9KSk7XG4gICAgICogY29uc29sZS5sb2coJ3JlcS5tZXRob2Q6JywgUmVxdWVzdE1ldGhvZFtyZXEubWV0aG9kXSk7IC8vIFBvc3RcbiAgICAgKiBjb25zb2xlLmxvZygnb3B0aW9ucy51cmw6Jywgb3B0aW9ucy51cmwpOyAvLyBudWxsXG4gICAgICogY29uc29sZS5sb2coJ3JlcS51cmw6JywgcmVxLnVybCk7IC8vIGh0dHBzOi8vZ29vZ2xlLmNvbVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFJlcXVlc3RPcHRpb25zLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdE9wdGlvbnMoe1xuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zICYmIG9wdGlvbnMubWV0aG9kICE9IG51bGwgPyBvcHRpb25zLm1ldGhvZCA6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlcnMgIT0gbnVsbCA/IG9wdGlvbnMuaGVhZGVycyA6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBib2R5OiBvcHRpb25zICYmIG9wdGlvbnMuYm9keSAhPSBudWxsID8gb3B0aW9ucy5ib2R5IDogdGhpcy5ib2R5LFxuICAgICAgICAgICAgdXJsOiBvcHRpb25zICYmIG9wdGlvbnMudXJsICE9IG51bGwgPyBvcHRpb25zLnVybCA6IHRoaXMudXJsLFxuICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zICYmIHRoaXMuX21lcmdlU2VhcmNoUGFyYW1zKG9wdGlvbnMucGFyYW1zIHx8IG9wdGlvbnMuc2VhcmNoKSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogb3B0aW9ucyAmJiBvcHRpb25zLndpdGhDcmVkZW50aWFscyAhPSBudWxsID8gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgOlxuICAgICAgICAgICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBvcHRpb25zICYmIG9wdGlvbnMucmVzcG9uc2VUeXBlICE9IG51bGwgPyBvcHRpb25zLnJlc3BvbnNlVHlwZSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXF1ZXN0T3B0aW9ucy5wcm90b3R5cGUuX21lcmdlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgICAgICAgaWYgKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VQYXJhbXMocGFyYW1zKTtcbiAgICB9O1xuICAgIFJlcXVlc3RPcHRpb25zLnByb3RvdHlwZS5fcGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAob2JqUGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvYmpQYXJhbXMgPT09IHZvaWQgMCkgeyBvYmpQYXJhbXMgPSB7fTsgfVxuICAgICAgICB2YXIgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmpQYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqUGFyYW1zW2tleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy5fYXBwZW5kUGFyYW0oa2V5LCBpdGVtLCBwYXJhbXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9hcHBlbmRQYXJhbShrZXksIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICAgIFJlcXVlc3RPcHRpb25zLnByb3RvdHlwZS5fYXBwZW5kUGFyYW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zO1xufSgpKTtcbi8qKlxuICogU3ViY2xhc3Mgb2Yge0BsaW5rIFJlcXVlc3RPcHRpb25zfSwgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBEZWZhdWx0IHZhbHVlczpcbiAqICAqIG1ldGhvZDoge0BsaW5rIFJlcXVlc3RNZXRob2QgUmVxdWVzdE1ldGhvZC5HZXR9XG4gKiAgKiBoZWFkZXJzOiBlbXB0eSB7QGxpbmsgSGVhZGVyc30gb2JqZWN0XG4gKlxuICogVGhpcyBjbGFzcyBjb3VsZCBiZSBleHRlbmRlZCBhbmQgYm91bmQgdG8gdGhlIHtAbGluayBSZXF1ZXN0T3B0aW9uc30gY2xhc3NcbiAqIHdoZW4gY29uZmlndXJpbmcgYW4ge0BsaW5rIEluamVjdG9yfSwgaW4gb3JkZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogdXNlZCBieSB7QGxpbmsgSHR0cH0gdG8gY3JlYXRlIGFuZCBzZW5kIHtAbGluayBSZXF1ZXN0IFJlcXVlc3RzfS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge0Jhc2VSZXF1ZXN0T3B0aW9ucywgUmVxdWVzdE9wdGlvbnN9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIGNsYXNzIE15T3B0aW9ucyBleHRlbmRzIEJhc2VSZXF1ZXN0T3B0aW9ucyB7XG4gKiAgIHNlYXJjaDogc3RyaW5nID0gJ2NvcmVUZWFtPXRydWUnO1xuICogfVxuICpcbiAqIHtwcm92aWRlOiBSZXF1ZXN0T3B0aW9ucywgdXNlQ2xhc3M6IE15T3B0aW9uc307XG4gKiBgYGBcbiAqXG4gKiBUaGUgb3B0aW9ucyBjb3VsZCBhbHNvIGJlIGV4dGVuZGVkIHdoZW4gbWFudWFsbHkgY3JlYXRpbmcgYSB7QGxpbmsgUmVxdWVzdH1cbiAqIG9iamVjdC5cbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7QmFzZVJlcXVlc3RPcHRpb25zLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAqXG4gKiBjb25zdCBvcHRpb25zID0gbmV3IEJhc2VSZXF1ZXN0T3B0aW9ucygpO1xuICogY29uc3QgcmVxID0gbmV3IFJlcXVlc3Qob3B0aW9ucy5tZXJnZSh7XG4gKiAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5Qb3N0LFxuICogICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nXG4gKiB9KSk7XG4gKiBjb25zb2xlLmxvZygncmVxLm1ldGhvZDonLCBSZXF1ZXN0TWV0aG9kW3JlcS5tZXRob2RdKTsgLy8gUG9zdFxuICogY29uc29sZS5sb2coJ29wdGlvbnMudXJsOicsIG9wdGlvbnMudXJsKTsgLy8gbnVsbFxuICogY29uc29sZS5sb2coJ3JlcS51cmw6JywgcmVxLnVybCk7IC8vIGh0dHBzOi8vZ29vZ2xlLmNvbVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBCYXNlUmVxdWVzdE9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VSZXF1ZXN0T3B0aW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlUmVxdWVzdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB7IG1ldGhvZDogUmVxdWVzdE1ldGhvZC5HZXQsIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCkgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgQmFzZVJlcXVlc3RPcHRpb25zID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuICAgIF0sIEJhc2VSZXF1ZXN0T3B0aW9ucyk7XG4gICAgcmV0dXJuIEJhc2VSZXF1ZXN0T3B0aW9ucztcbn0oUmVxdWVzdE9wdGlvbnMpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gVE9ETyhqZWZmYmNyb3NzKTogcHJvcGVybHkgaW1wbGVtZW50IGJvZHkgYWNjZXNzb3JzXG4vKipcbiAqIENyZWF0ZXMgYFJlcXVlc3RgIGluc3RhbmNlcyBmcm9tIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBUaGUgUmVxdWVzdCdzIGludGVyZmFjZSBpcyBpbnNwaXJlZCBieSB0aGUgUmVxdWVzdCBjb25zdHJ1Y3RvciBkZWZpbmVkIGluIHRoZSBbRmV0Y2hcbiAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzKSxcbiAqIGJ1dCBpcyBjb25zaWRlcmVkIGEgc3RhdGljIHZhbHVlIHdob3NlIGJvZHkgY2FuIGJlIGFjY2Vzc2VkIG1hbnkgdGltZXMuIFRoZXJlIGFyZSBvdGhlclxuICogZGlmZmVyZW5jZXMgaW4gdGhlIGltcGxlbWVudGF0aW9uLCBidXQgdGhpcyBpcyB0aGUgbW9zdCBzaWduaWZpY2FudC5cbiAqXG4gKiBgUmVxdWVzdGAgaW5zdGFuY2VzIGFyZSB0eXBpY2FsbHkgY3JlYXRlZCBieSBoaWdoZXItbGV2ZWwgY2xhc3NlcywgbGlrZSB7QGxpbmsgSHR0cH0gYW5kXG4gKiB7QGxpbmsgSnNvbnB9LCBidXQgaXQgbWF5IG9jY2FzaW9uYWxseSBiZSB1c2VmdWwgdG8gZXhwbGljaXRseSBjcmVhdGUgYFJlcXVlc3RgIGluc3RhbmNlcy5cbiAqIE9uZSBzdWNoIGV4YW1wbGUgaXMgd2hlbiBjcmVhdGluZyBzZXJ2aWNlcyB0aGF0IHdyYXAgaGlnaGVyLWxldmVsIHNlcnZpY2VzLCBsaWtlIHtAbGluayBIdHRwfSxcbiAqIHdoZXJlIGl0IG1heSBiZSB1c2VmdWwgdG8gZ2VuZXJhdGUgYSBgUmVxdWVzdGAgd2l0aCBhcmJpdHJhcnkgaGVhZGVycyBhbmQgc2VhcmNoIHBhcmFtcy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge0luamVjdGFibGUsIEluamVjdG9yfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7SFRUUF9QUk9WSURFUlMsIEh0dHAsIFJlcXVlc3QsIFJlcXVlc3RNZXRob2R9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIEF1dG9BdXRoZW50aWNhdG9yIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIGh0dHA6SHR0cCkge31cbiAqICAgcmVxdWVzdCh1cmw6c3RyaW5nKSB7XG4gKiAgICAgcmV0dXJuIHRoaXMuaHR0cC5yZXF1ZXN0KG5ldyBSZXF1ZXN0KHtcbiAqICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5HZXQsXG4gKiAgICAgICB1cmw6IHVybCxcbiAqICAgICAgIHNlYXJjaDogJ3Bhc3N3b3JkPTEyMydcbiAqICAgICB9KSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtIVFRQX1BST1ZJREVSUywgQXV0b0F1dGhlbnRpY2F0b3JdKTtcbiAqIHZhciBhdXRoZW50aWNhdG9yID0gaW5qZWN0b3IuZ2V0KEF1dG9BdXRoZW50aWNhdG9yKTtcbiAqIGF1dGhlbnRpY2F0b3IucmVxdWVzdCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUocmVzID0+IHtcbiAqICAgLy9VUkwgc2hvdWxkIGhhdmUgaW5jbHVkZWQgJz9wYXNzd29yZD0xMjMnXG4gKiAgIGNvbnNvbGUubG9nKCdwZW9wbGUnLCByZXMuanNvbigpKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXF1ZXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gVE9ETzogYXNzZXJ0IHRoYXQgdXJsIGlzIHByZXNlbnRcbiAgICAgICAgdmFyIHVybCA9IHJlcXVlc3RPcHRpb25zLnVybDtcbiAgICAgICAgX3RoaXMudXJsID0gcmVxdWVzdE9wdGlvbnMudXJsO1xuICAgICAgICB2YXIgcGFyYW1zQXJnID0gcmVxdWVzdE9wdGlvbnMucGFyYW1zIHx8IHJlcXVlc3RPcHRpb25zLnNlYXJjaDtcbiAgICAgICAgaWYgKHBhcmFtc0FyZykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zQXJnID09PSAnb2JqZWN0JyAmJiAhKHBhcmFtc0FyZyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB1cmxFbmNvZGVQYXJhbXMocGFyYW1zQXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zQXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gJz8nO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51cmwuaW5kZXhPZignPycpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IChfdGhpcy51cmxbX3RoaXMudXJsLmxlbmd0aCAtIDFdID09ICcmJykgPyAnJyA6ICcmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzoganVzdCBkZWxldGUgc2VhcmNoLXF1ZXJ5LWxvb2tpbmcgc3RyaW5nIGluIHVybD9cbiAgICAgICAgICAgICAgICBfdGhpcy51cmwgPSB1cmwgKyBwcmVmaXggKyBwYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX2JvZHkgPSByZXF1ZXN0T3B0aW9ucy5ib2R5O1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2ROYW1lKHJlcXVlc3RPcHRpb25zLm1ldGhvZCk7XG4gICAgICAgIC8vIFRPRE8oamVmZmJjcm9zcyk6IGltcGxlbWVudCBiZWhhdmlvclxuICAgICAgICAvLyBEZWZhdWx0cyB0byAnb21pdCcsIGNvbnNpc3RlbnQgd2l0aCBicm93c2VyXG4gICAgICAgIF90aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgX3RoaXMuY29udGVudFR5cGUgPSBfdGhpcy5kZXRlY3RDb250ZW50VHlwZSgpO1xuICAgICAgICBfdGhpcy53aXRoQ3JlZGVudGlhbHMgPSByZXF1ZXN0T3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3RPcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IHR5cGUgZW51bSBiYXNlZCBvbiBoZWFkZXIgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5kZXRlY3RDb250ZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLkpTT047XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZW50VHlwZS5GT1JNO1xuICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLkZPUk1fREFUQTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHQvcGxhaW4nOlxuICAgICAgICAgICAgY2FzZSAndGV4dC9odG1sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuVEVYVDtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciQxID8gQ29udGVudFR5cGUuQVJSQVlfQlVGRkVSIDogQ29udGVudFR5cGUuQkxPQjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0ZWN0Q29udGVudFR5cGVGcm9tQm9keSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IHR5cGUgb2YgcmVxdWVzdCdzIGJvZHkgYmFzZWQgb24gaXRzIHR5cGUuXG4gICAgICovXG4gICAgUmVxdWVzdC5wcm90b3R5cGUuZGV0ZWN0Q29udGVudFR5cGVGcm9tQm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLk5PTkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLkZPUk07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuRk9STV9EQVRBO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBCbG9iJDEpIHtcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50VHlwZS5CTE9CO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciQxKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuQVJSQVlfQlVGRkVSO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2JvZHkgJiYgdHlwZW9mIHRoaXMuX2JvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuSlNPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50VHlwZS5URVhUO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXF1ZXN0J3MgYm9keSBhY2NvcmRpbmcgdG8gaXRzIHR5cGUuIElmIGJvZHkgaXMgdW5kZWZpbmVkLCByZXR1cm5cbiAgICAgKiBudWxsLlxuICAgICAqL1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5KU09OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKTtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuRk9STTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLkZPUk1fREFUQTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuVEVYVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLkJMT0I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpO1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5BUlJBWV9CVUZGRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZXF1ZXN0O1xufShCb2R5KSk7XG5mdW5jdGlvbiB1cmxFbmNvZGVQYXJhbXMocGFyYW1zKSB7XG4gICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgZWxlbWVudC50b1N0cmluZygpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgdyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgPyB3aW5kb3cgOiBub29wO1xudmFyIEZvcm1EYXRhID0gdyAvKiogVE9ETyAjOTEwMCAqL1snRm9ybURhdGEnXSB8fCBub29wO1xudmFyIEJsb2IkMSA9IHcgLyoqIFRPRE8gIzkxMDAgKi9bJ0Jsb2InXSB8fCBub29wO1xudmFyIEFycmF5QnVmZmVyJDEgPSB3IC8qKiBUT0RPICM5MTAwICovWydBcnJheUJ1ZmZlciddIHx8IG5vb3A7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0KGJhY2tlbmQsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gYmFja2VuZC5jcmVhdGVDb25uZWN0aW9uKHJlcXVlc3QpLnJlc3BvbnNlO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRzLCBwcm92aWRlZE9wdHMsIG1ldGhvZCwgdXJsKSB7XG4gICAgdmFyIG5ld09wdGlvbnMgPSBkZWZhdWx0T3B0cztcbiAgICBpZiAocHJvdmlkZWRPcHRzKSB7XG4gICAgICAgIC8vIEhhY2sgc28gRGFydCBjYW4gdXNlZCBuYW1lZCBwYXJhbWV0ZXJzXG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zLm1lcmdlKG5ldyBSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3ZpZGVkT3B0cy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiBwcm92aWRlZE9wdHMudXJsIHx8IHVybCxcbiAgICAgICAgICAgIHNlYXJjaDogcHJvdmlkZWRPcHRzLnNlYXJjaCxcbiAgICAgICAgICAgIHBhcmFtczogcHJvdmlkZWRPcHRzLnBhcmFtcyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHByb3ZpZGVkT3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogcHJvdmlkZWRPcHRzLmJvZHksXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHByb3ZpZGVkT3B0cy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IHByb3ZpZGVkT3B0cy5yZXNwb25zZVR5cGVcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T3B0aW9ucy5tZXJnZShuZXcgUmVxdWVzdE9wdGlvbnMoeyBtZXRob2Q6IG1ldGhvZCwgdXJsOiB1cmwgfSkpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBodHRwIHJlcXVlc3RzIHVzaW5nIGBYTUxIdHRwUmVxdWVzdGAgYXMgdGhlIGRlZmF1bHQgYmFja2VuZC5cbiAqXG4gKiBgSHR0cGAgaXMgYXZhaWxhYmxlIGFzIGFuIGluamVjdGFibGUgY2xhc3MsIHdpdGggbWV0aG9kcyB0byBwZXJmb3JtIGh0dHAgcmVxdWVzdHMuIENhbGxpbmdcbiAqIGByZXF1ZXN0YCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlYCB3aGljaCB3aWxsIGVtaXQgYSBzaW5nbGUge0BsaW5rIFJlc3BvbnNlfSB3aGVuIGFcbiAqIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7SHR0cCwgSFRUUF9QUk9WSURFUlN9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICogaW1wb3J0IHttYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdodHRwLWFwcCcsXG4gKiAgIHZpZXdQcm92aWRlcnM6IFtIVFRQX1BST1ZJREVSU10sXG4gKiAgIHRlbXBsYXRlVXJsOiAncGVvcGxlLmh0bWwnXG4gKiB9KVxuICogY2xhc3MgUGVvcGxlQ29tcG9uZW50IHtcbiAqICAgY29uc3RydWN0b3IoaHR0cDogSHR0cCkge1xuICogICAgIGh0dHAuZ2V0KCdwZW9wbGUuanNvbicpXG4gKiAgICAgICAvLyBDYWxsIG1hcCBvbiB0aGUgcmVzcG9uc2Ugb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHBhcnNlZCBwZW9wbGUgb2JqZWN0XG4gKiAgICAgICAucGlwZShtYXAocmVzID0+IHJlcy5qc29uKCkpKVxuICogICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgcGFyc2VkIHBlb3BsZSBvYmplY3QgYW5kIGF0dGFjaCBpdCB0byB0aGVcbiAqICAgICAgIC8vIGNvbXBvbmVudFxuICogICAgICAgLnN1YnNjcmliZShwZW9wbGUgPT4gdGhpcy5wZW9wbGUgPSBwZW9wbGUpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIGh0dHAuZ2V0KCdwZW9wbGUuanNvbicpLnN1YnNjcmliZSgocmVzOlJlc3BvbnNlKSA9PiB0aGlzLnBlb3BsZSA9IHJlcy5qc29uKCkpO1xuICogYGBgXG4gKlxuICogVGhlIGRlZmF1bHQgY29uc3RydWN0IHVzZWQgdG8gcGVyZm9ybSByZXF1ZXN0cywgYFhNTEh0dHBSZXF1ZXN0YCwgaXMgYWJzdHJhY3RlZCBhcyBhIFwiQmFja2VuZFwiIChcbiAqIHtAbGluayBYSFJCYWNrZW5kfSBpbiB0aGlzIGNhc2UpLCB3aGljaCBjb3VsZCBiZSBtb2NrZWQgd2l0aCBkZXBlbmRlbmN5IGluamVjdGlvbiBieSByZXBsYWNpbmdcbiAqIHRoZSB7QGxpbmsgWEhSQmFja2VuZH0gcHJvdmlkZXIsIGFzIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZTpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7QmFzZVJlcXVlc3RPcHRpb25zLCBIdHRwfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAqIGltcG9ydCB7TW9ja0JhY2tlbmR9IGZyb20gJ0Bhbmd1bGFyL2h0dHAvdGVzdGluZyc7XG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAqICAgQmFzZVJlcXVlc3RPcHRpb25zLFxuICogICBNb2NrQmFja2VuZCxcbiAqICAge3Byb3ZpZGU6IEh0dHAsIHVzZUZhY3Rvcnk6XG4gKiAgICAgICBmdW5jdGlvbihiYWNrZW5kLCBkZWZhdWx0T3B0aW9ucykge1xuICogICAgICAgICByZXR1cm4gbmV3IEh0dHAoYmFja2VuZCwgZGVmYXVsdE9wdGlvbnMpO1xuICogICAgICAgfSxcbiAqICAgICAgIGRlcHM6IFtNb2NrQmFja2VuZCwgQmFzZVJlcXVlc3RPcHRpb25zXX1cbiAqIF0pO1xuICogdmFyIGh0dHAgPSBpbmplY3Rvci5nZXQoSHR0cCk7XG4gKiBodHRwLmdldCgncmVxdWVzdC1mcm9tLW1vY2stYmFja2VuZC5qc29uJykuc3Vic2NyaWJlKChyZXM6UmVzcG9uc2UpID0+IGRvU29tZXRoaW5nKHJlcykpO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBIdHRwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHAoX2JhY2tlbmQsIF9kZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB0aGlzLl9iYWNrZW5kID0gX2JhY2tlbmQ7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gX2RlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbnkgdHlwZSBvZiBodHRwIHJlcXVlc3QuIEZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkLCBhbmQgY2FuIGVpdGhlciBiZSBhIHVybCBvclxuICAgICAqIGEge0BsaW5rIFJlcXVlc3R9IGluc3RhbmNlLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSB1cmwsIGFuIG9wdGlvbmFsIHtAbGluayBSZXF1ZXN0T3B0aW9uc31cbiAgICAgKiBvYmplY3QgY2FuIGJlIHByb3ZpZGVkIGFzIHRoZSAybmQgYXJndW1lbnQuIFRoZSBvcHRpb25zIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSB2YWx1ZXNcbiAgICAgKiBvZiB7QGxpbmsgQmFzZVJlcXVlc3RPcHRpb25zfSBiZWZvcmUgcGVyZm9ybWluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzcG9uc2VPYnNlcnZhYmxlO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2YWJsZSA9IGh0dHBSZXF1ZXN0KHRoaXMuX2JhY2tlbmQsIG5ldyBSZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgUmVxdWVzdE1ldGhvZC5HZXQsIHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cmwgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXNwb25zZU9ic2VydmFibGUgPSBodHRwUmVxdWVzdCh0aGlzLl9iYWNrZW5kLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdXJsIHN0cmluZyBvciBSZXF1ZXN0IGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZU9ic2VydmFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgZ2V0YCBodHRwIG1ldGhvZC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkdldCwgdXJsKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZXF1ZXN0IHdpdGggYHBvc3RgIGh0dHAgbWV0aG9kLlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLm1lcmdlKG5ldyBSZXF1ZXN0T3B0aW9ucyh7IGJvZHk6IGJvZHkgfSkpLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLlBvc3QsIHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBwdXRgIGh0dHAgbWV0aG9kLlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChuZXcgUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMubWVyZ2UobmV3IFJlcXVlc3RPcHRpb25zKHsgYm9keTogYm9keSB9KSksIG9wdGlvbnMsIFJlcXVlc3RNZXRob2QuUHV0LCB1cmwpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgZGVsZXRlYCBodHRwIG1ldGhvZC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkRlbGV0ZSwgdXJsKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZXF1ZXN0IHdpdGggYHBhdGNoYCBodHRwIG1ldGhvZC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChuZXcgUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMubWVyZ2UobmV3IFJlcXVlc3RPcHRpb25zKHsgYm9keTogYm9keSB9KSksIG9wdGlvbnMsIFJlcXVlc3RNZXRob2QuUGF0Y2gsIHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBoZWFkYCBodHRwIG1ldGhvZC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5oZWFkID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG5ldyBSZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgUmVxdWVzdE1ldGhvZC5IZWFkLCB1cmwpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgb3B0aW9uc2AgaHR0cCBtZXRob2QuXG4gICAgICovXG4gICAgSHR0cC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChuZXcgUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIFJlcXVlc3RNZXRob2QuT3B0aW9ucywgdXJsKSkpO1xuICAgIH07XG4gICAgSHR0cCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29ubmVjdGlvbkJhY2tlbmQsIFJlcXVlc3RPcHRpb25zXSlcbiAgICBdLCBIdHRwKTtcbiAgICByZXR1cm4gSHR0cDtcbn0oKSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSnNvbnAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpzb25wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpzb25wKGJhY2tlbmQsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBiYWNrZW5kLCBkZWZhdWx0T3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW55IHR5cGUgb2YgaHR0cCByZXF1ZXN0LiBGaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCwgYW5kIGNhbiBlaXRoZXIgYmUgYSB1cmwgb3JcbiAgICAgKiBhIHtAbGluayBSZXF1ZXN0fSBpbnN0YW5jZS4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgdXJsLCBhbiBvcHRpb25hbCB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9XG4gICAgICogb2JqZWN0IGNhbiBiZSBwcm92aWRlZCBhcyB0aGUgMm5kIGFyZ3VtZW50LiBUaGUgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgdmFsdWVzXG4gICAgICogb2Yge0BsaW5rIEJhc2VSZXF1ZXN0T3B0aW9uc30gYmVmb3JlIHBlcmZvcm1pbmcgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgUmVndWxhciBYSFIgaXMgdGhlIHNhZmVzdCBhbHRlcm5hdGl2ZSB0byBKU09OUCBmb3IgbW9zdCBhcHBsaWNhdGlvbnMsIGFuZCBpc1xuICAgICAqIHN1cHBvcnRlZCBieSBhbGwgY3VycmVudCBicm93c2Vycy4gQmVjYXVzZSBKU09OUCBjcmVhdGVzIGEgYDxzY3JpcHQ+YCBlbGVtZW50IHdpdGhcbiAgICAgKiBjb250ZW50cyByZXRyaWV2ZWQgZnJvbSBhIHJlbW90ZSBzb3VyY2UsIGF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGFuIHVudHJ1c3RlZFxuICAgICAqIHNvdXJjZSBjb3VsZCBleHBvc2UgeW91ciBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIERhdGEgZXhwb3NlZCBieSBKU09OUCBtYXkgYWxzbyBiZVxuICAgICAqIHJlYWRhYmxlIGJ5IG1hbGljaW91cyB0aGlyZC1wYXJ0eSB3ZWJzaXRlcy4gSW4gYWRkaXRpb24sIEpTT05QIGludHJvZHVjZXMgcG90ZW50aWFsIHJpc2sgZm9yXG4gICAgICogZnV0dXJlIHNlY3VyaXR5IGlzc3VlcyAoZS5nLiBjb250ZW50IHNuaWZmaW5nKS4gIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZVxuICAgICAqIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqL1xuICAgIEpzb25wLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzcG9uc2VPYnNlcnZhYmxlO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHVybCA9XG4gICAgICAgICAgICAgICAgbmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkdldCwgdXJsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmICh1cmwubWV0aG9kICE9PSBSZXF1ZXN0TWV0aG9kLkdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgR0VUIHJlcXVlc3QgbWV0aG9kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZhYmxlID0gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHVybCBzdHJpbmcgb3IgUmVxdWVzdCBpbnN0YW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VPYnNlcnZhYmxlO1xuICAgIH07XG4gICAgSnNvbnAgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Nvbm5lY3Rpb25CYWNrZW5kLCBSZXF1ZXN0T3B0aW9uc10pXG4gICAgXSwgSnNvbnApO1xuICAgIHJldHVybiBKc29ucDtcbn0oSHR0cCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBfY3JlYXRlRGVmYXVsdENvb2tpZVhTUkZTdHJhdGVneSgpIHtcbiAgICByZXR1cm4gbmV3IENvb2tpZVhTUkZTdHJhdGVneSgpO1xufVxuZnVuY3Rpb24gaHR0cEZhY3RvcnkoeGhyQmFja2VuZCwgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEh0dHAoeGhyQmFja2VuZCwgcmVxdWVzdE9wdGlvbnMpO1xufVxuZnVuY3Rpb24ganNvbnBGYWN0b3J5KGpzb25wQmFja2VuZCwgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpzb25wKGpzb25wQmFja2VuZCwgcmVxdWVzdE9wdGlvbnMpO1xufVxuLyoqXG4gKiBUaGUgbW9kdWxlIHRoYXQgaW5jbHVkZXMgaHR0cCdzIHByb3ZpZGVyc1xuICpcbiAqIEBkZXByZWNhdGVkIHNlZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaHR0cFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSHR0cE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwTW9kdWxlKCkge1xuICAgIH1cbiAgICBIdHRwTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIC8vIFRPRE8ocGFzY2FsKTogdXNlIGZhY3RvcnkgdHlwZSBhbm5vdGF0aW9ucyBvbmNlIHN1cHBvcnRlZCBpbiBESVxuICAgICAgICAgICAgICAgIC8vIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTgzXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBIdHRwLCB1c2VGYWN0b3J5OiBodHRwRmFjdG9yeSwgZGVwczogW1hIUkJhY2tlbmQsIFJlcXVlc3RPcHRpb25zXSB9LFxuICAgICAgICAgICAgICAgIEJyb3dzZXJYaHIsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBSZXF1ZXN0T3B0aW9ucywgdXNlQ2xhc3M6IEJhc2VSZXF1ZXN0T3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogUmVzcG9uc2VPcHRpb25zLCB1c2VDbGFzczogQmFzZVJlc3BvbnNlT3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgIFhIUkJhY2tlbmQsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBYU1JGU3RyYXRlZ3ksIHVzZUZhY3Rvcnk6IF9jcmVhdGVEZWZhdWx0Q29va2llWFNSRlN0cmF0ZWd5IH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KVxuICAgIF0sIEh0dHBNb2R1bGUpO1xuICAgIHJldHVybiBIdHRwTW9kdWxlO1xufSgpKTtcbi8qKlxuICogVGhlIG1vZHVsZSB0aGF0IGluY2x1ZGVzIGpzb25wJ3MgcHJvdmlkZXJzXG4gKlxuICogQGRlcHJlY2F0ZWQgc2VlIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9odHRwXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBKc29ucE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29ucE1vZHVsZSgpIHtcbiAgICB9XG4gICAgSnNvbnBNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe1xuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhwYXNjYWwpOiB1c2UgZmFjdG9yeSB0eXBlIGFubm90YXRpb25zIG9uY2Ugc3VwcG9ydGVkIGluIERJXG4gICAgICAgICAgICAgICAgLy8gaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMxODNcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEpzb25wLCB1c2VGYWN0b3J5OiBqc29ucEZhY3RvcnksIGRlcHM6IFtKU09OUEJhY2tlbmQsIFJlcXVlc3RPcHRpb25zXSB9LFxuICAgICAgICAgICAgICAgIEJyb3dzZXJKc29ucCxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFJlcXVlc3RPcHRpb25zLCB1c2VDbGFzczogQmFzZVJlcXVlc3RPcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBSZXNwb25zZU9wdGlvbnMsIHVzZUNsYXNzOiBCYXNlUmVzcG9uc2VPcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgSlNPTlBCYWNrZW5kLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSlcbiAgICBdLCBKc29ucE1vZHVsZSk7XG4gICAgcmV0dXJuIEpzb25wTW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBzZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2h0dHBcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFZFUlNJT04gPSBuZXcgVmVyc2lvbignNy4wLjQnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQnJvd3Nlckpzb25wIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19odHRwX2h0dHBfZSwgQm9keSBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfaHR0cF9odHRwX2YsIF9jcmVhdGVEZWZhdWx0Q29va2llWFNSRlN0cmF0ZWd5IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19odHRwX2h0dHBfYSwgaHR0cEZhY3RvcnkgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2h0dHBfaHR0cF9iLCBqc29ucEZhY3RvcnkgYXMgybVhbmd1bGFyX3BhY2thZ2VzX2h0dHBfaHR0cF9jLCBCcm93c2VyWGhyLCBKU09OUEJhY2tlbmQsIEpTT05QQ29ubmVjdGlvbiwgQ29va2llWFNSRlN0cmF0ZWd5LCBYSFJCYWNrZW5kLCBYSFJDb25uZWN0aW9uLCBCYXNlUmVxdWVzdE9wdGlvbnMsIFJlcXVlc3RPcHRpb25zLCBCYXNlUmVzcG9uc2VPcHRpb25zLCBSZXNwb25zZU9wdGlvbnMsIFJlYWR5U3RhdGUsIFJlcXVlc3RNZXRob2QsIFJlc3BvbnNlQ29udGVudFR5cGUsIFJlc3BvbnNlVHlwZSwgSGVhZGVycywgSHR0cCwgSnNvbnAsIEh0dHBNb2R1bGUsIEpzb25wTW9kdWxlLCBDb25uZWN0aW9uLCBDb25uZWN0aW9uQmFja2VuZCwgWFNSRlN0cmF0ZWd5LCBSZXF1ZXN0LCBSZXNwb25zZSwgUXVlcnlFbmNvZGVyLCBVUkxTZWFyY2hQYXJhbXMsIFZFUlNJT04gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///349\\n\")},354:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('__webpack_require__.r(__webpack_exports__);\\n\\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\\nvar tslib_es6 = __webpack_require__(0);\\n\\n// EXTERNAL MODULE: ./node_modules/@angular/core/fesm5/core.js\\nvar core = __webpack_require__(1);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js + 1 modules\\nvar of = __webpack_require__(72);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 5 modules\\nvar from = __webpack_require__(22);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/BehaviorSubject.js\\nvar BehaviorSubject = __webpack_require__(162);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 1 modules\\nvar Observable = __webpack_require__(4);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/EmptyError.js\\nvar EmptyError = __webpack_require__(54);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js\\nvar Subject = __webpack_require__(20);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js\\nvar empty = __webpack_require__(11);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js\\nvar map = __webpack_require__(23);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatAll.js\\nvar concatAll = __webpack_require__(163);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js\\nvar Subscriber = __webpack_require__(5);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction filter(predicate, thisArg) {\\n    return function filterOperatorFunction(source) {\\n        return source.lift(new FilterOperator(predicate, thisArg));\\n    };\\n}\\nvar FilterOperator = /*@__PURE__*/ (function () {\\n    function FilterOperator(predicate, thisArg) {\\n        this.predicate = predicate;\\n        this.thisArg = thisArg;\\n    }\\n    FilterOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new filter_FilterSubscriber(subscriber, this.predicate, this.thisArg));\\n    };\\n    return FilterOperator;\\n}());\\nvar filter_FilterSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](FilterSubscriber, _super);\\n    function FilterSubscriber(destination, predicate, thisArg) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.predicate = predicate;\\n        _this.thisArg = thisArg;\\n        _this.count = 0;\\n        return _this;\\n    }\\n    FilterSubscriber.prototype._next = function (value) {\\n        var result;\\n        try {\\n            result = this.predicate.call(this.thisArg, value, this.count++);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        if (result) {\\n            this.destination.next(value);\\n        }\\n    };\\n    return FilterSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=filter.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js\\nvar ArgumentOutOfRangeError = __webpack_require__(71);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction takeLast(count) {\\n    return function takeLastOperatorFunction(source) {\\n        if (count === 0) {\\n            return Object(empty[\"b\" /* empty */])();\\n        }\\n        else {\\n            return source.lift(new takeLast_TakeLastOperator(count));\\n        }\\n    };\\n}\\nvar takeLast_TakeLastOperator = /*@__PURE__*/ (function () {\\n    function TakeLastOperator(total) {\\n        this.total = total;\\n        if (this.total < 0) {\\n            throw new ArgumentOutOfRangeError[\"a\" /* ArgumentOutOfRangeError */];\\n        }\\n    }\\n    TakeLastOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));\\n    };\\n    return TakeLastOperator;\\n}());\\nvar takeLast_TakeLastSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](TakeLastSubscriber, _super);\\n    function TakeLastSubscriber(destination, total) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.total = total;\\n        _this.ring = new Array();\\n        _this.count = 0;\\n        return _this;\\n    }\\n    TakeLastSubscriber.prototype._next = function (value) {\\n        var ring = this.ring;\\n        var total = this.total;\\n        var count = this.count++;\\n        if (ring.length < total) {\\n            ring.push(value);\\n        }\\n        else {\\n            var index = count % total;\\n            ring[index] = value;\\n        }\\n    };\\n    TakeLastSubscriber.prototype._complete = function () {\\n        var destination = this.destination;\\n        var count = this.count;\\n        if (count > 0) {\\n            var total = this.count >= this.total ? this.total : this.count;\\n            var ring = this.ring;\\n            for (var i = 0; i < total; i++) {\\n                var idx = (count++) % total;\\n                destination.next(ring[idx]);\\n            }\\n        }\\n        destination.complete();\\n    };\\n    return TakeLastSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=takeLast.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js\\nvar noop = __webpack_require__(21);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js\\nvar isFunction = __webpack_require__(37);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction tap(nextOrObserver, error, complete) {\\n    return function tapOperatorFunction(source) {\\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\\n    };\\n}\\nvar DoOperator = /*@__PURE__*/ (function () {\\n    function DoOperator(nextOrObserver, error, complete) {\\n        this.nextOrObserver = nextOrObserver;\\n        this.error = error;\\n        this.complete = complete;\\n    }\\n    DoOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new tap_TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\\n    };\\n    return DoOperator;\\n}());\\nvar tap_TapSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](TapSubscriber, _super);\\n    function TapSubscriber(destination, observerOrNext, error, complete) {\\n        var _this = _super.call(this, destination) || this;\\n        _this._tapNext = noop[\"a\" /* noop */];\\n        _this._tapError = noop[\"a\" /* noop */];\\n        _this._tapComplete = noop[\"a\" /* noop */];\\n        _this._tapError = error || noop[\"a\" /* noop */];\\n        _this._tapComplete = complete || noop[\"a\" /* noop */];\\n        if (Object(isFunction[\"a\" /* isFunction */])(observerOrNext)) {\\n            _this._context = _this;\\n            _this._tapNext = observerOrNext;\\n        }\\n        else if (observerOrNext) {\\n            _this._context = observerOrNext;\\n            _this._tapNext = observerOrNext.next || noop[\"a\" /* noop */];\\n            _this._tapError = observerOrNext.error || noop[\"a\" /* noop */];\\n            _this._tapComplete = observerOrNext.complete || noop[\"a\" /* noop */];\\n        }\\n        return _this;\\n    }\\n    TapSubscriber.prototype._next = function (value) {\\n        try {\\n            this._tapNext.call(this._context, value);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.destination.next(value);\\n    };\\n    TapSubscriber.prototype._error = function (err) {\\n        try {\\n            this._tapError.call(this._context, err);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.destination.error(err);\\n    };\\n    TapSubscriber.prototype._complete = function () {\\n        try {\\n            this._tapComplete.call(this._context);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        return this.destination.complete();\\n    };\\n    return TapSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=tap.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js\\n/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */\\n\\n\\nvar throwIfEmpty = function (errorFactory) {\\n    if (errorFactory === void 0) {\\n        errorFactory = defaultErrorFactory;\\n    }\\n    return tap({\\n        hasValue: false,\\n        next: function () { this.hasValue = true; },\\n        complete: function () {\\n            if (!this.hasValue) {\\n                throw errorFactory();\\n            }\\n        }\\n    });\\n};\\nfunction defaultErrorFactory() {\\n    return new EmptyError[\"a\" /* EmptyError */]();\\n}\\n//# sourceMappingURL=throwIfEmpty.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction defaultIfEmpty(defaultValue) {\\n    if (defaultValue === void 0) {\\n        defaultValue = null;\\n    }\\n    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\\n}\\nvar DefaultIfEmptyOperator = /*@__PURE__*/ (function () {\\n    function DefaultIfEmptyOperator(defaultValue) {\\n        this.defaultValue = defaultValue;\\n    }\\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new defaultIfEmpty_DefaultIfEmptySubscriber(subscriber, this.defaultValue));\\n    };\\n    return DefaultIfEmptyOperator;\\n}());\\nvar defaultIfEmpty_DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](DefaultIfEmptySubscriber, _super);\\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.defaultValue = defaultValue;\\n        _this.isEmpty = true;\\n        return _this;\\n    }\\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\\n        this.isEmpty = false;\\n        this.destination.next(value);\\n    };\\n    DefaultIfEmptySubscriber.prototype._complete = function () {\\n        if (this.isEmpty) {\\n            this.destination.next(this.defaultValue);\\n        }\\n        this.destination.complete();\\n    };\\n    return DefaultIfEmptySubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=defaultIfEmpty.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js\\nvar identity = __webpack_require__(36);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/last.js\\n/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction last(predicate, defaultValue) {\\n    var hasDefaultValue = arguments.length >= 2;\\n    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity[\"a\" /* identity */], takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError[\"a\" /* EmptyError */](); })); };\\n}\\n//# sourceMappingURL=last.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeAll.js\\nvar mergeAll = __webpack_require__(94);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/every.js\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction every(predicate, thisArg) {\\n    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\\n}\\nvar EveryOperator = /*@__PURE__*/ (function () {\\n    function EveryOperator(predicate, thisArg, source) {\\n        this.predicate = predicate;\\n        this.thisArg = thisArg;\\n        this.source = source;\\n    }\\n    EveryOperator.prototype.call = function (observer, source) {\\n        return source.subscribe(new every_EverySubscriber(observer, this.predicate, this.thisArg, this.source));\\n    };\\n    return EveryOperator;\\n}());\\nvar every_EverySubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](EverySubscriber, _super);\\n    function EverySubscriber(destination, predicate, thisArg, source) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.predicate = predicate;\\n        _this.thisArg = thisArg;\\n        _this.source = source;\\n        _this.index = 0;\\n        _this.thisArg = thisArg || _this;\\n        return _this;\\n    }\\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\\n        this.destination.next(everyValueMatch);\\n        this.destination.complete();\\n    };\\n    EverySubscriber.prototype._next = function (value) {\\n        var result = false;\\n        try {\\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        if (!result) {\\n            this.notifyComplete(false);\\n        }\\n    };\\n    EverySubscriber.prototype._complete = function () {\\n        this.notifyComplete(true);\\n    };\\n    return EverySubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=every.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js\\nvar OuterSubscriber = __webpack_require__(25);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js\\nvar InnerSubscriber = __webpack_require__(55);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js\\nvar subscribeToResult = __webpack_require__(24);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js\\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction catchError(selector) {\\n    return function catchErrorOperatorFunction(source) {\\n        var operator = new CatchOperator(selector);\\n        var caught = source.lift(operator);\\n        return (operator.caught = caught);\\n    };\\n}\\nvar CatchOperator = /*@__PURE__*/ (function () {\\n    function CatchOperator(selector) {\\n        this.selector = selector;\\n    }\\n    CatchOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new catchError_CatchSubscriber(subscriber, this.selector, this.caught));\\n    };\\n    return CatchOperator;\\n}());\\nvar catchError_CatchSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](CatchSubscriber, _super);\\n    function CatchSubscriber(destination, selector, caught) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.selector = selector;\\n        _this.caught = caught;\\n        return _this;\\n    }\\n    CatchSubscriber.prototype.error = function (err) {\\n        if (!this.isStopped) {\\n            var result = void 0;\\n            try {\\n                result = this.selector(err, this.caught);\\n            }\\n            catch (err2) {\\n                _super.prototype.error.call(this, err2);\\n                return;\\n            }\\n            this._unsubscribeAndRecycle();\\n            var innerSubscriber = new InnerSubscriber[\"a\" /* InnerSubscriber */](this, undefined, undefined);\\n            this.add(innerSubscriber);\\n            Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, result, undefined, undefined, innerSubscriber);\\n        }\\n    };\\n    return CatchSubscriber;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n//# sourceMappingURL=catchError.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction take(count) {\\n    return function (source) {\\n        if (count === 0) {\\n            return Object(empty[\"b\" /* empty */])();\\n        }\\n        else {\\n            return source.lift(new take_TakeOperator(count));\\n        }\\n    };\\n}\\nvar take_TakeOperator = /*@__PURE__*/ (function () {\\n    function TakeOperator(total) {\\n        this.total = total;\\n        if (this.total < 0) {\\n            throw new ArgumentOutOfRangeError[\"a\" /* ArgumentOutOfRangeError */];\\n        }\\n    }\\n    TakeOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new take_TakeSubscriber(subscriber, this.total));\\n    };\\n    return TakeOperator;\\n}());\\nvar take_TakeSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](TakeSubscriber, _super);\\n    function TakeSubscriber(destination, total) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.total = total;\\n        _this.count = 0;\\n        return _this;\\n    }\\n    TakeSubscriber.prototype._next = function (value) {\\n        var total = this.total;\\n        var count = ++this.count;\\n        if (count <= total) {\\n            this.destination.next(value);\\n            if (count === total) {\\n                this.destination.complete();\\n                this.unsubscribe();\\n            }\\n        }\\n    };\\n    return TakeSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=take.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/first.js\\n/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction first(predicate, defaultValue) {\\n    var hasDefaultValue = arguments.length >= 2;\\n    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity[\"a\" /* identity */], take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError[\"a\" /* EmptyError */](); })); };\\n}\\n//# sourceMappingURL=first.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js\\nvar mergeMap = __webpack_require__(95);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js\\n/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction switchMap(project, resultSelector) {\\n    if (typeof resultSelector === \\'function\\') {\\n        return function (source) { return source.pipe(switchMap(function (a, i) { return Object(from[\"a\" /* from */])(project(a, i)).pipe(Object(map[\"a\" /* map */])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };\\n    }\\n    return function (source) { return source.lift(new SwitchMapOperator(project)); };\\n}\\nvar SwitchMapOperator = /*@__PURE__*/ (function () {\\n    function SwitchMapOperator(project) {\\n        this.project = project;\\n    }\\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new switchMap_SwitchMapSubscriber(subscriber, this.project));\\n    };\\n    return SwitchMapOperator;\\n}());\\nvar switchMap_SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](SwitchMapSubscriber, _super);\\n    function SwitchMapSubscriber(destination, project) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.project = project;\\n        _this.index = 0;\\n        return _this;\\n    }\\n    SwitchMapSubscriber.prototype._next = function (value) {\\n        var result;\\n        var index = this.index++;\\n        try {\\n            result = this.project(value, index);\\n        }\\n        catch (error) {\\n            this.destination.error(error);\\n            return;\\n        }\\n        this._innerSub(result, value, index);\\n    };\\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\\n        var innerSubscription = this.innerSubscription;\\n        if (innerSubscription) {\\n            innerSubscription.unsubscribe();\\n        }\\n        var innerSubscriber = new InnerSubscriber[\"a\" /* InnerSubscriber */](this, undefined, undefined);\\n        var destination = this.destination;\\n        destination.add(innerSubscriber);\\n        this.innerSubscription = Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, result, value, index, innerSubscriber);\\n    };\\n    SwitchMapSubscriber.prototype._complete = function () {\\n        var innerSubscription = this.innerSubscription;\\n        if (!innerSubscription || innerSubscription.closed) {\\n            _super.prototype._complete.call(this);\\n        }\\n        this.unsubscribe();\\n    };\\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\\n        this.innerSubscription = null;\\n    };\\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\\n        var destination = this.destination;\\n        destination.remove(innerSub);\\n        this.innerSubscription = null;\\n        if (this.isStopped) {\\n            _super.prototype._complete.call(this);\\n        }\\n    };\\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        this.destination.next(innerValue);\\n    };\\n    return SwitchMapSubscriber;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n//# sourceMappingURL=switchMap.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js\\n/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\\n\\nfunction concatMap(project, resultSelector) {\\n    return Object(mergeMap[\"a\" /* mergeMap */])(project, resultSelector, 1);\\n}\\n//# sourceMappingURL=concatMap.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js\\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\\n\\n\\nfunction scan(accumulator, seed) {\\n    var hasSeed = false;\\n    if (arguments.length >= 2) {\\n        hasSeed = true;\\n    }\\n    return function scanOperatorFunction(source) {\\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\\n    };\\n}\\nvar ScanOperator = /*@__PURE__*/ (function () {\\n    function ScanOperator(accumulator, seed, hasSeed) {\\n        if (hasSeed === void 0) {\\n            hasSeed = false;\\n        }\\n        this.accumulator = accumulator;\\n        this.seed = seed;\\n        this.hasSeed = hasSeed;\\n    }\\n    ScanOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new scan_ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\\n    };\\n    return ScanOperator;\\n}());\\nvar scan_ScanSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ScanSubscriber, _super);\\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.accumulator = accumulator;\\n        _this._seed = _seed;\\n        _this.hasSeed = hasSeed;\\n        _this.index = 0;\\n        return _this;\\n    }\\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\\n        get: function () {\\n            return this._seed;\\n        },\\n        set: function (value) {\\n            this.hasSeed = true;\\n            this._seed = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ScanSubscriber.prototype._next = function (value) {\\n        if (!this.hasSeed) {\\n            this.seed = value;\\n            this.destination.next(value);\\n        }\\n        else {\\n            return this._tryNext(value);\\n        }\\n    };\\n    ScanSubscriber.prototype._tryNext = function (value) {\\n        var index = this.index++;\\n        var result;\\n        try {\\n            result = this.accumulator(this.seed, value, index);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n        }\\n        this.seed = result;\\n        this.destination.next(result);\\n    };\\n    return ScanSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=scan.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js\\nvar pipe = __webpack_require__(63);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/reduce.js\\n/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction reduce(accumulator, seed) {\\n    if (arguments.length >= 2) {\\n        return function reduceOperatorFunctionWithSeed(source) {\\n            return Object(pipe[\"a\" /* pipe */])(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);\\n        };\\n    }\\n    return function reduceOperatorFunction(source) {\\n        return Object(pipe[\"a\" /* pipe */])(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);\\n    };\\n}\\n//# sourceMappingURL=reduce.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 2 modules\\nvar Subscription = __webpack_require__(6);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\\n\\n\\n\\nfunction finalize(callback) {\\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\\n}\\nvar FinallyOperator = /*@__PURE__*/ (function () {\\n    function FinallyOperator(callback) {\\n        this.callback = callback;\\n    }\\n    FinallyOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));\\n    };\\n    return FinallyOperator;\\n}());\\nvar finalize_FinallySubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](FinallySubscriber, _super);\\n    function FinallySubscriber(destination, callback) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.add(new Subscription[\"a\" /* Subscription */](callback));\\n        return _this;\\n    }\\n    return FinallySubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n//# sourceMappingURL=finalize.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/@angular/common/fesm5/common.js\\nvar common = __webpack_require__(14);\\n\\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm5/platform-browser.js\\nvar platform_browser = __webpack_require__(62);\\n\\n// CONCATENATED MODULE: ./node_modules/@angular/router/fesm5/router.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_a\", function() { return ROUTER_FORROOT_GUARD; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_h\", function() { return router_RouterInitializer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_c\", function() { return createRouterScroller; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_i\", function() { return getAppInitializer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_j\", function() { return getBootstrapListener; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_e\", function() { return provideForRootGuard; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_d\", function() { return provideLocationStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_k\", function() { return provideRouterInitializer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_g\", function() { return rootRoute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_b\", function() { return routerNgProbeToken; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_f\", function() { return setupRouter; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_n\", function() { return RouterScroller; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_l\", function() { return Tree; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵangular_packages_router_router_m\", function() { return TreeNode; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLink\", function() { return router_RouterLink; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLinkWithHref\", function() { return router_RouterLinkWithHref; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterLinkActive\", function() { return router_RouterLinkActive; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterOutlet\", function() { return router_RouterOutlet; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivationEnd\", function() { return ActivationEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivationStart\", function() { return ActivationStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildActivationEnd\", function() { return ChildActivationEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildActivationStart\", function() { return ChildActivationStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GuardsCheckEnd\", function() { return router_GuardsCheckEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GuardsCheckStart\", function() { return router_GuardsCheckStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationCancel\", function() { return router_NavigationCancel; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationEnd\", function() { return router_NavigationEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationError\", function() { return router_NavigationError; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NavigationStart\", function() { return router_NavigationStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolveEnd\", function() { return router_ResolveEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolveStart\", function() { return router_ResolveStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteConfigLoadEnd\", function() { return RouteConfigLoadEnd; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteConfigLoadStart\", function() { return RouteConfigLoadStart; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterEvent\", function() { return RouterEvent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RoutesRecognized\", function() { return router_RoutesRecognized; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scroll\", function() { return Scroll; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouteReuseStrategy\", function() { return RouteReuseStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Router\", function() { return router_Router; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTES\", function() { return ROUTES; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTER_CONFIGURATION\", function() { return ROUTER_CONFIGURATION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROUTER_INITIALIZER\", function() { return ROUTER_INITIALIZER; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterModule\", function() { return router_RouterModule; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"provideRoutes\", function() { return provideRoutes; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildrenOutletContexts\", function() { return ChildrenOutletContexts; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OutletContext\", function() { return OutletContext; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoPreloading\", function() { return router_NoPreloading; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreloadAllModules\", function() { return router_PreloadAllModules; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreloadingStrategy\", function() { return PreloadingStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterPreloader\", function() { return router_RouterPreloader; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivatedRoute\", function() { return router_ActivatedRoute; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ActivatedRouteSnapshot\", function() { return ActivatedRouteSnapshot; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterState\", function() { return router_RouterState; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RouterStateSnapshot\", function() { return router_RouterStateSnapshot; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PRIMARY_OUTLET\", function() { return PRIMARY_OUTLET; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToParamMap\", function() { return convertToParamMap; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlHandlingStrategy\", function() { return UrlHandlingStrategy; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultUrlSerializer\", function() { return DefaultUrlSerializer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSegment\", function() { return UrlSegment; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSegmentGroup\", function() { return UrlSegmentGroup; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlSerializer\", function() { return UrlSerializer; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlTree\", function() { return UrlTree; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵEmptyOutletComponent\", function() { return router_EmptyOutletComponent; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵROUTER_PROVIDERS\", function() { return ROUTER_PROVIDERS; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵflatten\", function() { return flatten; });\\n/**\\n * @license Angular v7.0.4\\n * (c) 2010-2018 Google, Inc. https://angular.io/\\n * License: MIT\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Base for events the Router goes through, as opposed to events tied to a specific\\n * Route. `RouterEvent`s will only be fired one time for any given navigation.\\n *\\n * Example:\\n *\\n * ```\\n * class MyService {\\n *   constructor(public router: Router, logger: Logger) {\\n *     router.events.pipe(\\n *       filter(e => e instanceof RouterEvent)\\n *     ).subscribe(e => {\\n *       logger.log(e.id, e.url);\\n *     });\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar RouterEvent = /** @class */ (function () {\\n    function RouterEvent(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url) {\\n        this.id = id;\\n        this.url = url;\\n    }\\n    return RouterEvent;\\n}());\\n/**\\n * @description\\n *\\n * Represents an event triggered when a navigation starts.\\n *\\n * @publicApi\\n */\\nvar router_NavigationStart = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(NavigationStart, _super);\\n    function NavigationStart(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    navigationTrigger, \\n    /** @docsNotRequired */\\n    restoredState) {\\n        if (navigationTrigger === void 0) { navigationTrigger = \\'imperative\\'; }\\n        if (restoredState === void 0) { restoredState = null; }\\n        var _this = _super.call(this, id, url) || this;\\n        _this.navigationTrigger = navigationTrigger;\\n        _this.restoredState = restoredState;\\n        return _this;\\n    }\\n    /** @docsNotRequired */\\n    NavigationStart.prototype.toString = function () { return \"NavigationStart(id: \" + this.id + \", url: \\'\" + this.url + \"\\')\"; };\\n    return NavigationStart;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents an event triggered when a navigation ends successfully.\\n *\\n * @publicApi\\n */\\nvar router_NavigationEnd = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(NavigationEnd, _super);\\n    function NavigationEnd(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        return _this;\\n    }\\n    /** @docsNotRequired */\\n    NavigationEnd.prototype.toString = function () {\\n        return \"NavigationEnd(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\')\";\\n    };\\n    return NavigationEnd;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents an event triggered when a navigation is canceled.\\n *\\n * @publicApi\\n */\\nvar router_NavigationCancel = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(NavigationCancel, _super);\\n    function NavigationCancel(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    reason) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.reason = reason;\\n        return _this;\\n    }\\n    /** @docsNotRequired */\\n    NavigationCancel.prototype.toString = function () { return \"NavigationCancel(id: \" + this.id + \", url: \\'\" + this.url + \"\\')\"; };\\n    return NavigationCancel;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents an event triggered when a navigation fails due to an unexpected error.\\n *\\n * @publicApi\\n */\\nvar router_NavigationError = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(NavigationError, _super);\\n    function NavigationError(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    error) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.error = error;\\n        return _this;\\n    }\\n    /** @docsNotRequired */\\n    NavigationError.prototype.toString = function () {\\n        return \"NavigationError(id: \" + this.id + \", url: \\'\" + this.url + \"\\', error: \" + this.error + \")\";\\n    };\\n    return NavigationError;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents an event triggered when routes are recognized.\\n *\\n * @publicApi\\n */\\nvar router_RoutesRecognized = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(RoutesRecognized, _super);\\n    function RoutesRecognized(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects, \\n    /** @docsNotRequired */\\n    state) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        _this.state = state;\\n        return _this;\\n    }\\n    /** @docsNotRequired */\\n    RoutesRecognized.prototype.toString = function () {\\n        return \"RoutesRecognized(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\', state: \" + this.state + \")\";\\n    };\\n    return RoutesRecognized;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents the start of the Guard phase of routing.\\n *\\n * @publicApi\\n */\\nvar router_GuardsCheckStart = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(GuardsCheckStart, _super);\\n    function GuardsCheckStart(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects, \\n    /** @docsNotRequired */\\n    state) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        _this.state = state;\\n        return _this;\\n    }\\n    GuardsCheckStart.prototype.toString = function () {\\n        return \"GuardsCheckStart(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\', state: \" + this.state + \")\";\\n    };\\n    return GuardsCheckStart;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents the end of the Guard phase of routing.\\n *\\n * @publicApi\\n */\\nvar router_GuardsCheckEnd = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(GuardsCheckEnd, _super);\\n    function GuardsCheckEnd(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects, \\n    /** @docsNotRequired */\\n    state, \\n    /** @docsNotRequired */\\n    shouldActivate) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        _this.state = state;\\n        _this.shouldActivate = shouldActivate;\\n        return _this;\\n    }\\n    GuardsCheckEnd.prototype.toString = function () {\\n        return \"GuardsCheckEnd(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\', state: \" + this.state + \", shouldActivate: \" + this.shouldActivate + \")\";\\n    };\\n    return GuardsCheckEnd;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents the start of the Resolve phase of routing. The timing of this\\n * event may change, thus it\\'s experimental. In the current iteration it will run\\n * in the \"resolve\" phase whether there\\'s things to resolve or not. In the future this\\n * behavior may change to only run when there are things to be resolved.\\n *\\n * @publicApi\\n */\\nvar router_ResolveStart = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(ResolveStart, _super);\\n    function ResolveStart(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects, \\n    /** @docsNotRequired */\\n    state) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        _this.state = state;\\n        return _this;\\n    }\\n    ResolveStart.prototype.toString = function () {\\n        return \"ResolveStart(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\', state: \" + this.state + \")\";\\n    };\\n    return ResolveStart;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents the end of the Resolve phase of routing. See note on\\n * `ResolveStart` for use of this experimental API.\\n *\\n * @publicApi\\n */\\nvar router_ResolveEnd = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(ResolveEnd, _super);\\n    function ResolveEnd(\\n    /** @docsNotRequired */\\n    id, \\n    /** @docsNotRequired */\\n    url, \\n    /** @docsNotRequired */\\n    urlAfterRedirects, \\n    /** @docsNotRequired */\\n    state) {\\n        var _this = _super.call(this, id, url) || this;\\n        _this.urlAfterRedirects = urlAfterRedirects;\\n        _this.state = state;\\n        return _this;\\n    }\\n    ResolveEnd.prototype.toString = function () {\\n        return \"ResolveEnd(id: \" + this.id + \", url: \\'\" + this.url + \"\\', urlAfterRedirects: \\'\" + this.urlAfterRedirects + \"\\', state: \" + this.state + \")\";\\n    };\\n    return ResolveEnd;\\n}(RouterEvent));\\n/**\\n * @description\\n *\\n * Represents an event triggered before lazy loading a route config.\\n *\\n * @publicApi\\n */\\nvar RouteConfigLoadStart = /** @class */ (function () {\\n    function RouteConfigLoadStart(\\n    /** @docsNotRequired */\\n    route) {\\n        this.route = route;\\n    }\\n    RouteConfigLoadStart.prototype.toString = function () { return \"RouteConfigLoadStart(path: \" + this.route.path + \")\"; };\\n    return RouteConfigLoadStart;\\n}());\\n/**\\n * @description\\n *\\n * Represents an event triggered when a route has been lazy loaded.\\n *\\n * @publicApi\\n */\\nvar RouteConfigLoadEnd = /** @class */ (function () {\\n    function RouteConfigLoadEnd(\\n    /** @docsNotRequired */\\n    route) {\\n        this.route = route;\\n    }\\n    RouteConfigLoadEnd.prototype.toString = function () { return \"RouteConfigLoadEnd(path: \" + this.route.path + \")\"; };\\n    return RouteConfigLoadEnd;\\n}());\\n/**\\n * @description\\n *\\n * Represents the start of end of the Resolve phase of routing. See note on\\n * `ChildActivationEnd` for use of this experimental API.\\n *\\n * @publicApi\\n */\\nvar ChildActivationStart = /** @class */ (function () {\\n    function ChildActivationStart(\\n    /** @docsNotRequired */\\n    snapshot) {\\n        this.snapshot = snapshot;\\n    }\\n    ChildActivationStart.prototype.toString = function () {\\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \\'\\';\\n        return \"ChildActivationStart(path: \\'\" + path + \"\\')\";\\n    };\\n    return ChildActivationStart;\\n}());\\n/**\\n * @description\\n *\\n * Represents the start of end of the Resolve phase of routing. See note on\\n * `ChildActivationStart` for use of this experimental API.\\n *\\n * @publicApi\\n */\\nvar ChildActivationEnd = /** @class */ (function () {\\n    function ChildActivationEnd(\\n    /** @docsNotRequired */\\n    snapshot) {\\n        this.snapshot = snapshot;\\n    }\\n    ChildActivationEnd.prototype.toString = function () {\\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \\'\\';\\n        return \"ChildActivationEnd(path: \\'\" + path + \"\\')\";\\n    };\\n    return ChildActivationEnd;\\n}());\\n/**\\n * @description\\n *\\n * Represents the start of end of the Resolve phase of routing. See note on\\n * `ActivationEnd` for use of this experimental API.\\n *\\n * @publicApi\\n */\\nvar ActivationStart = /** @class */ (function () {\\n    function ActivationStart(\\n    /** @docsNotRequired */\\n    snapshot) {\\n        this.snapshot = snapshot;\\n    }\\n    ActivationStart.prototype.toString = function () {\\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \\'\\';\\n        return \"ActivationStart(path: \\'\" + path + \"\\')\";\\n    };\\n    return ActivationStart;\\n}());\\n/**\\n * @description\\n *\\n * Represents the start of end of the Resolve phase of routing. See note on\\n * `ActivationStart` for use of this experimental API.\\n *\\n * @publicApi\\n */\\nvar ActivationEnd = /** @class */ (function () {\\n    function ActivationEnd(\\n    /** @docsNotRequired */\\n    snapshot) {\\n        this.snapshot = snapshot;\\n    }\\n    ActivationEnd.prototype.toString = function () {\\n        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \\'\\';\\n        return \"ActivationEnd(path: \\'\" + path + \"\\')\";\\n    };\\n    return ActivationEnd;\\n}());\\n/**\\n * @description\\n *\\n * Represents a scrolling event.\\n *\\n * @publicApi\\n */\\nvar Scroll = /** @class */ (function () {\\n    function Scroll(\\n    /** @docsNotRequired */\\n    routerEvent, \\n    /** @docsNotRequired */\\n    position, \\n    /** @docsNotRequired */\\n    anchor) {\\n        this.routerEvent = routerEvent;\\n        this.position = position;\\n        this.anchor = anchor;\\n    }\\n    Scroll.prototype.toString = function () {\\n        var pos = this.position ? this.position[0] + \", \" + this.position[1] : null;\\n        return \"Scroll(anchor: \\'\" + this.anchor + \"\\', position: \\'\" + pos + \"\\')\";\\n    };\\n    return Scroll;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * This component is used internally within the router to be a placeholder when an empty\\n * router-outlet is needed. For example, with a config such as:\\n *\\n * `{path: \\'parent\\', outlet: \\'nav\\', children: [...]}`\\n *\\n * In order to render, there needs to be a component on this config, which will default\\n * to this `EmptyOutletComponent`.\\n */\\nvar router_EmptyOutletComponent = /** @class */ (function () {\\n    function EmptyOutletComponent() {\\n    }\\n    EmptyOutletComponent = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Component\"])({ template: \"<router-outlet></router-outlet>\" })\\n    ], EmptyOutletComponent);\\n    return EmptyOutletComponent;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Name of the primary outlet.\\n *\\n * @publicApi\\n */\\nvar PRIMARY_OUTLET = \\'primary\\';\\nvar ParamsAsMap = /** @class */ (function () {\\n    function ParamsAsMap(params) {\\n        this.params = params || {};\\n    }\\n    ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };\\n    ParamsAsMap.prototype.get = function (name) {\\n        if (this.has(name)) {\\n            var v = this.params[name];\\n            return Array.isArray(v) ? v[0] : v;\\n        }\\n        return null;\\n    };\\n    ParamsAsMap.prototype.getAll = function (name) {\\n        if (this.has(name)) {\\n            var v = this.params[name];\\n            return Array.isArray(v) ? v : [v];\\n        }\\n        return [];\\n    };\\n    Object.defineProperty(ParamsAsMap.prototype, \"keys\", {\\n        get: function () { return Object.keys(this.params); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    return ParamsAsMap;\\n}());\\n/**\\n * Convert a `Params` instance to a `ParamMap`.\\n *\\n * @publicApi\\n */\\nfunction convertToParamMap(params) {\\n    return new ParamsAsMap(params);\\n}\\nvar NAVIGATION_CANCELING_ERROR = \\'ngNavigationCancelingError\\';\\nfunction navigationCancelingError(message) {\\n    var error = Error(\\'NavigationCancelingError: \\' + message);\\n    error[NAVIGATION_CANCELING_ERROR] = true;\\n    return error;\\n}\\nfunction isNavigationCancelingError(error) {\\n    return error && error[NAVIGATION_CANCELING_ERROR];\\n}\\n// Matches the route configuration (`route`) against the actual URL (`segments`).\\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\\n    var parts = route.path.split(\\'/\\');\\n    if (parts.length > segments.length) {\\n        // The actual URL is shorter than the config, no match\\n        return null;\\n    }\\n    if (route.pathMatch === \\'full\\' &&\\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\\n        // The config is longer than the actual URL but we are looking for a full match, return null\\n        return null;\\n    }\\n    var posParams = {};\\n    // Check each config part against the actual URL\\n    for (var index = 0; index < parts.length; index++) {\\n        var part = parts[index];\\n        var segment = segments[index];\\n        var isParameter = part.startsWith(\\':\\');\\n        if (isParameter) {\\n            posParams[part.substring(1)] = segment;\\n        }\\n        else if (part !== segment.path) {\\n            // The actual URL part does not match the config, no match\\n            return null;\\n        }\\n    }\\n    return { consumed: segments.slice(0, parts.length), posParams: posParams };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar LoadedRouterConfig = /** @class */ (function () {\\n    function LoadedRouterConfig(routes, module) {\\n        this.routes = routes;\\n        this.module = module;\\n    }\\n    return LoadedRouterConfig;\\n}());\\nfunction validateConfig(config, parentPath) {\\n    if (parentPath === void 0) { parentPath = \\'\\'; }\\n    // forEach doesn\\'t iterate undefined values\\n    for (var i = 0; i < config.length; i++) {\\n        var route = config[i];\\n        var fullPath = getFullPath(parentPath, route);\\n        validateNode(route, fullPath);\\n    }\\n}\\nfunction validateNode(route, fullPath) {\\n    if (!route) {\\n        throw new Error(\"\\\\n      Invalid configuration of route \\'\" + fullPath + \"\\': Encountered undefined route.\\\\n      The reason might be an extra comma.\\\\n\\\\n      Example:\\\\n      const routes: Routes = [\\\\n        { path: \\'\\', redirectTo: \\'/dashboard\\', pathMatch: \\'full\\' },\\\\n        { path: \\'dashboard\\',  component: DashboardComponent },, << two commas\\\\n        { path: \\'detail/:id\\', component: HeroDetailComponent }\\\\n      ];\\\\n    \");\\n    }\\n    if (Array.isArray(route)) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': Array cannot be specified\");\\n    }\\n    if (!route.component && !route.children && !route.loadChildren &&\\n        (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': a componentless route without children or loadChildren cannot have a named outlet set\");\\n    }\\n    if (route.redirectTo && route.children) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': redirectTo and children cannot be used together\");\\n    }\\n    if (route.redirectTo && route.loadChildren) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': redirectTo and loadChildren cannot be used together\");\\n    }\\n    if (route.children && route.loadChildren) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': children and loadChildren cannot be used together\");\\n    }\\n    if (route.redirectTo && route.component) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': redirectTo and component cannot be used together\");\\n    }\\n    if (route.path && route.matcher) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': path and matcher cannot be used together\");\\n    }\\n    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\'. One of the following must be provided: component, redirectTo, children or loadChildren\");\\n    }\\n    if (route.path === void 0 && route.matcher === void 0) {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': routes must have either a path or a matcher specified\");\\n    }\\n    if (typeof route.path === \\'string\\' && route.path.charAt(0) === \\'/\\') {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': path cannot start with a slash\");\\n    }\\n    if (route.path === \\'\\' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\\n        var exp = \"The default value of \\'pathMatch\\' is \\'prefix\\', but often the intent is to use \\'full\\'.\";\\n        throw new Error(\"Invalid configuration of route \\'{path: \\\\\"\" + fullPath + \"\\\\\", redirectTo: \\\\\"\" + route.redirectTo + \"\\\\\"}\\': please provide \\'pathMatch\\'. \" + exp);\\n    }\\n    if (route.pathMatch !== void 0 && route.pathMatch !== \\'full\\' && route.pathMatch !== \\'prefix\\') {\\n        throw new Error(\"Invalid configuration of route \\'\" + fullPath + \"\\': pathMatch can only be set to \\'prefix\\' or \\'full\\'\");\\n    }\\n    if (route.children) {\\n        validateConfig(route.children, fullPath);\\n    }\\n}\\nfunction getFullPath(parentPath, currentRoute) {\\n    if (!currentRoute) {\\n        return parentPath;\\n    }\\n    if (!parentPath && !currentRoute.path) {\\n        return \\'\\';\\n    }\\n    else if (parentPath && !currentRoute.path) {\\n        return parentPath + \"/\";\\n    }\\n    else if (!parentPath && currentRoute.path) {\\n        return currentRoute.path;\\n    }\\n    else {\\n        return parentPath + \"/\" + currentRoute.path;\\n    }\\n}\\n/**\\n * Makes a copy of the config and adds any default required properties.\\n */\\nfunction standardizeConfig(r) {\\n    var children = r.children && r.children.map(standardizeConfig);\\n    var c = children ? Object(tslib_es6[\"a\" /* __assign */])({}, r, { children: children }) : Object(tslib_es6[\"a\" /* __assign */])({}, r);\\n    if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\\n        c.component = router_EmptyOutletComponent;\\n    }\\n    return c;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction shallowEqualArrays(a, b) {\\n    if (a.length !== b.length)\\n        return false;\\n    for (var i = 0; i < a.length; ++i) {\\n        if (!shallowEqual(a[i], b[i]))\\n            return false;\\n    }\\n    return true;\\n}\\nfunction shallowEqual(a, b) {\\n    var k1 = Object.keys(a);\\n    var k2 = Object.keys(b);\\n    if (k1.length != k2.length) {\\n        return false;\\n    }\\n    var key;\\n    for (var i = 0; i < k1.length; i++) {\\n        key = k1[i];\\n        if (a[key] !== b[key]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n/**\\n * Flattens single-level nested arrays.\\n */\\nfunction flatten(arr) {\\n    return Array.prototype.concat.apply([], arr);\\n}\\n/**\\n * Return the last element of an array.\\n */\\nfunction last$1(a) {\\n    return a.length > 0 ? a[a.length - 1] : null;\\n}\\nfunction forEach(map$$1, callback) {\\n    for (var prop in map$$1) {\\n        if (map$$1.hasOwnProperty(prop)) {\\n            callback(map$$1[prop], prop);\\n        }\\n    }\\n}\\nfunction waitForMap(obj, fn) {\\n    if (Object.keys(obj).length === 0) {\\n        return Object(of[\"a\" /* of */])({});\\n    }\\n    var waitHead = [];\\n    var waitTail = [];\\n    var res = {};\\n    forEach(obj, function (a, k) {\\n        var mapped = fn(k, a).pipe(Object(map[\"a\" /* map */])(function (r) { return res[k] = r; }));\\n        if (k === PRIMARY_OUTLET) {\\n            waitHead.push(mapped);\\n        }\\n        else {\\n            waitTail.push(mapped);\\n        }\\n    });\\n    // Closure compiler has problem with using spread operator here. So just using Array.concat.\\n    return of[\"a\" /* of */].apply(null, waitHead.concat(waitTail)).pipe(Object(concatAll[\"a\" /* concatAll */])(), last(), Object(map[\"a\" /* map */])(function () { return res; }));\\n}\\n/**\\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\\n * input Observables return `true`.\\n */\\nfunction andObservables(observables) {\\n    return observables.pipe(Object(mergeAll[\"a\" /* mergeAll */])(), every(function (result) { return result === true; }));\\n}\\nfunction wrapIntoObservable(value) {\\n    if (Object(core[\"ɵisObservable\"])(value)) {\\n        return value;\\n    }\\n    if (Object(core[\"ɵisPromise\"])(value)) {\\n        // Use `Promise.resolve()` to wrap promise-like instances.\\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\\n        // change detection.\\n        return Object(from[\"a\" /* from */])(Promise.resolve(value));\\n    }\\n    return Object(of[\"a\" /* of */])(value);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction createEmptyUrlTree() {\\n    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\\n}\\nfunction containsTree(container, containee, exact) {\\n    if (exact) {\\n        return equalQueryParams(container.queryParams, containee.queryParams) &&\\n            equalSegmentGroups(container.root, containee.root);\\n    }\\n    return containsQueryParams(container.queryParams, containee.queryParams) &&\\n        containsSegmentGroup(container.root, containee.root);\\n}\\nfunction equalQueryParams(container, containee) {\\n    // TODO: This does not handle array params correctly.\\n    return shallowEqual(container, containee);\\n}\\nfunction equalSegmentGroups(container, containee) {\\n    if (!equalPath(container.segments, containee.segments))\\n        return false;\\n    if (container.numberOfChildren !== containee.numberOfChildren)\\n        return false;\\n    for (var c in containee.children) {\\n        if (!container.children[c])\\n            return false;\\n        if (!equalSegmentGroups(container.children[c], containee.children[c]))\\n            return false;\\n    }\\n    return true;\\n}\\nfunction containsQueryParams(container, containee) {\\n    // TODO: This does not handle array params correctly.\\n    return Object.keys(containee).length <= Object.keys(container).length &&\\n        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });\\n}\\nfunction containsSegmentGroup(container, containee) {\\n    return containsSegmentGroupHelper(container, containee, containee.segments);\\n}\\nfunction containsSegmentGroupHelper(container, containee, containeePaths) {\\n    if (container.segments.length > containeePaths.length) {\\n        var current = container.segments.slice(0, containeePaths.length);\\n        if (!equalPath(current, containeePaths))\\n            return false;\\n        if (containee.hasChildren())\\n            return false;\\n        return true;\\n    }\\n    else if (container.segments.length === containeePaths.length) {\\n        if (!equalPath(container.segments, containeePaths))\\n            return false;\\n        for (var c in containee.children) {\\n            if (!container.children[c])\\n                return false;\\n            if (!containsSegmentGroup(container.children[c], containee.children[c]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    else {\\n        var current = containeePaths.slice(0, container.segments.length);\\n        var next = containeePaths.slice(container.segments.length);\\n        if (!equalPath(container.segments, current))\\n            return false;\\n        if (!container.children[PRIMARY_OUTLET])\\n            return false;\\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);\\n    }\\n}\\n/**\\n * @description\\n *\\n * Represents the parsed URL.\\n *\\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\\n * serialized tree.\\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * @Component({templateUrl:\\'template.html\\'})\\n * class MyComponent {\\n *   constructor(router: Router) {\\n *     const tree: UrlTree =\\n *       router.parseUrl(\\'/team/33/(user/victor//support:help)?debug=true#fragment\\');\\n *     const f = tree.fragment; // return \\'fragment\\'\\n *     const q = tree.queryParams; // returns {debug: \\'true\\'}\\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\\n *     const s: UrlSegment[] = g.segments; // returns 2 segments \\'team\\' and \\'33\\'\\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments \\'user\\' and \\'victor\\'\\n *     g.children[\\'support\\'].segments; // return 1 segment \\'help\\'\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar UrlTree = /** @class */ (function () {\\n    /** @internal */\\n    function UrlTree(\\n    /** The root segment group of the URL tree */\\n    root, \\n    /** The query params of the URL */\\n    queryParams, \\n    /** The fragment of the URL */\\n    fragment) {\\n        this.root = root;\\n        this.queryParams = queryParams;\\n        this.fragment = fragment;\\n    }\\n    Object.defineProperty(UrlTree.prototype, \"queryParamMap\", {\\n        get: function () {\\n            if (!this._queryParamMap) {\\n                this._queryParamMap = convertToParamMap(this.queryParams);\\n            }\\n            return this._queryParamMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /** @docsNotRequired */\\n    UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };\\n    return UrlTree;\\n}());\\n/**\\n * @description\\n *\\n * Represents the parsed URL segment group.\\n *\\n * See `UrlTree` for more information.\\n *\\n * @publicApi\\n */\\nvar UrlSegmentGroup = /** @class */ (function () {\\n    function UrlSegmentGroup(\\n    /** The URL segments of this group. See `UrlSegment` for more information */\\n    segments, \\n    /** The list of children of this group */\\n    children) {\\n        var _this = this;\\n        this.segments = segments;\\n        this.children = children;\\n        /** The parent node in the url tree */\\n        this.parent = null;\\n        forEach(children, function (v, k) { return v.parent = _this; });\\n    }\\n    /** Whether the segment has child segments */\\n    UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };\\n    Object.defineProperty(UrlSegmentGroup.prototype, \"numberOfChildren\", {\\n        /** Number of child segments */\\n        get: function () { return Object.keys(this.children).length; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /** @docsNotRequired */\\n    UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };\\n    return UrlSegmentGroup;\\n}());\\n/**\\n * @description\\n *\\n * Represents a single URL segment.\\n *\\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\\n * parameters associated with the segment.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * @Component({templateUrl:\\'template.html\\'})\\n * class MyComponent {\\n *   constructor(router: Router) {\\n *     const tree: UrlTree = router.parseUrl(\\'/team;id=33\\');\\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\\n *     const s: UrlSegment[] = g.segments;\\n *     s[0].path; // returns \\'team\\'\\n *     s[0].parameters; // returns {id: 33}\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar UrlSegment = /** @class */ (function () {\\n    function UrlSegment(\\n    /** The path part of a URL segment */\\n    path, \\n    /** The matrix parameters associated with a segment */\\n    parameters) {\\n        this.path = path;\\n        this.parameters = parameters;\\n    }\\n    Object.defineProperty(UrlSegment.prototype, \"parameterMap\", {\\n        get: function () {\\n            if (!this._parameterMap) {\\n                this._parameterMap = convertToParamMap(this.parameters);\\n            }\\n            return this._parameterMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /** @docsNotRequired */\\n    UrlSegment.prototype.toString = function () { return serializePath(this); };\\n    return UrlSegment;\\n}());\\nfunction equalSegments(as, bs) {\\n    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });\\n}\\nfunction equalPath(as, bs) {\\n    if (as.length !== bs.length)\\n        return false;\\n    return as.every(function (a, i) { return a.path === bs[i].path; });\\n}\\nfunction mapChildrenIntoArray(segment, fn) {\\n    var res = [];\\n    forEach(segment.children, function (child, childOutlet) {\\n        if (childOutlet === PRIMARY_OUTLET) {\\n            res = res.concat(fn(child, childOutlet));\\n        }\\n    });\\n    forEach(segment.children, function (child, childOutlet) {\\n        if (childOutlet !== PRIMARY_OUTLET) {\\n            res = res.concat(fn(child, childOutlet));\\n        }\\n    });\\n    return res;\\n}\\n/**\\n * @description\\n *\\n * Serializes and deserializes a URL string into a URL tree.\\n *\\n * The url serialization strategy is customizable. You can\\n * make all URLs case insensitive by providing a custom UrlSerializer.\\n *\\n * See `DefaultUrlSerializer` for an example of a URL serializer.\\n *\\n * @publicApi\\n */\\nvar UrlSerializer = /** @class */ (function () {\\n    function UrlSerializer() {\\n    }\\n    return UrlSerializer;\\n}());\\n/**\\n * @description\\n *\\n * A default implementation of the `UrlSerializer`.\\n *\\n * Example URLs:\\n *\\n * ```\\n * /inbox/33(popup:compose)\\n * /inbox/33;open=true/messages/44\\n * ```\\n *\\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\\n * colon syntax to specify the outlet, and the \\';parameter=value\\' syntax (e.g., open=true) to\\n * specify route specific parameters.\\n *\\n * @publicApi\\n */\\nvar DefaultUrlSerializer = /** @class */ (function () {\\n    function DefaultUrlSerializer() {\\n    }\\n    /** Parses a url into a `UrlTree` */\\n    DefaultUrlSerializer.prototype.parse = function (url) {\\n        var p = new UrlParser(url);\\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\\n    };\\n    /** Converts a `UrlTree` into a url */\\n    DefaultUrlSerializer.prototype.serialize = function (tree) {\\n        var segment = \"/\" + serializeSegment(tree.root, true);\\n        var query = serializeQueryParams(tree.queryParams);\\n        var fragment = typeof tree.fragment === \"string\" ? \"#\" + encodeUriFragment(tree.fragment) : \\'\\';\\n        return \"\" + segment + query + fragment;\\n    };\\n    return DefaultUrlSerializer;\\n}());\\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\\nfunction serializePaths(segment) {\\n    return segment.segments.map(function (p) { return serializePath(p); }).join(\\'/\\');\\n}\\nfunction serializeSegment(segment, root) {\\n    if (!segment.hasChildren()) {\\n        return serializePaths(segment);\\n    }\\n    if (root) {\\n        var primary = segment.children[PRIMARY_OUTLET] ?\\n            serializeSegment(segment.children[PRIMARY_OUTLET], false) :\\n            \\'\\';\\n        var children_1 = [];\\n        forEach(segment.children, function (v, k) {\\n            if (k !== PRIMARY_OUTLET) {\\n                children_1.push(k + \":\" + serializeSegment(v, false));\\n            }\\n        });\\n        return children_1.length > 0 ? primary + \"(\" + children_1.join(\\'//\\') + \")\" : primary;\\n    }\\n    else {\\n        var children = mapChildrenIntoArray(segment, function (v, k) {\\n            if (k === PRIMARY_OUTLET) {\\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\\n            }\\n            return [k + \":\" + serializeSegment(v, false)];\\n        });\\n        return serializePaths(segment) + \"/(\" + children.join(\\'//\\') + \")\";\\n    }\\n}\\n/**\\n * Encodes a URI string with the default encoding. This function will only ever be called from\\n * `encodeUriQuery` or `encodeUriSegment` as it\\'s the base set of encodings to be used. We need\\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn\\'t\\n * have to be encoded per https://url.spec.whatwg.org.\\n */\\nfunction encodeUriString(s) {\\n    return encodeURIComponent(s)\\n        .replace(/%40/g, \\'@\\')\\n        .replace(/%3A/gi, \\':\\')\\n        .replace(/%24/g, \\'$\\')\\n        .replace(/%2C/gi, \\',\\');\\n}\\n/**\\n * This function should be used to encode both keys and values in a query string key/value. In\\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\\n *\\n * http://www.site.org/html;mk=mv?k=v#f\\n */\\nfunction encodeUriQuery(s) {\\n    return encodeUriString(s).replace(/%3B/gi, \\';\\');\\n}\\n/**\\n * This function should be used to encode a URL fragment. In the following URL, you need to call\\n * encodeUriFragment on \"f\":\\n *\\n * http://www.site.org/html;mk=mv?k=v#f\\n */\\nfunction encodeUriFragment(s) {\\n    return encodeURI(s);\\n}\\n/**\\n * This function should be run on any URI segment as well as the key and value in a key/value\\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\\n * \"mk\", and \"mv\":\\n *\\n * http://www.site.org/html;mk=mv?k=v#f\\n */\\nfunction encodeUriSegment(s) {\\n    return encodeUriString(s).replace(/\\\\(/g, \\'%28\\').replace(/\\\\)/g, \\'%29\\').replace(/%26/gi, \\'&\\');\\n}\\nfunction decode(s) {\\n    return decodeURIComponent(s);\\n}\\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\\n// decodeURIComponent function will not decode \"+\" as a space.\\nfunction decodeQuery(s) {\\n    return decode(s.replace(/\\\\+/g, \\'%20\\'));\\n}\\nfunction serializePath(path) {\\n    return \"\" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);\\n}\\nfunction serializeMatrixParams(params) {\\n    return Object.keys(params)\\n        .map(function (key) { return \";\" + encodeUriSegment(key) + \"=\" + encodeUriSegment(params[key]); })\\n        .join(\\'\\');\\n}\\nfunction serializeQueryParams(params) {\\n    var strParams = Object.keys(params).map(function (name) {\\n        var value = params[name];\\n        return Array.isArray(value) ?\\n            value.map(function (v) { return encodeUriQuery(name) + \"=\" + encodeUriQuery(v); }).join(\\'&\\') :\\n            encodeUriQuery(name) + \"=\" + encodeUriQuery(value);\\n    });\\n    return strParams.length ? \"?\" + strParams.join(\"&\") : \\'\\';\\n}\\nvar SEGMENT_RE = /^[^\\\\/()?;=#]+/;\\nfunction matchSegments(str) {\\n    var match = str.match(SEGMENT_RE);\\n    return match ? match[0] : \\'\\';\\n}\\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\\n// Return the name of the query param at the start of the string or an empty string\\nfunction matchQueryParams(str) {\\n    var match = str.match(QUERY_PARAM_RE);\\n    return match ? match[0] : \\'\\';\\n}\\nvar QUERY_PARAM_VALUE_RE = /^[^?&#]+/;\\n// Return the value of the query param at the start of the string or an empty string\\nfunction matchUrlQueryParamValue(str) {\\n    var match = str.match(QUERY_PARAM_VALUE_RE);\\n    return match ? match[0] : \\'\\';\\n}\\nvar UrlParser = /** @class */ (function () {\\n    function UrlParser(url) {\\n        this.url = url;\\n        this.remaining = url;\\n    }\\n    UrlParser.prototype.parseRootSegment = function () {\\n        this.consumeOptional(\\'/\\');\\n        if (this.remaining === \\'\\' || this.peekStartsWith(\\'?\\') || this.peekStartsWith(\\'#\\')) {\\n            return new UrlSegmentGroup([], {});\\n        }\\n        // The root segment group never has segments\\n        return new UrlSegmentGroup([], this.parseChildren());\\n    };\\n    UrlParser.prototype.parseQueryParams = function () {\\n        var params = {};\\n        if (this.consumeOptional(\\'?\\')) {\\n            do {\\n                this.parseQueryParam(params);\\n            } while (this.consumeOptional(\\'&\\'));\\n        }\\n        return params;\\n    };\\n    UrlParser.prototype.parseFragment = function () {\\n        return this.consumeOptional(\\'#\\') ? decodeURIComponent(this.remaining) : null;\\n    };\\n    UrlParser.prototype.parseChildren = function () {\\n        if (this.remaining === \\'\\') {\\n            return {};\\n        }\\n        this.consumeOptional(\\'/\\');\\n        var segments = [];\\n        if (!this.peekStartsWith(\\'(\\')) {\\n            segments.push(this.parseSegment());\\n        }\\n        while (this.peekStartsWith(\\'/\\') && !this.peekStartsWith(\\'//\\') && !this.peekStartsWith(\\'/(\\')) {\\n            this.capture(\\'/\\');\\n            segments.push(this.parseSegment());\\n        }\\n        var children = {};\\n        if (this.peekStartsWith(\\'/(\\')) {\\n            this.capture(\\'/\\');\\n            children = this.parseParens(true);\\n        }\\n        var res = {};\\n        if (this.peekStartsWith(\\'(\\')) {\\n            res = this.parseParens(false);\\n        }\\n        if (segments.length > 0 || Object.keys(children).length > 0) {\\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\\n        }\\n        return res;\\n    };\\n    // parse a segment with its matrix parameters\\n    // ie `name;k1=v1;k2`\\n    UrlParser.prototype.parseSegment = function () {\\n        var path = matchSegments(this.remaining);\\n        if (path === \\'\\' && this.peekStartsWith(\\';\\')) {\\n            throw new Error(\"Empty path url segment cannot have parameters: \\'\" + this.remaining + \"\\'.\");\\n        }\\n        this.capture(path);\\n        return new UrlSegment(decode(path), this.parseMatrixParams());\\n    };\\n    UrlParser.prototype.parseMatrixParams = function () {\\n        var params = {};\\n        while (this.consumeOptional(\\';\\')) {\\n            this.parseParam(params);\\n        }\\n        return params;\\n    };\\n    UrlParser.prototype.parseParam = function (params) {\\n        var key = matchSegments(this.remaining);\\n        if (!key) {\\n            return;\\n        }\\n        this.capture(key);\\n        var value = \\'\\';\\n        if (this.consumeOptional(\\'=\\')) {\\n            var valueMatch = matchSegments(this.remaining);\\n            if (valueMatch) {\\n                value = valueMatch;\\n                this.capture(value);\\n            }\\n        }\\n        params[decode(key)] = decode(value);\\n    };\\n    // Parse a single query parameter `name[=value]`\\n    UrlParser.prototype.parseQueryParam = function (params) {\\n        var key = matchQueryParams(this.remaining);\\n        if (!key) {\\n            return;\\n        }\\n        this.capture(key);\\n        var value = \\'\\';\\n        if (this.consumeOptional(\\'=\\')) {\\n            var valueMatch = matchUrlQueryParamValue(this.remaining);\\n            if (valueMatch) {\\n                value = valueMatch;\\n                this.capture(value);\\n            }\\n        }\\n        var decodedKey = decodeQuery(key);\\n        var decodedVal = decodeQuery(value);\\n        if (params.hasOwnProperty(decodedKey)) {\\n            // Append to existing values\\n            var currentVal = params[decodedKey];\\n            if (!Array.isArray(currentVal)) {\\n                currentVal = [currentVal];\\n                params[decodedKey] = currentVal;\\n            }\\n            currentVal.push(decodedVal);\\n        }\\n        else {\\n            // Create a new value\\n            params[decodedKey] = decodedVal;\\n        }\\n    };\\n    // parse `(a/b//outlet_name:c/d)`\\n    UrlParser.prototype.parseParens = function (allowPrimary) {\\n        var segments = {};\\n        this.capture(\\'(\\');\\n        while (!this.consumeOptional(\\')\\') && this.remaining.length > 0) {\\n            var path = matchSegments(this.remaining);\\n            var next = this.remaining[path.length];\\n            // if is is not one of these characters, then the segment was unescaped\\n            // or the group was not closed\\n            if (next !== \\'/\\' && next !== \\')\\' && next !== \\';\\') {\\n                throw new Error(\"Cannot parse url \\'\" + this.url + \"\\'\");\\n            }\\n            var outletName = undefined;\\n            if (path.indexOf(\\':\\') > -1) {\\n                outletName = path.substr(0, path.indexOf(\\':\\'));\\n                this.capture(outletName);\\n                this.capture(\\':\\');\\n            }\\n            else if (allowPrimary) {\\n                outletName = PRIMARY_OUTLET;\\n            }\\n            var children = this.parseChildren();\\n            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :\\n                new UrlSegmentGroup([], children);\\n            this.consumeOptional(\\'//\\');\\n        }\\n        return segments;\\n    };\\n    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };\\n    // Consumes the prefix when it is present and returns whether it has been consumed\\n    UrlParser.prototype.consumeOptional = function (str) {\\n        if (this.peekStartsWith(str)) {\\n            this.remaining = this.remaining.substring(str.length);\\n            return true;\\n        }\\n        return false;\\n    };\\n    UrlParser.prototype.capture = function (str) {\\n        if (!this.consumeOptional(str)) {\\n            throw new Error(\"Expected \\\\\"\" + str + \"\\\\\".\");\\n        }\\n    };\\n    return UrlParser;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar Tree = /** @class */ (function () {\\n    function Tree(root) {\\n        this._root = root;\\n    }\\n    Object.defineProperty(Tree.prototype, \"root\", {\\n        get: function () { return this._root.value; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * @internal\\n     */\\n    Tree.prototype.parent = function (t) {\\n        var p = this.pathFromRoot(t);\\n        return p.length > 1 ? p[p.length - 2] : null;\\n    };\\n    /**\\n     * @internal\\n     */\\n    Tree.prototype.children = function (t) {\\n        var n = findNode(t, this._root);\\n        return n ? n.children.map(function (t) { return t.value; }) : [];\\n    };\\n    /**\\n     * @internal\\n     */\\n    Tree.prototype.firstChild = function (t) {\\n        var n = findNode(t, this._root);\\n        return n && n.children.length > 0 ? n.children[0].value : null;\\n    };\\n    /**\\n     * @internal\\n     */\\n    Tree.prototype.siblings = function (t) {\\n        var p = findPath(t, this._root);\\n        if (p.length < 2)\\n            return [];\\n        var c = p[p.length - 2].children.map(function (c) { return c.value; });\\n        return c.filter(function (cc) { return cc !== t; });\\n    };\\n    /**\\n     * @internal\\n     */\\n    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };\\n    return Tree;\\n}());\\n// DFS for the node matching the value\\nfunction findNode(value, node) {\\n    var e_1, _a;\\n    if (value === node.value)\\n        return node;\\n    try {\\n        for (var _b = Object(tslib_es6[\"h\" /* __values */])(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {\\n            var child = _c.value;\\n            var node_1 = findNode(value, child);\\n            if (node_1)\\n                return node_1;\\n        }\\n    }\\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n    finally {\\n        try {\\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\\n        }\\n        finally { if (e_1) throw e_1.error; }\\n    }\\n    return null;\\n}\\n// Return the path to the node with the given value using DFS\\nfunction findPath(value, node) {\\n    var e_2, _a;\\n    if (value === node.value)\\n        return [node];\\n    try {\\n        for (var _b = Object(tslib_es6[\"h\" /* __values */])(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {\\n            var child = _c.value;\\n            var path = findPath(value, child);\\n            if (path.length) {\\n                path.unshift(node);\\n                return path;\\n            }\\n        }\\n    }\\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\\n    finally {\\n        try {\\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\\n        }\\n        finally { if (e_2) throw e_2.error; }\\n    }\\n    return [];\\n}\\nvar TreeNode = /** @class */ (function () {\\n    function TreeNode(value, children) {\\n        this.value = value;\\n        this.children = children;\\n    }\\n    TreeNode.prototype.toString = function () { return \"TreeNode(\" + this.value + \")\"; };\\n    return TreeNode;\\n}());\\n// Return the list of T indexed by outlet name\\nfunction nodeChildrenAsMap(node) {\\n    var map$$1 = {};\\n    if (node) {\\n        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });\\n    }\\n    return map$$1;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Represents the state of the router.\\n *\\n * RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL\\n * segments, the extracted parameters, and the resolved data.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * @Component({templateUrl:\\'template.html\\'})\\n * class MyComponent {\\n *   constructor(router: Router) {\\n *     const state: RouterState = router.routerState;\\n *     const root: ActivatedRoute = state.root;\\n *     const child = root.firstChild;\\n *     const id: Observable<string> = child.params.map(p => p.id);\\n *     //...\\n *   }\\n * }\\n * ```\\n *\\n * See `ActivatedRoute` for more information.\\n *\\n * @publicApi\\n */\\nvar router_RouterState = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(RouterState, _super);\\n    /** @internal */\\n    function RouterState(root, \\n    /** The current snapshot of the router state */\\n    snapshot) {\\n        var _this = _super.call(this, root) || this;\\n        _this.snapshot = snapshot;\\n        setRouterState(_this, root);\\n        return _this;\\n    }\\n    RouterState.prototype.toString = function () { return this.snapshot.toString(); };\\n    return RouterState;\\n}(Tree));\\nfunction createEmptyState(urlTree, rootComponent) {\\n    var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);\\n    var emptyUrl = new BehaviorSubject[\"a\" /* BehaviorSubject */]([new UrlSegment(\\'\\', {})]);\\n    var emptyParams = new BehaviorSubject[\"a\" /* BehaviorSubject */]({});\\n    var emptyData = new BehaviorSubject[\"a\" /* BehaviorSubject */]({});\\n    var emptyQueryParams = new BehaviorSubject[\"a\" /* BehaviorSubject */]({});\\n    var fragment = new BehaviorSubject[\"a\" /* BehaviorSubject */](\\'\\');\\n    var activated = new router_ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\\n    activated.snapshot = snapshot.root;\\n    return new router_RouterState(new TreeNode(activated, []), snapshot);\\n}\\nfunction createEmptyStateSnapshot(urlTree, rootComponent) {\\n    var emptyParams = {};\\n    var emptyData = {};\\n    var emptyQueryParams = {};\\n    var fragment = \\'\\';\\n    var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});\\n    return new router_RouterStateSnapshot(\\'\\', new TreeNode(activated, []));\\n}\\n/**\\n * @description\\n *\\n * Contains the information about a route associated with a component loaded in an\\n * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.\\n *\\n * ```\\n * @Component({...})\\n * class MyComponent {\\n *   constructor(route: ActivatedRoute) {\\n *     const id: Observable<string> = route.params.map(p => p.id);\\n *     const url: Observable<string> = route.url.map(segments => segments.join(\\'\\'));\\n *     // route.data includes both `data` and `resolve`\\n *     const user = route.data.map(d => d.user);\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar router_ActivatedRoute = /** @class */ (function () {\\n    /** @internal */\\n    function ActivatedRoute(\\n    /** An observable of the URL segments matched by this route */\\n    url, \\n    /** An observable of the matrix parameters scoped to this route */\\n    params, \\n    /** An observable of the query parameters shared by all the routes */\\n    queryParams, \\n    /** An observable of the URL fragment shared by all the routes */\\n    fragment, \\n    /** An observable of the static and resolved data of this route. */\\n    data, \\n    /** The outlet name of the route. It\\'s a constant */\\n    outlet, \\n    /** The component of the route. It\\'s a constant */\\n    // TODO(vsavkin): remove |string\\n    component, futureSnapshot) {\\n        this.url = url;\\n        this.params = params;\\n        this.queryParams = queryParams;\\n        this.fragment = fragment;\\n        this.data = data;\\n        this.outlet = outlet;\\n        this.component = component;\\n        this._futureSnapshot = futureSnapshot;\\n    }\\n    Object.defineProperty(ActivatedRoute.prototype, \"routeConfig\", {\\n        /** The configuration used to match this route */\\n        get: function () { return this._futureSnapshot.routeConfig; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"root\", {\\n        /** The root of the router state */\\n        get: function () { return this._routerState.root; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"parent\", {\\n        /** The parent of this route in the router state tree */\\n        get: function () { return this._routerState.parent(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"firstChild\", {\\n        /** The first child of this route in the router state tree */\\n        get: function () { return this._routerState.firstChild(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"children\", {\\n        /** The children of this route in the router state tree */\\n        get: function () { return this._routerState.children(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"pathFromRoot\", {\\n        /** The path from the root of the router state tree to this route */\\n        get: function () { return this._routerState.pathFromRoot(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"paramMap\", {\\n        get: function () {\\n            if (!this._paramMap) {\\n                this._paramMap = this.params.pipe(Object(map[\"a\" /* map */])(function (p) { return convertToParamMap(p); }));\\n            }\\n            return this._paramMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRoute.prototype, \"queryParamMap\", {\\n        get: function () {\\n            if (!this._queryParamMap) {\\n                this._queryParamMap =\\n                    this.queryParams.pipe(Object(map[\"a\" /* map */])(function (p) { return convertToParamMap(p); }));\\n            }\\n            return this._queryParamMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ActivatedRoute.prototype.toString = function () {\\n        return this.snapshot ? this.snapshot.toString() : \"Future(\" + this._futureSnapshot + \")\";\\n    };\\n    return ActivatedRoute;\\n}());\\n/**\\n * Returns the inherited params, data, and resolve for a given route.\\n * By default, this only inherits values up to the nearest path-less or component-less route.\\n * @internal\\n */\\nfunction inheritedParamsDataResolve(route, paramsInheritanceStrategy) {\\n    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = \\'emptyOnly\\'; }\\n    var pathFromRoot = route.pathFromRoot;\\n    var inheritingStartingFrom = 0;\\n    if (paramsInheritanceStrategy !== \\'always\\') {\\n        inheritingStartingFrom = pathFromRoot.length - 1;\\n        while (inheritingStartingFrom >= 1) {\\n            var current = pathFromRoot[inheritingStartingFrom];\\n            var parent_1 = pathFromRoot[inheritingStartingFrom - 1];\\n            // current route is an empty path => inherits its parent\\'s params and data\\n            if (current.routeConfig && current.routeConfig.path === \\'\\') {\\n                inheritingStartingFrom--;\\n                // parent is componentless => current route should inherit its params and data\\n            }\\n            else if (!parent_1.component) {\\n                inheritingStartingFrom--;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n    }\\n    return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));\\n}\\n/** @internal */\\nfunction flattenInherited(pathFromRoot) {\\n    return pathFromRoot.reduce(function (res, curr) {\\n        var params = Object(tslib_es6[\"a\" /* __assign */])({}, res.params, curr.params);\\n        var data = Object(tslib_es6[\"a\" /* __assign */])({}, res.data, curr.data);\\n        var resolve = Object(tslib_es6[\"a\" /* __assign */])({}, res.resolve, curr._resolvedData);\\n        return { params: params, data: data, resolve: resolve };\\n    }, { params: {}, data: {}, resolve: {} });\\n}\\n/**\\n * @description\\n *\\n * Contains the information about a route associated with a component loaded in an\\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\\n * traverse the router state tree.\\n *\\n * ```\\n * @Component({templateUrl:\\'./my-component.html\\'})\\n * class MyComponent {\\n *   constructor(route: ActivatedRoute) {\\n *     const id: string = route.snapshot.params.id;\\n *     const url: string = route.snapshot.url.join(\\'\\');\\n *     const user = route.snapshot.data.user;\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar ActivatedRouteSnapshot = /** @class */ (function () {\\n    /** @internal */\\n    function ActivatedRouteSnapshot(\\n    /** The URL segments matched by this route */\\n    url, \\n    /** The matrix parameters scoped to this route */\\n    params, \\n    /** The query parameters shared by all the routes */\\n    queryParams, \\n    /** The URL fragment shared by all the routes */\\n    fragment, \\n    /** The static and resolved data of this route */\\n    data, \\n    /** The outlet name of the route */\\n    outlet, \\n    /** The component of the route */\\n    component, routeConfig, urlSegment, lastPathIndex, resolve) {\\n        this.url = url;\\n        this.params = params;\\n        this.queryParams = queryParams;\\n        this.fragment = fragment;\\n        this.data = data;\\n        this.outlet = outlet;\\n        this.component = component;\\n        this.routeConfig = routeConfig;\\n        this._urlSegment = urlSegment;\\n        this._lastPathIndex = lastPathIndex;\\n        this._resolve = resolve;\\n    }\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"root\", {\\n        /** The root of the router state */\\n        get: function () { return this._routerState.root; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"parent\", {\\n        /** The parent of this route in the router state tree */\\n        get: function () { return this._routerState.parent(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"firstChild\", {\\n        /** The first child of this route in the router state tree */\\n        get: function () { return this._routerState.firstChild(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"children\", {\\n        /** The children of this route in the router state tree */\\n        get: function () { return this._routerState.children(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"pathFromRoot\", {\\n        /** The path from the root of the router state tree to this route */\\n        get: function () { return this._routerState.pathFromRoot(this); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"paramMap\", {\\n        get: function () {\\n            if (!this._paramMap) {\\n                this._paramMap = convertToParamMap(this.params);\\n            }\\n            return this._paramMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(ActivatedRouteSnapshot.prototype, \"queryParamMap\", {\\n        get: function () {\\n            if (!this._queryParamMap) {\\n                this._queryParamMap = convertToParamMap(this.queryParams);\\n            }\\n            return this._queryParamMap;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    ActivatedRouteSnapshot.prototype.toString = function () {\\n        var url = this.url.map(function (segment) { return segment.toString(); }).join(\\'/\\');\\n        var matched = this.routeConfig ? this.routeConfig.path : \\'\\';\\n        return \"Route(url:\\'\" + url + \"\\', path:\\'\" + matched + \"\\')\";\\n    };\\n    return ActivatedRouteSnapshot;\\n}());\\n/**\\n * @description\\n *\\n * Represents the state of the router at a moment in time.\\n *\\n * This is a tree of activated route snapshots. Every node in this tree knows about\\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * @Component({templateUrl:\\'template.html\\'})\\n * class MyComponent {\\n *   constructor(router: Router) {\\n *     const state: RouterState = router.routerState;\\n *     const snapshot: RouterStateSnapshot = state.snapshot;\\n *     const root: ActivatedRouteSnapshot = snapshot.root;\\n *     const child = root.firstChild;\\n *     const id: Observable<string> = child.params.map(p => p.id);\\n *     //...\\n *   }\\n * }\\n * ```\\n *\\n * @publicApi\\n */\\nvar router_RouterStateSnapshot = /** @class */ (function (_super) {\\n    Object(tslib_es6[\"c\" /* __extends */])(RouterStateSnapshot, _super);\\n    /** @internal */\\n    function RouterStateSnapshot(\\n    /** The url from which this snapshot was created */\\n    url, root) {\\n        var _this = _super.call(this, root) || this;\\n        _this.url = url;\\n        setRouterState(_this, root);\\n        return _this;\\n    }\\n    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };\\n    return RouterStateSnapshot;\\n}(Tree));\\nfunction setRouterState(state, node) {\\n    node.value._routerState = state;\\n    node.children.forEach(function (c) { return setRouterState(state, c); });\\n}\\nfunction serializeNode(node) {\\n    var c = node.children.length > 0 ? \" { \" + node.children.map(serializeNode).join(\\', \\') + \" } \" : \\'\\';\\n    return \"\" + node.value + c;\\n}\\n/**\\n * The expectation is that the activate route is created with the right set of parameters.\\n * So we push new values into the observables only when they are not the initial values.\\n * And we detect that by checking if the snapshot field is set.\\n */\\nfunction advanceActivatedRoute(route) {\\n    if (route.snapshot) {\\n        var currentSnapshot = route.snapshot;\\n        var nextSnapshot = route._futureSnapshot;\\n        route.snapshot = nextSnapshot;\\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\\n            route.queryParams.next(nextSnapshot.queryParams);\\n        }\\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\\n            route.fragment.next(nextSnapshot.fragment);\\n        }\\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\\n            route.params.next(nextSnapshot.params);\\n        }\\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\\n            route.url.next(nextSnapshot.url);\\n        }\\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\\n            route.data.next(nextSnapshot.data);\\n        }\\n    }\\n    else {\\n        route.snapshot = route._futureSnapshot;\\n        // this is for resolved data\\n        route.data.next(route._futureSnapshot.data);\\n    }\\n}\\nfunction equalParamsAndUrlSegments(a, b) {\\n    var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\\n    var parentsMismatch = !a.parent !== !b.parent;\\n    return equalUrlParams && !parentsMismatch &&\\n        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\\n    var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\\n    return new router_RouterState(root, curr);\\n}\\nfunction createNode(routeReuseStrategy, curr, prevState) {\\n    // reuse an activated route that is currently displayed on the screen\\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\\n        var value = prevState.value;\\n        value._futureSnapshot = curr.value;\\n        var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\\n        return new TreeNode(value, children);\\n        // retrieve an activated route that is used to be displayed, but is not currently displayed\\n    }\\n    else {\\n        var detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\\n        if (detachedRouteHandle) {\\n            var tree = detachedRouteHandle.route;\\n            setFutureSnapshotsOfActivatedRoutes(curr, tree);\\n            return tree;\\n        }\\n        else {\\n            var value = createActivatedRoute(curr.value);\\n            var children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });\\n            return new TreeNode(value, children);\\n        }\\n    }\\n}\\nfunction setFutureSnapshotsOfActivatedRoutes(curr, result) {\\n    if (curr.value.routeConfig !== result.value.routeConfig) {\\n        throw new Error(\\'Cannot reattach ActivatedRouteSnapshot created from a different route\\');\\n    }\\n    if (curr.children.length !== result.children.length) {\\n        throw new Error(\\'Cannot reattach ActivatedRouteSnapshot with a different number of children\\');\\n    }\\n    result.value._futureSnapshot = curr.value;\\n    for (var i = 0; i < curr.children.length; ++i) {\\n        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);\\n    }\\n}\\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\\n    return curr.children.map(function (child) {\\n        var e_1, _a;\\n        try {\\n            for (var _b = Object(tslib_es6[\"h\" /* __values */])(prevState.children), _c = _b.next(); !_c.done; _c = _b.next()) {\\n                var p = _c.value;\\n                if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {\\n                    return createNode(routeReuseStrategy, child, p);\\n                }\\n            }\\n        }\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n        finally {\\n            try {\\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\\n            }\\n            finally { if (e_1) throw e_1.error; }\\n        }\\n        return createNode(routeReuseStrategy, child);\\n    });\\n}\\nfunction createActivatedRoute(c) {\\n    return new router_ActivatedRoute(new BehaviorSubject[\"a\" /* BehaviorSubject */](c.url), new BehaviorSubject[\"a\" /* BehaviorSubject */](c.params), new BehaviorSubject[\"a\" /* BehaviorSubject */](c.queryParams), new BehaviorSubject[\"a\" /* BehaviorSubject */](c.fragment), new BehaviorSubject[\"a\" /* BehaviorSubject */](c.data), c.outlet, c.component, c);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction createUrlTree(route, urlTree, commands, queryParams, fragment) {\\n    if (commands.length === 0) {\\n        return router_tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);\\n    }\\n    var nav = computeNavigation(commands);\\n    if (nav.toRoot()) {\\n        return router_tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);\\n    }\\n    var startingPosition = findStartingPosition(nav, urlTree, route);\\n    var segmentGroup = startingPosition.processChildren ?\\n        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :\\n        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);\\n    return router_tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);\\n}\\nfunction isMatrixParams(command) {\\n    return typeof command === \\'object\\' && command != null && !command.outlets && !command.segmentPath;\\n}\\nfunction router_tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {\\n    var qp = {};\\n    if (queryParams) {\\n        forEach(queryParams, function (value, name) {\\n            qp[name] = Array.isArray(value) ? value.map(function (v) { return \"\" + v; }) : \"\" + value;\\n        });\\n    }\\n    if (urlTree.root === oldSegmentGroup) {\\n        return new UrlTree(newSegmentGroup, qp, fragment);\\n    }\\n    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);\\n}\\nfunction replaceSegment(current, oldSegment, newSegment) {\\n    var children = {};\\n    forEach(current.children, function (c, outletName) {\\n        if (c === oldSegment) {\\n            children[outletName] = newSegment;\\n        }\\n        else {\\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\\n        }\\n    });\\n    return new UrlSegmentGroup(current.segments, children);\\n}\\nvar Navigation = /** @class */ (function () {\\n    function Navigation(isAbsolute, numberOfDoubleDots, commands) {\\n        this.isAbsolute = isAbsolute;\\n        this.numberOfDoubleDots = numberOfDoubleDots;\\n        this.commands = commands;\\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\\n            throw new Error(\\'Root segment cannot have matrix parameters\\');\\n        }\\n        var cmdWithOutlet = commands.find(function (c) { return typeof c === \\'object\\' && c != null && c.outlets; });\\n        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {\\n            throw new Error(\\'{outlets:{}} has to be the last command\\');\\n        }\\n    }\\n    Navigation.prototype.toRoot = function () {\\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == \\'/\\';\\n    };\\n    return Navigation;\\n}());\\n/** Transforms commands to a normalized `Navigation` */\\nfunction computeNavigation(commands) {\\n    if ((typeof commands[0] === \\'string\\') && commands.length === 1 && commands[0] === \\'/\\') {\\n        return new Navigation(true, 0, commands);\\n    }\\n    var numberOfDoubleDots = 0;\\n    var isAbsolute = false;\\n    var res = commands.reduce(function (res, cmd, cmdIdx) {\\n        if (typeof cmd === \\'object\\' && cmd != null) {\\n            if (cmd.outlets) {\\n                var outlets_1 = {};\\n                forEach(cmd.outlets, function (commands, name) {\\n                    outlets_1[name] = typeof commands === \\'string\\' ? commands.split(\\'/\\') : commands;\\n                });\\n                return Object(tslib_es6[\"g\" /* __spread */])(res, [{ outlets: outlets_1 }]);\\n            }\\n            if (cmd.segmentPath) {\\n                return Object(tslib_es6[\"g\" /* __spread */])(res, [cmd.segmentPath]);\\n            }\\n        }\\n        if (!(typeof cmd === \\'string\\')) {\\n            return Object(tslib_es6[\"g\" /* __spread */])(res, [cmd]);\\n        }\\n        if (cmdIdx === 0) {\\n            cmd.split(\\'/\\').forEach(function (urlPart, partIndex) {\\n                if (partIndex == 0 && urlPart === \\'.\\') ;\\n                else if (partIndex == 0 && urlPart === \\'\\') { //  \\'/a\\'\\n                    isAbsolute = true;\\n                }\\n                else if (urlPart === \\'..\\') { //  \\'../a\\'\\n                    numberOfDoubleDots++;\\n                }\\n                else if (urlPart != \\'\\') {\\n                    res.push(urlPart);\\n                }\\n            });\\n            return res;\\n        }\\n        return Object(tslib_es6[\"g\" /* __spread */])(res, [cmd]);\\n    }, []);\\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\\n}\\nvar Position = /** @class */ (function () {\\n    function Position(segmentGroup, processChildren, index) {\\n        this.segmentGroup = segmentGroup;\\n        this.processChildren = processChildren;\\n        this.index = index;\\n    }\\n    return Position;\\n}());\\nfunction findStartingPosition(nav, tree, route) {\\n    if (nav.isAbsolute) {\\n        return new Position(tree.root, true, 0);\\n    }\\n    if (route.snapshot._lastPathIndex === -1) {\\n        return new Position(route.snapshot._urlSegment, true, 0);\\n    }\\n    var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\\n    var index = route.snapshot._lastPathIndex + modifier;\\n    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);\\n}\\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\\n    var g = group;\\n    var ci = index;\\n    var dd = numberOfDoubleDots;\\n    while (dd > ci) {\\n        dd -= ci;\\n        g = g.parent;\\n        if (!g) {\\n            throw new Error(\\'Invalid number of \\\\\\'../\\\\\\'\\');\\n        }\\n        ci = g.segments.length;\\n    }\\n    return new Position(g, false, ci - dd);\\n}\\nfunction getPath(command) {\\n    if (typeof command === \\'object\\' && command != null && command.outlets) {\\n        return command.outlets[PRIMARY_OUTLET];\\n    }\\n    return \"\" + command;\\n}\\nfunction getOutlets(commands) {\\n    var _a, _b;\\n    if (!(typeof commands[0] === \\'object\\'))\\n        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;\\n    if (commands[0].outlets === undefined)\\n        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;\\n    return commands[0].outlets;\\n}\\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\\n    if (!segmentGroup) {\\n        segmentGroup = new UrlSegmentGroup([], {});\\n    }\\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\\n    }\\n    var m = prefixedWith(segmentGroup, startIndex, commands);\\n    var slicedCommands = commands.slice(m.commandIndex);\\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\\n        var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\\n        g.children[PRIMARY_OUTLET] =\\n            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\\n    }\\n    else if (m.match && slicedCommands.length === 0) {\\n        return new UrlSegmentGroup(segmentGroup.segments, {});\\n    }\\n    else if (m.match && !segmentGroup.hasChildren()) {\\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\\n    }\\n    else if (m.match) {\\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\\n    }\\n    else {\\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\\n    }\\n}\\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\\n    if (commands.length === 0) {\\n        return new UrlSegmentGroup(segmentGroup.segments, {});\\n    }\\n    else {\\n        var outlets_2 = getOutlets(commands);\\n        var children_1 = {};\\n        forEach(outlets_2, function (commands, outlet) {\\n            if (commands !== null) {\\n                children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\\n            }\\n        });\\n        forEach(segmentGroup.children, function (child, childOutlet) {\\n            if (outlets_2[childOutlet] === undefined) {\\n                children_1[childOutlet] = child;\\n            }\\n        });\\n        return new UrlSegmentGroup(segmentGroup.segments, children_1);\\n    }\\n}\\nfunction prefixedWith(segmentGroup, startIndex, commands) {\\n    var currentCommandIndex = 0;\\n    var currentPathIndex = startIndex;\\n    var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\\n    while (currentPathIndex < segmentGroup.segments.length) {\\n        if (currentCommandIndex >= commands.length)\\n            return noMatch;\\n        var path = segmentGroup.segments[currentPathIndex];\\n        var curr = getPath(commands[currentCommandIndex]);\\n        var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\\n        if (currentPathIndex > 0 && curr === undefined)\\n            break;\\n        if (curr && next && (typeof next === \\'object\\') && next.outlets === undefined) {\\n            if (!compare(curr, next, path))\\n                return noMatch;\\n            currentCommandIndex += 2;\\n        }\\n        else {\\n            if (!compare(curr, {}, path))\\n                return noMatch;\\n            currentCommandIndex++;\\n        }\\n        currentPathIndex++;\\n    }\\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\\n}\\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\\n    var paths = segmentGroup.segments.slice(0, startIndex);\\n    var i = 0;\\n    while (i < commands.length) {\\n        if (typeof commands[i] === \\'object\\' && commands[i].outlets !== undefined) {\\n            var children = createNewSegmentChildren(commands[i].outlets);\\n            return new UrlSegmentGroup(paths, children);\\n        }\\n        // if we start with an object literal, we need to reuse the path part from the segment\\n        if (i === 0 && isMatrixParams(commands[0])) {\\n            var p = segmentGroup.segments[startIndex];\\n            paths.push(new UrlSegment(p.path, commands[0]));\\n            i++;\\n            continue;\\n        }\\n        var curr = getPath(commands[i]);\\n        var next = (i < commands.length - 1) ? commands[i + 1] : null;\\n        if (curr && next && isMatrixParams(next)) {\\n            paths.push(new UrlSegment(curr, stringify(next)));\\n            i += 2;\\n        }\\n        else {\\n            paths.push(new UrlSegment(curr, {}));\\n            i++;\\n        }\\n    }\\n    return new UrlSegmentGroup(paths, {});\\n}\\nfunction createNewSegmentChildren(outlets) {\\n    var children = {};\\n    forEach(outlets, function (commands, outlet) {\\n        if (commands !== null) {\\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\\n        }\\n    });\\n    return children;\\n}\\nfunction stringify(params) {\\n    var res = {};\\n    forEach(params, function (v, k) { return res[k] = \"\" + v; });\\n    return res;\\n}\\nfunction compare(path, params, segment) {\\n    return path == segment.path && shallowEqual(params, segment.parameters);\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar activateRoutes = function (rootContexts, routeReuseStrategy, forwardEvent) {\\n    return Object(map[\"a\" /* map */])(function (t) {\\n        new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent)\\n            .activate(rootContexts);\\n        return t;\\n    });\\n};\\nvar ActivateRoutes = /** @class */ (function () {\\n    function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {\\n        this.routeReuseStrategy = routeReuseStrategy;\\n        this.futureState = futureState;\\n        this.currState = currState;\\n        this.forwardEvent = forwardEvent;\\n    }\\n    ActivateRoutes.prototype.activate = function (parentContexts) {\\n        var futureRoot = this.futureState._root;\\n        var currRoot = this.currState ? this.currState._root : null;\\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\\n        advanceActivatedRoute(this.futureState.root);\\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\\n    };\\n    // De-activate the child route that are not re-used for the future state\\n    ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {\\n        var _this = this;\\n        var children = nodeChildrenAsMap(currNode);\\n        // Recurse on the routes active in the future state to de-activate deeper children\\n        futureNode.children.forEach(function (futureChild) {\\n            var childOutletName = futureChild.value.outlet;\\n            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);\\n            delete children[childOutletName];\\n        });\\n        // De-activate the routes that will not be re-used\\n        forEach(children, function (v, childName) {\\n            _this.deactivateRouteAndItsChildren(v, contexts);\\n        });\\n    };\\n    ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {\\n        var future = futureNode.value;\\n        var curr = currNode ? currNode.value : null;\\n        if (future === curr) {\\n            // Reusing the node, check to see if the children need to be de-activated\\n            if (future.component) {\\n                // If we have a normal route, we need to go through an outlet.\\n                var context = parentContext.getContext(future.outlet);\\n                if (context) {\\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\\n                }\\n            }\\n            else {\\n                // if we have a componentless route, we recurse but keep the same outlet map.\\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\\n            }\\n        }\\n        else {\\n            if (curr) {\\n                // Deactivate the current route which will not be re-used\\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\\n            }\\n        }\\n    };\\n    ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {\\n        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\\n            this.detachAndStoreRouteSubtree(route, parentContexts);\\n        }\\n        else {\\n            this.deactivateRouteAndOutlet(route, parentContexts);\\n        }\\n    };\\n    ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {\\n        var context = parentContexts.getContext(route.value.outlet);\\n        if (context && context.outlet) {\\n            var componentRef = context.outlet.detach();\\n            var contexts = context.children.onOutletDeactivated();\\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });\\n        }\\n    };\\n    ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {\\n        var _this = this;\\n        var context = parentContexts.getContext(route.value.outlet);\\n        if (context) {\\n            var children = nodeChildrenAsMap(route);\\n            var contexts_1 = route.value.component ? context.children : parentContexts;\\n            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });\\n            if (context.outlet) {\\n                // Destroy the component\\n                context.outlet.deactivate();\\n                // Destroy the contexts for all the outlets that were in the component\\n                context.children.onOutletDeactivated();\\n            }\\n        }\\n    };\\n    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {\\n        var _this = this;\\n        var children = nodeChildrenAsMap(currNode);\\n        futureNode.children.forEach(function (c) {\\n            _this.activateRoutes(c, children[c.value.outlet], contexts);\\n            _this.forwardEvent(new ActivationEnd(c.value.snapshot));\\n        });\\n        if (futureNode.children.length) {\\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\\n        }\\n    };\\n    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {\\n        var future = futureNode.value;\\n        var curr = currNode ? currNode.value : null;\\n        advanceActivatedRoute(future);\\n        // reusing the node\\n        if (future === curr) {\\n            if (future.component) {\\n                // If we have a normal route, we need to go through an outlet.\\n                var context = parentContexts.getOrCreateContext(future.outlet);\\n                this.activateChildRoutes(futureNode, currNode, context.children);\\n            }\\n            else {\\n                // if we have a componentless route, we recurse but keep the same outlet map.\\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\\n            }\\n        }\\n        else {\\n            if (future.component) {\\n                // if we have a normal route, we need to place the component into the outlet and recurse.\\n                var context = parentContexts.getOrCreateContext(future.outlet);\\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\\n                    var stored = this.routeReuseStrategy.retrieve(future.snapshot);\\n                    this.routeReuseStrategy.store(future.snapshot, null);\\n                    context.children.onOutletReAttached(stored.contexts);\\n                    context.attachRef = stored.componentRef;\\n                    context.route = stored.route.value;\\n                    if (context.outlet) {\\n                        // Attach right away when the outlet has already been instantiated\\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\\n                        context.outlet.attach(stored.componentRef, stored.route.value);\\n                    }\\n                    advanceActivatedRouteNodeAndItsChildren(stored.route);\\n                }\\n                else {\\n                    var config = parentLoadedConfig(future.snapshot);\\n                    var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\\n                    context.attachRef = null;\\n                    context.route = future;\\n                    context.resolver = cmpFactoryResolver;\\n                    if (context.outlet) {\\n                        // Activate the outlet when it has already been instantiated\\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\\n                        context.outlet.activateWith(future, cmpFactoryResolver);\\n                    }\\n                    this.activateChildRoutes(futureNode, null, context.children);\\n                }\\n            }\\n            else {\\n                // if we have a componentless route, we recurse but keep the same outlet map.\\n                this.activateChildRoutes(futureNode, null, parentContexts);\\n            }\\n        }\\n    };\\n    return ActivateRoutes;\\n}());\\nfunction advanceActivatedRouteNodeAndItsChildren(node) {\\n    advanceActivatedRoute(node.value);\\n    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\\n}\\nfunction parentLoadedConfig(snapshot) {\\n    for (var s = snapshot.parent; s; s = s.parent) {\\n        var route = s.routeConfig;\\n        if (route && route._loadedConfig)\\n            return route._loadedConfig;\\n        if (route && route.component)\\n            return null;\\n    }\\n    return null;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar NoMatch = /** @class */ (function () {\\n    function NoMatch(segmentGroup) {\\n        this.segmentGroup = segmentGroup || null;\\n    }\\n    return NoMatch;\\n}());\\nvar AbsoluteRedirect = /** @class */ (function () {\\n    function AbsoluteRedirect(urlTree) {\\n        this.urlTree = urlTree;\\n    }\\n    return AbsoluteRedirect;\\n}());\\nfunction noMatch(segmentGroup) {\\n    return new Observable[\"a\" /* Observable */](function (obs) { return obs.error(new NoMatch(segmentGroup)); });\\n}\\nfunction absoluteRedirect(newTree) {\\n    return new Observable[\"a\" /* Observable */](function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });\\n}\\nfunction namedOutletsRedirect(redirectTo) {\\n    return new Observable[\"a\" /* Observable */](function (obs) { return obs.error(new Error(\"Only absolute redirects can have named outlets. redirectTo: \\'\" + redirectTo + \"\\'\")); });\\n}\\nfunction canLoadFails(route) {\\n    return new Observable[\"a\" /* Observable */](function (obs) { return obs.error(navigationCancelingError(\"Cannot load children because the guard of the route \\\\\"path: \\'\" + route.path + \"\\'\\\\\" returned false\")); });\\n}\\n/**\\n * Returns the `UrlTree` with the redirection applied.\\n *\\n * Lazy modules are loaded along the way.\\n */\\nfunction applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\\n    return new router_ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\\n}\\nvar router_ApplyRedirects = /** @class */ (function () {\\n    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {\\n        this.configLoader = configLoader;\\n        this.urlSerializer = urlSerializer;\\n        this.urlTree = urlTree;\\n        this.config = config;\\n        this.allowRedirects = true;\\n        this.ngModule = moduleInjector.get(core[\"NgModuleRef\"]);\\n    }\\n    ApplyRedirects.prototype.apply = function () {\\n        var _this = this;\\n        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\\n        var urlTrees$ = expanded$.pipe(Object(map[\"a\" /* map */])(function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); }));\\n        return urlTrees$.pipe(catchError(function (e) {\\n            if (e instanceof AbsoluteRedirect) {\\n                // after an absolute redirect we do not apply any more redirects!\\n                _this.allowRedirects = false;\\n                // we need to run matching, so we can fetch all lazy-loaded modules\\n                return _this.match(e.urlTree);\\n            }\\n            if (e instanceof NoMatch) {\\n                throw _this.noMatchError(e);\\n            }\\n            throw e;\\n        }));\\n    };\\n    ApplyRedirects.prototype.match = function (tree) {\\n        var _this = this;\\n        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\\n        var mapped$ = expanded$.pipe(Object(map[\"a\" /* map */])(function (rootSegmentGroup) {\\n            return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);\\n        }));\\n        return mapped$.pipe(catchError(function (e) {\\n            if (e instanceof NoMatch) {\\n                throw _this.noMatchError(e);\\n            }\\n            throw e;\\n        }));\\n    };\\n    ApplyRedirects.prototype.noMatchError = function (e) {\\n        return new Error(\"Cannot match any routes. URL Segment: \\'\" + e.segmentGroup + \"\\'\");\\n    };\\n    ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {\\n        var _a;\\n        var root = rootCandidate.segments.length > 0 ?\\n            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :\\n            rootCandidate;\\n        return new UrlTree(root, queryParams, fragment);\\n    };\\n    ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {\\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\\n            return this.expandChildren(ngModule, routes, segmentGroup)\\n                .pipe(Object(map[\"a\" /* map */])(function (children) { return new UrlSegmentGroup([], children); }));\\n        }\\n        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\\n    };\\n    // Recursively expand segment groups for all the child outlets\\n    ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {\\n        var _this = this;\\n        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });\\n    };\\n    ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {\\n        var _this = this;\\n        return of[\"a\" /* of */].apply(void 0, Object(tslib_es6[\"g\" /* __spread */])(routes)).pipe(Object(map[\"a\" /* map */])(function (r) {\\n            var expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\\n            return expanded$.pipe(catchError(function (e) {\\n                if (e instanceof NoMatch) {\\n                    // TODO(i): this return type doesn\\'t match the declared Observable<UrlSegmentGroup> -\\n                    // talk to Jason\\n                    return Object(of[\"a\" /* of */])(null);\\n                }\\n                throw e;\\n            }));\\n        }), Object(concatAll[\"a\" /* concatAll */])(), first(function (s) { return !!s; }), catchError(function (e, _) {\\n            if (e instanceof EmptyError[\"a\" /* EmptyError */] || e.name === \\'EmptyError\\') {\\n                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\\n                    return Object(of[\"a\" /* of */])(new UrlSegmentGroup([], {}));\\n                }\\n                throw new NoMatch(segmentGroup);\\n            }\\n            throw e;\\n        }));\\n    };\\n    ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\\n        return segments.length === 0 && !segmentGroup.children[outlet];\\n    };\\n    ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {\\n        if (getOutlet(route) !== outlet) {\\n            return noMatch(segmentGroup);\\n        }\\n        if (route.redirectTo === undefined) {\\n            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\\n        }\\n        if (allowRedirects && this.allowRedirects) {\\n            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);\\n        }\\n        return noMatch(segmentGroup);\\n    };\\n    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {\\n        if (route.path === \\'**\\') {\\n            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);\\n        }\\n        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);\\n    };\\n    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {\\n        var _this = this;\\n        var newTree = this.applyRedirectCommands([], route.redirectTo, {});\\n        if (route.redirectTo.startsWith(\\'/\\')) {\\n            return absoluteRedirect(newTree);\\n        }\\n        return this.lineralizeSegments(route, newTree).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (newSegments) {\\n            var group = new UrlSegmentGroup(newSegments, {});\\n            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\\n        }));\\n    };\\n    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {\\n        var _this = this;\\n        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;\\n        if (!matched)\\n            return noMatch(segmentGroup);\\n        var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);\\n        if (route.redirectTo.startsWith(\\'/\\')) {\\n            return absoluteRedirect(newTree);\\n        }\\n        return this.lineralizeSegments(route, newTree).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (newSegments) {\\n            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);\\n        }));\\n    };\\n    ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {\\n        var _this = this;\\n        if (route.path === \\'**\\') {\\n            if (route.loadChildren) {\\n                return this.configLoader.load(ngModule.injector, route)\\n                    .pipe(Object(map[\"a\" /* map */])(function (cfg) {\\n                    route._loadedConfig = cfg;\\n                    return new UrlSegmentGroup(segments, {});\\n                }));\\n            }\\n            return Object(of[\"a\" /* of */])(new UrlSegmentGroup(segments, {}));\\n        }\\n        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;\\n        if (!matched)\\n            return noMatch(rawSegmentGroup);\\n        var rawSlicedSegments = segments.slice(lastChild);\\n        var childConfig$ = this.getChildConfig(ngModule, route, segments);\\n        return childConfig$.pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (routerConfig) {\\n            var childModule = routerConfig.module;\\n            var childConfig = routerConfig.routes;\\n            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\\n            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\\n                var expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);\\n                return expanded$_1.pipe(Object(map[\"a\" /* map */])(function (children) { return new UrlSegmentGroup(consumedSegments, children); }));\\n            }\\n            if (childConfig.length === 0 && slicedSegments.length === 0) {\\n                return Object(of[\"a\" /* of */])(new UrlSegmentGroup(consumedSegments, {}));\\n            }\\n            var expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\\n            return expanded$.pipe(Object(map[\"a\" /* map */])(function (cs) {\\n                return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);\\n            }));\\n        }));\\n    };\\n    ApplyRedirects.prototype.getChildConfig = function (ngModule, route, segments) {\\n        var _this = this;\\n        if (route.children) {\\n            // The children belong to the same module\\n            return Object(of[\"a\" /* of */])(new LoadedRouterConfig(route.children, ngModule));\\n        }\\n        if (route.loadChildren) {\\n            // lazy children belong to the loaded module\\n            if (route._loadedConfig !== undefined) {\\n                return Object(of[\"a\" /* of */])(route._loadedConfig);\\n            }\\n            return runCanLoadGuard(ngModule.injector, route, segments)\\n                .pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (shouldLoad) {\\n                if (shouldLoad) {\\n                    return _this.configLoader.load(ngModule.injector, route)\\n                        .pipe(Object(map[\"a\" /* map */])(function (cfg) {\\n                        route._loadedConfig = cfg;\\n                        return cfg;\\n                    }));\\n                }\\n                return canLoadFails(route);\\n            }));\\n        }\\n        return Object(of[\"a\" /* of */])(new LoadedRouterConfig([], ngModule));\\n    };\\n    ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {\\n        var res = [];\\n        var c = urlTree.root;\\n        while (true) {\\n            res = res.concat(c.segments);\\n            if (c.numberOfChildren === 0) {\\n                return Object(of[\"a\" /* of */])(res);\\n            }\\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\\n                return namedOutletsRedirect(route.redirectTo);\\n            }\\n            c = c.children[PRIMARY_OUTLET];\\n        }\\n    };\\n    ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {\\n        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\\n    };\\n    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {\\n        var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\\n    };\\n    ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {\\n        var res = {};\\n        forEach(redirectToParams, function (v, k) {\\n            var copySourceValue = typeof v === \\'string\\' && v.startsWith(\\':\\');\\n            if (copySourceValue) {\\n                var sourceName = v.substring(1);\\n                res[k] = actualParams[sourceName];\\n            }\\n            else {\\n                res[k] = v;\\n            }\\n        });\\n        return res;\\n    };\\n    ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {\\n        var _this = this;\\n        var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\\n        var children = {};\\n        forEach(group.children, function (child, name) {\\n            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);\\n        });\\n        return new UrlSegmentGroup(updatedSegments, children);\\n    };\\n    ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {\\n        var _this = this;\\n        return redirectToSegments.map(function (s) { return s.path.startsWith(\\':\\') ? _this.findPosParam(redirectTo, s, posParams) :\\n            _this.findOrReturn(s, actualSegments); });\\n    };\\n    ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {\\n        var pos = posParams[redirectToUrlSegment.path.substring(1)];\\n        if (!pos)\\n            throw new Error(\"Cannot redirect to \\'\" + redirectTo + \"\\'. Cannot find \\'\" + redirectToUrlSegment.path + \"\\'.\");\\n        return pos;\\n    };\\n    ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {\\n        var e_1, _a;\\n        var idx = 0;\\n        try {\\n            for (var actualSegments_1 = Object(tslib_es6[\"h\" /* __values */])(actualSegments), actualSegments_1_1 = actualSegments_1.next(); !actualSegments_1_1.done; actualSegments_1_1 = actualSegments_1.next()) {\\n                var s = actualSegments_1_1.value;\\n                if (s.path === redirectToUrlSegment.path) {\\n                    actualSegments.splice(idx);\\n                    return s;\\n                }\\n                idx++;\\n            }\\n        }\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n        finally {\\n            try {\\n                if (actualSegments_1_1 && !actualSegments_1_1.done && (_a = actualSegments_1.return)) _a.call(actualSegments_1);\\n            }\\n            finally { if (e_1) throw e_1.error; }\\n        }\\n        return redirectToUrlSegment;\\n    };\\n    return ApplyRedirects;\\n}());\\nfunction runCanLoadGuard(moduleInjector, route, segments) {\\n    var canLoad = route.canLoad;\\n    if (!canLoad || canLoad.length === 0)\\n        return Object(of[\"a\" /* of */])(true);\\n    var obs = Object(from[\"a\" /* from */])(canLoad).pipe(Object(map[\"a\" /* map */])(function (injectionToken) {\\n        var guard = moduleInjector.get(injectionToken);\\n        return wrapIntoObservable(guard.canLoad ? guard.canLoad(route, segments) : guard(route, segments));\\n    }));\\n    return andObservables(obs);\\n}\\nfunction match(segmentGroup, route, segments) {\\n    if (route.path === \\'\\') {\\n        if ((route.pathMatch === \\'full\\') && (segmentGroup.hasChildren() || segments.length > 0)) {\\n            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\\n        }\\n        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };\\n    }\\n    var matcher = route.matcher || defaultUrlMatcher;\\n    var res = matcher(segments, segmentGroup, route);\\n    if (!res) {\\n        return {\\n            matched: false,\\n            consumedSegments: [],\\n            lastChild: 0,\\n            positionalParamSegments: {},\\n        };\\n    }\\n    return {\\n        matched: true,\\n        consumedSegments: res.consumed,\\n        lastChild: res.consumed.length,\\n        positionalParamSegments: res.posParams,\\n    };\\n}\\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\\n    if (slicedSegments.length > 0 &&\\n        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\\n        var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };\\n    }\\n    if (slicedSegments.length === 0 &&\\n        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\\n        var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\\n        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };\\n    }\\n    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };\\n}\\nfunction mergeTrivialChildren(s) {\\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\\n        var c = s.children[PRIMARY_OUTLET];\\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\\n    }\\n    return s;\\n}\\nfunction addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\\n    var e_2, _a;\\n    var res = {};\\n    try {\\n        for (var routes_1 = Object(tslib_es6[\"h\" /* __values */])(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\\n            var r = routes_1_1.value;\\n            if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\\n                res[getOutlet(r)] = new UrlSegmentGroup([], {});\\n            }\\n        }\\n    }\\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\\n    finally {\\n        try {\\n            if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\\n        }\\n        finally { if (e_2) throw e_2.error; }\\n    }\\n    return Object(tslib_es6[\"a\" /* __assign */])({}, children, res);\\n}\\nfunction createChildrenForEmptySegments(routes, primarySegmentGroup) {\\n    var e_3, _a;\\n    var res = {};\\n    res[PRIMARY_OUTLET] = primarySegmentGroup;\\n    try {\\n        for (var routes_2 = Object(tslib_es6[\"h\" /* __values */])(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {\\n            var r = routes_2_1.value;\\n            if (r.path === \\'\\' && getOutlet(r) !== PRIMARY_OUTLET) {\\n                res[getOutlet(r)] = new UrlSegmentGroup([], {});\\n            }\\n        }\\n    }\\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\\n    finally {\\n        try {\\n            if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);\\n        }\\n        finally { if (e_3) throw e_3.error; }\\n    }\\n    return res;\\n}\\nfunction containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {\\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });\\n}\\nfunction containsEmptyPathRedirects(segmentGroup, segments, routes) {\\n    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });\\n}\\nfunction isEmptyPathRedirect(segmentGroup, segments, r) {\\n    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === \\'full\\') {\\n        return false;\\n    }\\n    return r.path === \\'\\' && r.redirectTo !== undefined;\\n}\\nfunction getOutlet(route) {\\n    return route.outlet || PRIMARY_OUTLET;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {\\n    return function (source) {\\n        return source.pipe(switchMap(function (t) { return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config)\\n            .pipe(Object(map[\"a\" /* map */])(function (urlAfterRedirects) { return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { urlAfterRedirects: urlAfterRedirects })); })); }));\\n    };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar CanActivate = /** @class */ (function () {\\n    function CanActivate(path) {\\n        this.path = path;\\n        this.route = this.path[this.path.length - 1];\\n    }\\n    return CanActivate;\\n}());\\nvar CanDeactivate = /** @class */ (function () {\\n    function CanDeactivate(component, route) {\\n        this.component = component;\\n        this.route = route;\\n    }\\n    return CanDeactivate;\\n}());\\nfunction getAllRouteGuards(future, curr, parentContexts) {\\n    var futureRoot = future._root;\\n    var currRoot = curr ? curr._root : null;\\n    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\\n}\\nfunction getCanActivateChild(p) {\\n    var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\\n    if (!canActivateChild || canActivateChild.length === 0)\\n        return null;\\n    return { node: p, guards: canActivateChild };\\n}\\nfunction getToken(token, snapshot, moduleInjector) {\\n    var config = getClosestLoadedConfig(snapshot);\\n    var injector = config ? config.module.injector : moduleInjector;\\n    return injector.get(token);\\n}\\nfunction getClosestLoadedConfig(snapshot) {\\n    if (!snapshot)\\n        return null;\\n    for (var s = snapshot.parent; s; s = s.parent) {\\n        var route = s.routeConfig;\\n        if (route && route._loadedConfig)\\n            return route._loadedConfig;\\n    }\\n    return null;\\n}\\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks) {\\n    if (checks === void 0) { checks = {\\n        canDeactivateChecks: [],\\n        canActivateChecks: []\\n    }; }\\n    var prevChildren = nodeChildrenAsMap(currNode);\\n    // Process the children of the future route\\n    futureNode.children.forEach(function (c) {\\n        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\\n        delete prevChildren[c.value.outlet];\\n    });\\n    // Process any children left from the current route (not active for the future route)\\n    forEach(prevChildren, function (v, k) {\\n        return deactivateRouteAndItsChildren(v, contexts.getContext(k), checks);\\n    });\\n    return checks;\\n}\\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks) {\\n    if (checks === void 0) { checks = {\\n        canDeactivateChecks: [],\\n        canActivateChecks: []\\n    }; }\\n    var future = futureNode.value;\\n    var curr = currNode ? currNode.value : null;\\n    var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\\n    // reusing the node\\n    if (curr && future.routeConfig === curr.routeConfig) {\\n        var shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\\n        if (shouldRun) {\\n            checks.canActivateChecks.push(new CanActivate(futurePath));\\n        }\\n        else {\\n            // we need to set the data\\n            future.data = curr.data;\\n            future._resolvedData = curr._resolvedData;\\n        }\\n        // If we have a component, we need to go through an outlet.\\n        if (future.component) {\\n            getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\\n            // if we have a componentless route, we recurse but keep the same outlet map.\\n        }\\n        else {\\n            getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\\n        }\\n        if (shouldRun) {\\n            var component = context && context.outlet && context.outlet.component || null;\\n            checks.canDeactivateChecks.push(new CanDeactivate(component, curr));\\n        }\\n    }\\n    else {\\n        if (curr) {\\n            deactivateRouteAndItsChildren(currNode, context, checks);\\n        }\\n        checks.canActivateChecks.push(new CanActivate(futurePath));\\n        // If we have a component, we need to go through an outlet.\\n        if (future.component) {\\n            getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\\n            // if we have a componentless route, we recurse but keep the same outlet map.\\n        }\\n        else {\\n            getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\\n        }\\n    }\\n    return checks;\\n}\\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\\n    switch (mode) {\\n        case \\'always\\':\\n            return true;\\n        case \\'paramsOrQueryParamsChange\\':\\n            return !equalParamsAndUrlSegments(curr, future) ||\\n                !shallowEqual(curr.queryParams, future.queryParams);\\n        case \\'paramsChange\\':\\n        default:\\n            return !equalParamsAndUrlSegments(curr, future);\\n    }\\n}\\nfunction deactivateRouteAndItsChildren(route, context, checks) {\\n    var children = nodeChildrenAsMap(route);\\n    var r = route.value;\\n    forEach(children, function (node, childName) {\\n        if (!r.component) {\\n            deactivateRouteAndItsChildren(node, context, checks);\\n        }\\n        else if (context) {\\n            deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\\n        }\\n        else {\\n            deactivateRouteAndItsChildren(node, null, checks);\\n        }\\n    });\\n    if (!r.component) {\\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\\n    }\\n    else if (context && context.outlet && context.outlet.isActivated) {\\n        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\\n    }\\n    else {\\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction checkGuards(moduleInjector, forwardEvent) {\\n    return function (source) {\\n        return source.pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (t) {\\n            var targetSnapshot = t.targetSnapshot, currentSnapshot = t.currentSnapshot, _a = t.guards, canActivateChecks = _a.canActivateChecks, canDeactivateChecks = _a.canDeactivateChecks;\\n            if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\\n                return Object(of[\"a\" /* of */])(Object(tslib_es6[\"a\" /* __assign */])({}, t, { guardsResult: true }));\\n            }\\n            return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector)\\n                .pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (canDeactivate) {\\n                return canDeactivate ?\\n                    runCanActivateChecks(targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) :\\n                    Object(of[\"a\" /* of */])(false);\\n            }), Object(map[\"a\" /* map */])(function (guardsResult) { return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { guardsResult: guardsResult })); }));\\n        }));\\n    };\\n}\\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {\\n    return Object(from[\"a\" /* from */])(checks).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (check) {\\n        return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);\\n    }), every(function (result) { return result === true; }));\\n}\\nfunction runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {\\n    return Object(from[\"a\" /* from */])(checks).pipe(concatMap(function (check) { return andObservables(Object(from[\"a\" /* from */])([\\n        fireChildActivationStart(check.route.parent, forwardEvent),\\n        fireActivationStart(check.route, forwardEvent),\\n        runCanActivateChild(futureSnapshot, check.path, moduleInjector),\\n        runCanActivate(futureSnapshot, check.route, moduleInjector)\\n    ])); }), every(function (result) { return result === true; }));\\n}\\n/**\\n   * This should fire off `ActivationStart` events for each route being activated at this\\n   * level.\\n   * In other words, if you\\'re activating `a` and `b` below, `path` will contain the\\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\\n   * return\\n   * `true` so checks continue to run.\\n   */\\nfunction fireActivationStart(snapshot, forwardEvent) {\\n    if (snapshot !== null && forwardEvent) {\\n        forwardEvent(new ActivationStart(snapshot));\\n    }\\n    return Object(of[\"a\" /* of */])(true);\\n}\\n/**\\n   * This should fire off `ChildActivationStart` events for each route being activated at this\\n   * level.\\n   * In other words, if you\\'re activating `a` and `b` below, `path` will contain the\\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\\n   * return\\n   * `true` so checks continue to run.\\n   */\\nfunction fireChildActivationStart(snapshot, forwardEvent) {\\n    if (snapshot !== null && forwardEvent) {\\n        forwardEvent(new ChildActivationStart(snapshot));\\n    }\\n    return Object(of[\"a\" /* of */])(true);\\n}\\nfunction runCanActivate(futureRSS, futureARS, moduleInjector) {\\n    var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\\n    if (!canActivate || canActivate.length === 0)\\n        return Object(of[\"a\" /* of */])(true);\\n    var obs = Object(from[\"a\" /* from */])(canActivate).pipe(Object(map[\"a\" /* map */])(function (c) {\\n        var guard = getToken(c, futureARS, moduleInjector);\\n        var observable;\\n        if (guard.canActivate) {\\n            observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));\\n        }\\n        else {\\n            observable = wrapIntoObservable(guard(futureARS, futureRSS));\\n        }\\n        return observable.pipe(first());\\n    }));\\n    return andObservables(obs);\\n}\\nfunction runCanActivateChild(futureRSS, path, moduleInjector) {\\n    var futureARS = path[path.length - 1];\\n    var canActivateChildGuards = path.slice(0, path.length - 1)\\n        .reverse()\\n        .map(function (p) { return getCanActivateChild(p); })\\n        .filter(function (_) { return _ !== null; });\\n    return andObservables(Object(from[\"a\" /* from */])(canActivateChildGuards).pipe(Object(map[\"a\" /* map */])(function (d) {\\n        var obs = Object(from[\"a\" /* from */])(d.guards).pipe(Object(map[\"a\" /* map */])(function (c) {\\n            var guard = getToken(c, d.node, moduleInjector);\\n            var observable;\\n            if (guard.canActivateChild) {\\n                observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));\\n            }\\n            else {\\n                observable = wrapIntoObservable(guard(futureARS, futureRSS));\\n            }\\n            return observable.pipe(first());\\n        }));\\n        return andObservables(obs);\\n    })));\\n}\\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {\\n    var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\\n    if (!canDeactivate || canDeactivate.length === 0)\\n        return Object(of[\"a\" /* of */])(true);\\n    var canDeactivate$ = Object(from[\"a\" /* from */])(canDeactivate).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (c) {\\n        var guard = getToken(c, currARS, moduleInjector);\\n        var observable;\\n        if (guard.canDeactivate) {\\n            observable = wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));\\n        }\\n        else {\\n            observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));\\n        }\\n        return observable.pipe(first());\\n    }));\\n    return canDeactivate$.pipe(every(function (result) { return result === true; }));\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar NoMatch$1 = /** @class */ (function () {\\n    function NoMatch() {\\n    }\\n    return NoMatch;\\n}());\\nfunction recognize(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\\n    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = \\'emptyOnly\\'; }\\n    if (relativeLinkResolution === void 0) { relativeLinkResolution = \\'legacy\\'; }\\n    return new router_Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution)\\n        .recognize();\\n}\\nvar router_Recognizer = /** @class */ (function () {\\n    function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {\\n        this.rootComponentType = rootComponentType;\\n        this.config = config;\\n        this.urlTree = urlTree;\\n        this.url = url;\\n        this.paramsInheritanceStrategy = paramsInheritanceStrategy;\\n        this.relativeLinkResolution = relativeLinkResolution;\\n    }\\n    Recognizer.prototype.recognize = function () {\\n        try {\\n            var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\\n            var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\\n            var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(Object(tslib_es6[\"a\" /* __assign */])({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\\n            var rootNode = new TreeNode(root, children);\\n            var routeState = new router_RouterStateSnapshot(this.url, rootNode);\\n            this.inheritParamsAndData(routeState._root);\\n            return Object(of[\"a\" /* of */])(routeState);\\n        }\\n        catch (e) {\\n            return new Observable[\"a\" /* Observable */](function (obs) { return obs.error(e); });\\n        }\\n    };\\n    Recognizer.prototype.inheritParamsAndData = function (routeNode) {\\n        var _this = this;\\n        var route = routeNode.value;\\n        var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);\\n        route.params = Object.freeze(i.params);\\n        route.data = Object.freeze(i.data);\\n        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });\\n    };\\n    Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {\\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\\n            return this.processChildren(config, segmentGroup);\\n        }\\n        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\\n    };\\n    Recognizer.prototype.processChildren = function (config, segmentGroup) {\\n        var _this = this;\\n        var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });\\n        checkOutletNameUniqueness(children);\\n        sortActivatedRouteSnapshots(children);\\n        return children;\\n    };\\n    Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {\\n        var e_1, _a;\\n        try {\\n            for (var config_1 = Object(tslib_es6[\"h\" /* __values */])(config), config_1_1 = config_1.next(); !config_1_1.done; config_1_1 = config_1.next()) {\\n                var r = config_1_1.value;\\n                try {\\n                    return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\\n                }\\n                catch (e) {\\n                    if (!(e instanceof NoMatch$1))\\n                        throw e;\\n                }\\n            }\\n        }\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n        finally {\\n            try {\\n                if (config_1_1 && !config_1_1.done && (_a = config_1.return)) _a.call(config_1);\\n            }\\n            finally { if (e_1) throw e_1.error; }\\n        }\\n        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\\n            return [];\\n        }\\n        throw new NoMatch$1();\\n    };\\n    Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {\\n        return segments.length === 0 && !segmentGroup.children[outlet];\\n    };\\n    Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {\\n        if (route.redirectTo)\\n            throw new NoMatch$1();\\n        if ((route.outlet || PRIMARY_OUTLET) !== outlet)\\n            throw new NoMatch$1();\\n        var snapshot;\\n        var consumedSegments = [];\\n        var rawSlicedSegments = [];\\n        if (route.path === \\'**\\') {\\n            var params = segments.length > 0 ? last$1(segments).parameters : {};\\n            snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(Object(tslib_es6[\"a\" /* __assign */])({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));\\n        }\\n        else {\\n            var result = match$1(rawSegment, route, segments);\\n            consumedSegments = result.consumedSegments;\\n            rawSlicedSegments = segments.slice(result.lastChild);\\n            snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(Object(tslib_es6[\"a\" /* __assign */])({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\\n        }\\n        var childConfig = getChildConfig(route);\\n        var _a = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;\\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\\n            var children_1 = this.processChildren(childConfig, segmentGroup);\\n            return [new TreeNode(snapshot, children_1)];\\n        }\\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\\n            return [new TreeNode(snapshot, [])];\\n        }\\n        var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\\n        return [new TreeNode(snapshot, children)];\\n    };\\n    return Recognizer;\\n}());\\nfunction sortActivatedRouteSnapshots(nodes) {\\n    nodes.sort(function (a, b) {\\n        if (a.value.outlet === PRIMARY_OUTLET)\\n            return -1;\\n        if (b.value.outlet === PRIMARY_OUTLET)\\n            return 1;\\n        return a.value.outlet.localeCompare(b.value.outlet);\\n    });\\n}\\nfunction getChildConfig(route) {\\n    if (route.children) {\\n        return route.children;\\n    }\\n    if (route.loadChildren) {\\n        return route._loadedConfig.routes;\\n    }\\n    return [];\\n}\\nfunction match$1(segmentGroup, route, segments) {\\n    if (route.path === \\'\\') {\\n        if (route.pathMatch === \\'full\\' && (segmentGroup.hasChildren() || segments.length > 0)) {\\n            throw new NoMatch$1();\\n        }\\n        return { consumedSegments: [], lastChild: 0, parameters: {} };\\n    }\\n    var matcher = route.matcher || defaultUrlMatcher;\\n    var res = matcher(segments, segmentGroup, route);\\n    if (!res)\\n        throw new NoMatch$1();\\n    var posParams = {};\\n    forEach(res.posParams, function (v, k) { posParams[k] = v.path; });\\n    var parameters = res.consumed.length > 0 ? Object(tslib_es6[\"a\" /* __assign */])({}, posParams, res.consumed[res.consumed.length - 1].parameters) :\\n        posParams;\\n    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };\\n}\\nfunction checkOutletNameUniqueness(nodes) {\\n    var names = {};\\n    nodes.forEach(function (n) {\\n        var routeWithSameOutletName = names[n.value.outlet];\\n        if (routeWithSameOutletName) {\\n            var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join(\\'/\\');\\n            var c = n.value.url.map(function (s) { return s.toString(); }).join(\\'/\\');\\n            throw new Error(\"Two segments cannot have the same outlet name: \\'\" + p + \"\\' and \\'\" + c + \"\\'.\");\\n        }\\n        names[n.value.outlet] = n.value;\\n    });\\n}\\nfunction getSourceSegmentGroup(segmentGroup) {\\n    var s = segmentGroup;\\n    while (s._sourceSegment) {\\n        s = s._sourceSegment;\\n    }\\n    return s;\\n}\\nfunction getPathIndexShift(segmentGroup) {\\n    var s = segmentGroup;\\n    var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);\\n    while (s._sourceSegment) {\\n        s = s._sourceSegment;\\n        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);\\n    }\\n    return res - 1;\\n}\\nfunction split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {\\n    if (slicedSegments.length > 0 &&\\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\\n        var s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\\n        s_1._sourceSegment = segmentGroup;\\n        s_1._segmentIndexShift = consumedSegments.length;\\n        return { segmentGroup: s_1, slicedSegments: [] };\\n    }\\n    if (slicedSegments.length === 0 &&\\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\\n        var s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));\\n        s_2._sourceSegment = segmentGroup;\\n        s_2._segmentIndexShift = consumedSegments.length;\\n        return { segmentGroup: s_2, slicedSegments: slicedSegments };\\n    }\\n    var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\\n    s._sourceSegment = segmentGroup;\\n    s._segmentIndexShift = consumedSegments.length;\\n    return { segmentGroup: s, slicedSegments: slicedSegments };\\n}\\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {\\n    var e_2, _a;\\n    var res = {};\\n    try {\\n        for (var routes_1 = Object(tslib_es6[\"h\" /* __values */])(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\\n            var r = routes_1_1.value;\\n            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {\\n                var s = new UrlSegmentGroup([], {});\\n                s._sourceSegment = segmentGroup;\\n                if (relativeLinkResolution === \\'legacy\\') {\\n                    s._segmentIndexShift = segmentGroup.segments.length;\\n                }\\n                else {\\n                    s._segmentIndexShift = consumedSegments.length;\\n                }\\n                res[getOutlet$1(r)] = s;\\n            }\\n        }\\n    }\\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\\n    finally {\\n        try {\\n            if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\\n        }\\n        finally { if (e_2) throw e_2.error; }\\n    }\\n    return Object(tslib_es6[\"a\" /* __assign */])({}, children, res);\\n}\\nfunction createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {\\n    var e_3, _a;\\n    var res = {};\\n    res[PRIMARY_OUTLET] = primarySegment;\\n    primarySegment._sourceSegment = segmentGroup;\\n    primarySegment._segmentIndexShift = consumedSegments.length;\\n    try {\\n        for (var routes_2 = Object(tslib_es6[\"h\" /* __values */])(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {\\n            var r = routes_2_1.value;\\n            if (r.path === \\'\\' && getOutlet$1(r) !== PRIMARY_OUTLET) {\\n                var s = new UrlSegmentGroup([], {});\\n                s._sourceSegment = segmentGroup;\\n                s._segmentIndexShift = consumedSegments.length;\\n                res[getOutlet$1(r)] = s;\\n            }\\n        }\\n    }\\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\\n    finally {\\n        try {\\n            if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);\\n        }\\n        finally { if (e_3) throw e_3.error; }\\n    }\\n    return res;\\n}\\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });\\n}\\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\\n    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });\\n}\\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === \\'full\\') {\\n        return false;\\n    }\\n    return r.path === \\'\\' && r.redirectTo === undefined;\\n}\\nfunction getOutlet$1(route) {\\n    return route.outlet || PRIMARY_OUTLET;\\n}\\nfunction getData(route) {\\n    return route.data || {};\\n}\\nfunction getResolve(route) {\\n    return route.resolve || {};\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {\\n    return function (source) {\\n        return source.pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (t) { return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution)\\n            .pipe(Object(map[\"a\" /* map */])(function (targetSnapshot) { return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { targetSnapshot: targetSnapshot })); })); }));\\n    };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction resolveData(paramsInheritanceStrategy, moduleInjector) {\\n    return function (source) {\\n        return source.pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (t) {\\n            var targetSnapshot = t.targetSnapshot, canActivateChecks = t.guards.canActivateChecks;\\n            if (!canActivateChecks.length) {\\n                return Object(of[\"a\" /* of */])(t);\\n            }\\n            return Object(from[\"a\" /* from */])(canActivateChecks)\\n                .pipe(concatMap(function (check) { return runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector); }), reduce(function (_, __) { return _; }), Object(map[\"a\" /* map */])(function (_) { return t; }));\\n        }));\\n    };\\n}\\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {\\n    var resolve = futureARS._resolve;\\n    return resolveNode(resolve, futureARS, futureRSS, moduleInjector)\\n        .pipe(Object(map[\"a\" /* map */])(function (resolvedData) {\\n        futureARS._resolvedData = resolvedData;\\n        futureARS.data = Object(tslib_es6[\"a\" /* __assign */])({}, futureARS.data, inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);\\n        return null;\\n    }));\\n}\\nfunction resolveNode(resolve, futureARS, futureRSS, moduleInjector) {\\n    var keys = Object.keys(resolve);\\n    if (keys.length === 0) {\\n        return Object(of[\"a\" /* of */])({});\\n    }\\n    if (keys.length === 1) {\\n        var key_1 = keys[0];\\n        return getResolver(resolve[key_1], futureARS, futureRSS, moduleInjector)\\n            .pipe(Object(map[\"a\" /* map */])(function (value) {\\n            var _a;\\n            return _a = {}, _a[key_1] = value, _a;\\n        }));\\n    }\\n    var data = {};\\n    var runningResolvers$ = Object(from[\"a\" /* from */])(keys).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (key) {\\n        return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)\\n            .pipe(Object(map[\"a\" /* map */])(function (value) {\\n            data[key] = value;\\n            return value;\\n        }));\\n    }));\\n    return runningResolvers$.pipe(last(), Object(map[\"a\" /* map */])(function () { return data; }));\\n}\\nfunction getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {\\n    var resolver = getToken(injectionToken, futureARS, moduleInjector);\\n    return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :\\n        wrapIntoObservable(resolver(futureARS, futureRSS));\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Perform a side effect through a switchMap for every emission on the source Observable,\\n * but return an Observable that is identical to the source. It\\'s essentially the same as\\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\\n * it will wait before continuing with the original value.\\n */\\nfunction switchTap(next) {\\n    return function (source) {\\n        return source.pipe(switchMap(function (v) {\\n            var nextResult = next(v);\\n            if (nextResult) {\\n                return Object(from[\"a\" /* from */])(nextResult).pipe(Object(map[\"a\" /* map */])(function () { return v; }));\\n            }\\n            return Object(from[\"a\" /* from */])([v]);\\n        }));\\n    };\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Provides a way to customize when activated routes get reused.\\n *\\n * @publicApi\\n */\\nvar RouteReuseStrategy = /** @class */ (function () {\\n    function RouteReuseStrategy() {\\n    }\\n    return RouteReuseStrategy;\\n}());\\n/**\\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\\n */\\nvar DefaultRouteReuseStrategy = /** @class */ (function () {\\n    function DefaultRouteReuseStrategy() {\\n    }\\n    DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };\\n    DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };\\n    DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };\\n    DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };\\n    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {\\n        return future.routeConfig === curr.routeConfig;\\n    };\\n    return DefaultRouteReuseStrategy;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @docsNotRequired\\n * @publicApi\\n */\\nvar ROUTES = new core[\"InjectionToken\"](\\'ROUTES\\');\\nvar router_RouterConfigLoader = /** @class */ (function () {\\n    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {\\n        this.loader = loader;\\n        this.compiler = compiler;\\n        this.onLoadStartListener = onLoadStartListener;\\n        this.onLoadEndListener = onLoadEndListener;\\n    }\\n    RouterConfigLoader.prototype.load = function (parentInjector, route) {\\n        var _this = this;\\n        if (this.onLoadStartListener) {\\n            this.onLoadStartListener(route);\\n        }\\n        var moduleFactory$ = this.loadModuleFactory(route.loadChildren);\\n        return moduleFactory$.pipe(Object(map[\"a\" /* map */])(function (factory) {\\n            if (_this.onLoadEndListener) {\\n                _this.onLoadEndListener(route);\\n            }\\n            var module = factory.create(parentInjector);\\n            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\\n        }));\\n    };\\n    RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {\\n        var _this = this;\\n        if (typeof loadChildren === \\'string\\') {\\n            return Object(from[\"a\" /* from */])(this.loader.load(loadChildren));\\n        }\\n        else {\\n            return wrapIntoObservable(loadChildren()).pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (t) {\\n                if (t instanceof core[\"NgModuleFactory\"]) {\\n                    return Object(of[\"a\" /* of */])(t);\\n                }\\n                else {\\n                    return Object(from[\"a\" /* from */])(_this.compiler.compileModuleAsync(t));\\n                }\\n            }));\\n        }\\n    };\\n    return RouterConfigLoader;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Provides a way to migrate AngularJS applications to Angular.\\n *\\n * @publicApi\\n */\\nvar UrlHandlingStrategy = /** @class */ (function () {\\n    function UrlHandlingStrategy() {\\n    }\\n    return UrlHandlingStrategy;\\n}());\\n/**\\n * @publicApi\\n */\\nvar DefaultUrlHandlingStrategy = /** @class */ (function () {\\n    function DefaultUrlHandlingStrategy() {\\n    }\\n    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };\\n    DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };\\n    DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };\\n    return DefaultUrlHandlingStrategy;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nfunction defaultErrorHandler(error) {\\n    throw error;\\n}\\nfunction defaultMalformedUriErrorHandler(error, urlSerializer, url) {\\n    return urlSerializer.parse(\\'/\\');\\n}\\n/**\\n * @internal\\n */\\nfunction defaultRouterHook(snapshot, runExtras) {\\n    return Object(of[\"a\" /* of */])(null);\\n}\\n/**\\n * @description\\n *\\n * Provides the navigation and url manipulation capabilities.\\n *\\n * See `Routes` for more details and examples.\\n *\\n * @ngModule RouterModule\\n *\\n * @publicApi\\n */\\nvar router_Router = /** @class */ (function () {\\n    /**\\n     * Creates the router service.\\n     */\\n    // TODO: vsavkin make internal after the final is out.\\n    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {\\n        var _this = this;\\n        this.rootComponentType = rootComponentType;\\n        this.urlSerializer = urlSerializer;\\n        this.rootContexts = rootContexts;\\n        this.location = location;\\n        this.config = config;\\n        this.navigationId = 0;\\n        this.isNgZoneEnabled = false;\\n        this.events = new Subject[\"a\" /* Subject */]();\\n        /**\\n         * Error handler that is invoked when a navigation errors.\\n         *\\n         * See `ErrorHandler` for more information.\\n         */\\n        this.errorHandler = defaultErrorHandler;\\n        /**\\n         * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an\\n         * error due to containing an invalid character. The most common case would be a `%` sign\\n         * that\\'s not encoded and is not part of a percent encoded sequence.\\n         */\\n        this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;\\n        /**\\n         * Indicates if at least one navigation happened.\\n         */\\n        this.navigated = false;\\n        this.lastSuccessfulId = -1;\\n        /**\\n         * Used by RouterModule. This allows us to\\n         * pause the navigation either before preactivation or after it.\\n         * @internal\\n         */\\n        this.hooks = {\\n            beforePreactivation: defaultRouterHook,\\n            afterPreactivation: defaultRouterHook\\n        };\\n        /**\\n         * Extracts and merges URLs. Used for AngularJS to Angular migrations.\\n         */\\n        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();\\n        this.routeReuseStrategy = new DefaultRouteReuseStrategy();\\n        /**\\n         * Define what the router should do if it receives a navigation request to the current URL.\\n         * By default, the router will ignore this navigation. However, this prevents features such\\n         * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\\n         * current URL. Default is \\'ignore\\'.\\n         */\\n        this.onSameUrlNavigation = \\'ignore\\';\\n        /**\\n         * Defines how the router merges params, data and resolved data from parent to child\\n         * routes. Available options are:\\n         *\\n         * - `\\'emptyOnly\\'`, the default, only inherits parent params for path-less or component-less\\n         *   routes.\\n         * - `\\'always\\'`, enables unconditional inheritance of parent params.\\n         */\\n        this.paramsInheritanceStrategy = \\'emptyOnly\\';\\n        /**\\n         * Defines when the router updates the browser URL. The default behavior is to update after\\n         * successful navigation. However, some applications may prefer a mode where the URL gets\\n         * updated at the beginning of navigation. The most common use case would be updating the\\n         * URL early so if navigation fails, you can show an error message with the URL that failed.\\n         * Available options are:\\n         *\\n         * - `\\'deferred\\'`, the default, updates the browser URL after navigation has finished.\\n         * - `\\'eager\\'`, updates browser URL at the beginning of navigation.\\n         */\\n        this.urlUpdateStrategy = \\'deferred\\';\\n        /**\\n         * See {@link RouterModule} for more information.\\n         */\\n        this.relativeLinkResolution = \\'legacy\\';\\n        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };\\n        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };\\n        this.ngModule = injector.get(core[\"NgModuleRef\"]);\\n        this.console = injector.get(core[\"ɵConsole\"]);\\n        var ngZone = injector.get(core[\"NgZone\"]);\\n        this.isNgZoneEnabled = ngZone instanceof core[\"NgZone\"];\\n        this.resetConfig(config);\\n        this.currentUrlTree = createEmptyUrlTree();\\n        this.rawUrlTree = this.currentUrlTree;\\n        this.configLoader = new router_RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\\n        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\\n        this.transitions = new BehaviorSubject[\"a\" /* BehaviorSubject */]({\\n            id: 0,\\n            currentUrlTree: this.currentUrlTree,\\n            currentRawUrl: this.currentUrlTree,\\n            extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),\\n            urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),\\n            rawUrl: this.currentUrlTree,\\n            extras: {},\\n            resolve: null,\\n            reject: null,\\n            promise: Promise.resolve(true),\\n            source: \\'imperative\\',\\n            state: null,\\n            currentSnapshot: this.routerState.snapshot,\\n            targetSnapshot: null,\\n            currentRouterState: this.routerState,\\n            targetRouterState: null,\\n            guards: { canActivateChecks: [], canDeactivateChecks: [] },\\n            guardsResult: null,\\n        });\\n        this.navigations = this.setupNavigations(this.transitions);\\n        this.processNavigations();\\n    }\\n    Router.prototype.setupNavigations = function (transitions) {\\n        var _this = this;\\n        var eventsSubject = this.events;\\n        return transitions.pipe(filter(function (t) { return t.id !== 0; }), \\n        // Extract URL\\n        Object(map[\"a\" /* map */])(function (t) { return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { extractedUrl: _this.urlHandlingStrategy.extract(t.rawUrl) })); }), \\n        // Using switchMap so we cancel executing navigations when a new one comes in\\n        switchMap(function (t) {\\n            var completed = false;\\n            var errored = false;\\n            return Object(of[\"a\" /* of */])(t).pipe(switchMap(function (t) {\\n                var urlTransition = !_this.navigated || t.extractedUrl.toString() !== _this.currentUrlTree.toString();\\n                var processCurrentUrl = (_this.onSameUrlNavigation === \\'reload\\' ? true : urlTransition) &&\\n                    _this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);\\n                if (processCurrentUrl) {\\n                    return Object(of[\"a\" /* of */])(t).pipe(\\n                    // Update URL if in `eager` update mode\\n                    tap(function (t) { return _this.urlUpdateStrategy === \\'eager\\' && !t.extras.skipLocationChange &&\\n                        _this.setBrowserUrl(t.rawUrl, !!t.extras.replaceUrl, t.id); }), \\n                    // Fire NavigationStart event\\n                    switchMap(function (t) {\\n                        var transition = _this.transitions.getValue();\\n                        eventsSubject.next(new router_NavigationStart(t.id, _this.serializeUrl(t.extractedUrl), t.source, t.state));\\n                        if (transition !== _this.transitions.getValue()) {\\n                            return empty[\"a\" /* EMPTY */];\\n                        }\\n                        return [t];\\n                    }), \\n                    // This delay is required to match old behavior that forced navigation to\\n                    // always be async\\n                    switchMap(function (t) { return Promise.resolve(t); }), \\n                    // ApplyRedirects\\n                    applyRedirects$1(_this.ngModule.injector, _this.configLoader, _this.urlSerializer, _this.config), \\n                    // Recognize\\n                    recognize$1(_this.rootComponentType, _this.config, function (url) { return _this.serializeUrl(url); }, _this.paramsInheritanceStrategy, _this.relativeLinkResolution), \\n                    // Fire RoutesRecognized\\n                    tap(function (t) {\\n                        var routesRecognized = new router_RoutesRecognized(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\\n                        eventsSubject.next(routesRecognized);\\n                    }));\\n                }\\n                else {\\n                    var processPreviousUrl = urlTransition && _this.rawUrlTree &&\\n                        _this.urlHandlingStrategy.shouldProcessUrl(_this.rawUrlTree);\\n                    /* When the current URL shouldn\\'t be processed, but the previous one was, we\\n                     * handle this \"error condition\" by navigating to the previously successful URL,\\n                     * but leaving the URL intact.*/\\n                    if (processPreviousUrl) {\\n                        var id = t.id, extractedUrl = t.extractedUrl, source = t.source, state = t.state, extras = t.extras;\\n                        var navStart = new router_NavigationStart(id, _this.serializeUrl(extractedUrl), source, state);\\n                        eventsSubject.next(navStart);\\n                        var targetSnapshot = createEmptyState(extractedUrl, _this.rootComponentType).snapshot;\\n                        return Object(of[\"a\" /* of */])(Object(tslib_es6[\"a\" /* __assign */])({}, t, { targetSnapshot: targetSnapshot, urlAfterRedirects: extractedUrl, extras: Object(tslib_es6[\"a\" /* __assign */])({}, extras, { skipLocationChange: false, replaceUrl: false }) }));\\n                    }\\n                    else {\\n                        /* When neither the current or previous URL can be processed, do nothing other\\n                         * than update router\\'s internal reference to the current \"settled\" URL. This\\n                         * way the next navigation will be coming from the current URL in the browser.\\n                         */\\n                        _this.rawUrlTree = t.rawUrl;\\n                        t.resolve(null);\\n                        return empty[\"a\" /* EMPTY */];\\n                    }\\n                }\\n            }), \\n            // Before Preactivation\\n            switchTap(function (t) {\\n                var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;\\n                return _this.hooks.beforePreactivation(targetSnapshot, {\\n                    navigationId: navigationId,\\n                    appliedUrlTree: appliedUrlTree,\\n                    rawUrlTree: rawUrlTree,\\n                    skipLocationChange: !!skipLocationChange,\\n                    replaceUrl: !!replaceUrl,\\n                });\\n            }), \\n            // --- GUARDS ---\\n            tap(function (t) {\\n                var guardsStart = new router_GuardsCheckStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\\n                _this.triggerEvent(guardsStart);\\n            }), Object(map[\"a\" /* map */])(function (t) { return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, _this.rootContexts) })); }), checkGuards(_this.ngModule.injector, function (evt) { return _this.triggerEvent(evt); }), tap(function (t) {\\n                var guardsEnd = new router_GuardsCheckEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\\n                _this.triggerEvent(guardsEnd);\\n            }), filter(function (t) {\\n                if (!t.guardsResult) {\\n                    _this.resetUrlToCurrentUrlTree();\\n                    var navCancel = new router_NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), \\'\\');\\n                    eventsSubject.next(navCancel);\\n                    t.resolve(false);\\n                    return false;\\n                }\\n                return true;\\n            }), \\n            // --- RESOLVE ---\\n            switchTap(function (t) {\\n                if (t.guards.canActivateChecks.length) {\\n                    return Object(of[\"a\" /* of */])(t).pipe(tap(function (t) {\\n                        var resolveStart = new router_ResolveStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\\n                        _this.triggerEvent(resolveStart);\\n                    }), resolveData(_this.paramsInheritanceStrategy, _this.ngModule.injector), //\\n                    tap(function (t) {\\n                        var resolveEnd = new router_ResolveEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);\\n                        _this.triggerEvent(resolveEnd);\\n                    }));\\n                }\\n                return undefined;\\n            }), \\n            // --- AFTER PREACTIVATION ---\\n            switchTap(function (t) {\\n                var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;\\n                return _this.hooks.afterPreactivation(targetSnapshot, {\\n                    navigationId: navigationId,\\n                    appliedUrlTree: appliedUrlTree,\\n                    rawUrlTree: rawUrlTree,\\n                    skipLocationChange: !!skipLocationChange,\\n                    replaceUrl: !!replaceUrl,\\n                });\\n            }), Object(map[\"a\" /* map */])(function (t) {\\n                var targetRouterState = createRouterState(_this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\\n                return (Object(tslib_es6[\"a\" /* __assign */])({}, t, { targetRouterState: targetRouterState }));\\n            }), \\n            /* Once here, we are about to activate syncronously. The assumption is this will\\n               succeed, and user code may read from the Router service. Therefore before\\n               activation, we need to update router properties storing the current URL and the\\n               RouterState, as well as updated the browser URL. All this should happen *before*\\n               activating. */\\n            tap(function (t) {\\n                _this.currentUrlTree = t.urlAfterRedirects;\\n                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, t.rawUrl);\\n                _this.routerState = t.targetRouterState;\\n                if (_this.urlUpdateStrategy === \\'deferred\\' && !t.extras.skipLocationChange) {\\n                    _this.setBrowserUrl(_this.rawUrlTree, !!t.extras.replaceUrl, t.id);\\n                }\\n            }), activateRoutes(_this.rootContexts, _this.routeReuseStrategy, function (evt) { return _this.triggerEvent(evt); }), tap({ next: function () { completed = true; }, complete: function () { completed = true; } }), finalize(function () {\\n                /* When the navigation stream finishes either through error or success, we set the\\n                 * `completed` or `errored` flag. However, there are some situations where we could\\n                 * get here without either of those being set. For instance, a redirect during\\n                 * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel\\n                 * event is fired when a navigation gets cancelled but not caught by other means. */\\n                if (!completed && !errored) {\\n                    // Must reset to current URL tree here to ensure history.state is set. On a fresh\\n                    // page load, if a new navigation comes in before a successful navigation\\n                    // completes, there will be nothing in history.state.navigationId. This can cause\\n                    // sync problems with AngularJS sync code which looks for a value here in order\\n                    // to determine whether or not to handle a given popstate event or to leave it\\n                    // to the Angualr router.\\n                    _this.resetUrlToCurrentUrlTree();\\n                    var navCancel = new router_NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), \"Navigation ID \" + t.id + \" is not equal to the current navigation id \" + _this.navigationId);\\n                    eventsSubject.next(navCancel);\\n                    t.resolve(false);\\n                }\\n            }), catchError(function (e) {\\n                errored = true;\\n                /* This error type is issued during Redirect, and is handled as a cancellation\\n                 * rather than an error. */\\n                if (isNavigationCancelingError(e)) {\\n                    _this.navigated = true;\\n                    _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\\n                    var navCancel = new router_NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), e.message);\\n                    eventsSubject.next(navCancel);\\n                    t.resolve(false);\\n                    /* All other errors should reset to the router\\'s internal URL reference to the\\n                     * pre-error state. */\\n                }\\n                else {\\n                    _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\\n                    var navError = new router_NavigationError(t.id, _this.serializeUrl(t.extractedUrl), e);\\n                    eventsSubject.next(navError);\\n                    try {\\n                        t.resolve(_this.errorHandler(e));\\n                    }\\n                    catch (ee) {\\n                        t.reject(ee);\\n                    }\\n                }\\n                return empty[\"a\" /* EMPTY */];\\n            }));\\n            // TODO(jasonaden): remove cast once g3 is on updated TypeScript\\n        }));\\n    };\\n    /**\\n     * @internal\\n     * TODO: this should be removed once the constructor of the router made internal\\n     */\\n    Router.prototype.resetRootComponentType = function (rootComponentType) {\\n        this.rootComponentType = rootComponentType;\\n        // TODO: vsavkin router 4.0 should make the root component set to null\\n        // this will simplify the lifecycle of the router.\\n        this.routerState.root.component = this.rootComponentType;\\n    };\\n    Router.prototype.getTransition = function () { return this.transitions.value; };\\n    Router.prototype.setTransition = function (t) {\\n        this.transitions.next(Object(tslib_es6[\"a\" /* __assign */])({}, this.getTransition(), t));\\n    };\\n    /**\\n     * Sets up the location change listener and performs the initial navigation.\\n     */\\n    Router.prototype.initialNavigation = function () {\\n        this.setUpLocationChangeListener();\\n        if (this.navigationId === 0) {\\n            this.navigateByUrl(this.location.path(true), { replaceUrl: true });\\n        }\\n    };\\n    /**\\n     * Sets up the location change listener.\\n     */\\n    Router.prototype.setUpLocationChangeListener = function () {\\n        var _this = this;\\n        // Don\\'t need to use Zone.wrap any more, because zone.js\\n        // already patch onPopState, so location change callback will\\n        // run into ngZone\\n        if (!this.locationSubscription) {\\n            this.locationSubscription = this.location.subscribe(function (change) {\\n                var rawUrlTree = _this.parseUrl(change[\\'url\\']);\\n                var source = change[\\'type\\'] === \\'popstate\\' ? \\'popstate\\' : \\'hashchange\\';\\n                var state = change.state && change.state.navigationId ?\\n                    { navigationId: change.state.navigationId } :\\n                    null;\\n                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true }); }, 0);\\n            });\\n        }\\n    };\\n    Object.defineProperty(Router.prototype, \"url\", {\\n        /** The current url */\\n        get: function () { return this.serializeUrl(this.currentUrlTree); },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /** @internal */\\n    Router.prototype.triggerEvent = function (event) { this.events.next(event); };\\n    /**\\n     * Resets the configuration used for navigation and generating links.\\n     *\\n     * @usageNotes\\n     *\\n     * ### Example\\n     *\\n     * ```\\n     * router.resetConfig([\\n     *  { path: \\'team/:id\\', component: TeamCmp, children: [\\n     *    { path: \\'simple\\', component: SimpleCmp },\\n     *    { path: \\'user/:name\\', component: UserCmp }\\n     *  ]}\\n     * ]);\\n     * ```\\n     */\\n    Router.prototype.resetConfig = function (config) {\\n        validateConfig(config);\\n        this.config = config.map(standardizeConfig);\\n        this.navigated = false;\\n        this.lastSuccessfulId = -1;\\n    };\\n    /** @docsNotRequired */\\n    Router.prototype.ngOnDestroy = function () { this.dispose(); };\\n    /** Disposes of the router */\\n    Router.prototype.dispose = function () {\\n        if (this.locationSubscription) {\\n            this.locationSubscription.unsubscribe();\\n            this.locationSubscription = null;\\n        }\\n    };\\n    /**\\n     * Applies an array of commands to the current url tree and creates a new url tree.\\n     *\\n     * When given an activate route, applies the given commands starting from the route.\\n     * When not given a route, applies the given command starting from the root.\\n     *\\n     * @usageNotes\\n     *\\n     * ### Example\\n     *\\n     * ```\\n     * // create /team/33/user/11\\n     * router.createUrlTree([\\'/team\\', 33, \\'user\\', 11]);\\n     *\\n     * // create /team/33;expand=true/user/11\\n     * router.createUrlTree([\\'/team\\', 33, {expand: true}, \\'user\\', 11]);\\n     *\\n     * // you can collapse static segments like this (this works only with the first passed-in value):\\n     * router.createUrlTree([\\'/team/33/user\\', userId]);\\n     *\\n     * // If the first segment can contain slashes, and you do not want the router to split it, you\\n     * // can do the following:\\n     *\\n     * router.createUrlTree([{segmentPath: \\'/one/two\\'}]);\\n     *\\n     * // create /team/33/(user/11//right:chat)\\n     * router.createUrlTree([\\'/team\\', 33, {outlets: {primary: \\'user/11\\', right: \\'chat\\'}}]);\\n     *\\n     * // remove the right secondary node\\n     * router.createUrlTree([\\'/team\\', 33, {outlets: {primary: \\'user/11\\', right: null}}]);\\n     *\\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\\n     *\\n     * // navigate to /team/33/user/11/details\\n     * router.createUrlTree([\\'details\\'], {relativeTo: route});\\n     *\\n     * // navigate to /team/33/user/22\\n     * router.createUrlTree([\\'../22\\'], {relativeTo: route});\\n     *\\n     * // navigate to /team/44/user/22\\n     * router.createUrlTree([\\'../../team/44/user/22\\'], {relativeTo: route});\\n     * ```\\n     */\\n    Router.prototype.createUrlTree = function (commands, navigationExtras) {\\n        if (navigationExtras === void 0) { navigationExtras = {}; }\\n        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;\\n        if (Object(core[\"isDevMode\"])() && preserveQueryParams && console && console.warn) {\\n            console.warn(\\'preserveQueryParams is deprecated, use queryParamsHandling instead.\\');\\n        }\\n        var a = relativeTo || this.routerState.root;\\n        var f = preserveFragment ? this.currentUrlTree.fragment : fragment;\\n        var q = null;\\n        if (queryParamsHandling) {\\n            switch (queryParamsHandling) {\\n                case \\'merge\\':\\n                    q = Object(tslib_es6[\"a\" /* __assign */])({}, this.currentUrlTree.queryParams, queryParams);\\n                    break;\\n                case \\'preserve\\':\\n                    q = this.currentUrlTree.queryParams;\\n                    break;\\n                default:\\n                    q = queryParams || null;\\n            }\\n        }\\n        else {\\n            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\\n        }\\n        if (q !== null) {\\n            q = this.removeEmptyProps(q);\\n        }\\n        return createUrlTree(a, this.currentUrlTree, commands, q, f);\\n    };\\n    /**\\n     * Navigate based on the provided url. This navigation is always absolute.\\n     *\\n     * Returns a promise that:\\n     * - resolves to \\'true\\' when navigation succeeds,\\n     * - resolves to \\'false\\' when navigation fails,\\n     * - is rejected when an error happens.\\n     *\\n     * @usageNotes\\n     *\\n     * ### Example\\n     *\\n     * ```\\n     * router.navigateByUrl(\"/team/33/user/11\");\\n     *\\n     * // Navigate without updating the URL\\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\\n     * ```\\n     *\\n     * Since `navigateByUrl()` takes an absolute URL as the first parameter,\\n     * it will not apply any delta to the current URL and ignores any properties\\n     * in the second parameter (the `NavigationExtras`) that would change the\\n     * provided URL.\\n     */\\n    Router.prototype.navigateByUrl = function (url, extras) {\\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\\n        if (Object(core[\"isDevMode\"])() && this.isNgZoneEnabled && !core[\"NgZone\"].isInAngularZone()) {\\n            this.console.warn(\"Navigation triggered outside Angular zone, did you forget to call \\'ngZone.run()\\'?\");\\n        }\\n        var urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\\n        var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\\n        return this.scheduleNavigation(mergedTree, \\'imperative\\', null, extras);\\n    };\\n    /**\\n     * Navigate based on the provided array of commands and a starting point.\\n     * If no starting route is provided, the navigation is absolute.\\n     *\\n     * Returns a promise that:\\n     * - resolves to \\'true\\' when navigation succeeds,\\n     * - resolves to \\'false\\' when navigation fails,\\n     * - is rejected when an error happens.\\n     *\\n     * @usageNotes\\n     *\\n     * ### Example\\n     *\\n     * ```\\n     * router.navigate([\\'team\\', 33, \\'user\\', 11], {relativeTo: route});\\n     *\\n     * // Navigate without updating the URL\\n     * router.navigate([\\'team\\', 33, \\'user\\', 11], {relativeTo: route, skipLocationChange: true});\\n     * ```\\n     *\\n     * The first parameter of `navigate()` is a delta to be applied to the current URL\\n     * or the one provided in the `relativeTo` property of the second parameter (the\\n     * `NavigationExtras`).\\n     */\\n    Router.prototype.navigate = function (commands, extras) {\\n        if (extras === void 0) { extras = { skipLocationChange: false }; }\\n        validateCommands(commands);\\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\\n    };\\n    /** Serializes a `UrlTree` into a string */\\n    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };\\n    /** Parses a string into a `UrlTree` */\\n    Router.prototype.parseUrl = function (url) {\\n        var urlTree;\\n        try {\\n            urlTree = this.urlSerializer.parse(url);\\n        }\\n        catch (e) {\\n            urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\\n        }\\n        return urlTree;\\n    };\\n    /** Returns whether the url is activated */\\n    Router.prototype.isActive = function (url, exact) {\\n        if (url instanceof UrlTree) {\\n            return containsTree(this.currentUrlTree, url, exact);\\n        }\\n        var urlTree = this.parseUrl(url);\\n        return containsTree(this.currentUrlTree, urlTree, exact);\\n    };\\n    Router.prototype.removeEmptyProps = function (params) {\\n        return Object.keys(params).reduce(function (result, key) {\\n            var value = params[key];\\n            if (value !== null && value !== undefined) {\\n                result[key] = value;\\n            }\\n            return result;\\n        }, {});\\n    };\\n    Router.prototype.processNavigations = function () {\\n        var _this = this;\\n        this.navigations.subscribe(function (t) {\\n            _this.navigated = true;\\n            _this.lastSuccessfulId = t.id;\\n            _this.events\\n                .next(new router_NavigationEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(_this.currentUrlTree)));\\n            t.resolve(true);\\n        }, function (e) { _this.console.warn(\"Unhandled Navigation Error: \"); });\\n    };\\n    Router.prototype.scheduleNavigation = function (rawUrl, source, state, extras) {\\n        var lastNavigation = this.getTransition();\\n        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\\n        // and that navigation results in \\'replaceState\\' that leads to the same URL,\\n        // we should skip those.\\n        if (lastNavigation && source !== \\'imperative\\' && lastNavigation.source === \\'imperative\\' &&\\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\\n            return Promise.resolve(true); // return value is not used\\n        }\\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\\n        // flicker. Handles the case when a popstate was emitted first.\\n        if (lastNavigation && source == \\'hashchange\\' && lastNavigation.source === \\'popstate\\' &&\\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\\n            return Promise.resolve(true); // return value is not used\\n        }\\n        // Because of a bug in IE and Edge, the location class fires two events (popstate and\\n        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\\n        // flicker. Handles the case when a hashchange was emitted first.\\n        if (lastNavigation && source == \\'popstate\\' && lastNavigation.source === \\'hashchange\\' &&\\n            lastNavigation.rawUrl.toString() === rawUrl.toString()) {\\n            return Promise.resolve(true); // return value is not used\\n        }\\n        var resolve = null;\\n        var reject = null;\\n        var promise = new Promise(function (res, rej) {\\n            resolve = res;\\n            reject = rej;\\n        });\\n        var id = ++this.navigationId;\\n        this.setTransition({\\n            id: id,\\n            source: source,\\n            state: state,\\n            currentUrlTree: this.currentUrlTree,\\n            currentRawUrl: this.rawUrlTree, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise,\\n            currentSnapshot: this.routerState.snapshot,\\n            currentRouterState: this.routerState\\n        });\\n        // Make sure that the error is propagated even though `processNavigations` catch\\n        // handler does not rethrow\\n        return promise.catch(function (e) { return Promise.reject(e); });\\n    };\\n    Router.prototype.setBrowserUrl = function (url, replaceUrl, id) {\\n        var path = this.urlSerializer.serialize(url);\\n        if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\\n            this.location.replaceState(path, \\'\\', { navigationId: id });\\n        }\\n        else {\\n            this.location.go(path, \\'\\', { navigationId: id });\\n        }\\n    };\\n    Router.prototype.resetStateAndUrl = function (storedState, storedUrl, rawUrl) {\\n        this.routerState = storedState;\\n        this.currentUrlTree = storedUrl;\\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\\n        this.resetUrlToCurrentUrlTree();\\n    };\\n    Router.prototype.resetUrlToCurrentUrlTree = function () {\\n        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), \\'\\', { navigationId: this.lastSuccessfulId });\\n    };\\n    return Router;\\n}());\\nfunction validateCommands(commands) {\\n    for (var i = 0; i < commands.length; i++) {\\n        var cmd = commands[i];\\n        if (cmd == null) {\\n            throw new Error(\"The requested path contains \" + cmd + \" segment at index \" + i);\\n        }\\n    }\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Lets you link to specific routes in your app.\\n *\\n * Consider the following route configuration:\\n * `[{ path: \\'user/:name\\', component: UserCmp }]`.\\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\\n *\\n * If the link is static, you can use the directive as follows:\\n * `<a routerLink=\"/user/bob\">link to user component</a>`\\n *\\n * If you use dynamic values to generate the link, you can pass an array of path\\n * segments, followed by the params for each segment.\\n *\\n * For instance `[\\'/team\\', teamId, \\'user\\', userName, {details: true}]`\\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\\n *\\n * Multiple static segments can be merged into one\\n * (e.g., `[\\'/team/11/user\\', userName, {details: true}]`).\\n *\\n * The first segment name can be prepended with `/`, `./`, or `../`:\\n * * If the first segment begins with `/`, the router will look up the route from the root of the\\n *   app.\\n * * If the first segment begins with `./`, or doesn\\'t begin with a slash, the router will\\n *   instead look in the children of the current activated route.\\n * * And if the first segment begins with `../`, the router will go up one level.\\n *\\n * You can set query params and fragment as follows:\\n *\\n * ```\\n * <a [routerLink]=\"[\\'/user/bob\\']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\\n *   link to user component\\n * </a>\\n * ```\\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\\n *\\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\\n * directive to preserve the current query params and fragment:\\n *\\n * ```\\n * <a [routerLink]=\"[\\'/user/bob\\']\" preserveQueryParams preserveFragment>\\n *   link to user component\\n * </a>\\n * ```\\n *\\n * You can tell the directive to how to handle queryParams, available options are:\\n *  - `\\'merge\\'`: merge the queryParams into the current queryParams\\n *  - `\\'preserve\\'`: preserve the current queryParams\\n *  - default/`\\'\\'`: use the queryParams only\\n *\\n * Same options for {@link NavigationExtras#queryParamsHandling\\n * NavigationExtras#queryParamsHandling}.\\n *\\n * ```\\n * <a [routerLink]=\"[\\'/user/bob\\']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\\n *   link to user component\\n * </a>\\n * ```\\n *\\n * The router link directive always treats the provided input as a delta to the current url.\\n *\\n * For instance, if the current url is `/user/(box//aux:team)`.\\n *\\n * Then the following link `<a [routerLink]=\"[\\'/user/jim\\']\">Jim</a>` will generate the link\\n * `/user/(jim//aux:team)`.\\n *\\n * See {@link Router#createUrlTree createUrlTree} for more information.\\n *\\n * @ngModule RouterModule\\n *\\n * @publicApi\\n */\\nvar router_RouterLink = /** @class */ (function () {\\n    function RouterLink(router, route, tabIndex, renderer, el) {\\n        this.router = router;\\n        this.route = route;\\n        this.commands = [];\\n        if (tabIndex == null) {\\n            renderer.setAttribute(el.nativeElement, \\'tabindex\\', \\'0\\');\\n        }\\n    }\\n    Object.defineProperty(RouterLink.prototype, \"routerLink\", {\\n        set: function (commands) {\\n            if (commands != null) {\\n                this.commands = Array.isArray(commands) ? commands : [commands];\\n            }\\n            else {\\n                this.commands = [];\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(RouterLink.prototype, \"preserveQueryParams\", {\\n        /**\\n         * @deprecated 4.0.0 use `queryParamsHandling` instead.\\n         */\\n        set: function (value) {\\n            if (Object(core[\"isDevMode\"])() && console && console.warn) {\\n                console.warn(\\'preserveQueryParams is deprecated!, use queryParamsHandling instead.\\');\\n            }\\n            this.preserve = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    RouterLink.prototype.onClick = function () {\\n        var extras = {\\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\\n            replaceUrl: attrBoolValue(this.replaceUrl),\\n        };\\n        this.router.navigateByUrl(this.urlTree, extras);\\n        return true;\\n    };\\n    Object.defineProperty(RouterLink.prototype, \"urlTree\", {\\n        get: function () {\\n            return this.router.createUrlTree(this.commands, {\\n                relativeTo: this.route,\\n                queryParams: this.queryParams,\\n                fragment: this.fragment,\\n                preserveQueryParams: attrBoolValue(this.preserve),\\n                queryParamsHandling: this.queryParamsHandling,\\n                preserveFragment: attrBoolValue(this.preserveFragment),\\n            });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object)\\n    ], RouterLink.prototype, \"queryParams\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLink.prototype, \"fragment\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLink.prototype, \"queryParamsHandling\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLink.prototype, \"preserveFragment\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLink.prototype, \"skipLocationChange\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLink.prototype, \"replaceUrl\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Object])\\n    ], RouterLink.prototype, \"routerLink\", null);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Boolean])\\n    ], RouterLink.prototype, \"preserveQueryParams\", null);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"HostListener\"])(\\'click\\'),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Function),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", []),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:returntype\", Boolean)\\n    ], RouterLink.prototype, \"onClick\", null);\\n    RouterLink = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Directive\"])({ selector: \\':not(a)[routerLink]\\' }),\\n        Object(tslib_es6[\"e\" /* __param */])(2, Object(core[\"Attribute\"])(\\'tabindex\\')),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [router_Router, router_ActivatedRoute, String, core[\"Renderer2\"], core[\"ElementRef\"]])\\n    ], RouterLink);\\n    return RouterLink;\\n}());\\n/**\\n * @description\\n *\\n * Lets you link to specific routes in your app.\\n *\\n * See `RouterLink` for more information.\\n *\\n * @ngModule RouterModule\\n *\\n * @publicApi\\n */\\nvar router_RouterLinkWithHref = /** @class */ (function () {\\n    function RouterLinkWithHref(router, route, locationStrategy) {\\n        var _this = this;\\n        this.router = router;\\n        this.route = route;\\n        this.locationStrategy = locationStrategy;\\n        this.commands = [];\\n        this.subscription = router.events.subscribe(function (s) {\\n            if (s instanceof router_NavigationEnd) {\\n                _this.updateTargetUrlAndHref();\\n            }\\n        });\\n    }\\n    Object.defineProperty(RouterLinkWithHref.prototype, \"routerLink\", {\\n        set: function (commands) {\\n            if (commands != null) {\\n                this.commands = Array.isArray(commands) ? commands : [commands];\\n            }\\n            else {\\n                this.commands = [];\\n            }\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(RouterLinkWithHref.prototype, \"preserveQueryParams\", {\\n        set: function (value) {\\n            if (Object(core[\"isDevMode\"])() && console && console.warn) {\\n                console.warn(\\'preserveQueryParams is deprecated, use queryParamsHandling instead.\\');\\n            }\\n            this.preserve = value;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };\\n    RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\\n    RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {\\n        if (button !== 0 || ctrlKey || metaKey || shiftKey) {\\n            return true;\\n        }\\n        if (typeof this.target === \\'string\\' && this.target != \\'_self\\') {\\n            return true;\\n        }\\n        var extras = {\\n            skipLocationChange: attrBoolValue(this.skipLocationChange),\\n            replaceUrl: attrBoolValue(this.replaceUrl),\\n        };\\n        this.router.navigateByUrl(this.urlTree, extras);\\n        return false;\\n    };\\n    RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {\\n        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));\\n    };\\n    Object.defineProperty(RouterLinkWithHref.prototype, \"urlTree\", {\\n        get: function () {\\n            return this.router.createUrlTree(this.commands, {\\n                relativeTo: this.route,\\n                queryParams: this.queryParams,\\n                fragment: this.fragment,\\n                preserveQueryParams: attrBoolValue(this.preserve),\\n                queryParamsHandling: this.queryParamsHandling,\\n                preserveFragment: attrBoolValue(this.preserveFragment),\\n            });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"HostBinding\"])(\\'attr.target\\'), Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLinkWithHref.prototype, \"target\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object)\\n    ], RouterLinkWithHref.prototype, \"queryParams\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLinkWithHref.prototype, \"fragment\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLinkWithHref.prototype, \"queryParamsHandling\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLinkWithHref.prototype, \"preserveFragment\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLinkWithHref.prototype, \"skipLocationChange\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean)\\n    ], RouterLinkWithHref.prototype, \"replaceUrl\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"HostBinding\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", String)\\n    ], RouterLinkWithHref.prototype, \"href\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Object])\\n    ], RouterLinkWithHref.prototype, \"routerLink\", null);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Boolean),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Boolean])\\n    ], RouterLinkWithHref.prototype, \"preserveQueryParams\", null);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"HostListener\"])(\\'click\\', [\\'$event.button\\', \\'$event.ctrlKey\\', \\'$event.metaKey\\', \\'$event.shiftKey\\']),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Function),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Number, Boolean, Boolean, Boolean]),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:returntype\", Boolean)\\n    ], RouterLinkWithHref.prototype, \"onClick\", null);\\n    RouterLinkWithHref = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Directive\"])({ selector: \\'a[routerLink]\\' }),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [router_Router, router_ActivatedRoute,\\n            common[\"LocationStrategy\"]])\\n    ], RouterLinkWithHref);\\n    return RouterLinkWithHref;\\n}());\\nfunction attrBoolValue(s) {\\n    return s === \\'\\' || !!s;\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n *\\n * @description\\n *\\n * Lets you add a CSS class to an element when the link\\'s route becomes active.\\n *\\n * This directive lets you add a CSS class to an element when the link\\'s route\\n * becomes active.\\n *\\n * Consider the following example:\\n *\\n * ```\\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\\n * ```\\n *\\n * When the url is either \\'/user\\' or \\'/user/bob\\', the active-link class will\\n * be added to the `a` tag. If the url changes, the class will be removed.\\n *\\n * You can set more than one class, as follows:\\n *\\n * ```\\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"[\\'class1\\', \\'class2\\']\">Bob</a>\\n * ```\\n *\\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\\n * only when the url matches the link exactly.\\n *\\n * ```\\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\\n * true}\">Bob</a>\\n * ```\\n *\\n * You can assign the RouterLinkActive instance to a template variable and directly check\\n * the `isActive` status.\\n * ```\\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\\n *   Bob {{ rla.isActive ? \\'(already open)\\' : \\'\\'}}\\n * </a>\\n * ```\\n *\\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\\n *\\n * ```\\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\\n *   <a routerLink=\"/user/jim\">Jim</a>\\n *   <a routerLink=\"/user/bob\">Bob</a>\\n * </div>\\n * ```\\n *\\n * This will set the active-link class on the div tag if the url is either \\'/user/jim\\' or\\n * \\'/user/bob\\'.\\n *\\n * @ngModule RouterModule\\n *\\n * @publicApi\\n */\\nvar router_RouterLinkActive = /** @class */ (function () {\\n    function RouterLinkActive(router, element, renderer, cdr) {\\n        var _this = this;\\n        this.router = router;\\n        this.element = element;\\n        this.renderer = renderer;\\n        this.cdr = cdr;\\n        this.classes = [];\\n        this.isActive = false;\\n        this.routerLinkActiveOptions = { exact: false };\\n        this.subscription = router.events.subscribe(function (s) {\\n            if (s instanceof router_NavigationEnd) {\\n                _this.update();\\n            }\\n        });\\n    }\\n    RouterLinkActive.prototype.ngAfterContentInit = function () {\\n        var _this = this;\\n        this.links.changes.subscribe(function (_) { return _this.update(); });\\n        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });\\n        this.update();\\n    };\\n    Object.defineProperty(RouterLinkActive.prototype, \"routerLinkActive\", {\\n        set: function (data) {\\n            var classes = Array.isArray(data) ? data : data.split(\\' \\');\\n            this.classes = classes.filter(function (c) { return !!c; });\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };\\n    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\\n    RouterLinkActive.prototype.update = function () {\\n        var _this = this;\\n        if (!this.links || !this.linksWithHrefs || !this.router.navigated)\\n            return;\\n        Promise.resolve().then(function () {\\n            var hasActiveLinks = _this.hasActiveLinks();\\n            if (_this.isActive !== hasActiveLinks) {\\n                _this.isActive = hasActiveLinks;\\n                _this.classes.forEach(function (c) {\\n                    if (hasActiveLinks) {\\n                        _this.renderer.addClass(_this.element.nativeElement, c);\\n                    }\\n                    else {\\n                        _this.renderer.removeClass(_this.element.nativeElement, c);\\n                    }\\n                });\\n            }\\n        });\\n    };\\n    RouterLinkActive.prototype.isLinkActive = function (router) {\\n        var _this = this;\\n        return function (link) {\\n            return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);\\n        };\\n    };\\n    RouterLinkActive.prototype.hasActiveLinks = function () {\\n        return this.links.some(this.isLinkActive(this.router)) ||\\n            this.linksWithHrefs.some(this.isLinkActive(this.router));\\n    };\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"ContentChildren\"])(router_RouterLink, { descendants: true }),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", core[\"QueryList\"])\\n    ], RouterLinkActive.prototype, \"links\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"ContentChildren\"])(router_RouterLinkWithHref, { descendants: true }),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", core[\"QueryList\"])\\n    ], RouterLinkActive.prototype, \"linksWithHrefs\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object)\\n    ], RouterLinkActive.prototype, \"routerLinkActiveOptions\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Input\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Object])\\n    ], RouterLinkActive.prototype, \"routerLinkActive\", null);\\n    RouterLinkActive = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Directive\"])({\\n            selector: \\'[routerLinkActive]\\',\\n            exportAs: \\'routerLinkActive\\',\\n        }),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [router_Router, core[\"ElementRef\"], core[\"Renderer2\"],\\n            core[\"ChangeDetectorRef\"]])\\n    ], RouterLinkActive);\\n    return RouterLinkActive;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * Store contextual information about a `RouterOutlet`\\n *\\n * @publicApi\\n */\\nvar OutletContext = /** @class */ (function () {\\n    function OutletContext() {\\n        this.outlet = null;\\n        this.route = null;\\n        this.resolver = null;\\n        this.children = new ChildrenOutletContexts();\\n        this.attachRef = null;\\n    }\\n    return OutletContext;\\n}());\\n/**\\n * Store contextual information about the children (= nested) `RouterOutlet`\\n *\\n * @publicApi\\n */\\nvar ChildrenOutletContexts = /** @class */ (function () {\\n    function ChildrenOutletContexts() {\\n        // contexts for child outlets, by name.\\n        this.contexts = new Map();\\n    }\\n    /** Called when a `RouterOutlet` directive is instantiated */\\n    ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {\\n        var context = this.getOrCreateContext(childName);\\n        context.outlet = outlet;\\n        this.contexts.set(childName, context);\\n    };\\n    /**\\n     * Called when a `RouterOutlet` directive is destroyed.\\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\\n     * re-created later.\\n     */\\n    ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {\\n        var context = this.getContext(childName);\\n        if (context) {\\n            context.outlet = null;\\n        }\\n    };\\n    /**\\n     * Called when the corresponding route is deactivated during navigation.\\n     * Because the component get destroyed, all children outlet are destroyed.\\n     */\\n    ChildrenOutletContexts.prototype.onOutletDeactivated = function () {\\n        var contexts = this.contexts;\\n        this.contexts = new Map();\\n        return contexts;\\n    };\\n    ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };\\n    ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {\\n        var context = this.getContext(childName);\\n        if (!context) {\\n            context = new OutletContext();\\n            this.contexts.set(childName, context);\\n        }\\n        return context;\\n    };\\n    ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };\\n    return ChildrenOutletContexts;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\\n *\\n * ```\\n * <router-outlet></router-outlet>\\n * <router-outlet name=\\'left\\'></router-outlet>\\n * <router-outlet name=\\'right\\'></router-outlet>\\n * ```\\n *\\n * A router outlet will emit an activate event any time a new component is being instantiated,\\n * and a deactivate event when it is being destroyed.\\n *\\n * ```\\n * <router-outlet\\n *   (activate)=\\'onActivate($event)\\'\\n *   (deactivate)=\\'onDeactivate($event)\\'></router-outlet>\\n * ```\\n * @ngModule RouterModule\\n *\\n * @publicApi\\n */\\nvar router_RouterOutlet = /** @class */ (function () {\\n    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {\\n        this.parentContexts = parentContexts;\\n        this.location = location;\\n        this.resolver = resolver;\\n        this.changeDetector = changeDetector;\\n        this.activated = null;\\n        this._activatedRoute = null;\\n        this.activateEvents = new core[\"EventEmitter\"]();\\n        this.deactivateEvents = new core[\"EventEmitter\"]();\\n        this.name = name || PRIMARY_OUTLET;\\n        parentContexts.onChildOutletCreated(this.name, this);\\n    }\\n    RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };\\n    RouterOutlet.prototype.ngOnInit = function () {\\n        if (!this.activated) {\\n            // If the outlet was not instantiated at the time the route got activated we need to populate\\n            // the outlet when it is initialized (ie inside a NgIf)\\n            var context = this.parentContexts.getContext(this.name);\\n            if (context && context.route) {\\n                if (context.attachRef) {\\n                    // `attachRef` is populated when there is an existing component to mount\\n                    this.attach(context.attachRef, context.route);\\n                }\\n                else {\\n                    // otherwise the component defined in the configuration is created\\n                    this.activateWith(context.route, context.resolver || null);\\n                }\\n            }\\n        }\\n    };\\n    Object.defineProperty(RouterOutlet.prototype, \"isActivated\", {\\n        get: function () { return !!this.activated; },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(RouterOutlet.prototype, \"component\", {\\n        get: function () {\\n            if (!this.activated)\\n                throw new Error(\\'Outlet is not activated\\');\\n            return this.activated.instance;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRoute\", {\\n        get: function () {\\n            if (!this.activated)\\n                throw new Error(\\'Outlet is not activated\\');\\n            return this._activatedRoute;\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    Object.defineProperty(RouterOutlet.prototype, \"activatedRouteData\", {\\n        get: function () {\\n            if (this._activatedRoute) {\\n                return this._activatedRoute.snapshot.data;\\n            }\\n            return {};\\n        },\\n        enumerable: true,\\n        configurable: true\\n    });\\n    /**\\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\\n     */\\n    RouterOutlet.prototype.detach = function () {\\n        if (!this.activated)\\n            throw new Error(\\'Outlet is not activated\\');\\n        this.location.detach();\\n        var cmp = this.activated;\\n        this.activated = null;\\n        this._activatedRoute = null;\\n        return cmp;\\n    };\\n    /**\\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\\n     */\\n    RouterOutlet.prototype.attach = function (ref, activatedRoute) {\\n        this.activated = ref;\\n        this._activatedRoute = activatedRoute;\\n        this.location.insert(ref.hostView);\\n    };\\n    RouterOutlet.prototype.deactivate = function () {\\n        if (this.activated) {\\n            var c = this.component;\\n            this.activated.destroy();\\n            this.activated = null;\\n            this._activatedRoute = null;\\n            this.deactivateEvents.emit(c);\\n        }\\n    };\\n    RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {\\n        if (this.isActivated) {\\n            throw new Error(\\'Cannot activate an already activated outlet\\');\\n        }\\n        this._activatedRoute = activatedRoute;\\n        var snapshot = activatedRoute._futureSnapshot;\\n        var component = snapshot.routeConfig.component;\\n        resolver = resolver || this.resolver;\\n        var factory = resolver.resolveComponentFactory(component);\\n        var childContexts = this.parentContexts.getOrCreateContext(this.name).children;\\n        var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);\\n        this.activated = this.location.createComponent(factory, this.location.length, injector);\\n        // Calling `markForCheck` to make sure we will run the change detection when the\\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\\n        this.changeDetector.markForCheck();\\n        this.activateEvents.emit(this.activated.instance);\\n    };\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Output\"])(\\'activate\\'),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object)\\n    ], RouterOutlet.prototype, \"activateEvents\", void 0);\\n    Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Output\"])(\\'deactivate\\'),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:type\", Object)\\n    ], RouterOutlet.prototype, \"deactivateEvents\", void 0);\\n    RouterOutlet = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Directive\"])({ selector: \\'router-outlet\\', exportAs: \\'outlet\\' }),\\n        Object(tslib_es6[\"e\" /* __param */])(3, Object(core[\"Attribute\"])(\\'name\\')),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [ChildrenOutletContexts, core[\"ViewContainerRef\"],\\n            core[\"ComponentFactoryResolver\"], String, core[\"ChangeDetectorRef\"]])\\n    ], RouterOutlet);\\n    return RouterOutlet;\\n}());\\nvar OutletInjector = /** @class */ (function () {\\n    function OutletInjector(route, childContexts, parent) {\\n        this.route = route;\\n        this.childContexts = childContexts;\\n        this.parent = parent;\\n    }\\n    OutletInjector.prototype.get = function (token, notFoundValue) {\\n        if (token === router_ActivatedRoute) {\\n            return this.route;\\n        }\\n        if (token === ChildrenOutletContexts) {\\n            return this.childContexts;\\n        }\\n        return this.parent.get(token, notFoundValue);\\n    };\\n    return OutletInjector;\\n}());\\n\\n/**\\n*@license\\n*Copyright Google Inc. All Rights Reserved.\\n*\\n*Use of this source code is governed by an MIT-style license that can be\\n*found in the LICENSE file at https://angular.io/license\\n*/\\n/**\\n * @description\\n *\\n * Provides a preloading strategy.\\n *\\n * @publicApi\\n */\\nvar PreloadingStrategy = /** @class */ (function () {\\n    function PreloadingStrategy() {\\n    }\\n    return PreloadingStrategy;\\n}());\\n/**\\n * @description\\n *\\n * Provides a preloading strategy that preloads all modules as quickly as possible.\\n *\\n * ```\\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\\n * ```\\n *\\n * @publicApi\\n */\\nvar router_PreloadAllModules = /** @class */ (function () {\\n    function PreloadAllModules() {\\n    }\\n    PreloadAllModules.prototype.preload = function (route, fn) {\\n        return fn().pipe(catchError(function () { return Object(of[\"a\" /* of */])(null); }));\\n    };\\n    return PreloadAllModules;\\n}());\\n/**\\n * @description\\n *\\n * Provides a preloading strategy that does not preload any modules.\\n *\\n * This strategy is enabled by default.\\n *\\n * @publicApi\\n */\\nvar router_NoPreloading = /** @class */ (function () {\\n    function NoPreloading() {\\n    }\\n    NoPreloading.prototype.preload = function (route, fn) { return Object(of[\"a\" /* of */])(null); };\\n    return NoPreloading;\\n}());\\n/**\\n * The preloader optimistically loads all router configurations to\\n * make navigations into lazily-loaded sections of the application faster.\\n *\\n * The preloader runs in the background. When the router bootstraps, the preloader\\n * starts listening to all navigation events. After every such event, the preloader\\n * will check if any configurations can be loaded lazily.\\n *\\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\\n *\\n * @publicApi\\n */\\nvar router_RouterPreloader = /** @class */ (function () {\\n    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {\\n        this.router = router;\\n        this.injector = injector;\\n        this.preloadingStrategy = preloadingStrategy;\\n        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };\\n        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };\\n        this.loader = new router_RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);\\n    }\\n    RouterPreloader.prototype.setUpPreloading = function () {\\n        var _this = this;\\n        this.subscription =\\n            this.router.events\\n                .pipe(filter(function (e) { return e instanceof router_NavigationEnd; }), concatMap(function () { return _this.preload(); }))\\n                .subscribe(function () { });\\n    };\\n    RouterPreloader.prototype.preload = function () {\\n        var ngModule = this.injector.get(core[\"NgModuleRef\"]);\\n        return this.processRoutes(ngModule, this.router.config);\\n    };\\n    // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If\\n    // this hasn\\'t been done, ngOnDestroy will fail as this.subscription will be undefined. This\\n    // should be refactored.\\n    RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };\\n    RouterPreloader.prototype.processRoutes = function (ngModule, routes) {\\n        var e_1, _a;\\n        var res = [];\\n        try {\\n            for (var routes_1 = Object(tslib_es6[\"h\" /* __values */])(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\\n                var route = routes_1_1.value;\\n                // we already have the config loaded, just recurse\\n                if (route.loadChildren && !route.canLoad && route._loadedConfig) {\\n                    var childConfig = route._loadedConfig;\\n                    res.push(this.processRoutes(childConfig.module, childConfig.routes));\\n                    // no config loaded, fetch the config\\n                }\\n                else if (route.loadChildren && !route.canLoad) {\\n                    res.push(this.preloadConfig(ngModule, route));\\n                    // recurse into children\\n                }\\n                else if (route.children) {\\n                    res.push(this.processRoutes(ngModule, route.children));\\n                }\\n            }\\n        }\\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\\n        finally {\\n            try {\\n                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\\n            }\\n            finally { if (e_1) throw e_1.error; }\\n        }\\n        return Object(from[\"a\" /* from */])(res).pipe(Object(mergeAll[\"a\" /* mergeAll */])(), Object(map[\"a\" /* map */])(function (_) { return void 0; }));\\n    };\\n    RouterPreloader.prototype.preloadConfig = function (ngModule, route) {\\n        var _this = this;\\n        return this.preloadingStrategy.preload(route, function () {\\n            var loaded$ = _this.loader.load(ngModule.injector, route);\\n            return loaded$.pipe(Object(mergeMap[\"a\" /* mergeMap */])(function (config) {\\n                route._loadedConfig = config;\\n                return _this.processRoutes(config.module, config.routes);\\n            }));\\n        });\\n    };\\n    RouterPreloader = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Injectable\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [router_Router, core[\"NgModuleFactoryLoader\"], core[\"Compiler\"],\\n            core[\"Injector\"], PreloadingStrategy])\\n    ], RouterPreloader);\\n    return RouterPreloader;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\nvar RouterScroller = /** @class */ (function () {\\n    function RouterScroller(router, \\n    /** @docsNotRequired */ viewportScroller, options) {\\n        if (options === void 0) { options = {}; }\\n        this.router = router;\\n        this.viewportScroller = viewportScroller;\\n        this.options = options;\\n        this.lastId = 0;\\n        this.lastSource = \\'imperative\\';\\n        this.restoredId = 0;\\n        this.store = {};\\n        // Default both options to \\'disabled\\'\\n        options.scrollPositionRestoration = options.scrollPositionRestoration || \\'disabled\\';\\n        options.anchorScrolling = options.anchorScrolling || \\'disabled\\';\\n    }\\n    RouterScroller.prototype.init = function () {\\n        // we want to disable the automatic scrolling because having two places\\n        // responsible for scrolling results race conditions, especially given\\n        // that browser don\\'t implement this behavior consistently\\n        if (this.options.scrollPositionRestoration !== \\'disabled\\') {\\n            this.viewportScroller.setHistoryScrollRestoration(\\'manual\\');\\n        }\\n        this.routerEventsSubscription = this.createScrollEvents();\\n        this.scrollEventsSubscription = this.consumeScrollEvents();\\n    };\\n    RouterScroller.prototype.createScrollEvents = function () {\\n        var _this = this;\\n        return this.router.events.subscribe(function (e) {\\n            if (e instanceof router_NavigationStart) {\\n                // store the scroll position of the current stable navigations.\\n                _this.store[_this.lastId] = _this.viewportScroller.getScrollPosition();\\n                _this.lastSource = e.navigationTrigger;\\n                _this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\\n            }\\n            else if (e instanceof router_NavigationEnd) {\\n                _this.lastId = e.id;\\n                _this.scheduleScrollEvent(e, _this.router.parseUrl(e.urlAfterRedirects).fragment);\\n            }\\n        });\\n    };\\n    RouterScroller.prototype.consumeScrollEvents = function () {\\n        var _this = this;\\n        return this.router.events.subscribe(function (e) {\\n            if (!(e instanceof Scroll))\\n                return;\\n            // a popstate event. The pop state event will always ignore anchor scrolling.\\n            if (e.position) {\\n                if (_this.options.scrollPositionRestoration === \\'top\\') {\\n                    _this.viewportScroller.scrollToPosition([0, 0]);\\n                }\\n                else if (_this.options.scrollPositionRestoration === \\'enabled\\') {\\n                    _this.viewportScroller.scrollToPosition(e.position);\\n                }\\n                // imperative navigation \"forward\"\\n            }\\n            else {\\n                if (e.anchor && _this.options.anchorScrolling === \\'enabled\\') {\\n                    _this.viewportScroller.scrollToAnchor(e.anchor);\\n                }\\n                else if (_this.options.scrollPositionRestoration !== \\'disabled\\') {\\n                    _this.viewportScroller.scrollToPosition([0, 0]);\\n                }\\n            }\\n        });\\n    };\\n    RouterScroller.prototype.scheduleScrollEvent = function (routerEvent, anchor) {\\n        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === \\'popstate\\' ? this.store[this.restoredId] : null, anchor));\\n    };\\n    RouterScroller.prototype.ngOnDestroy = function () {\\n        if (this.routerEventsSubscription) {\\n            this.routerEventsSubscription.unsubscribe();\\n        }\\n        if (this.scrollEventsSubscription) {\\n            this.scrollEventsSubscription.unsubscribe();\\n        }\\n    };\\n    return RouterScroller;\\n}());\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @description\\n *\\n * Contains a list of directives\\n *\\n *\\n */\\nvar ROUTER_DIRECTIVES = [router_RouterOutlet, router_RouterLink, router_RouterLinkWithHref, router_RouterLinkActive, router_EmptyOutletComponent];\\n/**\\n * @description\\n *\\n * Is used in DI to configure the router.\\n *\\n * @publicApi\\n */\\nvar ROUTER_CONFIGURATION = new core[\"InjectionToken\"](\\'ROUTER_CONFIGURATION\\');\\n/**\\n * @docsNotRequired\\n */\\nvar ROUTER_FORROOT_GUARD = new core[\"InjectionToken\"](\\'ROUTER_FORROOT_GUARD\\');\\nvar ROUTER_PROVIDERS = [\\n    common[\"Location\"],\\n    { provide: UrlSerializer, useClass: DefaultUrlSerializer },\\n    {\\n        provide: router_Router,\\n        useFactory: setupRouter,\\n        deps: [\\n            core[\"ApplicationRef\"], UrlSerializer, ChildrenOutletContexts, common[\"Location\"], core[\"Injector\"],\\n            core[\"NgModuleFactoryLoader\"], core[\"Compiler\"], ROUTES, ROUTER_CONFIGURATION,\\n            [UrlHandlingStrategy, new core[\"Optional\"]()], [RouteReuseStrategy, new core[\"Optional\"]()]\\n        ]\\n    },\\n    ChildrenOutletContexts,\\n    { provide: router_ActivatedRoute, useFactory: rootRoute, deps: [router_Router] },\\n    { provide: core[\"NgModuleFactoryLoader\"], useClass: core[\"SystemJsNgModuleLoader\"] },\\n    router_RouterPreloader,\\n    router_NoPreloading,\\n    router_PreloadAllModules,\\n    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },\\n];\\nfunction routerNgProbeToken() {\\n    return new core[\"NgProbeToken\"](\\'Router\\', router_Router);\\n}\\n/**\\n * @usageNotes\\n *\\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\\n * Since the router deals with a global shared resource--location, we cannot have\\n * more than one router service active.\\n *\\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\\n * `RouterModule.forChild`.\\n *\\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\\n *   service itself.\\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\\n *   include the router service.\\n *\\n * When registered at the root, the module should be used as follows\\n *\\n * ```\\n * @NgModule({\\n *   imports: [RouterModule.forRoot(ROUTES)]\\n * })\\n * class MyNgModule {}\\n * ```\\n *\\n * For submodules and lazy loaded submodules the module should be used as follows:\\n *\\n * ```\\n * @NgModule({\\n *   imports: [RouterModule.forChild(ROUTES)]\\n * })\\n * class MyNgModule {}\\n * ```\\n *\\n * @description\\n *\\n * Adds router directives and providers.\\n *\\n * Managing state transitions is one of the hardest parts of building applications. This is\\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\\n * In addition, we often want to split applications into multiple bundles and load them on demand.\\n * Doing this transparently is not trivial.\\n *\\n * The Angular router solves these problems. Using the router, you can declaratively specify\\n * application states, manage state transitions while taking care of the URL, and load bundles on\\n * demand.\\n *\\n * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an\\n * overview of how the router should be used.\\n *\\n * @publicApi\\n */\\nvar router_RouterModule = /** @class */ (function () {\\n    // Note: We are injecting the Router so it gets created eagerly...\\n    function RouterModule(guard, router) {\\n    }\\n    RouterModule_1 = RouterModule;\\n    /**\\n     * Creates a module with all the router providers and directives. It also optionally sets up an\\n     * application listener to perform an initial navigation.\\n     *\\n     * Options (see `ExtraOptions`):\\n     * * `enableTracing` makes the router log all its internal events to the console.\\n     * * `useHash` enables the location strategy that uses the URL fragment instead of the history\\n     * API.\\n     * * `initialNavigation` disables the initial navigation.\\n     * * `errorHandler` provides a custom error handler.\\n     * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).\\n     * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See\\n     * `ExtraOptions` for more details.\\n     * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data\\n     * from parent to child routes.\\n     */\\n    RouterModule.forRoot = function (routes, config) {\\n        return {\\n            ngModule: RouterModule_1,\\n            providers: [\\n                ROUTER_PROVIDERS,\\n                provideRoutes(routes),\\n                {\\n                    provide: ROUTER_FORROOT_GUARD,\\n                    useFactory: provideForRootGuard,\\n                    deps: [[router_Router, new core[\"Optional\"](), new core[\"SkipSelf\"]()]]\\n                },\\n                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\\n                {\\n                    provide: common[\"LocationStrategy\"],\\n                    useFactory: provideLocationStrategy,\\n                    deps: [\\n                        common[\"PlatformLocation\"], [new core[\"Inject\"](common[\"APP_BASE_HREF\"]), new core[\"Optional\"]()], ROUTER_CONFIGURATION\\n                    ]\\n                },\\n                {\\n                    provide: RouterScroller,\\n                    useFactory: createRouterScroller,\\n                    deps: [router_Router, common[\"ViewportScroller\"], ROUTER_CONFIGURATION]\\n                },\\n                {\\n                    provide: PreloadingStrategy,\\n                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :\\n                        router_NoPreloading\\n                },\\n                { provide: core[\"NgProbeToken\"], multi: true, useFactory: routerNgProbeToken },\\n                provideRouterInitializer(),\\n            ],\\n        };\\n    };\\n    /**\\n     * Creates a module with all the router directives and a provider registering routes.\\n     */\\n    RouterModule.forChild = function (routes) {\\n        return { ngModule: RouterModule_1, providers: [provideRoutes(routes)] };\\n    };\\n    var RouterModule_1;\\n    RouterModule = RouterModule_1 = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"NgModule\"])({\\n            declarations: ROUTER_DIRECTIVES,\\n            exports: ROUTER_DIRECTIVES,\\n            entryComponents: [router_EmptyOutletComponent]\\n        }),\\n        Object(tslib_es6[\"e\" /* __param */])(0, Object(core[\"Optional\"])()), Object(tslib_es6[\"e\" /* __param */])(0, Object(core[\"Inject\"])(ROUTER_FORROOT_GUARD)), Object(tslib_es6[\"e\" /* __param */])(1, Object(core[\"Optional\"])()),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [Object, router_Router])\\n    ], RouterModule);\\n    return RouterModule;\\n}());\\nfunction createRouterScroller(router, viewportScroller, config) {\\n    if (config.scrollOffset) {\\n        viewportScroller.setOffset(config.scrollOffset);\\n    }\\n    return new RouterScroller(router, viewportScroller, config);\\n}\\nfunction provideLocationStrategy(platformLocationStrategy, baseHref, options) {\\n    if (options === void 0) { options = {}; }\\n    return options.useHash ? new common[\"HashLocationStrategy\"](platformLocationStrategy, baseHref) :\\n        new common[\"PathLocationStrategy\"](platformLocationStrategy, baseHref);\\n}\\nfunction provideForRootGuard(router) {\\n    if (router) {\\n        throw new Error(\"RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.\");\\n    }\\n    return \\'guarded\\';\\n}\\n/**\\n * @description\\n *\\n * Registers routes.\\n *\\n * @usageNotes\\n * ### Example\\n *\\n * ```\\n * @NgModule({\\n *   imports: [RouterModule.forChild(ROUTES)],\\n *   providers: [provideRoutes(EXTRA_ROUTES)]\\n * })\\n * class MyNgModule {}\\n * ```\\n *\\n * @publicApi\\n */\\nfunction provideRoutes(routes) {\\n    return [\\n        { provide: core[\"ANALYZE_FOR_ENTRY_COMPONENTS\"], multi: true, useValue: routes },\\n        { provide: ROUTES, multi: true, useValue: routes },\\n    ];\\n}\\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {\\n    if (opts === void 0) { opts = {}; }\\n    var router = new router_Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));\\n    if (urlHandlingStrategy) {\\n        router.urlHandlingStrategy = urlHandlingStrategy;\\n    }\\n    if (routeReuseStrategy) {\\n        router.routeReuseStrategy = routeReuseStrategy;\\n    }\\n    if (opts.errorHandler) {\\n        router.errorHandler = opts.errorHandler;\\n    }\\n    if (opts.malformedUriErrorHandler) {\\n        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\\n    }\\n    if (opts.enableTracing) {\\n        var dom_1 = Object(platform_browser[\"ɵgetDOM\"])();\\n        router.events.subscribe(function (e) {\\n            dom_1.logGroup(\"Router Event: \" + e.constructor.name);\\n            dom_1.log(e.toString());\\n            dom_1.log(e);\\n            dom_1.logGroupEnd();\\n        });\\n    }\\n    if (opts.onSameUrlNavigation) {\\n        router.onSameUrlNavigation = opts.onSameUrlNavigation;\\n    }\\n    if (opts.paramsInheritanceStrategy) {\\n        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\\n    }\\n    if (opts.urlUpdateStrategy) {\\n        router.urlUpdateStrategy = opts.urlUpdateStrategy;\\n    }\\n    if (opts.relativeLinkResolution) {\\n        router.relativeLinkResolution = opts.relativeLinkResolution;\\n    }\\n    return router;\\n}\\nfunction rootRoute(router) {\\n    return router.routerState.root;\\n}\\n/**\\n * To initialize the router properly we need to do in two steps:\\n *\\n * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if\\n * a resolver or a guards executes asynchronously. Second, we need to actually run\\n * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation\\n * hook provided by the router to do that.\\n *\\n * The router navigation starts, reaches the point when preactivation is done, and then\\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\\n */\\nvar router_RouterInitializer = /** @class */ (function () {\\n    function RouterInitializer(injector) {\\n        this.injector = injector;\\n        this.initNavigation = false;\\n        this.resultOfPreactivationDone = new Subject[\"a\" /* Subject */]();\\n    }\\n    RouterInitializer.prototype.appInitializer = function () {\\n        var _this = this;\\n        var p = this.injector.get(common[\"LOCATION_INITIALIZED\"], Promise.resolve(null));\\n        return p.then(function () {\\n            var resolve = null;\\n            var res = new Promise(function (r) { return resolve = r; });\\n            var router = _this.injector.get(router_Router);\\n            var opts = _this.injector.get(ROUTER_CONFIGURATION);\\n            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {\\n                resolve(true);\\n            }\\n            else if (opts.initialNavigation === \\'disabled\\') {\\n                router.setUpLocationChangeListener();\\n                resolve(true);\\n            }\\n            else if (opts.initialNavigation === \\'enabled\\') {\\n                router.hooks.afterPreactivation = function () {\\n                    // only the initial navigation should be delayed\\n                    if (!_this.initNavigation) {\\n                        _this.initNavigation = true;\\n                        resolve(true);\\n                        return _this.resultOfPreactivationDone;\\n                        // subsequent navigations should not be delayed\\n                    }\\n                    else {\\n                        return Object(of[\"a\" /* of */])(null);\\n                    }\\n                };\\n                router.initialNavigation();\\n            }\\n            else {\\n                throw new Error(\"Invalid initialNavigation options: \\'\" + opts.initialNavigation + \"\\'\");\\n            }\\n            return res;\\n        });\\n    };\\n    RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {\\n        var opts = this.injector.get(ROUTER_CONFIGURATION);\\n        var preloader = this.injector.get(router_RouterPreloader);\\n        var routerScroller = this.injector.get(RouterScroller);\\n        var router = this.injector.get(router_Router);\\n        var ref = this.injector.get(core[\"ApplicationRef\"]);\\n        if (bootstrappedComponentRef !== ref.components[0]) {\\n            return;\\n        }\\n        if (this.isLegacyEnabled(opts)) {\\n            router.initialNavigation();\\n        }\\n        else if (this.isLegacyDisabled(opts)) {\\n            router.setUpLocationChangeListener();\\n        }\\n        preloader.setUpPreloading();\\n        routerScroller.init();\\n        router.resetRootComponentType(ref.componentTypes[0]);\\n        this.resultOfPreactivationDone.next(null);\\n        this.resultOfPreactivationDone.complete();\\n    };\\n    RouterInitializer.prototype.isLegacyEnabled = function (opts) {\\n        return opts.initialNavigation === \\'legacy_enabled\\' || opts.initialNavigation === true ||\\n            opts.initialNavigation === undefined;\\n    };\\n    RouterInitializer.prototype.isLegacyDisabled = function (opts) {\\n        return opts.initialNavigation === \\'legacy_disabled\\' || opts.initialNavigation === false;\\n    };\\n    RouterInitializer = Object(tslib_es6[\"b\" /* __decorate */])([\\n        Object(core[\"Injectable\"])(),\\n        Object(tslib_es6[\"d\" /* __metadata */])(\"design:paramtypes\", [core[\"Injector\"]])\\n    ], RouterInitializer);\\n    return RouterInitializer;\\n}());\\nfunction getAppInitializer(r) {\\n    return r.appInitializer.bind(r);\\n}\\nfunction getBootstrapListener(r) {\\n    return r.bootstrapListener.bind(r);\\n}\\n/**\\n * A token for the router initializer that will be called after the app is bootstrapped.\\n *\\n * @publicApi\\n */\\nvar ROUTER_INITIALIZER = new core[\"InjectionToken\"](\\'Router Initializer\\');\\nfunction provideRouterInitializer() {\\n    return [\\n        router_RouterInitializer,\\n        {\\n            provide: core[\"APP_INITIALIZER\"],\\n            multi: true,\\n            useFactory: getAppInitializer,\\n            deps: [router_RouterInitializer]\\n        },\\n        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [router_RouterInitializer] },\\n        { provide: core[\"APP_BOOTSTRAP_LISTENER\"], multi: true, useExisting: ROUTER_INITIALIZER },\\n    ];\\n}\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n/**\\n * @publicApi\\n */\\nvar VERSION = new core[\"Version\"](\\'7.0.4\\');\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n// This file only reexports content of the `src` folder. Keep it that way.\\n\\n/**\\n * @license\\n * Copyright Google Inc. All Rights Reserved.\\n *\\n * Use of this source code is governed by an MIT-style license that can be\\n * found in the LICENSE file at https://angular.io/license\\n */\\n\\n/**\\n * Generated bundle index. Do not edit.\\n */\\n\\n\\n//# sourceMappingURL=router.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qcz81NjcwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlTGFzdC5qcz8wMzE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy90YXAuanM/YzRjYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3dJZkVtcHR5LmpzP2I0ZDUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzPzFjOTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2xhc3QuanM/YzM1MSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZXZlcnkuanM/Y2MwNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvY2F0Y2hFcnJvci5qcz9mNTlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzP2I3ZDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpcnN0LmpzPzNmYWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaE1hcC5qcz9kNzkyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXAuanM/M2UxOCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvc2Nhbi5qcz83NDJkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanM/NDIwNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmluYWxpemUuanM/ZDk2YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcm91dGVyL2Zlc201L3JvdXRlci5qcz82NTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpbHRlck9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSk7XG4gICAgfTtcbn1cbnZhciBGaWx0ZXJPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlsdGVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCkpO1xudmFyIEZpbHRlclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfdXRpbF9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcixfb2JzZXJ2YWJsZV9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgfSBmcm9tICcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9lbXB0eSc7XG5leHBvcnQgZnVuY3Rpb24gdGFrZUxhc3QoY291bnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGFrZUxhc3RPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlTGFzdE9wZXJhdG9yKGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIFRha2VMYXN0T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VMYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VMYXN0T3BlcmF0b3I7XG59KCkpO1xudmFyIFRha2VMYXN0U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUYWtlTGFzdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZUxhc3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgX3RoaXMucmluZyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFrZUxhc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCB0b3RhbCkge1xuICAgICAgICAgICAgcmluZy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvdW50ICUgdG90YWw7XG4gICAgICAgICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWtlTGFzdFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5jb3VudCA+PSB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCA6IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHRoaXMucmluZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSAoY291bnQrKykgJSB0b3RhbDtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJpbmdbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlTGFzdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VMYXN0LmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfdXRpbF9ub29wLF91dGlsX2lzRnVuY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXNGdW5jdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gdGFwKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGFwT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpKTtcbiAgICB9O1xufVxudmFyIERvT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMubmV4dE9yT2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIERvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dE9yT2JzZXJ2ZXIsIHRoaXMuZXJyb3IsIHRoaXMuY29tcGxldGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEb09wZXJhdG9yO1xufSgpKTtcbnZhciBUYXBTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRhcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3RhcE5leHQgPSBub29wO1xuICAgICAgICBfdGhpcy5fdGFwRXJyb3IgPSBub29wO1xuICAgICAgICBfdGhpcy5fdGFwQ29tcGxldGUgPSBub29wO1xuICAgICAgICBfdGhpcy5fdGFwRXJyb3IgPSBlcnJvciB8fCBub29wO1xuICAgICAgICBfdGhpcy5fdGFwQ29tcGxldGUgPSBjb21wbGV0ZSB8fCBub29wO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb250ZXh0ID0gX3RoaXM7XG4gICAgICAgICAgICBfdGhpcy5fdGFwTmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBfdGhpcy5fY29udGV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgX3RoaXMuX3RhcE5leHQgPSBvYnNlcnZlck9yTmV4dC5uZXh0IHx8IG5vb3A7XG4gICAgICAgICAgICBfdGhpcy5fdGFwRXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvciB8fCBub29wO1xuICAgICAgICAgICAgX3RoaXMuX3RhcENvbXBsZXRlID0gb2JzZXJ2ZXJPck5leHQuY29tcGxldGUgfHwgbm9vcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90YXBOZXh0LmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgVGFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fdGFwRXJyb3IuY2FsbCh0aGlzLl9jb250ZXh0LCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBUYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90YXBDb21wbGV0ZS5jYWxsKHRoaXMuX2NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3RhcCxfdXRpbF9FbXB0eUVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IHRhcCB9IGZyb20gJy4vdGFwJztcbmltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuLi91dGlsL0VtcHR5RXJyb3InO1xuZXhwb3J0IHZhciB0aHJvd0lmRW1wdHkgPSBmdW5jdGlvbiAoZXJyb3JGYWN0b3J5KSB7XG4gICAgaWYgKGVycm9yRmFjdG9yeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVycm9yRmFjdG9yeSA9IGRlZmF1bHRFcnJvckZhY3Rvcnk7XG4gICAgfVxuICAgIHJldHVybiB0YXAoe1xuICAgICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5oYXNWYWx1ZSA9IHRydWU7IH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvckZhY3RvcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eUVycm9yKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd0lmRW1wdHkuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdElmRW1wdHkoZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UubGlmdChuZXcgRGVmYXVsdElmRW1wdHlPcGVyYXRvcihkZWZhdWx0VmFsdWUpKTsgfTtcbn1cbnZhciBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElmRW1wdHlPcGVyYXRvcjtcbn0oKSk7XG52YXIgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBfdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgRGVmYXVsdElmRW1wdHlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdElmRW1wdHkuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF91dGlsX0VtcHR5RXJyb3IsX2ZpbHRlcixfdGFrZUxhc3QsX3Rocm93SWZFbXB0eSxfZGVmYXVsdElmRW1wdHksX3V0aWxfaWRlbnRpdHkgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgeyB0YWtlTGFzdCB9IGZyb20gJy4vdGFrZUxhc3QnO1xuaW1wb3J0IHsgdGhyb3dJZkVtcHR5IH0gZnJvbSAnLi90aHJvd0lmRW1wdHknO1xuaW1wb3J0IHsgZGVmYXVsdElmRW1wdHkgfSBmcm9tICcuL2RlZmF1bHRJZkVtcHR5JztcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vdXRpbC9pZGVudGl0eSc7XG5leHBvcnQgZnVuY3Rpb24gbGFzdChwcmVkaWNhdGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBoYXNEZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID49IDI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5waXBlKHByZWRpY2F0ZSA/IGZpbHRlcihmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gcHJlZGljYXRlKHYsIGksIHNvdXJjZSk7IH0pIDogaWRlbnRpdHksIHRha2VMYXN0KDEpLCBoYXNEZWZhdWx0VmFsdWUgPyBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUpIDogdGhyb3dJZkVtcHR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFbXB0eUVycm9yKCk7IH0pKTsgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhc3QuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBFdmVyeU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSk7IH07XG59XG52YXIgRXZlcnlPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVyeU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgRXZlcnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBFdmVyeVN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlcnlPcGVyYXRvcjtcbn0oKSk7XG52YXIgRXZlcnlTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZXJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVyeVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZywgc291cmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIF90aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIF90aGlzLmluZGV4ID0gMDtcbiAgICAgICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgX3RoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXZlcnlTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVyeVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGV2ZXJ5VmFsdWVNYXRjaCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEV2ZXJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVyeVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVyeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZXJ5LmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfT3V0ZXJTdWJzY3JpYmVyLF9Jbm5lclN1YnNjcmliZXIsX3V0aWxfc3Vic2NyaWJlVG9SZXN1bHQgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcbmV4cG9ydCBmdW5jdGlvbiBjYXRjaEVycm9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhdGNoRXJyb3JPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSBuZXcgQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcik7XG4gICAgICAgIHZhciBjYXVnaHQgPSBzb3VyY2UubGlmdChvcGVyYXRvcik7XG4gICAgICAgIHJldHVybiAob3BlcmF0b3IuY2F1Z2h0ID0gY2F1Z2h0KTtcbiAgICB9O1xufVxudmFyIENhdGNoT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIENhdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDYXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zZWxlY3RvciwgdGhpcy5jYXVnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRjaE9wZXJhdG9yO1xufSgpKTtcbnZhciBDYXRjaFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2F0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2VsZWN0b3IsIGNhdWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgX3RoaXMuY2F1Z2h0ID0gY2F1Z2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0b3IoZXJyLCB0aGlzLmNhdWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnIyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgICAgIHZhciBpbm5lclN1YnNjcmliZXIgPSBuZXcgSW5uZXJTdWJzY3JpYmVyKHRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKGlubmVyU3Vic2NyaWJlcik7XG4gICAgICAgICAgICBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbm5lclN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoRXJyb3IuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF91dGlsX0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLF9vYnNlcnZhYmxlX2VtcHR5IFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciB9IGZyb20gJy4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuaW1wb3J0IHsgZW1wdHkgfSBmcm9tICcuLi9vYnNlcnZhYmxlL2VtcHR5JztcbmV4cG9ydCBmdW5jdGlvbiB0YWtlKGNvdW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgVGFrZU9wZXJhdG9yKGNvdW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIFRha2VPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUYWtlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZU9wZXJhdG9yO1xufSgpKTtcbnZhciBUYWtlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUYWtlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWtlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICAgICAgdmFyIGNvdW50ID0gKyt0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgPD0gdG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRha2VTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9FbXB0eUVycm9yLF9maWx0ZXIsX3Rha2UsX2RlZmF1bHRJZkVtcHR5LF90aHJvd0lmRW1wdHksX3V0aWxfaWRlbnRpdHkgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgeyB0YWtlIH0gZnJvbSAnLi90YWtlJztcbmltcG9ydCB7IGRlZmF1bHRJZkVtcHR5IH0gZnJvbSAnLi9kZWZhdWx0SWZFbXB0eSc7XG5pbXBvcnQgeyB0aHJvd0lmRW1wdHkgfSBmcm9tICcuL3Rocm93SWZFbXB0eSc7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4uL3V0aWwvaWRlbnRpdHknO1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGhhc0RlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLnBpcGUocHJlZGljYXRlID8gZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBwcmVkaWNhdGUodiwgaSwgc291cmNlKTsgfSkgOiBpZGVudGl0eSwgdGFrZSgxKSwgaGFzRGVmYXVsdFZhbHVlID8gZGVmYXVsdElmRW1wdHkoZGVmYXVsdFZhbHVlKSA6IHRocm93SWZFbXB0eShmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRW1wdHlFcnJvcigpOyB9KSk7IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX091dGVyU3Vic2NyaWJlcixfSW5uZXJTdWJzY3JpYmVyLF91dGlsX3N1YnNjcmliZVRvUmVzdWx0LF9tYXAsX29ic2VydmFibGVfZnJvbSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvZnJvbSc7XG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLnBpcGUoc3dpdGNoTWFwKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBmcm9tKHByb2plY3QoYSwgaSkpLnBpcGUobWFwKGZ1bmN0aW9uIChiLCBpaSkgeyByZXR1cm4gcmVzdWx0U2VsZWN0b3IoYSwgYiwgaSwgaWkpOyB9KSk7IH0pKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0KSk7IH07XG59XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBTd2l0Y2hNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoTWFwT3BlcmF0b3I7XG59KCkpO1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3dpdGNoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgX3RoaXMuaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKHJlc3VsdCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpYmVyID0gbmV3IElubmVyU3Vic2NyaWJlcih0aGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGRlc3RpbmF0aW9uLmFkZChpbm5lclN1YnNjcmliZXIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGlubmVyU3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBkZXN0aW5hdGlvbi5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX21lcmdlTWFwIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IG1lcmdlTWFwIH0gZnJvbSAnLi9tZXJnZU1hcCc7XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCAxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBzY2FuKGFjY3VtdWxhdG9yLCBzZWVkKSB7XG4gICAgdmFyIGhhc1NlZWQgPSBmYWxzZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGhhc1NlZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gc2Nhbk9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG4gICAgfTtcbn1cbnZhciBTY2FuT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIGlmIChoYXNTZWVkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc1NlZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yID0gYWNjdW11bGF0b3I7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMuaGFzU2VlZCA9IGhhc1NlZWQ7XG4gICAgfVxuICAgIFNjYW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNjYW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5oYXNTZWVkKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nhbk9wZXJhdG9yO1xufSgpKTtcbnZhciBTY2FuU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTY2FuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FuU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgYWNjdW11bGF0b3IsIF9zZWVkLCBoYXNTZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yO1xuICAgICAgICBfdGhpcy5fc2VlZCA9IF9zZWVkO1xuICAgICAgICBfdGhpcy5oYXNTZWVkID0gaGFzU2VlZDtcbiAgICAgICAgX3RoaXMuaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUsIFwic2VlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1NlZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2VlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTY2FuU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1NlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NhblN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYWNjdW11bGF0b3IodGhpcy5zZWVkLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlZWQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjYW5TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc2NhbixfdGFrZUxhc3QsX2RlZmF1bHRJZkVtcHR5LF91dGlsX3BpcGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgc2NhbiB9IGZyb20gJy4vc2Nhbic7XG5pbXBvcnQgeyB0YWtlTGFzdCB9IGZyb20gJy4vdGFrZUxhc3QnO1xuaW1wb3J0IHsgZGVmYXVsdElmRW1wdHkgfSBmcm9tICcuL2RlZmF1bHRJZkVtcHR5JztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICcuLi91dGlsL3BpcGUnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZShhY2N1bXVsYXRvciwgc2VlZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlZHVjZU9wZXJhdG9yRnVuY3Rpb25XaXRoU2VlZChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBlKHNjYW4oYWNjdW11bGF0b3IsIHNlZWQpLCB0YWtlTGFzdCgxKSwgZGVmYXVsdElmRW1wdHkoc2VlZCkpKHNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiByZWR1Y2VPcGVyYXRvckZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcGlwZShzY2FuKGZ1bmN0aW9uIChhY2MsIHZhbHVlLCBpbmRleCkgeyByZXR1cm4gYWNjdW11bGF0b3IoYWNjLCB2YWx1ZSwgaW5kZXggKyAxKTsgfSksIHRha2VMYXN0KDEpKShzb3VyY2UpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2UuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmxpZnQobmV3IEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykpOyB9O1xufVxudmFyIEZpbmFsbHlPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5hbGx5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNhbGxiYWNrKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluYWxseU9wZXJhdG9yO1xufSgpKTtcbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZpbmFsbHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5hbGl6ZS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Ny4wLjRcbiAqIChjKSAyMDEwLTIwMTggR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IF9fdmFsdWVzLCBfX2RlY29yYXRlLCBfX3BhcmFtLCBfX21ldGFkYXRhLCBfX2V4dGVuZHMsIF9fYXNzaWduLCBfX3NwcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IENvbXBvbmVudCwgybVpc09ic2VydmFibGUsIMm1aXNQcm9taXNlLCBOZ01vZHVsZVJlZiwgSW5qZWN0aW9uVG9rZW4sIE5nTW9kdWxlRmFjdG9yeSwgTmdab25lLCBpc0Rldk1vZGUsIMm1Q29uc29sZSwgQXR0cmlidXRlLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBSZW5kZXJlcjIsIENoYW5nZURldGVjdG9yUmVmLCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgVmlld0NvbnRhaW5lclJlZiwgQ29tcGlsZXIsIEluamVjdGFibGUsIEluamVjdG9yLCBOZ01vZHVsZUZhY3RvcnlMb2FkZXIsIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIEFQUF9CT09UU1RSQVBfTElTVEVORVIsIEFQUF9JTklUSUFMSVpFUiwgQXBwbGljYXRpb25SZWYsIEluamVjdCwgTmdNb2R1bGUsIE5nUHJvYmVUb2tlbiwgT3B0aW9uYWwsIFNraXBTZWxmLCBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLCBWZXJzaW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tLCBvZiwgQmVoYXZpb3JTdWJqZWN0LCBFbXB0eUVycm9yLCBPYnNlcnZhYmxlLCBFTVBUWSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY29uY2F0QWxsLCBldmVyeSwgbGFzdCwgbWFwLCBtZXJnZUFsbCwgY2F0Y2hFcnJvciwgZmlyc3QsIG1lcmdlTWFwLCBzd2l0Y2hNYXAsIGNvbmNhdE1hcCwgcmVkdWNlLCBmaWx0ZXIsIGZpbmFsaXplLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBMb2NhdGlvblN0cmF0ZWd5LCBBUFBfQkFTRV9IUkVGLCBIYXNoTG9jYXRpb25TdHJhdGVneSwgTE9DQVRJT05fSU5JVElBTElaRUQsIExvY2F0aW9uLCBQYXRoTG9jYXRpb25TdHJhdGVneSwgUGxhdGZvcm1Mb2NhdGlvbiwgVmlld3BvcnRTY3JvbGxlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyDJtWdldERPTSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEJhc2UgZm9yIGV2ZW50cyB0aGUgUm91dGVyIGdvZXMgdGhyb3VnaCwgYXMgb3Bwb3NlZCB0byBldmVudHMgdGllZCB0byBhIHNwZWNpZmljXG4gKiBSb3V0ZS4gYFJvdXRlckV2ZW50YHMgd2lsbCBvbmx5IGJlIGZpcmVkIG9uZSB0aW1lIGZvciBhbnkgZ2l2ZW4gbmF2aWdhdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogY2xhc3MgTXlTZXJ2aWNlIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIHJvdXRlcjogUm91dGVyLCBsb2dnZXI6IExvZ2dlcikge1xuICogICAgIHJvdXRlci5ldmVudHMucGlwZShcbiAqICAgICAgIGZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBSb3V0ZXJFdmVudClcbiAqICAgICApLnN1YnNjcmliZShlID0+IHtcbiAqICAgICAgIGxvZ2dlci5sb2coZS5pZCwgZS51cmwpO1xuICogICAgIH0pO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSb3V0ZXJFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJFdmVudChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gUm91dGVyRXZlbnQ7XG59KCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgbmF2aWdhdGlvbiBzdGFydHMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgTmF2aWdhdGlvblN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uU3RhcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvblN0YXJ0KFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgaWQsIFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgdXJsLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIG5hdmlnYXRpb25UcmlnZ2VyLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHJlc3RvcmVkU3RhdGUpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRpb25UcmlnZ2VyID09PSB2b2lkIDApIHsgbmF2aWdhdGlvblRyaWdnZXIgPSAnaW1wZXJhdGl2ZSc7IH1cbiAgICAgICAgaWYgKHJlc3RvcmVkU3RhdGUgPT09IHZvaWQgMCkgeyByZXN0b3JlZFN0YXRlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYXZpZ2F0aW9uVHJpZ2dlciA9IG5hdmlnYXRpb25UcmlnZ2VyO1xuICAgICAgICBfdGhpcy5yZXN0b3JlZFN0YXRlID0gcmVzdG9yZWRTdGF0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIE5hdmlnYXRpb25TdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5hdmlnYXRpb25TdGFydChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicpXCI7IH07XG4gICAgcmV0dXJuIE5hdmlnYXRpb25TdGFydDtcbn0oUm91dGVyRXZlbnQpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gZW5kcyBzdWNjZXNzZnVsbHkuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgTmF2aWdhdGlvbkVuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmF2aWdhdGlvbkVuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uRW5kKFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgaWQsIFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgdXJsLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybEFmdGVyUmVkaXJlY3RzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBOYXZpZ2F0aW9uRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiTmF2aWdhdGlvbkVuZChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInKVwiO1xuICAgIH07XG4gICAgcmV0dXJuIE5hdmlnYXRpb25FbmQ7XG59KFJvdXRlckV2ZW50KSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE5hdmlnYXRpb25DYW5jZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hdmlnYXRpb25DYW5jZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmF2aWdhdGlvbkNhbmNlbChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICByZWFzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVhc29uID0gcmVhc29uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgTmF2aWdhdGlvbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5hdmlnYXRpb25DYW5jZWwoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInKVwiOyB9O1xuICAgIHJldHVybiBOYXZpZ2F0aW9uQ2FuY2VsO1xufShSb3V0ZXJFdmVudCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgbmF2aWdhdGlvbiBmYWlscyBkdWUgdG8gYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBOYXZpZ2F0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hdmlnYXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uRXJyb3IoXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBpZCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICB1cmwsIFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgZXJyb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIE5hdmlnYXRpb25FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIk5hdmlnYXRpb25FcnJvcihpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIGVycm9yOiBcIiArIHRoaXMuZXJyb3IgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBOYXZpZ2F0aW9uRXJyb3I7XG59KFJvdXRlckV2ZW50KSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gcm91dGVzIGFyZSByZWNvZ25pemVkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlc1JlY29nbml6ZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdXRlc1JlY29nbml6ZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm91dGVzUmVjb2duaXplZChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgUm91dGVzUmVjb2duaXplZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJvdXRlc1JlY29nbml6ZWQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCB1cmxBZnRlclJlZGlyZWN0czogJ1wiICsgdGhpcy51cmxBZnRlclJlZGlyZWN0cyArIFwiJywgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiKVwiO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdXRlc1JlY29nbml6ZWQ7XG59KFJvdXRlckV2ZW50KSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBHdWFyZCBwaGFzZSBvZiByb3V0aW5nLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEd1YXJkc0NoZWNrU3RhcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEd1YXJkc0NoZWNrU3RhcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3VhcmRzQ2hlY2tTdGFydChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEd1YXJkc0NoZWNrU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJHdWFyZHNDaGVja1N0YXJ0KGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBHdWFyZHNDaGVja1N0YXJ0O1xufShSb3V0ZXJFdmVudCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhlIEd1YXJkIHBoYXNlIG9mIHJvdXRpbmcuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgR3VhcmRzQ2hlY2tFbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEd1YXJkc0NoZWNrRW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEd1YXJkc0NoZWNrRW5kKFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgaWQsIFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgdXJsLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybEFmdGVyUmVkaXJlY3RzLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHN0YXRlLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHNob3VsZEFjdGl2YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgIF90aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIF90aGlzLnNob3VsZEFjdGl2YXRlID0gc2hvdWxkQWN0aXZhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR3VhcmRzQ2hlY2tFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJHdWFyZHNDaGVja0VuZChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIsIHNob3VsZEFjdGl2YXRlOiBcIiArIHRoaXMuc2hvdWxkQWN0aXZhdGUgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBHdWFyZHNDaGVja0VuZDtcbn0oUm91dGVyRXZlbnQpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gVGhlIHRpbWluZyBvZiB0aGlzXG4gKiBldmVudCBtYXkgY2hhbmdlLCB0aHVzIGl0J3MgZXhwZXJpbWVudGFsLiBJbiB0aGUgY3VycmVudCBpdGVyYXRpb24gaXQgd2lsbCBydW5cbiAqIGluIHRoZSBcInJlc29sdmVcIiBwaGFzZSB3aGV0aGVyIHRoZXJlJ3MgdGhpbmdzIHRvIHJlc29sdmUgb3Igbm90LiBJbiB0aGUgZnV0dXJlIHRoaXNcbiAqIGJlaGF2aW9yIG1heSBjaGFuZ2UgdG8gb25seSBydW4gd2hlbiB0aGVyZSBhcmUgdGhpbmdzIHRvIGJlIHJlc29sdmVkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJlc29sdmVTdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb2x2ZVN0YXJ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc29sdmVTdGFydChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc29sdmVTdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlJlc29sdmVTdGFydChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzb2x2ZVN0YXJ0O1xufShSb3V0ZXJFdmVudCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAqIGBSZXNvbHZlU3RhcnRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJlc29sdmVFbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc29sdmVFbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZUVuZChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGlkLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHVybCwgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBzdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc29sdmVFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNvbHZlRW5kKGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZlRW5kO1xufShSb3V0ZXJFdmVudCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCBiZWZvcmUgbGF6eSBsb2FkaW5nIGEgcm91dGUgY29uZmlnLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlQ29uZmlnTG9hZFN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlQ29uZmlnTG9hZFN0YXJ0KFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgcm91dGUpIHtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgIH1cbiAgICBSb3V0ZUNvbmZpZ0xvYWRTdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlJvdXRlQ29uZmlnTG9hZFN0YXJ0KHBhdGg6IFwiICsgdGhpcy5yb3V0ZS5wYXRoICsgXCIpXCI7IH07XG4gICAgcmV0dXJuIFJvdXRlQ29uZmlnTG9hZFN0YXJ0O1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHJvdXRlIGhhcyBiZWVuIGxhenkgbG9hZGVkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlQ29uZmlnTG9hZEVuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZUNvbmZpZ0xvYWRFbmQoXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICByb3V0ZSkge1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgfVxuICAgIFJvdXRlQ29uZmlnTG9hZEVuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlJvdXRlQ29uZmlnTG9hZEVuZChwYXRoOiBcIiArIHRoaXMucm91dGUucGF0aCArIFwiKVwiOyB9O1xuICAgIHJldHVybiBSb3V0ZUNvbmZpZ0xvYWRFbmQ7XG59KCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAqIGBDaGlsZEFjdGl2YXRpb25FbmRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENoaWxkQWN0aXZhdGlvblN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoaWxkQWN0aXZhdGlvblN0YXJ0KFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgc25hcHNob3QpIHtcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgIH1cbiAgICBDaGlsZEFjdGl2YXRpb25TdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZyAmJiB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnLnBhdGggfHwgJyc7XG4gICAgICAgIHJldHVybiBcIkNoaWxkQWN0aXZhdGlvblN0YXJ0KHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hpbGRBY3RpdmF0aW9uU3RhcnQ7XG59KCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAqIGBDaGlsZEFjdGl2YXRpb25TdGFydGAgZm9yIHVzZSBvZiB0aGlzIGV4cGVyaW1lbnRhbCBBUEkuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQ2hpbGRBY3RpdmF0aW9uRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoaWxkQWN0aXZhdGlvbkVuZChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHNuYXBzaG90KSB7XG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICB9XG4gICAgQ2hpbGRBY3RpdmF0aW9uRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgcmV0dXJuIFwiQ2hpbGRBY3RpdmF0aW9uRW5kKHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hpbGRBY3RpdmF0aW9uRW5kO1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gKiBgQWN0aXZhdGlvbkVuZGAgZm9yIHVzZSBvZiB0aGlzIGV4cGVyaW1lbnRhbCBBUEkuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQWN0aXZhdGlvblN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25TdGFydChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHNuYXBzaG90KSB7XG4gICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICB9XG4gICAgQWN0aXZhdGlvblN0YXJ0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgcmV0dXJuIFwiQWN0aXZhdGlvblN0YXJ0KHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aXZhdGlvblN0YXJ0O1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gKiBgQWN0aXZhdGlvblN0YXJ0YCBmb3IgdXNlIG9mIHRoaXMgZXhwZXJpbWVudGFsIEFQSS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBBY3RpdmF0aW9uRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25FbmQoXG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBzbmFwc2hvdCkge1xuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgfVxuICAgIEFjdGl2YXRpb25FbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuc25hcHNob3Qucm91dGVDb25maWcgJiYgdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZy5wYXRoIHx8ICcnO1xuICAgICAgICByZXR1cm4gXCJBY3RpdmF0aW9uRW5kKHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aXZhdGlvbkVuZDtcbn0oKSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgYSBzY3JvbGxpbmcgZXZlbnQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgU2Nyb2xsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbChcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHJvdXRlckV2ZW50LCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIHBvc2l0aW9uLCBcbiAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgIGFuY2hvcikge1xuICAgICAgICB0aGlzLnJvdXRlckV2ZW50ID0gcm91dGVyRXZlbnQ7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIFNjcm9sbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uID8gdGhpcy5wb3NpdGlvblswXSArIFwiLCBcIiArIHRoaXMucG9zaXRpb25bMV0gOiBudWxsO1xuICAgICAgICByZXR1cm4gXCJTY3JvbGwoYW5jaG9yOiAnXCIgKyB0aGlzLmFuY2hvciArIFwiJywgcG9zaXRpb246ICdcIiArIHBvcyArIFwiJylcIjtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGw7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgaW50ZXJuYWxseSB3aXRoaW4gdGhlIHJvdXRlciB0byBiZSBhIHBsYWNlaG9sZGVyIHdoZW4gYW4gZW1wdHlcbiAqIHJvdXRlci1vdXRsZXQgaXMgbmVlZGVkLiBGb3IgZXhhbXBsZSwgd2l0aCBhIGNvbmZpZyBzdWNoIGFzOlxuICpcbiAqIGB7cGF0aDogJ3BhcmVudCcsIG91dGxldDogJ25hdicsIGNoaWxkcmVuOiBbLi4uXX1gXG4gKlxuICogSW4gb3JkZXIgdG8gcmVuZGVyLCB0aGVyZSBuZWVkcyB0byBiZSBhIGNvbXBvbmVudCBvbiB0aGlzIGNvbmZpZywgd2hpY2ggd2lsbCBkZWZhdWx0XG4gKiB0byB0aGlzIGBFbXB0eU91dGxldENvbXBvbmVudGAuXG4gKi9cbnZhciBFbXB0eU91dGxldENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbXB0eU91dGxldENvbXBvbmVudCgpIHtcbiAgICB9XG4gICAgRW1wdHlPdXRsZXRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHsgdGVtcGxhdGU6IFwiPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlwiIH0pXG4gICAgXSwgRW1wdHlPdXRsZXRDb21wb25lbnQpO1xuICAgIHJldHVybiBFbXB0eU91dGxldENvbXBvbmVudDtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTmFtZSBvZiB0aGUgcHJpbWFyeSBvdXRsZXQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUFJJTUFSWV9PVVRMRVQgPSAncHJpbWFyeSc7XG52YXIgUGFyYW1zQXNNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyYW1zQXNNYXAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICBQYXJhbXNBc01hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpOyB9O1xuICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5wYXJhbXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbMF0gOiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUGFyYW1zQXNNYXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYW1zQXNNYXAucHJvdG90eXBlLCBcImtleXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1zKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFBhcmFtc0FzTWFwO1xufSgpKTtcbi8qKlxuICogQ29udmVydCBhIGBQYXJhbXNgIGluc3RhbmNlIHRvIGEgYFBhcmFtTWFwYC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1BhcmFtTWFwKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUGFyYW1zQXNNYXAocGFyYW1zKTtcbn1cbnZhciBOQVZJR0FUSU9OX0NBTkNFTElOR19FUlJPUiA9ICduZ05hdmlnYXRpb25DYW5jZWxpbmdFcnJvcic7XG5mdW5jdGlvbiBuYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBlcnJvciA9IEVycm9yKCdOYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3I6ICcgKyBtZXNzYWdlKTtcbiAgICBlcnJvcltOQVZJR0FUSU9OX0NBTkNFTElOR19FUlJPUl0gPSB0cnVlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzTmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yICYmIGVycm9yW05BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SXTtcbn1cbi8vIE1hdGNoZXMgdGhlIHJvdXRlIGNvbmZpZ3VyYXRpb24gKGByb3V0ZWApIGFnYWluc3QgdGhlIGFjdHVhbCBVUkwgKGBzZWdtZW50c2ApLlxuZnVuY3Rpb24gZGVmYXVsdFVybE1hdGNoZXIoc2VnbWVudHMsIHNlZ21lbnRHcm91cCwgcm91dGUpIHtcbiAgICB2YXIgcGFydHMgPSByb3V0ZS5wYXRoLnNwbGl0KCcvJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgYWN0dWFsIFVSTCBpcyBzaG9ydGVyIHRoYW4gdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5wYXRoTWF0Y2ggPT09ICdmdWxsJyAmJlxuICAgICAgICAoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgcGFydHMubGVuZ3RoIDwgc2VnbWVudHMubGVuZ3RoKSkge1xuICAgICAgICAvLyBUaGUgY29uZmlnIGlzIGxvbmdlciB0aGFuIHRoZSBhY3R1YWwgVVJMIGJ1dCB3ZSBhcmUgbG9va2luZyBmb3IgYSBmdWxsIG1hdGNoLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHBvc1BhcmFtcyA9IHt9O1xuICAgIC8vIENoZWNrIGVhY2ggY29uZmlnIHBhcnQgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTFxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICB2YXIgaXNQYXJhbWV0ZXIgPSBwYXJ0LnN0YXJ0c1dpdGgoJzonKTtcbiAgICAgICAgaWYgKGlzUGFyYW1ldGVyKSB7XG4gICAgICAgICAgICBwb3NQYXJhbXNbcGFydC5zdWJzdHJpbmcoMSldID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ICE9PSBzZWdtZW50LnBhdGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgVVJMIHBhcnQgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiBzZWdtZW50cy5zbGljZSgwLCBwYXJ0cy5sZW5ndGgpLCBwb3NQYXJhbXM6IHBvc1BhcmFtcyB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTG9hZGVkUm91dGVyQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvYWRlZFJvdXRlckNvbmZpZyhyb3V0ZXMsIG1vZHVsZSkge1xuICAgICAgICB0aGlzLnJvdXRlcyA9IHJvdXRlcztcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBMb2FkZWRSb3V0ZXJDb25maWc7XG59KCkpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnLCBwYXJlbnRQYXRoKSB7XG4gICAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkgeyBwYXJlbnRQYXRoID0gJyc7IH1cbiAgICAvLyBmb3JFYWNoIGRvZXNuJ3QgaXRlcmF0ZSB1bmRlZmluZWQgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvdXRlID0gY29uZmlnW2ldO1xuICAgICAgICB2YXIgZnVsbFBhdGggPSBnZXRGdWxsUGF0aChwYXJlbnRQYXRoLCByb3V0ZSk7XG4gICAgICAgIHZhbGlkYXRlTm9kZShyb3V0ZSwgZnVsbFBhdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTm9kZShyb3V0ZSwgZnVsbFBhdGgpIHtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIEludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogRW5jb3VudGVyZWQgdW5kZWZpbmVkIHJvdXRlLlxcbiAgICAgIFRoZSByZWFzb24gbWlnaHQgYmUgYW4gZXh0cmEgY29tbWEuXFxuXFxuICAgICAgRXhhbXBsZTpcXG4gICAgICBjb25zdCByb3V0ZXM6IFJvdXRlcyA9IFtcXG4gICAgICAgIHsgcGF0aDogJycsIHJlZGlyZWN0VG86ICcvZGFzaGJvYXJkJywgcGF0aE1hdGNoOiAnZnVsbCcgfSxcXG4gICAgICAgIHsgcGF0aDogJ2Rhc2hib2FyZCcsICBjb21wb25lbnQ6IERhc2hib2FyZENvbXBvbmVudCB9LCwgPDwgdHdvIGNvbW1hc1xcbiAgICAgICAgeyBwYXRoOiAnZGV0YWlsLzppZCcsIGNvbXBvbmVudDogSGVyb0RldGFpbENvbXBvbmVudCB9XFxuICAgICAgXTtcXG4gICAgXCIpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBBcnJheSBjYW5ub3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAoIXJvdXRlLmNvbXBvbmVudCAmJiAhcm91dGUuY2hpbGRyZW4gJiYgIXJvdXRlLmxvYWRDaGlsZHJlbiAmJlxuICAgICAgICAocm91dGUub3V0bGV0ICYmIHJvdXRlLm91dGxldCAhPT0gUFJJTUFSWV9PVVRMRVQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogYSBjb21wb25lbnRsZXNzIHJvdXRlIHdpdGhvdXQgY2hpbGRyZW4gb3IgbG9hZENoaWxkcmVuIGNhbm5vdCBoYXZlIGEgbmFtZWQgb3V0bGV0IHNldFwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gJiYgcm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBjaGlsZHJlbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gJiYgcm91dGUubG9hZENoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcmVkaXJlY3RUbyBhbmQgbG9hZENoaWxkcmVuIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUubG9hZENoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogY2hpbGRyZW4gYW5kIGxvYWRDaGlsZHJlbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gJiYgcm91dGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcmVkaXJlY3RUbyBhbmQgY29tcG9uZW50IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAocm91dGUucGF0aCAmJiByb3V0ZS5tYXRjaGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcGF0aCBhbmQgbWF0Y2hlciBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gPT09IHZvaWQgMCAmJiAhcm91dGUuY29tcG9uZW50ICYmICFyb3V0ZS5jaGlsZHJlbiAmJiAhcm91dGUubG9hZENoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJy4gT25lIG9mIHRoZSBmb2xsb3dpbmcgbXVzdCBiZSBwcm92aWRlZDogY29tcG9uZW50LCByZWRpcmVjdFRvLCBjaGlsZHJlbiBvciBsb2FkQ2hpbGRyZW5cIik7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5wYXRoID09PSB2b2lkIDAgJiYgcm91dGUubWF0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcm91dGVzIG11c3QgaGF2ZSBlaXRoZXIgYSBwYXRoIG9yIGEgbWF0Y2hlciBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygcm91dGUucGF0aCA9PT0gJ3N0cmluZycgJiYgcm91dGUucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgZnVsbFBhdGggKyBcIic6IHBhdGggY2Fubm90IHN0YXJ0IHdpdGggYSBzbGFzaFwiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGggPT09ICcnICYmIHJvdXRlLnJlZGlyZWN0VG8gIT09IHZvaWQgMCAmJiByb3V0ZS5wYXRoTWF0Y2ggPT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgZXhwID0gXCJUaGUgZGVmYXVsdCB2YWx1ZSBvZiAncGF0aE1hdGNoJyBpcyAncHJlZml4JywgYnV0IG9mdGVuIHRoZSBpbnRlbnQgaXMgdG8gdXNlICdmdWxsJy5cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICd7cGF0aDogXFxcIlwiICsgZnVsbFBhdGggKyBcIlxcXCIsIHJlZGlyZWN0VG86IFxcXCJcIiArIHJvdXRlLnJlZGlyZWN0VG8gKyBcIlxcXCJ9JzogcGxlYXNlIHByb3ZpZGUgJ3BhdGhNYXRjaCcuIFwiICsgZXhwKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLnBhdGhNYXRjaCAhPT0gdm9pZCAwICYmIHJvdXRlLnBhdGhNYXRjaCAhPT0gJ2Z1bGwnICYmIHJvdXRlLnBhdGhNYXRjaCAhPT0gJ3ByZWZpeCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBwYXRoTWF0Y2ggY2FuIG9ubHkgYmUgc2V0IHRvICdwcmVmaXgnIG9yICdmdWxsJ1wiKTtcbiAgICB9XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZhbGlkYXRlQ29uZmlnKHJvdXRlLmNoaWxkcmVuLCBmdWxsUGF0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgocGFyZW50UGF0aCwgY3VycmVudFJvdXRlKSB7XG4gICAgaWYgKCFjdXJyZW50Um91dGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGg7XG4gICAgfVxuICAgIGlmICghcGFyZW50UGF0aCAmJiAhY3VycmVudFJvdXRlLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnRQYXRoICYmICFjdXJyZW50Um91dGUucGF0aCkge1xuICAgICAgICByZXR1cm4gcGFyZW50UGF0aCArIFwiL1wiO1xuICAgIH1cbiAgICBlbHNlIGlmICghcGFyZW50UGF0aCAmJiBjdXJyZW50Um91dGUucGF0aCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFJvdXRlLnBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyZW50UGF0aCArIFwiL1wiICsgY3VycmVudFJvdXRlLnBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGNvbmZpZyBhbmQgYWRkcyBhbnkgZGVmYXVsdCByZXF1aXJlZCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUNvbmZpZyhyKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gci5jaGlsZHJlbiAmJiByLmNoaWxkcmVuLm1hcChzdGFuZGFyZGl6ZUNvbmZpZyk7XG4gICAgdmFyIGMgPSBjaGlsZHJlbiA/IF9fYXNzaWduKHt9LCByLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSA6IF9fYXNzaWduKHt9LCByKTtcbiAgICBpZiAoIWMuY29tcG9uZW50ICYmIChjaGlsZHJlbiB8fCBjLmxvYWRDaGlsZHJlbikgJiYgKGMub3V0bGV0ICYmIGMub3V0bGV0ICE9PSBQUklNQVJZX09VVExFVCkpIHtcbiAgICAgICAgYy5jb21wb25lbnQgPSBFbXB0eU91dGxldENvbXBvbmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbEFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwoYSwgYikge1xuICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGsxW2ldO1xuICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRmxhdHRlbnMgc2luZ2xlLWxldmVsIG5lc3RlZCBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBsYXN0JDEoYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA+IDAgPyBhW2EubGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuZnVuY3Rpb24gZm9yRWFjaChtYXAkJDEsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBtYXAkJDEpIHtcbiAgICAgICAgaWYgKG1hcCQkMS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobWFwJCQxW3Byb3BdLCBwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHdhaXRGb3JNYXAob2JqLCBmbikge1xuICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb2Yoe30pO1xuICAgIH1cbiAgICB2YXIgd2FpdEhlYWQgPSBbXTtcbiAgICB2YXIgd2FpdFRhaWwgPSBbXTtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uIChhLCBrKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBmbihrLCBhKS5waXBlKG1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzW2tdID0gcjsgfSkpO1xuICAgICAgICBpZiAoayA9PT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIHdhaXRIZWFkLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhaXRUYWlsLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIENsb3N1cmUgY29tcGlsZXIgaGFzIHByb2JsZW0gd2l0aCB1c2luZyBzcHJlYWQgb3BlcmF0b3IgaGVyZS4gU28ganVzdCB1c2luZyBBcnJheS5jb25jYXQuXG4gICAgcmV0dXJuIG9mLmFwcGx5KG51bGwsIHdhaXRIZWFkLmNvbmNhdCh3YWl0VGFpbCkpLnBpcGUoY29uY2F0QWxsKCksIGxhc3QoKSwgbWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlczsgfSkpO1xufVxuLyoqXG4gKiBBTkRzIE9ic2VydmFibGVzIGJ5IG1lcmdpbmcgYWxsIGlucHV0IG9ic2VydmFibGVzLCByZWR1Y2luZyB0byBhbiBPYnNlcnZhYmxlIHZlcmlmeWluZyBhbGxcbiAqIGlucHV0IE9ic2VydmFibGVzIHJldHVybiBgdHJ1ZWAuXG4gKi9cbmZ1bmN0aW9uIGFuZE9ic2VydmFibGVzKG9ic2VydmFibGVzKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVzLnBpcGUobWVyZ2VBbGwoKSwgZXZlcnkoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ID09PSB0cnVlOyB9KSk7XG59XG5mdW5jdGlvbiB3cmFwSW50b09ic2VydmFibGUodmFsdWUpIHtcbiAgICBpZiAoybVpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKMm1aXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICAvLyBVc2UgYFByb21pc2UucmVzb2x2ZSgpYCB0byB3cmFwIHByb21pc2UtbGlrZSBpbnN0YW5jZXMuXG4gICAgICAgIC8vIFJlcXVpcmVkIGllIHdoZW4gYSBSZXNvbHZlciByZXR1cm5zIGEgQW5ndWxhckpTIGAkcWAgcHJvbWlzZSB0byBjb3JyZWN0bHkgdHJpZ2dlciB0aGVcbiAgICAgICAgLy8gY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIGZyb20oUHJvbWlzZS5yZXNvbHZlKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBvZih2YWx1ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5VXJsVHJlZSgpIHtcbiAgICByZXR1cm4gbmV3IFVybFRyZWUobmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pLCB7fSwgbnVsbCk7XG59XG5mdW5jdGlvbiBjb250YWluc1RyZWUoY29udGFpbmVyLCBjb250YWluZWUsIGV4YWN0KSB7XG4gICAgaWYgKGV4YWN0KSB7XG4gICAgICAgIHJldHVybiBlcXVhbFF1ZXJ5UGFyYW1zKGNvbnRhaW5lci5xdWVyeVBhcmFtcywgY29udGFpbmVlLnF1ZXJ5UGFyYW1zKSAmJlxuICAgICAgICAgICAgZXF1YWxTZWdtZW50R3JvdXBzKGNvbnRhaW5lci5yb290LCBjb250YWluZWUucm9vdCk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluc1F1ZXJ5UGFyYW1zKGNvbnRhaW5lci5xdWVyeVBhcmFtcywgY29udGFpbmVlLnF1ZXJ5UGFyYW1zKSAmJlxuICAgICAgICBjb250YWluc1NlZ21lbnRHcm91cChjb250YWluZXIucm9vdCwgY29udGFpbmVlLnJvb3QpO1xufVxuZnVuY3Rpb24gZXF1YWxRdWVyeVBhcmFtcyhjb250YWluZXIsIGNvbnRhaW5lZSkge1xuICAgIC8vIFRPRE86IFRoaXMgZG9lcyBub3QgaGFuZGxlIGFycmF5IHBhcmFtcyBjb3JyZWN0bHkuXG4gICAgcmV0dXJuIHNoYWxsb3dFcXVhbChjb250YWluZXIsIGNvbnRhaW5lZSk7XG59XG5mdW5jdGlvbiBlcXVhbFNlZ21lbnRHcm91cHMoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIuc2VnbWVudHMsIGNvbnRhaW5lZS5zZWdtZW50cykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY29udGFpbmVyLm51bWJlck9mQ2hpbGRyZW4gIT09IGNvbnRhaW5lZS5udW1iZXJPZkNoaWxkcmVuKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgYyBpbiBjb250YWluZWUuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY2hpbGRyZW5bY10pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZXF1YWxTZWdtZW50R3JvdXBzKGNvbnRhaW5lci5jaGlsZHJlbltjXSwgY29udGFpbmVlLmNoaWxkcmVuW2NdKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb250YWluc1F1ZXJ5UGFyYW1zKGNvbnRhaW5lciwgY29udGFpbmVlKSB7XG4gICAgLy8gVE9ETzogVGhpcyBkb2VzIG5vdCBoYW5kbGUgYXJyYXkgcGFyYW1zIGNvcnJlY3RseS5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29udGFpbmVlKS5sZW5ndGggPD0gT2JqZWN0LmtleXMoY29udGFpbmVyKS5sZW5ndGggJiZcbiAgICAgICAgT2JqZWN0LmtleXMoY29udGFpbmVlKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb250YWluZWVba2V5XSA9PT0gY29udGFpbmVyW2tleV07IH0pO1xufVxuZnVuY3Rpb24gY29udGFpbnNTZWdtZW50R3JvdXAoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICByZXR1cm4gY29udGFpbnNTZWdtZW50R3JvdXBIZWxwZXIoY29udGFpbmVyLCBjb250YWluZWUsIGNvbnRhaW5lZS5zZWdtZW50cyk7XG59XG5mdW5jdGlvbiBjb250YWluc1NlZ21lbnRHcm91cEhlbHBlcihjb250YWluZXIsIGNvbnRhaW5lZSwgY29udGFpbmVlUGF0aHMpIHtcbiAgICBpZiAoY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCA+IGNvbnRhaW5lZVBhdGhzLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5zZWdtZW50cy5zbGljZSgwLCBjb250YWluZWVQYXRocy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWVxdWFsUGF0aChjdXJyZW50LCBjb250YWluZWVQYXRocykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjb250YWluZWUuaGFzQ2hpbGRyZW4oKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRhaW5lci5zZWdtZW50cy5sZW5ndGggPT09IGNvbnRhaW5lZVBhdGhzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIuc2VnbWVudHMsIGNvbnRhaW5lZVBhdGhzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBjb250YWluZWUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLmNoaWxkcmVuW2NdKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghY29udGFpbnNTZWdtZW50R3JvdXAoY29udGFpbmVyLmNoaWxkcmVuW2NdLCBjb250YWluZWUuY2hpbGRyZW5bY10pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVlUGF0aHMuc2xpY2UoMCwgY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBuZXh0ID0gY29udGFpbmVlUGF0aHMuc2xpY2UoY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICghZXF1YWxQYXRoKGNvbnRhaW5lci5zZWdtZW50cywgY3VycmVudCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY29udGFpbmVyLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zU2VnbWVudEdyb3VwSGVscGVyKGNvbnRhaW5lci5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGNvbnRhaW5lZSwgbmV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZXByZXNlbnRzIHRoZSBwYXJzZWQgVVJMLlxuICpcbiAqIFNpbmNlIGEgcm91dGVyIHN0YXRlIGlzIGEgdHJlZSwgYW5kIHRoZSBVUkwgaXMgbm90aGluZyBidXQgYSBzZXJpYWxpemVkIHN0YXRlLCB0aGUgVVJMIGlzIGFcbiAqIHNlcmlhbGl6ZWQgdHJlZS5cbiAqIFVybFRyZWUgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IHByb3ZpZGVzIGEgbG90IG9mIGFmZm9yZGFuY2VzIGluIGRlYWxpbmcgd2l0aCBVUkxzXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICogICAgIGNvbnN0IHRyZWU6IFVybFRyZWUgPVxuICogICAgICAgcm91dGVyLnBhcnNlVXJsKCcvdGVhbS8zMy8odXNlci92aWN0b3IvL3N1cHBvcnQ6aGVscCk/ZGVidWc9dHJ1ZSNmcmFnbWVudCcpO1xuICogICAgIGNvbnN0IGYgPSB0cmVlLmZyYWdtZW50OyAvLyByZXR1cm4gJ2ZyYWdtZW50J1xuICogICAgIGNvbnN0IHEgPSB0cmVlLnF1ZXJ5UGFyYW1zOyAvLyByZXR1cm5zIHtkZWJ1ZzogJ3RydWUnfVxuICogICAgIGNvbnN0IGc6IFVybFNlZ21lbnRHcm91cCA9IHRyZWUucm9vdC5jaGlsZHJlbltQUklNQVJZX09VVExFVF07XG4gKiAgICAgY29uc3QgczogVXJsU2VnbWVudFtdID0gZy5zZWdtZW50czsgLy8gcmV0dXJucyAyIHNlZ21lbnRzICd0ZWFtJyBhbmQgJzMzJ1xuICogICAgIGcuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdLnNlZ21lbnRzOyAvLyByZXR1cm5zIDIgc2VnbWVudHMgJ3VzZXInIGFuZCAndmljdG9yJ1xuICogICAgIGcuY2hpbGRyZW5bJ3N1cHBvcnQnXS5zZWdtZW50czsgLy8gcmV0dXJuIDEgc2VnbWVudCAnaGVscCdcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVXJsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gVXJsVHJlZShcbiAgICAvKiogVGhlIHJvb3Qgc2VnbWVudCBncm91cCBvZiB0aGUgVVJMIHRyZWUgKi9cbiAgICByb290LCBcbiAgICAvKiogVGhlIHF1ZXJ5IHBhcmFtcyBvZiB0aGUgVVJMICovXG4gICAgcXVlcnlQYXJhbXMsIFxuICAgIC8qKiBUaGUgZnJhZ21lbnQgb2YgdGhlIFVSTCAqL1xuICAgIGZyYWdtZW50KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsVHJlZS5wcm90b3R5cGUsIFwicXVlcnlQYXJhbU1hcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWVyeVBhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbU1hcCA9IGNvbnZlcnRUb1BhcmFtTWFwKHRoaXMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1NYXA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgVXJsVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBERUZBVUxUX1NFUklBTElaRVIuc2VyaWFsaXplKHRoaXMpOyB9O1xuICAgIHJldHVybiBVcmxUcmVlO1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgcGFyc2VkIFVSTCBzZWdtZW50IGdyb3VwLlxuICpcbiAqIFNlZSBgVXJsVHJlZWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVXJsU2VnbWVudEdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVybFNlZ21lbnRHcm91cChcbiAgICAvKiogVGhlIFVSTCBzZWdtZW50cyBvZiB0aGlzIGdyb3VwLiBTZWUgYFVybFNlZ21lbnRgIGZvciBtb3JlIGluZm9ybWF0aW9uICovXG4gICAgc2VnbWVudHMsIFxuICAgIC8qKiBUaGUgbGlzdCBvZiBjaGlsZHJlbiBvZiB0aGlzIGdyb3VwICovXG4gICAgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8qKiBUaGUgcGFyZW50IG5vZGUgaW4gdGhlIHVybCB0cmVlICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHYucGFyZW50ID0gX3RoaXM7IH0pO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgc2VnbWVudCBoYXMgY2hpbGQgc2VnbWVudHMgKi9cbiAgICBVcmxTZWdtZW50R3JvdXAucHJvdG90eXBlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5udW1iZXJPZkNoaWxkcmVuID4gMDsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsU2VnbWVudEdyb3VwLnByb3RvdHlwZSwgXCJudW1iZXJPZkNoaWxkcmVuXCIsIHtcbiAgICAgICAgLyoqIE51bWJlciBvZiBjaGlsZCBzZWdtZW50cyAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2hpbGRyZW4pLmxlbmd0aDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICBVcmxTZWdtZW50R3JvdXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VyaWFsaXplUGF0aHModGhpcyk7IH07XG4gICAgcmV0dXJuIFVybFNlZ21lbnRHcm91cDtcbn0oKSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgVVJMIHNlZ21lbnQuXG4gKlxuICogQSBVcmxTZWdtZW50IGlzIGEgcGFydCBvZiBhIFVSTCBiZXR3ZWVuIHRoZSB0d28gc2xhc2hlcy4gSXQgY29udGFpbnMgYSBwYXRoIGFuZCB0aGUgbWF0cml4XG4gKiBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2VnbWVudC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICrCoCMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICogICAgIGNvbnN0IHRyZWU6IFVybFRyZWUgPSByb3V0ZXIucGFyc2VVcmwoJy90ZWFtO2lkPTMzJyk7XG4gKiAgICAgY29uc3QgZzogVXJsU2VnbWVudEdyb3VwID0gdHJlZS5yb290LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXTtcbiAqICAgICBjb25zdCBzOiBVcmxTZWdtZW50W10gPSBnLnNlZ21lbnRzO1xuICogICAgIHNbMF0ucGF0aDsgLy8gcmV0dXJucyAndGVhbSdcbiAqICAgICBzWzBdLnBhcmFtZXRlcnM7IC8vIHJldHVybnMge2lkOiAzM31cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVXJsU2VnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxTZWdtZW50KFxuICAgIC8qKiBUaGUgcGF0aCBwYXJ0IG9mIGEgVVJMIHNlZ21lbnQgKi9cbiAgICBwYXRoLCBcbiAgICAvKiogVGhlIG1hdHJpeCBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBhIHNlZ21lbnQgKi9cbiAgICBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmxTZWdtZW50LnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJNYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGFyYW1ldGVyTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVyTWFwID0gY29udmVydFRvUGFyYW1NYXAodGhpcy5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJNYXA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgVXJsU2VnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJpYWxpemVQYXRoKHRoaXMpOyB9O1xuICAgIHJldHVybiBVcmxTZWdtZW50O1xufSgpKTtcbmZ1bmN0aW9uIGVxdWFsU2VnbWVudHMoYXMsIGJzKSB7XG4gICAgcmV0dXJuIGVxdWFsUGF0aChhcywgYnMpICYmIGFzLmV2ZXJ5KGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBzaGFsbG93RXF1YWwoYS5wYXJhbWV0ZXJzLCBic1tpXS5wYXJhbWV0ZXJzKTsgfSk7XG59XG5mdW5jdGlvbiBlcXVhbFBhdGgoYXMsIGJzKSB7XG4gICAgaWYgKGFzLmxlbmd0aCAhPT0gYnMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFzLmV2ZXJ5KGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBhLnBhdGggPT09IGJzW2ldLnBhdGg7IH0pO1xufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW5JbnRvQXJyYXkoc2VnbWVudCwgZm4pIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgIGlmIChjaGlsZE91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZm4oY2hpbGQsIGNoaWxkT3V0bGV0KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRPdXRsZXQpIHtcbiAgICAgICAgaWYgKGNoaWxkT3V0bGV0ICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChmbihjaGlsZCwgY2hpbGRPdXRsZXQpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFNlcmlhbGl6ZXMgYW5kIGRlc2VyaWFsaXplcyBhIFVSTCBzdHJpbmcgaW50byBhIFVSTCB0cmVlLlxuICpcbiAqIFRoZSB1cmwgc2VyaWFsaXphdGlvbiBzdHJhdGVneSBpcyBjdXN0b21pemFibGUuIFlvdSBjYW5cbiAqIG1ha2UgYWxsIFVSTHMgY2FzZSBpbnNlbnNpdGl2ZSBieSBwcm92aWRpbmcgYSBjdXN0b20gVXJsU2VyaWFsaXplci5cbiAqXG4gKiBTZWUgYERlZmF1bHRVcmxTZXJpYWxpemVyYCBmb3IgYW4gZXhhbXBsZSBvZiBhIFVSTCBzZXJpYWxpemVyLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFVybFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsU2VyaWFsaXplcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIFVybFNlcmlhbGl6ZXI7XG59KCkpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGBVcmxTZXJpYWxpemVyYC5cbiAqXG4gKiBFeGFtcGxlIFVSTHM6XG4gKlxuICogYGBgXG4gKiAvaW5ib3gvMzMocG9wdXA6Y29tcG9zZSlcbiAqIC9pbmJveC8zMztvcGVuPXRydWUvbWVzc2FnZXMvNDRcbiAqIGBgYFxuICpcbiAqIERlZmF1bHRVcmxTZXJpYWxpemVyIHVzZXMgcGFyZW50aGVzZXMgdG8gc2VyaWFsaXplIHNlY29uZGFyeSBzZWdtZW50cyAoZS5nLiwgcG9wdXA6Y29tcG9zZSksIHRoZVxuICogY29sb24gc3ludGF4IHRvIHNwZWNpZnkgdGhlIG91dGxldCwgYW5kIHRoZSAnO3BhcmFtZXRlcj12YWx1ZScgc3ludGF4IChlLmcuLCBvcGVuPXRydWUpIHRvXG4gKiBzcGVjaWZ5IHJvdXRlIHNwZWNpZmljIHBhcmFtZXRlcnMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgRGVmYXVsdFVybFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFVybFNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIC8qKiBQYXJzZXMgYSB1cmwgaW50byBhIGBVcmxUcmVlYCAqL1xuICAgIERlZmF1bHRVcmxTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgVXJsUGFyc2VyKHVybCk7XG4gICAgICAgIHJldHVybiBuZXcgVXJsVHJlZShwLnBhcnNlUm9vdFNlZ21lbnQoKSwgcC5wYXJzZVF1ZXJ5UGFyYW1zKCksIHAucGFyc2VGcmFnbWVudCgpKTtcbiAgICB9O1xuICAgIC8qKiBDb252ZXJ0cyBhIGBVcmxUcmVlYCBpbnRvIGEgdXJsICovXG4gICAgRGVmYXVsdFVybFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gXCIvXCIgKyBzZXJpYWxpemVTZWdtZW50KHRyZWUucm9vdCwgdHJ1ZSk7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHRyZWUucXVlcnlQYXJhbXMpO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSB0eXBlb2YgdHJlZS5mcmFnbWVudCA9PT0gXCJzdHJpbmdcIiA/IFwiI1wiICsgZW5jb2RlVXJpRnJhZ21lbnQodHJlZS5mcmFnbWVudCkgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBzZWdtZW50ICsgcXVlcnkgKyBmcmFnbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0VXJsU2VyaWFsaXplcjtcbn0oKSk7XG52YXIgREVGQVVMVF9TRVJJQUxJWkVSID0gbmV3IERlZmF1bHRVcmxTZXJpYWxpemVyKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVQYXRocyhzZWdtZW50KSB7XG4gICAgcmV0dXJuIHNlZ21lbnQuc2VnbWVudHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBzZXJpYWxpemVQYXRoKHApOyB9KS5qb2luKCcvJyk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTZWdtZW50KHNlZ21lbnQsIHJvb3QpIHtcbiAgICBpZiAoIXNlZ21lbnQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplUGF0aHMoc2VnbWVudCk7XG4gICAgfVxuICAgIGlmIChyb290KSB7XG4gICAgICAgIHZhciBwcmltYXJ5ID0gc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0gP1xuICAgICAgICAgICAgc2VyaWFsaXplU2VnbWVudChzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSwgZmFsc2UpIDpcbiAgICAgICAgICAgICcnO1xuICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IFtdO1xuICAgICAgICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbl8xLnB1c2goayArIFwiOlwiICsgc2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXzEubGVuZ3RoID4gMCA/IHByaW1hcnkgKyBcIihcIiArIGNoaWxkcmVuXzEuam9pbignLy8nKSArIFwiKVwiIDogcHJpbWFyeTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG1hcENoaWxkcmVuSW50b0FycmF5KHNlZ21lbnQsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGZhbHNlKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2sgKyBcIjpcIiArIHNlcmlhbGl6ZVNlZ21lbnQodiwgZmFsc2UpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVQYXRocyhzZWdtZW50KSArIFwiLyhcIiArIGNoaWxkcmVuLmpvaW4oJy8vJykgKyBcIilcIjtcbiAgICB9XG59XG4vKipcbiAqIEVuY29kZXMgYSBVUkkgc3RyaW5nIHdpdGggdGhlIGRlZmF1bHQgZW5jb2RpbmcuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IGV2ZXIgYmUgY2FsbGVkIGZyb21cbiAqIGBlbmNvZGVVcmlRdWVyeWAgb3IgYGVuY29kZVVyaVNlZ21lbnRgIGFzIGl0J3MgdGhlIGJhc2Ugc2V0IG9mIGVuY29kaW5ncyB0byBiZSB1c2VkLiBXZSBuZWVkXG4gKiBhIGN1c3RvbSBlbmNvZGluZyBiZWNhdXNlIGVuY29kZVVSSUNvbXBvbmVudCBpcyB0b28gYWdncmVzc2l2ZSBhbmQgZW5jb2RlcyBzdHVmZiB0aGF0IGRvZXNuJ3RcbiAqIGhhdmUgdG8gYmUgZW5jb2RlZCBwZXIgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLlxuICovXG5mdW5jdGlvbiBlbmNvZGVVcmlTdHJpbmcocykge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocylcbiAgICAgICAgLnJlcGxhY2UoLyU0MC9nLCAnQCcpXG4gICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgLnJlcGxhY2UoLyUyNC9nLCAnJCcpXG4gICAgICAgIC5yZXBsYWNlKC8lMkMvZ2ksICcsJyk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGJvdGgga2V5cyBhbmQgdmFsdWVzIGluIGEgcXVlcnkgc3RyaW5nIGtleS92YWx1ZS4gSW5cbiAqIHRoZSBmb2xsb3dpbmcgVVJMLCB5b3UgbmVlZCB0byBjYWxsIGVuY29kZVVyaVF1ZXJ5IG9uIFwia1wiIGFuZCBcInZcIjpcbiAqXG4gKiBodHRwOi8vd3d3LnNpdGUub3JnL2h0bWw7bWs9bXY/az12I2ZcbiAqL1xuZnVuY3Rpb24gZW5jb2RlVXJpUXVlcnkocykge1xuICAgIHJldHVybiBlbmNvZGVVcmlTdHJpbmcocykucmVwbGFjZSgvJTNCL2dpLCAnOycpO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBhIFVSTCBmcmFnbWVudC4gSW4gdGhlIGZvbGxvd2luZyBVUkwsIHlvdSBuZWVkIHRvIGNhbGxcbiAqIGVuY29kZVVyaUZyYWdtZW50IG9uIFwiZlwiOlxuICpcbiAqIGh0dHA6Ly93d3cuc2l0ZS5vcmcvaHRtbDttaz1tdj9rPXYjZlxuICovXG5mdW5jdGlvbiBlbmNvZGVVcmlGcmFnbWVudChzKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSShzKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgcnVuIG9uIGFueSBVUkkgc2VnbWVudCBhcyB3ZWxsIGFzIHRoZSBrZXkgYW5kIHZhbHVlIGluIGEga2V5L3ZhbHVlXG4gKiBwYWlyIGZvciBtYXRyaXggcGFyYW1zLiBJbiB0aGUgZm9sbG93aW5nIFVSTCwgeW91IG5lZWQgdG8gY2FsbCBlbmNvZGVVcmlTZWdtZW50IG9uIFwiaHRtbFwiLFxuICogXCJta1wiLCBhbmQgXCJtdlwiOlxuICpcbiAqIGh0dHA6Ly93d3cuc2l0ZS5vcmcvaHRtbDttaz1tdj9rPXYjZlxuICovXG5mdW5jdGlvbiBlbmNvZGVVcmlTZWdtZW50KHMpIHtcbiAgICByZXR1cm4gZW5jb2RlVXJpU3RyaW5nKHMpLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKS5yZXBsYWNlKC8lMjYvZ2ksICcmJyk7XG59XG5mdW5jdGlvbiBkZWNvZGUocykge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocyk7XG59XG4vLyBRdWVyeSBrZXlzL3ZhbHVlcyBzaG91bGQgaGF2ZSB0aGUgXCIrXCIgcmVwbGFjZWQgZmlyc3QsIGFzIFwiK1wiIGluIGEgcXVlcnkgc3RyaW5nIGlzIFwiIFwiLlxuLy8gZGVjb2RlVVJJQ29tcG9uZW50IGZ1bmN0aW9uIHdpbGwgbm90IGRlY29kZSBcIitcIiBhcyBhIHNwYWNlLlxuZnVuY3Rpb24gZGVjb2RlUXVlcnkocykge1xuICAgIHJldHVybiBkZWNvZGUocy5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGgocGF0aCkge1xuICAgIHJldHVybiBcIlwiICsgZW5jb2RlVXJpU2VnbWVudChwYXRoLnBhdGgpICsgc2VyaWFsaXplTWF0cml4UGFyYW1zKHBhdGgucGFyYW1ldGVycyk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVNYXRyaXhQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBcIjtcIiArIGVuY29kZVVyaVNlZ21lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVXJpU2VnbWVudChwYXJhbXNba2V5XSk7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHBhcmFtcykge1xuICAgIHZhciBzdHJQYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/XG4gICAgICAgICAgICB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGVuY29kZVVyaVF1ZXJ5KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVcmlRdWVyeSh2KTsgfSkuam9pbignJicpIDpcbiAgICAgICAgICAgIGVuY29kZVVyaVF1ZXJ5KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVcmlRdWVyeSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0clBhcmFtcy5sZW5ndGggPyBcIj9cIiArIHN0clBhcmFtcy5qb2luKFwiJlwiKSA6ICcnO1xufVxudmFyIFNFR01FTlRfUkUgPSAvXlteXFwvKCk/Oz0jXSsvO1xuZnVuY3Rpb24gbWF0Y2hTZWdtZW50cyhzdHIpIHtcbiAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goU0VHTUVOVF9SRSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbn1cbnZhciBRVUVSWV9QQVJBTV9SRSA9IC9eW149PyYjXSsvO1xuLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBxdWVyeSBwYXJhbSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZyBvciBhbiBlbXB0eSBzdHJpbmdcbmZ1bmN0aW9uIG1hdGNoUXVlcnlQYXJhbXMoc3RyKSB7XG4gICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKFFVRVJZX1BBUkFNX1JFKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xufVxudmFyIFFVRVJZX1BBUkFNX1ZBTFVFX1JFID0gL15bXj8mI10rLztcbi8vIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHF1ZXJ5IHBhcmFtIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nIG9yIGFuIGVtcHR5IHN0cmluZ1xuZnVuY3Rpb24gbWF0Y2hVcmxRdWVyeVBhcmFtVmFsdWUoc3RyKSB7XG4gICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKFFVRVJZX1BBUkFNX1ZBTFVFX1JFKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xufVxudmFyIFVybFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxQYXJzZXIodXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHVybDtcbiAgICB9XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJvb3RTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbCgnLycpO1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcgPT09ICcnIHx8IHRoaXMucGVla1N0YXJ0c1dpdGgoJz8nKSB8fCB0aGlzLnBlZWtTdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHJvb3Qgc2VnbWVudCBncm91cCBuZXZlciBoYXMgc2VnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHRoaXMucGFyc2VDaGlsZHJlbigpKTtcbiAgICB9O1xuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWwoJz8nKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VRdWVyeVBhcmFtKHBhcmFtcyk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbCgnJicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lT3B0aW9uYWwoJyMnKSA/IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLnJlbWFpbmluZykgOiBudWxsO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWwoJy8nKTtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICAgIGlmICghdGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHRoaXMucGFyc2VTZWdtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8vJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8oJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLycpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh0aGlzLnBhcnNlU2VnbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJy8oJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLycpO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnBhcnNlUGFyZW5zKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoJygnKSkge1xuICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVBhcmVucyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRzLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8vIHBhcnNlIGEgc2VnbWVudCB3aXRoIGl0cyBtYXRyaXggcGFyYW1ldGVyc1xuICAgIC8vIGllIGBuYW1lO2sxPXYxO2syYFxuICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IG1hdGNoU2VnbWVudHModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICBpZiAocGF0aCA9PT0gJycgJiYgdGhpcy5wZWVrU3RhcnRzV2l0aCgnOycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXRoIHVybCBzZWdtZW50IGNhbm5vdCBoYXZlIHBhcmFtZXRlcnM6ICdcIiArIHRoaXMucmVtYWluaW5nICsgXCInLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhcHR1cmUocGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudChkZWNvZGUocGF0aCksIHRoaXMucGFyc2VNYXRyaXhQYXJhbXMoKSk7XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlTWF0cml4UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbCgnOycpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUGFyYW0ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIga2V5ID0gbWF0Y2hTZWdtZW50cyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXB0dXJlKGtleSk7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWwoJz0nKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlTWF0Y2ggPSBtYXRjaFNlZ21lbnRzKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZU1hdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zW2RlY29kZShrZXkpXSA9IGRlY29kZSh2YWx1ZSk7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIHNpbmdsZSBxdWVyeSBwYXJhbWV0ZXIgYG5hbWVbPXZhbHVlXWBcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG1hdGNoUXVlcnlQYXJhbXModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FwdHVyZShrZXkpO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsKCc9JykpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hVcmxRdWVyeVBhcmFtVmFsdWUodGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlTWF0Y2g7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjb2RlZEtleSA9IGRlY29kZVF1ZXJ5KGtleSk7XG4gICAgICAgIHZhciBkZWNvZGVkVmFsID0gZGVjb2RlUXVlcnkodmFsdWUpO1xuICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGRlY29kZWRLZXkpKSB7XG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbCA9IHBhcmFtc1tkZWNvZGVkS2V5XTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWwgPSBbY3VycmVudFZhbF07XG4gICAgICAgICAgICAgICAgcGFyYW1zW2RlY29kZWRLZXldID0gY3VycmVudFZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRWYWwucHVzaChkZWNvZGVkVmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgcGFyYW1zW2RlY29kZWRLZXldID0gZGVjb2RlZFZhbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gcGFyc2UgYChhL2IvL291dGxldF9uYW1lOmMvZClgXG4gICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhcmVucyA9IGZ1bmN0aW9uIChhbGxvd1ByaW1hcnkpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0ge307XG4gICAgICAgIHRoaXMuY2FwdHVyZSgnKCcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuY29uc3VtZU9wdGlvbmFsKCcpJykgJiYgdGhpcy5yZW1haW5pbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBtYXRjaFNlZ21lbnRzKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5yZW1haW5pbmdbcGF0aC5sZW5ndGhdO1xuICAgICAgICAgICAgLy8gaWYgaXMgaXMgbm90IG9uZSBvZiB0aGVzZSBjaGFyYWN0ZXJzLCB0aGVuIHRoZSBzZWdtZW50IHdhcyB1bmVzY2FwZWRcbiAgICAgICAgICAgIC8vIG9yIHRoZSBncm91cCB3YXMgbm90IGNsb3NlZFxuICAgICAgICAgICAgaWYgKG5leHQgIT09ICcvJyAmJiBuZXh0ICE9PSAnKScgJiYgbmV4dCAhPT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHVybCAnXCIgKyB0aGlzLnVybCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRsZXROYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHBhdGguaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRsZXROYW1lID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5pbmRleE9mKCc6JykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZShvdXRsZXROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUoJzonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFsbG93UHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIG91dGxldE5hbWUgPSBQUklNQVJZX09VVExFVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucGFyc2VDaGlsZHJlbigpO1xuICAgICAgICAgICAgc2VnbWVudHNbb3V0bGV0TmFtZV0gPSBPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdIDpcbiAgICAgICAgICAgICAgICBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbCgnLy8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBlZWtTdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gdGhpcy5yZW1haW5pbmcuc3RhcnRzV2l0aChzdHIpOyB9O1xuICAgIC8vIENvbnN1bWVzIHRoZSBwcmVmaXggd2hlbiBpdCBpcyBwcmVzZW50IGFuZCByZXR1cm5zIHdoZXRoZXIgaXQgaGFzIGJlZW4gY29uc3VtZWRcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVPcHRpb25hbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKHRoaXMucGVla1N0YXJ0c1dpdGgoc3RyKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHJpbmcoc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBVcmxQYXJzZXIucHJvdG90eXBlLmNhcHR1cmUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25zdW1lT3B0aW9uYWwoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgc3RyICsgXCJcXFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVybFBhcnNlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWUocm9vdCkge1xuICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWUucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXRoRnJvbVJvb3QodCk7XG4gICAgICAgIHJldHVybiBwLmxlbmd0aCA+IDEgPyBwW3AubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgbiA9IGZpbmROb2RlKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICByZXR1cm4gbiA/IG4uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnZhbHVlOyB9KSA6IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBuID0gZmluZE5vZGUodCwgdGhpcy5fcm9vdCk7XG4gICAgICAgIHJldHVybiBuICYmIG4uY2hpbGRyZW4ubGVuZ3RoID4gMCA/IG4uY2hpbGRyZW5bMF0udmFsdWUgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuc2libGluZ3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgcCA9IGZpbmRQYXRoKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICBpZiAocC5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgYyA9IHBbcC5sZW5ndGggLSAyXS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmFsdWU7IH0pO1xuICAgICAgICByZXR1cm4gYy5maWx0ZXIoZnVuY3Rpb24gKGNjKSB7IHJldHVybiBjYyAhPT0gdDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5wYXRoRnJvbVJvb3QgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gZmluZFBhdGgodCwgdGhpcy5fcm9vdCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlOyB9KTsgfTtcbiAgICByZXR1cm4gVHJlZTtcbn0oKSk7XG4vLyBERlMgZm9yIHRoZSBub2RlIG1hdGNoaW5nIHRoZSB2YWx1ZVxuZnVuY3Rpb24gZmluZE5vZGUodmFsdWUsIG5vZGUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICBpZiAodmFsdWUgPT09IG5vZGUudmFsdWUpXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMobm9kZS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVfMSA9IGZpbmROb2RlKHZhbHVlLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAobm9kZV8xKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUmV0dXJuIHRoZSBwYXRoIHRvIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHVzaW5nIERGU1xuZnVuY3Rpb24gZmluZFBhdGgodmFsdWUsIG5vZGUpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICBpZiAodmFsdWUgPT09IG5vZGUudmFsdWUpXG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2RlLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGZpbmRQYXRoKHZhbHVlLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbnZhciBUcmVlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTm9kZSh2YWx1ZSwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVHJlZU5vZGUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7IH07XG4gICAgcmV0dXJuIFRyZWVOb2RlO1xufSgpKTtcbi8vIFJldHVybiB0aGUgbGlzdCBvZiBUIGluZGV4ZWQgYnkgb3V0bGV0IG5hbWVcbmZ1bmN0aW9uIG5vZGVDaGlsZHJlbkFzTWFwKG5vZGUpIHtcbiAgICB2YXIgbWFwJCQxID0ge307XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gbWFwJCQxW2NoaWxkLnZhbHVlLm91dGxldF0gPSBjaGlsZDsgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXAkJDE7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJvdXRlci5cbiAqXG4gKiBSb3V0ZXJTdGF0ZSBpcyBhIHRyZWUgb2YgYWN0aXZhdGVkIHJvdXRlcy4gRXZlcnkgbm9kZSBpbiB0aGlzIHRyZWUga25vd3MgYWJvdXQgdGhlIFwiY29uc3VtZWRcIiBVUkxcbiAqIHNlZ21lbnRzLCB0aGUgZXh0cmFjdGVkIHBhcmFtZXRlcnMsIGFuZCB0aGUgcmVzb2x2ZWQgZGF0YS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIEBDb21wb25lbnQoe3RlbXBsYXRlVXJsOid0ZW1wbGF0ZS5odG1sJ30pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyKSB7XG4gKiAgICAgY29uc3Qgc3RhdGU6IFJvdXRlclN0YXRlID0gcm91dGVyLnJvdXRlclN0YXRlO1xuICogICAgIGNvbnN0IHJvb3Q6IEFjdGl2YXRlZFJvdXRlID0gc3RhdGUucm9vdDtcbiAqICAgICBjb25zdCBjaGlsZCA9IHJvb3QuZmlyc3RDaGlsZDtcbiAqICAgICBjb25zdCBpZDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gY2hpbGQucGFyYW1zLm1hcChwID0+IHAuaWQpO1xuICogICAgIC8vLi4uXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFNlZSBgQWN0aXZhdGVkUm91dGVgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb3V0ZXJTdGF0ZSwgX3N1cGVyKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gUm91dGVyU3RhdGUocm9vdCwgXG4gICAgLyoqIFRoZSBjdXJyZW50IHNuYXBzaG90IG9mIHRoZSByb3V0ZXIgc3RhdGUgKi9cbiAgICBzbmFwc2hvdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICBzZXRSb3V0ZXJTdGF0ZShfdGhpcywgcm9vdCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUm91dGVyU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zbmFwc2hvdC50b1N0cmluZygpOyB9O1xuICAgIHJldHVybiBSb3V0ZXJTdGF0ZTtcbn0oVHJlZSkpO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZSh1cmxUcmVlLCByb290Q29tcG9uZW50KSB7XG4gICAgdmFyIHNuYXBzaG90ID0gY3JlYXRlRW1wdHlTdGF0ZVNuYXBzaG90KHVybFRyZWUsIHJvb3RDb21wb25lbnQpO1xuICAgIHZhciBlbXB0eVVybCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW25ldyBVcmxTZWdtZW50KCcnLCB7fSldKTtcbiAgICB2YXIgZW1wdHlQYXJhbXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICB2YXIgZW1wdHlEYXRhID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgdmFyIGVtcHR5UXVlcnlQYXJhbXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KCcnKTtcbiAgICB2YXIgYWN0aXZhdGVkID0gbmV3IEFjdGl2YXRlZFJvdXRlKGVtcHR5VXJsLCBlbXB0eVBhcmFtcywgZW1wdHlRdWVyeVBhcmFtcywgZnJhZ21lbnQsIGVtcHR5RGF0YSwgUFJJTUFSWV9PVVRMRVQsIHJvb3RDb21wb25lbnQsIHNuYXBzaG90LnJvb3QpO1xuICAgIGFjdGl2YXRlZC5zbmFwc2hvdCA9IHNuYXBzaG90LnJvb3Q7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZXJTdGF0ZShuZXcgVHJlZU5vZGUoYWN0aXZhdGVkLCBbXSksIHNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5U3RhdGVTbmFwc2hvdCh1cmxUcmVlLCByb290Q29tcG9uZW50KSB7XG4gICAgdmFyIGVtcHR5UGFyYW1zID0ge307XG4gICAgdmFyIGVtcHR5RGF0YSA9IHt9O1xuICAgIHZhciBlbXB0eVF1ZXJ5UGFyYW1zID0ge307XG4gICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgdmFyIGFjdGl2YXRlZCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KFtdLCBlbXB0eVBhcmFtcywgZW1wdHlRdWVyeVBhcmFtcywgZnJhZ21lbnQsIGVtcHR5RGF0YSwgUFJJTUFSWV9PVVRMRVQsIHJvb3RDb21wb25lbnQsIG51bGwsIHVybFRyZWUucm9vdCwgLTEsIHt9KTtcbiAgICByZXR1cm4gbmV3IFJvdXRlclN0YXRlU25hcHNob3QoJycsIG5ldyBUcmVlTm9kZShhY3RpdmF0ZWQsIFtdKSk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIENvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhIHJvdXRlIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudCBsb2FkZWQgaW4gYW5cbiAqIG91dGxldC4gIEFuIGBBY3RpdmF0ZWRSb3V0ZWAgY2FuIGFsc28gYmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgcm91dGVyIHN0YXRlIHRyZWUuXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHsuLi59KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZTogQWN0aXZhdGVkUm91dGUpIHtcbiAqICAgICBjb25zdCBpZDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gcm91dGUucGFyYW1zLm1hcChwID0+IHAuaWQpO1xuICogICAgIGNvbnN0IHVybDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gcm91dGUudXJsLm1hcChzZWdtZW50cyA9PiBzZWdtZW50cy5qb2luKCcnKSk7XG4gKiAgICAgLy8gcm91dGUuZGF0YSBpbmNsdWRlcyBib3RoIGBkYXRhYCBhbmQgYHJlc29sdmVgXG4gKiAgICAgY29uc3QgdXNlciA9IHJvdXRlLmRhdGEubWFwKGQgPT4gZC51c2VyKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQWN0aXZhdGVkUm91dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRlZFJvdXRlKFxuICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBVUkwgc2VnbWVudHMgbWF0Y2hlZCBieSB0aGlzIHJvdXRlICovXG4gICAgdXJsLCBcbiAgICAvKiogQW4gb2JzZXJ2YWJsZSBvZiB0aGUgbWF0cml4IHBhcmFtZXRlcnMgc2NvcGVkIHRvIHRoaXMgcm91dGUgKi9cbiAgICBwYXJhbXMsIFxuICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgIHF1ZXJ5UGFyYW1zLCBcbiAgICAvKiogQW4gb2JzZXJ2YWJsZSBvZiB0aGUgVVJMIGZyYWdtZW50IHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgIGZyYWdtZW50LCBcbiAgICAvKiogQW4gb2JzZXJ2YWJsZSBvZiB0aGUgc3RhdGljIGFuZCByZXNvbHZlZCBkYXRhIG9mIHRoaXMgcm91dGUuICovXG4gICAgZGF0YSwgXG4gICAgLyoqIFRoZSBvdXRsZXQgbmFtZSBvZiB0aGUgcm91dGUuIEl0J3MgYSBjb25zdGFudCAqL1xuICAgIG91dGxldCwgXG4gICAgLyoqIFRoZSBjb21wb25lbnQgb2YgdGhlIHJvdXRlLiBJdCdzIGEgY29uc3RhbnQgKi9cbiAgICAvLyBUT0RPKHZzYXZraW4pOiByZW1vdmUgfHN0cmluZ1xuICAgIGNvbXBvbmVudCwgZnV0dXJlU25hcHNob3QpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXM7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5vdXRsZXQgPSBvdXRsZXQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLl9mdXR1cmVTbmFwc2hvdCA9IGZ1dHVyZVNuYXBzaG90O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInJvdXRlQ29uZmlnXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWF0Y2ggdGhpcyByb3V0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Z1dHVyZVNuYXBzaG90LnJvdXRlQ29uZmlnOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAvKiogVGhlIHJvb3Qgb2YgdGhlIHJvdXRlciBzdGF0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnJvb3Q7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgLyoqIFRoZSBwYXJlbnQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5wYXJlbnQodGhpcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwiZmlyc3RDaGlsZFwiLCB7XG4gICAgICAgIC8qKiBUaGUgZmlyc3QgY2hpbGQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5maXJzdENoaWxkKHRoaXMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIHJvdXRlIGluIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLmNoaWxkcmVuKHRoaXMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInBhdGhGcm9tUm9vdFwiLCB7XG4gICAgICAgIC8qKiBUaGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSB0byB0aGlzIHJvdXRlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUucGF0aEZyb21Sb290KHRoaXMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLCBcInBhcmFtTWFwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1NYXAgPSB0aGlzLnBhcmFtcy5waXBlKG1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gY29udmVydFRvUGFyYW1NYXAocCk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbU1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlLnByb3RvdHlwZSwgXCJxdWVyeVBhcmFtTWFwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3F1ZXJ5UGFyYW1NYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeVBhcmFtTWFwID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcy5waXBlKG1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gY29udmVydFRvUGFyYW1NYXAocCk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVBhcmFtTWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNuYXBzaG90ID8gdGhpcy5zbmFwc2hvdC50b1N0cmluZygpIDogXCJGdXR1cmUoXCIgKyB0aGlzLl9mdXR1cmVTbmFwc2hvdCArIFwiKVwiO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGl2YXRlZFJvdXRlO1xufSgpKTtcbi8qKlxuICogUmV0dXJucyB0aGUgaW5oZXJpdGVkIHBhcmFtcywgZGF0YSwgYW5kIHJlc29sdmUgZm9yIGEgZ2l2ZW4gcm91dGUuXG4gKiBCeSBkZWZhdWx0LCB0aGlzIG9ubHkgaW5oZXJpdHMgdmFsdWVzIHVwIHRvIHRoZSBuZWFyZXN0IHBhdGgtbGVzcyBvciBjb21wb25lbnQtbGVzcyByb3V0ZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbmhlcml0ZWRQYXJhbXNEYXRhUmVzb2x2ZShyb3V0ZSwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSkge1xuICAgIGlmIChwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID09PSB2b2lkIDApIHsgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9ICdlbXB0eU9ubHknOyB9XG4gICAgdmFyIHBhdGhGcm9tUm9vdCA9IHJvdXRlLnBhdGhGcm9tUm9vdDtcbiAgICB2YXIgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbSA9IDA7XG4gICAgaWYgKHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgIT09ICdhbHdheXMnKSB7XG4gICAgICAgIGluaGVyaXRpbmdTdGFydGluZ0Zyb20gPSBwYXRoRnJvbVJvb3QubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGluaGVyaXRpbmdTdGFydGluZ0Zyb20gPj0gMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoRnJvbVJvb3RbaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbV07XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBwYXRoRnJvbVJvb3RbaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbSAtIDFdO1xuICAgICAgICAgICAgLy8gY3VycmVudCByb3V0ZSBpcyBhbiBlbXB0eSBwYXRoID0+IGluaGVyaXRzIGl0cyBwYXJlbnQncyBwYXJhbXMgYW5kIGRhdGFcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJvdXRlQ29uZmlnICYmIGN1cnJlbnQucm91dGVDb25maWcucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBpbmhlcml0aW5nU3RhcnRpbmdGcm9tLS07XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGNvbXBvbmVudGxlc3MgPT4gY3VycmVudCByb3V0ZSBzaG91bGQgaW5oZXJpdCBpdHMgcGFyYW1zIGFuZCBkYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcGFyZW50XzEuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5Jbmhlcml0ZWQocGF0aEZyb21Sb290LnNsaWNlKGluaGVyaXRpbmdTdGFydGluZ0Zyb20pKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Jbmhlcml0ZWQocGF0aEZyb21Sb290KSB7XG4gICAgcmV0dXJuIHBhdGhGcm9tUm9vdC5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgY3Vycikge1xuICAgICAgICB2YXIgcGFyYW1zID0gX19hc3NpZ24oe30sIHJlcy5wYXJhbXMsIGN1cnIucGFyYW1zKTtcbiAgICAgICAgdmFyIGRhdGEgPSBfX2Fzc2lnbih7fSwgcmVzLmRhdGEsIGN1cnIuZGF0YSk7XG4gICAgICAgIHZhciByZXNvbHZlID0gX19hc3NpZ24oe30sIHJlcy5yZXNvbHZlLCBjdXJyLl9yZXNvbHZlZERhdGEpO1xuICAgICAgICByZXR1cm4geyBwYXJhbXM6IHBhcmFtcywgZGF0YTogZGF0YSwgcmVzb2x2ZTogcmVzb2x2ZSB9O1xuICAgIH0sIHsgcGFyYW1zOiB7fSwgZGF0YToge30sIHJlc29sdmU6IHt9IH0pO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYSByb3V0ZSBhc3NvY2lhdGVkIHdpdGggYSBjb21wb25lbnQgbG9hZGVkIGluIGFuXG4gKiBvdXRsZXQgYXQgYSBwYXJ0aWN1bGFyIG1vbWVudCBpbiB0aW1lLiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IGNhbiBhbHNvIGJlIHVzZWQgdG9cbiAqIHRyYXZlcnNlIHRoZSByb3V0ZXIgc3RhdGUgdHJlZS5cbiAqXG4gKiBgYGBcbiAqIEBDb21wb25lbnQoe3RlbXBsYXRlVXJsOicuL215LWNvbXBvbmVudC5odG1sJ30pXG4gKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIGNvbnN0cnVjdG9yKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSkge1xuICogICAgIGNvbnN0IGlkOiBzdHJpbmcgPSByb3V0ZS5zbmFwc2hvdC5wYXJhbXMuaWQ7XG4gKiAgICAgY29uc3QgdXJsOiBzdHJpbmcgPSByb3V0ZS5zbmFwc2hvdC51cmwuam9pbignJyk7XG4gKiAgICAgY29uc3QgdXNlciA9IHJvdXRlLnNuYXBzaG90LmRhdGEudXNlcjtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gQWN0aXZhdGVkUm91dGVTbmFwc2hvdChcbiAgICAvKiogVGhlIFVSTCBzZWdtZW50cyBtYXRjaGVkIGJ5IHRoaXMgcm91dGUgKi9cbiAgICB1cmwsIFxuICAgIC8qKiBUaGUgbWF0cml4IHBhcmFtZXRlcnMgc2NvcGVkIHRvIHRoaXMgcm91dGUgKi9cbiAgICBwYXJhbXMsIFxuICAgIC8qKiBUaGUgcXVlcnkgcGFyYW1ldGVycyBzaGFyZWQgYnkgYWxsIHRoZSByb3V0ZXMgKi9cbiAgICBxdWVyeVBhcmFtcywgXG4gICAgLyoqIFRoZSBVUkwgZnJhZ21lbnQgc2hhcmVkIGJ5IGFsbCB0aGUgcm91dGVzICovXG4gICAgZnJhZ21lbnQsIFxuICAgIC8qKiBUaGUgc3RhdGljIGFuZCByZXNvbHZlZCBkYXRhIG9mIHRoaXMgcm91dGUgKi9cbiAgICBkYXRhLCBcbiAgICAvKiogVGhlIG91dGxldCBuYW1lIG9mIHRoZSByb3V0ZSAqL1xuICAgIG91dGxldCwgXG4gICAgLyoqIFRoZSBjb21wb25lbnQgb2YgdGhlIHJvdXRlICovXG4gICAgY29tcG9uZW50LCByb3V0ZUNvbmZpZywgdXJsU2VnbWVudCwgbGFzdFBhdGhJbmRleCwgcmVzb2x2ZSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm91dGxldCA9IG91dGxldDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMucm91dGVDb25maWcgPSByb3V0ZUNvbmZpZztcbiAgICAgICAgdGhpcy5fdXJsU2VnbWVudCA9IHVybFNlZ21lbnQ7XG4gICAgICAgIHRoaXMuX2xhc3RQYXRoSW5kZXggPSBsYXN0UGF0aEluZGV4O1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAvKiogVGhlIHJvb3Qgb2YgdGhlIHJvdXRlciBzdGF0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnJvb3Q7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAvKiogVGhlIHBhcmVudCBvZiB0aGlzIHJvdXRlIGluIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnBhcmVudCh0aGlzKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcImZpcnN0Q2hpbGRcIiwge1xuICAgICAgICAvKiogVGhlIGZpcnN0IGNoaWxkIG9mIHRoaXMgcm91dGUgaW4gdGhlIHJvdXRlciBzdGF0ZSB0cmVlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUuZmlyc3RDaGlsZCh0aGlzKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIHJvdXRlIGluIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLmNoaWxkcmVuKHRoaXMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUsIFwicGF0aEZyb21Sb290XCIsIHtcbiAgICAgICAgLyoqIFRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHRvIHRoaXMgcm91dGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5wYXRoRnJvbVJvb3QodGhpcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJwYXJhbU1hcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJhbU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtTWFwID0gY29udmVydFRvUGFyYW1NYXAodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtTWFwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUsIFwicXVlcnlQYXJhbU1hcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWVyeVBhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbU1hcCA9IGNvbnZlcnRUb1BhcmFtTWFwKHRoaXMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1NYXA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7IHJldHVybiBzZWdtZW50LnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSB0aGlzLnJvdXRlQ29uZmlnID8gdGhpcy5yb3V0ZUNvbmZpZy5wYXRoIDogJyc7XG4gICAgICAgIHJldHVybiBcIlJvdXRlKHVybDonXCIgKyB1cmwgKyBcIicsIHBhdGg6J1wiICsgbWF0Y2hlZCArIFwiJylcIjtcbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90O1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJvdXRlciBhdCBhIG1vbWVudCBpbiB0aW1lLlxuICpcbiAqIFRoaXMgaXMgYSB0cmVlIG9mIGFjdGl2YXRlZCByb3V0ZSBzbmFwc2hvdHMuIEV2ZXJ5IG5vZGUgaW4gdGhpcyB0cmVlIGtub3dzIGFib3V0XG4gKiB0aGUgXCJjb25zdW1lZFwiIFVSTCBzZWdtZW50cywgdGhlIGV4dHJhY3RlZCBwYXJhbWV0ZXJzLCBhbmQgdGhlIHJlc29sdmVkIGRhdGEuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICogICAgIGNvbnN0IHN0YXRlOiBSb3V0ZXJTdGF0ZSA9IHJvdXRlci5yb3V0ZXJTdGF0ZTtcbiAqICAgICBjb25zdCBzbmFwc2hvdDogUm91dGVyU3RhdGVTbmFwc2hvdCA9IHN0YXRlLnNuYXBzaG90O1xuICogICAgIGNvbnN0IHJvb3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgPSBzbmFwc2hvdC5yb290O1xuICogICAgIGNvbnN0IGNoaWxkID0gcm9vdC5maXJzdENoaWxkO1xuICogICAgIGNvbnN0IGlkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSBjaGlsZC5wYXJhbXMubWFwKHAgPT4gcC5pZCk7XG4gKiAgICAgLy8uLi5cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUm91dGVyU3RhdGVTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm91dGVyU3RhdGVTbmFwc2hvdCwgX3N1cGVyKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gUm91dGVyU3RhdGVTbmFwc2hvdChcbiAgICAvKiogVGhlIHVybCBmcm9tIHdoaWNoIHRoaXMgc25hcHNob3Qgd2FzIGNyZWF0ZWQgKi9cbiAgICB1cmwsIHJvb3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXJsID0gdXJsO1xuICAgICAgICBzZXRSb3V0ZXJTdGF0ZShfdGhpcywgcm9vdCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUm91dGVyU3RhdGVTbmFwc2hvdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJpYWxpemVOb2RlKHRoaXMuX3Jvb3QpOyB9O1xuICAgIHJldHVybiBSb3V0ZXJTdGF0ZVNuYXBzaG90O1xufShUcmVlKSk7XG5mdW5jdGlvbiBzZXRSb3V0ZXJTdGF0ZShzdGF0ZSwgbm9kZSkge1xuICAgIG5vZGUudmFsdWUuX3JvdXRlclN0YXRlID0gc3RhdGU7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBzZXRSb3V0ZXJTdGF0ZShzdGF0ZSwgYyk7IH0pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShub2RlKSB7XG4gICAgdmFyIGMgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyBcIiB7IFwiICsgbm9kZS5jaGlsZHJlbi5tYXAoc2VyaWFsaXplTm9kZSkuam9pbignLCAnKSArIFwiIH0gXCIgOiAnJztcbiAgICByZXR1cm4gXCJcIiArIG5vZGUudmFsdWUgKyBjO1xufVxuLyoqXG4gKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGUgYWN0aXZhdGUgcm91dGUgaXMgY3JlYXRlZCB3aXRoIHRoZSByaWdodCBzZXQgb2YgcGFyYW1ldGVycy5cbiAqIFNvIHdlIHB1c2ggbmV3IHZhbHVlcyBpbnRvIHRoZSBvYnNlcnZhYmxlcyBvbmx5IHdoZW4gdGhleSBhcmUgbm90IHRoZSBpbml0aWFsIHZhbHVlcy5cbiAqIEFuZCB3ZSBkZXRlY3QgdGhhdCBieSBjaGVja2luZyBpZiB0aGUgc25hcHNob3QgZmllbGQgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBhZHZhbmNlQWN0aXZhdGVkUm91dGUocm91dGUpIHtcbiAgICBpZiAocm91dGUuc25hcHNob3QpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTbmFwc2hvdCA9IHJvdXRlLnNuYXBzaG90O1xuICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICByb3V0ZS5zbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwoY3VycmVudFNuYXBzaG90LnF1ZXJ5UGFyYW1zLCBuZXh0U25hcHNob3QucXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICByb3V0ZS5xdWVyeVBhcmFtcy5uZXh0KG5leHRTbmFwc2hvdC5xdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRTbmFwc2hvdC5mcmFnbWVudCAhPT0gbmV4dFNuYXBzaG90LmZyYWdtZW50KSB7XG4gICAgICAgICAgICByb3V0ZS5mcmFnbWVudC5uZXh0KG5leHRTbmFwc2hvdC5mcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwoY3VycmVudFNuYXBzaG90LnBhcmFtcywgbmV4dFNuYXBzaG90LnBhcmFtcykpIHtcbiAgICAgICAgICAgIHJvdXRlLnBhcmFtcy5uZXh0KG5leHRTbmFwc2hvdC5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvd0VxdWFsQXJyYXlzKGN1cnJlbnRTbmFwc2hvdC51cmwsIG5leHRTbmFwc2hvdC51cmwpKSB7XG4gICAgICAgICAgICByb3V0ZS51cmwubmV4dChuZXh0U25hcHNob3QudXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChjdXJyZW50U25hcHNob3QuZGF0YSwgbmV4dFNuYXBzaG90LmRhdGEpKSB7XG4gICAgICAgICAgICByb3V0ZS5kYXRhLm5leHQobmV4dFNuYXBzaG90LmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb3V0ZS5zbmFwc2hvdCA9IHJvdXRlLl9mdXR1cmVTbmFwc2hvdDtcbiAgICAgICAgLy8gdGhpcyBpcyBmb3IgcmVzb2x2ZWQgZGF0YVxuICAgICAgICByb3V0ZS5kYXRhLm5leHQocm91dGUuX2Z1dHVyZVNuYXBzaG90LmRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoYSwgYikge1xuICAgIHZhciBlcXVhbFVybFBhcmFtcyA9IHNoYWxsb3dFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpICYmIGVxdWFsU2VnbWVudHMoYS51cmwsIGIudXJsKTtcbiAgICB2YXIgcGFyZW50c01pc21hdGNoID0gIWEucGFyZW50ICE9PSAhYi5wYXJlbnQ7XG4gICAgcmV0dXJuIGVxdWFsVXJsUGFyYW1zICYmICFwYXJlbnRzTWlzbWF0Y2ggJiZcbiAgICAgICAgKCFhLnBhcmVudCB8fCBlcXVhbFBhcmFtc0FuZFVybFNlZ21lbnRzKGEucGFyZW50LCBiLnBhcmVudCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJTdGF0ZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIsIHByZXZTdGF0ZSkge1xuICAgIHZhciByb290ID0gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIuX3Jvb3QsIHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5fcm9vdCA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZXJTdGF0ZShyb290LCBjdXJyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjdXJyLCBwcmV2U3RhdGUpIHtcbiAgICAvLyByZXVzZSBhbiBhY3RpdmF0ZWQgcm91dGUgdGhhdCBpcyBjdXJyZW50bHkgZGlzcGxheWVkIG9uIHRoZSBzY3JlZW5cbiAgICBpZiAocHJldlN0YXRlICYmIHJvdXRlUmV1c2VTdHJhdGVneS5zaG91bGRSZXVzZVJvdXRlKGN1cnIudmFsdWUsIHByZXZTdGF0ZS52YWx1ZS5zbmFwc2hvdCkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJldlN0YXRlLnZhbHVlO1xuICAgICAgICB2YWx1ZS5fZnV0dXJlU25hcHNob3QgPSBjdXJyLnZhbHVlO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjcmVhdGVPclJldXNlQ2hpbGRyZW4ocm91dGVSZXVzZVN0cmF0ZWd5LCBjdXJyLCBwcmV2U3RhdGUpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIC8vIHJldHJpZXZlIGFuIGFjdGl2YXRlZCByb3V0ZSB0aGF0IGlzIHVzZWQgdG8gYmUgZGlzcGxheWVkLCBidXQgaXMgbm90IGN1cnJlbnRseSBkaXNwbGF5ZWRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBkZXRhY2hlZFJvdXRlSGFuZGxlID0gcm91dGVSZXVzZVN0cmF0ZWd5LnJldHJpZXZlKGN1cnIudmFsdWUpO1xuICAgICAgICBpZiAoZGV0YWNoZWRSb3V0ZUhhbmRsZSkge1xuICAgICAgICAgICAgdmFyIHRyZWUgPSBkZXRhY2hlZFJvdXRlSGFuZGxlLnJvdXRlO1xuICAgICAgICAgICAgc2V0RnV0dXJlU25hcHNob3RzT2ZBY3RpdmF0ZWRSb3V0ZXMoY3VyciwgdHJlZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNyZWF0ZUFjdGl2YXRlZFJvdXRlKGN1cnIudmFsdWUpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3Vyci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRGdXR1cmVTbmFwc2hvdHNPZkFjdGl2YXRlZFJvdXRlcyhjdXJyLCByZXN1bHQpIHtcbiAgICBpZiAoY3Vyci52YWx1ZS5yb3V0ZUNvbmZpZyAhPT0gcmVzdWx0LnZhbHVlLnJvdXRlQ29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYXR0YWNoIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgY3JlYXRlZCBmcm9tIGEgZGlmZmVyZW50IHJvdXRlJyk7XG4gICAgfVxuICAgIGlmIChjdXJyLmNoaWxkcmVuLmxlbmd0aCAhPT0gcmVzdWx0LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWF0dGFjaCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGNoaWxkcmVuJyk7XG4gICAgfVxuICAgIHJlc3VsdC52YWx1ZS5fZnV0dXJlU25hcHNob3QgPSBjdXJyLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vyci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBzZXRGdXR1cmVTbmFwc2hvdHNPZkFjdGl2YXRlZFJvdXRlcyhjdXJyLmNoaWxkcmVuW2ldLCByZXN1bHQuY2hpbGRyZW5baV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9yUmV1c2VDaGlsZHJlbihyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIsIHByZXZTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHByZXZTdGF0ZS5jaGlsZHJlbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZVJldXNlU3RyYXRlZ3kuc2hvdWxkUmV1c2VSb3V0ZShwLnZhbHVlLnNuYXBzaG90LCBjaGlsZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjaGlsZCwgcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjaGlsZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3RpdmF0ZWRSb3V0ZShjKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmF0ZWRSb3V0ZShuZXcgQmVoYXZpb3JTdWJqZWN0KGMudXJsKSwgbmV3IEJlaGF2aW9yU3ViamVjdChjLnBhcmFtcyksIG5ldyBCZWhhdmlvclN1YmplY3QoYy5xdWVyeVBhcmFtcyksIG5ldyBCZWhhdmlvclN1YmplY3QoYy5mcmFnbWVudCksIG5ldyBCZWhhdmlvclN1YmplY3QoYy5kYXRhKSwgYy5vdXRsZXQsIGMuY29tcG9uZW50LCBjKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXJsVHJlZShyb3V0ZSwgdXJsVHJlZSwgY29tbWFuZHMsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCkge1xuICAgIGlmIChjb21tYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRyZWUodXJsVHJlZS5yb290LCB1cmxUcmVlLnJvb3QsIHVybFRyZWUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHZhciBuYXYgPSBjb21wdXRlTmF2aWdhdGlvbihjb21tYW5kcyk7XG4gICAgaWYgKG5hdi50b1Jvb3QoKSkge1xuICAgICAgICByZXR1cm4gdHJlZSh1cmxUcmVlLnJvb3QsIG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KSwgdXJsVHJlZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0aW5nUG9zaXRpb24gPSBmaW5kU3RhcnRpbmdQb3NpdGlvbihuYXYsIHVybFRyZWUsIHJvdXRlKTtcbiAgICB2YXIgc2VnbWVudEdyb3VwID0gc3RhcnRpbmdQb3NpdGlvbi5wcm9jZXNzQ2hpbGRyZW4gP1xuICAgICAgICB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnRHcm91cCwgc3RhcnRpbmdQb3NpdGlvbi5pbmRleCwgbmF2LmNvbW1hbmRzKSA6XG4gICAgICAgIHVwZGF0ZVNlZ21lbnRHcm91cChzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnRHcm91cCwgc3RhcnRpbmdQb3NpdGlvbi5pbmRleCwgbmF2LmNvbW1hbmRzKTtcbiAgICByZXR1cm4gdHJlZShzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnRHcm91cCwgc2VnbWVudEdyb3VwLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xufVxuZnVuY3Rpb24gaXNNYXRyaXhQYXJhbXMoY29tbWFuZCkge1xuICAgIHJldHVybiB0eXBlb2YgY29tbWFuZCA9PT0gJ29iamVjdCcgJiYgY29tbWFuZCAhPSBudWxsICYmICFjb21tYW5kLm91dGxldHMgJiYgIWNvbW1hbmQuc2VnbWVudFBhdGg7XG59XG5mdW5jdGlvbiB0cmVlKG9sZFNlZ21lbnRHcm91cCwgbmV3U2VnbWVudEdyb3VwLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpIHtcbiAgICB2YXIgcXAgPSB7fTtcbiAgICBpZiAocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgZm9yRWFjaChxdWVyeVBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICBxcFtuYW1lXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlwiICsgdjsgfSkgOiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodXJsVHJlZS5yb290ID09PSBvbGRTZWdtZW50R3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKG5ld1NlZ21lbnRHcm91cCwgcXAsIGZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVcmxUcmVlKHJlcGxhY2VTZWdtZW50KHVybFRyZWUucm9vdCwgb2xkU2VnbWVudEdyb3VwLCBuZXdTZWdtZW50R3JvdXApLCBxcCwgZnJhZ21lbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVNlZ21lbnQoY3VycmVudCwgb2xkU2VnbWVudCwgbmV3U2VnbWVudCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHt9O1xuICAgIGZvckVhY2goY3VycmVudC5jaGlsZHJlbiwgZnVuY3Rpb24gKGMsIG91dGxldE5hbWUpIHtcbiAgICAgICAgaWYgKGMgPT09IG9sZFNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW291dGxldE5hbWVdID0gbmV3U2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuW291dGxldE5hbWVdID0gcmVwbGFjZVNlZ21lbnQoYywgb2xkU2VnbWVudCwgbmV3U2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChjdXJyZW50LnNlZ21lbnRzLCBjaGlsZHJlbik7XG59XG52YXIgTmF2aWdhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKGlzQWJzb2x1dGUsIG51bWJlck9mRG91YmxlRG90cywgY29tbWFuZHMpIHtcbiAgICAgICAgdGhpcy5pc0Fic29sdXRlID0gaXNBYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5udW1iZXJPZkRvdWJsZURvdHMgPSBudW1iZXJPZkRvdWJsZURvdHM7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgaWYgKGlzQWJzb2x1dGUgJiYgY29tbWFuZHMubGVuZ3RoID4gMCAmJiBpc01hdHJpeFBhcmFtcyhjb21tYW5kc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBzZWdtZW50IGNhbm5vdCBoYXZlIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNtZFdpdGhPdXRsZXQgPSBjb21tYW5kcy5maW5kKGZ1bmN0aW9uIChjKSB7IHJldHVybiB0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgYyAhPSBudWxsICYmIGMub3V0bGV0czsgfSk7XG4gICAgICAgIGlmIChjbWRXaXRoT3V0bGV0ICYmIGNtZFdpdGhPdXRsZXQgIT09IGxhc3QkMShjb21tYW5kcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigne291dGxldHM6e319IGhhcyB0byBiZSB0aGUgbGFzdCBjb21tYW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTmF2aWdhdGlvbi5wcm90b3R5cGUudG9Sb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0Fic29sdXRlICYmIHRoaXMuY29tbWFuZHMubGVuZ3RoID09PSAxICYmIHRoaXMuY29tbWFuZHNbMF0gPT0gJy8nO1xuICAgIH07XG4gICAgcmV0dXJuIE5hdmlnYXRpb247XG59KCkpO1xuLyoqIFRyYW5zZm9ybXMgY29tbWFuZHMgdG8gYSBub3JtYWxpemVkIGBOYXZpZ2F0aW9uYCAqL1xuZnVuY3Rpb24gY29tcHV0ZU5hdmlnYXRpb24oY29tbWFuZHMpIHtcbiAgICBpZiAoKHR5cGVvZiBjb21tYW5kc1swXSA9PT0gJ3N0cmluZycpICYmIGNvbW1hbmRzLmxlbmd0aCA9PT0gMSAmJiBjb21tYW5kc1swXSA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbih0cnVlLCAwLCBjb21tYW5kcyk7XG4gICAgfVxuICAgIHZhciBudW1iZXJPZkRvdWJsZURvdHMgPSAwO1xuICAgIHZhciBpc0Fic29sdXRlID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IGNvbW1hbmRzLnJlZHVjZShmdW5jdGlvbiAocmVzLCBjbWQsIGNtZElkeCkge1xuICAgICAgICBpZiAodHlwZW9mIGNtZCA9PT0gJ29iamVjdCcgJiYgY21kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjbWQub3V0bGV0cykge1xuICAgICAgICAgICAgICAgIHZhciBvdXRsZXRzXzEgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGNtZC5vdXRsZXRzLCBmdW5jdGlvbiAoY29tbWFuZHMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0bGV0c18xW25hbWVdID0gdHlwZW9mIGNvbW1hbmRzID09PSAnc3RyaW5nJyA/IGNvbW1hbmRzLnNwbGl0KCcvJykgOiBjb21tYW5kcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQocmVzLCBbeyBvdXRsZXRzOiBvdXRsZXRzXzEgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZC5zZWdtZW50UGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChyZXMsIFtjbWQuc2VnbWVudFBhdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgY21kID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChyZXMsIFtjbWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kSWR4ID09PSAwKSB7XG4gICAgICAgICAgICBjbWQuc3BsaXQoJy8nKS5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQYXJ0LCBwYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydEluZGV4ID09IDAgJiYgdXJsUGFydCA9PT0gJy4nKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFydEluZGV4ID09IDAgJiYgdXJsUGFydCA9PT0gJycpIHsgLy8gICcvYSdcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFBhcnQgPT09ICcuLicpIHsgLy8gICcuLi9hJ1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkRvdWJsZURvdHMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUGFydCAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh1cmxQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkKHJlcywgW2NtZF0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbmV3IE5hdmlnYXRpb24oaXNBYnNvbHV0ZSwgbnVtYmVyT2ZEb3VibGVEb3RzLCByZXMpO1xufVxudmFyIFBvc2l0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKHNlZ21lbnRHcm91cCwgcHJvY2Vzc0NoaWxkcmVuLCBpbmRleCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRHcm91cCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ2hpbGRyZW4gPSBwcm9jZXNzQ2hpbGRyZW47XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIFBvc2l0aW9uO1xufSgpKTtcbmZ1bmN0aW9uIGZpbmRTdGFydGluZ1Bvc2l0aW9uKG5hdiwgdHJlZSwgcm91dGUpIHtcbiAgICBpZiAobmF2LmlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0cmVlLnJvb3QsIHRydWUsIDApO1xuICAgIH1cbiAgICBpZiAocm91dGUuc25hcHNob3QuX2xhc3RQYXRoSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIHRydWUsIDApO1xuICAgIH1cbiAgICB2YXIgbW9kaWZpZXIgPSBpc01hdHJpeFBhcmFtcyhuYXYuY29tbWFuZHNbMF0pID8gMCA6IDE7XG4gICAgdmFyIGluZGV4ID0gcm91dGUuc25hcHNob3QuX2xhc3RQYXRoSW5kZXggKyBtb2RpZmllcjtcbiAgICByZXR1cm4gY3JlYXRlUG9zaXRpb25BcHBseWluZ0RvdWJsZURvdHMocm91dGUuc25hcHNob3QuX3VybFNlZ21lbnQsIGluZGV4LCBuYXYubnVtYmVyT2ZEb3VibGVEb3RzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQXBwbHlpbmdEb3VibGVEb3RzKGdyb3VwLCBpbmRleCwgbnVtYmVyT2ZEb3VibGVEb3RzKSB7XG4gICAgdmFyIGcgPSBncm91cDtcbiAgICB2YXIgY2kgPSBpbmRleDtcbiAgICB2YXIgZGQgPSBudW1iZXJPZkRvdWJsZURvdHM7XG4gICAgd2hpbGUgKGRkID4gY2kpIHtcbiAgICAgICAgZGQgLT0gY2k7XG4gICAgICAgIGcgPSBnLnBhcmVudDtcbiAgICAgICAgaWYgKCFnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIFxcJy4uL1xcJycpO1xuICAgICAgICB9XG4gICAgICAgIGNpID0gZy5zZWdtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9zaXRpb24oZywgZmFsc2UsIGNpIC0gZGQpO1xufVxuZnVuY3Rpb24gZ2V0UGF0aChjb21tYW5kKSB7XG4gICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSAnb2JqZWN0JyAmJiBjb21tYW5kICE9IG51bGwgJiYgY29tbWFuZC5vdXRsZXRzKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kLm91dGxldHNbUFJJTUFSWV9PVVRMRVRdO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIGNvbW1hbmQ7XG59XG5mdW5jdGlvbiBnZXRPdXRsZXRzKGNvbW1hbmRzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoISh0eXBlb2YgY29tbWFuZHNbMF0gPT09ICdvYmplY3QnKSlcbiAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW1BSSU1BUllfT1VUTEVUXSA9IGNvbW1hbmRzLCBfYTtcbiAgICBpZiAoY29tbWFuZHNbMF0ub3V0bGV0cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gX2IgPSB7fSwgX2JbUFJJTUFSWV9PVVRMRVRdID0gY29tbWFuZHMsIF9iO1xuICAgIHJldHVybiBjb21tYW5kc1swXS5vdXRsZXRzO1xufVxuZnVuY3Rpb24gdXBkYXRlU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICBpZiAoIXNlZ21lbnRHcm91cCkge1xuICAgICAgICBzZWdtZW50R3JvdXAgPSBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgfVxuICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihzZWdtZW50R3JvdXAsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKTtcbiAgICB9XG4gICAgdmFyIG0gPSBwcmVmaXhlZFdpdGgoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgdmFyIHNsaWNlZENvbW1hbmRzID0gY29tbWFuZHMuc2xpY2UobS5jb21tYW5kSW5kZXgpO1xuICAgIGlmIChtLm1hdGNoICYmIG0ucGF0aEluZGV4IDwgc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZyA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLnNsaWNlKDAsIG0ucGF0aEluZGV4KSwge30pO1xuICAgICAgICBnLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSA9XG4gICAgICAgICAgICBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cy5zbGljZShtLnBhdGhJbmRleCksIHNlZ21lbnRHcm91cC5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihnLCAwLCBzbGljZWRDb21tYW5kcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG0ubWF0Y2ggJiYgc2xpY2VkQ29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywge30pO1xuICAgIH1cbiAgICBlbHNlIGlmIChtLm1hdGNoICYmICFzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTmV3U2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtLm1hdGNoKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihzZWdtZW50R3JvdXAsIDAsIHNsaWNlZENvbW1hbmRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOZXdTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcykge1xuICAgIGlmIChjb21tYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLCB7fSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3V0bGV0c18yID0gZ2V0T3V0bGV0cyhjb21tYW5kcyk7XG4gICAgICAgIHZhciBjaGlsZHJlbl8xID0ge307XG4gICAgICAgIGZvckVhY2gob3V0bGV0c18yLCBmdW5jdGlvbiAoY29tbWFuZHMsIG91dGxldCkge1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5fMVtvdXRsZXRdID0gdXBkYXRlU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5jaGlsZHJlbltvdXRsZXRdLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3JFYWNoKHNlZ21lbnRHcm91cC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZE91dGxldCkge1xuICAgICAgICAgICAgaWYgKG91dGxldHNfMltjaGlsZE91dGxldF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuXzFbY2hpbGRPdXRsZXRdID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIGNoaWxkcmVuXzEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZWZpeGVkV2l0aChzZWdtZW50R3JvdXAsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKSB7XG4gICAgdmFyIGN1cnJlbnRDb21tYW5kSW5kZXggPSAwO1xuICAgIHZhciBjdXJyZW50UGF0aEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB2YXIgbm9NYXRjaCA9IHsgbWF0Y2g6IGZhbHNlLCBwYXRoSW5kZXg6IDAsIGNvbW1hbmRJbmRleDogMCB9O1xuICAgIHdoaWxlIChjdXJyZW50UGF0aEluZGV4IDwgc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoY3VycmVudENvbW1hbmRJbmRleCA+PSBjb21tYW5kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbm9NYXRjaDtcbiAgICAgICAgdmFyIHBhdGggPSBzZWdtZW50R3JvdXAuc2VnbWVudHNbY3VycmVudFBhdGhJbmRleF07XG4gICAgICAgIHZhciBjdXJyID0gZ2V0UGF0aChjb21tYW5kc1tjdXJyZW50Q29tbWFuZEluZGV4XSk7XG4gICAgICAgIHZhciBuZXh0ID0gY3VycmVudENvbW1hbmRJbmRleCA8IGNvbW1hbmRzLmxlbmd0aCAtIDEgPyBjb21tYW5kc1tjdXJyZW50Q29tbWFuZEluZGV4ICsgMV0gOiBudWxsO1xuICAgICAgICBpZiAoY3VycmVudFBhdGhJbmRleCA+IDAgJiYgY3VyciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChjdXJyICYmIG5leHQgJiYgKHR5cGVvZiBuZXh0ID09PSAnb2JqZWN0JykgJiYgbmV4dC5vdXRsZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghY29tcGFyZShjdXJyLCBuZXh0LCBwYXRoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaDtcbiAgICAgICAgICAgIGN1cnJlbnRDb21tYW5kSW5kZXggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29tcGFyZShjdXJyLCB7fSwgcGF0aCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2g7XG4gICAgICAgICAgICBjdXJyZW50Q29tbWFuZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhdGhJbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXRjaDogdHJ1ZSwgcGF0aEluZGV4OiBjdXJyZW50UGF0aEluZGV4LCBjb21tYW5kSW5kZXg6IGN1cnJlbnRDb21tYW5kSW5kZXggfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5ld1NlZ21lbnRHcm91cChzZWdtZW50R3JvdXAsIHN0YXJ0SW5kZXgsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHBhdGhzID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzLnNsaWNlKDAsIHN0YXJ0SW5kZXgpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmRzW2ldID09PSAnb2JqZWN0JyAmJiBjb21tYW5kc1tpXS5vdXRsZXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNyZWF0ZU5ld1NlZ21lbnRDaGlsZHJlbihjb21tYW5kc1tpXS5vdXRsZXRzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKHBhdGhzLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2Ugc3RhcnQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCwgd2UgbmVlZCB0byByZXVzZSB0aGUgcGF0aCBwYXJ0IGZyb20gdGhlIHNlZ21lbnRcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgaXNNYXRyaXhQYXJhbXMoY29tbWFuZHNbMF0pKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNlZ21lbnRHcm91cC5zZWdtZW50c1tzdGFydEluZGV4XTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3IFVybFNlZ21lbnQocC5wYXRoLCBjb21tYW5kc1swXSkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnIgPSBnZXRQYXRoKGNvbW1hbmRzW2ldKTtcbiAgICAgICAgdmFyIG5leHQgPSAoaSA8IGNvbW1hbmRzLmxlbmd0aCAtIDEpID8gY29tbWFuZHNbaSArIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGN1cnIgJiYgbmV4dCAmJiBpc01hdHJpeFBhcmFtcyhuZXh0KSkge1xuICAgICAgICAgICAgcGF0aHMucHVzaChuZXcgVXJsU2VnbWVudChjdXJyLCBzdHJpbmdpZnkobmV4dCkpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3IFVybFNlZ21lbnQoY3Vyciwge30pKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChwYXRocywge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlTmV3U2VnbWVudENoaWxkcmVuKG91dGxldHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICBmb3JFYWNoKG91dGxldHMsIGZ1bmN0aW9uIChjb21tYW5kcywgb3V0bGV0KSB7XG4gICAgICAgIGlmIChjb21tYW5kcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5bb3V0bGV0XSA9IGNyZWF0ZU5ld1NlZ21lbnRHcm91cChuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSksIDAsIGNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShwYXJhbXMpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiByZXNba10gPSBcIlwiICsgdjsgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXBhcmUocGF0aCwgcGFyYW1zLCBzZWdtZW50KSB7XG4gICAgcmV0dXJuIHBhdGggPT0gc2VnbWVudC5wYXRoICYmIHNoYWxsb3dFcXVhbChwYXJhbXMsIHNlZ21lbnQucGFyYW1ldGVycyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBhY3RpdmF0ZVJvdXRlcyA9IGZ1bmN0aW9uIChyb290Q29udGV4dHMsIHJvdXRlUmV1c2VTdHJhdGVneSwgZm9yd2FyZEV2ZW50KSB7XG4gICAgcmV0dXJuIG1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICBuZXcgQWN0aXZhdGVSb3V0ZXMocm91dGVSZXVzZVN0cmF0ZWd5LCB0LnRhcmdldFJvdXRlclN0YXRlLCB0LmN1cnJlbnRSb3V0ZXJTdGF0ZSwgZm9yd2FyZEV2ZW50KVxuICAgICAgICAgICAgLmFjdGl2YXRlKHJvb3RDb250ZXh0cyk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xufTtcbnZhciBBY3RpdmF0ZVJvdXRlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBY3RpdmF0ZVJvdXRlcyhyb3V0ZVJldXNlU3RyYXRlZ3ksIGZ1dHVyZVN0YXRlLCBjdXJyU3RhdGUsIGZvcndhcmRFdmVudCkge1xuICAgICAgICB0aGlzLnJvdXRlUmV1c2VTdHJhdGVneSA9IHJvdXRlUmV1c2VTdHJhdGVneTtcbiAgICAgICAgdGhpcy5mdXR1cmVTdGF0ZSA9IGZ1dHVyZVN0YXRlO1xuICAgICAgICB0aGlzLmN1cnJTdGF0ZSA9IGN1cnJTdGF0ZTtcbiAgICAgICAgdGhpcy5mb3J3YXJkRXZlbnQgPSBmb3J3YXJkRXZlbnQ7XG4gICAgfVxuICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRDb250ZXh0cykge1xuICAgICAgICB2YXIgZnV0dXJlUm9vdCA9IHRoaXMuZnV0dXJlU3RhdGUuX3Jvb3Q7XG4gICAgICAgIHZhciBjdXJyUm9vdCA9IHRoaXMuY3VyclN0YXRlID8gdGhpcy5jdXJyU3RhdGUuX3Jvb3QgOiBudWxsO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICBhZHZhbmNlQWN0aXZhdGVkUm91dGUodGhpcy5mdXR1cmVTdGF0ZS5yb290KTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZVJvb3QsIGN1cnJSb290LCBwYXJlbnRDb250ZXh0cyk7XG4gICAgfTtcbiAgICAvLyBEZS1hY3RpdmF0ZSB0aGUgY2hpbGQgcm91dGUgdGhhdCBhcmUgbm90IHJlLXVzZWQgZm9yIHRoZSBmdXR1cmUgc3RhdGVcbiAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuZGVhY3RpdmF0ZUNoaWxkUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBjb250ZXh0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgIC8vIFJlY3Vyc2Ugb24gdGhlIHJvdXRlcyBhY3RpdmUgaW4gdGhlIGZ1dHVyZSBzdGF0ZSB0byBkZS1hY3RpdmF0ZSBkZWVwZXIgY2hpbGRyZW5cbiAgICAgICAgZnV0dXJlTm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChmdXR1cmVDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkT3V0bGV0TmFtZSA9IGZ1dHVyZUNoaWxkLnZhbHVlLm91dGxldDtcbiAgICAgICAgICAgIF90aGlzLmRlYWN0aXZhdGVSb3V0ZXMoZnV0dXJlQ2hpbGQsIGNoaWxkcmVuW2NoaWxkT3V0bGV0TmFtZV0sIGNvbnRleHRzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGlsZHJlbltjaGlsZE91dGxldE5hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGUtYWN0aXZhdGUgdGhlIHJvdXRlcyB0aGF0IHdpbGwgbm90IGJlIHJlLXVzZWRcbiAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4odiwgY29udGV4dHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5kZWFjdGl2YXRlUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgIHZhciBmdXR1cmUgPSBmdXR1cmVOb2RlLnZhbHVlO1xuICAgICAgICB2YXIgY3VyciA9IGN1cnJOb2RlID8gY3Vyck5vZGUudmFsdWUgOiBudWxsO1xuICAgICAgICBpZiAoZnV0dXJlID09PSBjdXJyKSB7XG4gICAgICAgICAgICAvLyBSZXVzaW5nIHRoZSBub2RlLCBjaGVjayB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIG5lZWQgdG8gYmUgZGUtYWN0aXZhdGVkXG4gICAgICAgICAgICBpZiAoZnV0dXJlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBub3JtYWwgcm91dGUsIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBhbiBvdXRsZXQuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0LmdldENvbnRleHQoZnV0dXJlLm91dGxldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjb21wb25lbnRsZXNzIHJvdXRlLCB3ZSByZWN1cnNlIGJ1dCBrZWVwIHRoZSBzYW1lIG91dGxldCBtYXAuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudENvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWFjdGl2YXRlIHRoZSBjdXJyZW50IHJvdXRlIHdoaWNoIHdpbGwgbm90IGJlIHJlLXVzZWRcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kuc2hvdWxkRGV0YWNoKHJvdXRlLnZhbHVlLnNuYXBzaG90KSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hBbmRTdG9yZVJvdXRlU3VidHJlZShyb3V0ZSwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlUm91dGVBbmRPdXRsZXQocm91dGUsIHBhcmVudENvbnRleHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRldGFjaEFuZFN0b3JlUm91dGVTdWJ0cmVlID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzLmdldENvbnRleHQocm91dGUudmFsdWUub3V0bGV0KTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vdXRsZXQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb250ZXh0Lm91dGxldC5kZXRhY2goKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IGNvbnRleHQuY2hpbGRyZW4ub25PdXRsZXREZWFjdGl2YXRlZCgpO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kuc3RvcmUocm91dGUudmFsdWUuc25hcHNob3QsIHsgY29tcG9uZW50UmVmOiBjb21wb25lbnRSZWYsIHJvdXRlOiByb3V0ZSwgY29udGV4dHM6IGNvbnRleHRzIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuZGVhY3RpdmF0ZVJvdXRlQW5kT3V0bGV0ID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzLmdldENvbnRleHQocm91dGUudmFsdWUub3V0bGV0KTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGVDaGlsZHJlbkFzTWFwKHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0c18xID0gcm91dGUudmFsdWUuY29tcG9uZW50ID8gY29udGV4dC5jaGlsZHJlbiA6IHBhcmVudENvbnRleHRzO1xuICAgICAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIF90aGlzLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHYsIGNvbnRleHRzXzEpOyB9KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm91dGxldCkge1xuICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGNvbnRleHQub3V0bGV0LmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBjb250ZXh0cyBmb3IgYWxsIHRoZSBvdXRsZXRzIHRoYXQgd2VyZSBpbiB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgY29udGV4dC5jaGlsZHJlbi5vbk91dGxldERlYWN0aXZhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5hY3RpdmF0ZUNoaWxkUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBjb250ZXh0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgIGZ1dHVyZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVSb3V0ZXMoYywgY2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdLCBjb250ZXh0cyk7XG4gICAgICAgICAgICBfdGhpcy5mb3J3YXJkRXZlbnQobmV3IEFjdGl2YXRpb25FbmQoYy52YWx1ZS5zbmFwc2hvdCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZ1dHVyZU5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRFdmVudChuZXcgQ2hpbGRBY3RpdmF0aW9uRW5kKGZ1dHVyZU5vZGUudmFsdWUuc25hcHNob3QpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmFjdGl2YXRlUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKGZ1dHVyZSk7XG4gICAgICAgIC8vIHJldXNpbmcgdGhlIG5vZGVcbiAgICAgICAgaWYgKGZ1dHVyZSA9PT0gY3Vycikge1xuICAgICAgICAgICAgaWYgKGZ1dHVyZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbm9ybWFsIHJvdXRlLCB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW4gb3V0bGV0LlxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50Q29udGV4dHMuZ2V0T3JDcmVhdGVDb250ZXh0KGZ1dHVyZS5vdXRsZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZ1dHVyZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbm9ybWFsIHJvdXRlLCB3ZSBuZWVkIHRvIHBsYWNlIHRoZSBjb21wb25lbnQgaW50byB0aGUgb3V0bGV0IGFuZCByZWN1cnNlLlxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50Q29udGV4dHMuZ2V0T3JDcmVhdGVDb250ZXh0KGZ1dHVyZS5vdXRsZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlUmV1c2VTdHJhdGVneS5zaG91bGRBdHRhY2goZnV0dXJlLnNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVkID0gdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kucmV0cmlldmUoZnV0dXJlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kuc3RvcmUoZnV0dXJlLnNuYXBzaG90LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGlsZHJlbi5vbk91dGxldFJlQXR0YWNoZWQoc3RvcmVkLmNvbnRleHRzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hSZWYgPSBzdG9yZWQuY29tcG9uZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdXRlID0gc3RvcmVkLnJvdXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vdXRsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCByaWdodCBhd2F5IHdoZW4gdGhlIG91dGxldCBoYXMgYWxyZWFkeSBiZWVuIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGF0dGFjaCBmcm9tIGBSb3V0ZXJPdXRsZXQubmdPbkluaXRgIHdoZW4gaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldC5hdHRhY2goc3RvcmVkLmNvbXBvbmVudFJlZiwgc3RvcmVkLnJvdXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQWN0aXZhdGVkUm91dGVOb2RlQW5kSXRzQ2hpbGRyZW4oc3RvcmVkLnJvdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBwYXJlbnRMb2FkZWRDb25maWcoZnV0dXJlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNtcEZhY3RvcnlSZXNvbHZlciA9IGNvbmZpZyA/IGNvbmZpZy5tb2R1bGUuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hSZWYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdXRlID0gZnV0dXJlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc29sdmVyID0gY21wRmFjdG9yeVJlc29sdmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vdXRsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2YXRlIHRoZSBvdXRsZXQgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IGFjdGl2YXRlZCBmcm9tIGl0cyBgbmdPbkluaXRgIHdoZW4gaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldC5hY3RpdmF0ZVdpdGgoZnV0dXJlLCBjbXBGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBudWxsLCBjb250ZXh0LmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBudWxsLCBwYXJlbnRDb250ZXh0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0ZVJvdXRlcztcbn0oKSk7XG5mdW5jdGlvbiBhZHZhbmNlQWN0aXZhdGVkUm91dGVOb2RlQW5kSXRzQ2hpbGRyZW4obm9kZSkge1xuICAgIGFkdmFuY2VBY3RpdmF0ZWRSb3V0ZShub2RlLnZhbHVlKTtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goYWR2YW5jZUFjdGl2YXRlZFJvdXRlTm9kZUFuZEl0c0NoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHBhcmVudExvYWRlZENvbmZpZyhzbmFwc2hvdCkge1xuICAgIGZvciAodmFyIHMgPSBzbmFwc2hvdC5wYXJlbnQ7IHM7IHMgPSBzLnBhcmVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBzLnJvdXRlQ29uZmlnO1xuICAgICAgICBpZiAocm91dGUgJiYgcm91dGUuX2xvYWRlZENvbmZpZylcbiAgICAgICAgICAgIHJldHVybiByb3V0ZS5fbG9hZGVkQ29uZmlnO1xuICAgICAgICBpZiAocm91dGUgJiYgcm91dGUuY29tcG9uZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTm9NYXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb01hdGNoKHNlZ21lbnRHcm91cCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRHcm91cCA9IHNlZ21lbnRHcm91cCB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gTm9NYXRjaDtcbn0oKSk7XG52YXIgQWJzb2x1dGVSZWRpcmVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnNvbHV0ZVJlZGlyZWN0KHVybFRyZWUpIHtcbiAgICAgICAgdGhpcy51cmxUcmVlID0gdXJsVHJlZTtcbiAgICB9XG4gICAgcmV0dXJuIEFic29sdXRlUmVkaXJlY3Q7XG59KCkpO1xuZnVuY3Rpb24gbm9NYXRjaChzZWdtZW50R3JvdXApIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLmVycm9yKG5ldyBOb01hdGNoKHNlZ21lbnRHcm91cCkpOyB9KTtcbn1cbmZ1bmN0aW9uIGFic29sdXRlUmVkaXJlY3QobmV3VHJlZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IobmV3IEFic29sdXRlUmVkaXJlY3QobmV3VHJlZSkpOyB9KTtcbn1cbmZ1bmN0aW9uIG5hbWVkT3V0bGV0c1JlZGlyZWN0KHJlZGlyZWN0VG8pIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLmVycm9yKG5ldyBFcnJvcihcIk9ubHkgYWJzb2x1dGUgcmVkaXJlY3RzIGNhbiBoYXZlIG5hbWVkIG91dGxldHMuIHJlZGlyZWN0VG86ICdcIiArIHJlZGlyZWN0VG8gKyBcIidcIikpOyB9KTtcbn1cbmZ1bmN0aW9uIGNhbkxvYWRGYWlscyhyb3V0ZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IobmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yKFwiQ2Fubm90IGxvYWQgY2hpbGRyZW4gYmVjYXVzZSB0aGUgZ3VhcmQgb2YgdGhlIHJvdXRlIFxcXCJwYXRoOiAnXCIgKyByb3V0ZS5wYXRoICsgXCInXFxcIiByZXR1cm5lZCBmYWxzZVwiKSk7IH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBgVXJsVHJlZWAgd2l0aCB0aGUgcmVkaXJlY3Rpb24gYXBwbGllZC5cbiAqXG4gKiBMYXp5IG1vZHVsZXMgYXJlIGxvYWRlZCBhbG9uZyB0aGUgd2F5LlxuICovXG5mdW5jdGlvbiBhcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB1cmxUcmVlLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IEFwcGx5UmVkaXJlY3RzKG1vZHVsZUluamVjdG9yLCBjb25maWdMb2FkZXIsIHVybFNlcmlhbGl6ZXIsIHVybFRyZWUsIGNvbmZpZykuYXBwbHkoKTtcbn1cbnZhciBBcHBseVJlZGlyZWN0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB1cmxUcmVlLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWdMb2FkZXIgPSBjb25maWdMb2FkZXI7XG4gICAgICAgIHRoaXMudXJsU2VyaWFsaXplciA9IHVybFNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMudXJsVHJlZSA9IHVybFRyZWU7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFsbG93UmVkaXJlY3RzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZ01vZHVsZSA9IG1vZHVsZUluamVjdG9yLmdldChOZ01vZHVsZVJlZik7XG4gICAgfVxuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cGFuZGVkJCA9IHRoaXMuZXhwYW5kU2VnbWVudEdyb3VwKHRoaXMubmdNb2R1bGUsIHRoaXMuY29uZmlnLCB0aGlzLnVybFRyZWUucm9vdCwgUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICB2YXIgdXJsVHJlZXMkID0gZXhwYW5kZWQkLnBpcGUobWFwKGZ1bmN0aW9uIChyb290U2VnbWVudEdyb3VwKSB7IHJldHVybiBfdGhpcy5jcmVhdGVVcmxUcmVlKHJvb3RTZWdtZW50R3JvdXAsIF90aGlzLnVybFRyZWUucXVlcnlQYXJhbXMsIF90aGlzLnVybFRyZWUuZnJhZ21lbnQpOyB9KSk7XG4gICAgICAgIHJldHVybiB1cmxUcmVlcyQucGlwZShjYXRjaEVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFic29sdXRlUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBhbiBhYnNvbHV0ZSByZWRpcmVjdCB3ZSBkbyBub3QgYXBwbHkgYW55IG1vcmUgcmVkaXJlY3RzIVxuICAgICAgICAgICAgICAgIF90aGlzLmFsbG93UmVkaXJlY3RzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gbWF0Y2hpbmcsIHNvIHdlIGNhbiBmZXRjaCBhbGwgbGF6eS1sb2FkZWQgbW9kdWxlc1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYXRjaChlLnVybFRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMubm9NYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cGFuZGVkJCA9IHRoaXMuZXhwYW5kU2VnbWVudEdyb3VwKHRoaXMubmdNb2R1bGUsIHRoaXMuY29uZmlnLCB0cmVlLnJvb3QsIFBSSU1BUllfT1VUTEVUKTtcbiAgICAgICAgdmFyIG1hcHBlZCQgPSBleHBhbmRlZCQucGlwZShtYXAoZnVuY3Rpb24gKHJvb3RTZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVVcmxUcmVlKHJvb3RTZWdtZW50R3JvdXAsIHRyZWUucXVlcnlQYXJhbXMsIHRyZWUuZnJhZ21lbnQpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQkLnBpcGUoY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMubm9NYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm5vTWF0Y2hFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJDYW5ub3QgbWF0Y2ggYW55IHJvdXRlcy4gVVJMIFNlZ21lbnQ6ICdcIiArIGUuc2VnbWVudEdyb3VwICsgXCInXCIpO1xuICAgIH07XG4gICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVVybFRyZWUgPSBmdW5jdGlvbiAocm9vdENhbmRpZGF0ZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q2FuZGlkYXRlLnNlZ21lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgbmV3IFVybFNlZ21lbnRHcm91cChbXSwgKF9hID0ge30sIF9hW1BSSU1BUllfT1VUTEVUXSA9IHJvb3RDYW5kaWRhdGUsIF9hKSkgOlxuICAgICAgICAgICAgcm9vdENhbmRpZGF0ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKHJvb3QsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCk7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kU2VnbWVudEdyb3VwID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZXMsIHNlZ21lbnRHcm91cCwgb3V0bGV0KSB7XG4gICAgICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRDaGlsZHJlbihuZ01vZHVsZSwgcm91dGVzLCBzZWdtZW50R3JvdXApXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKGZ1bmN0aW9uIChjaGlsZHJlbikgeyByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChbXSwgY2hpbGRyZW4pOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kU2VnbWVudChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHNlZ21lbnRHcm91cC5zZWdtZW50cywgb3V0bGV0LCB0cnVlKTtcbiAgICB9O1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGV4cGFuZCBzZWdtZW50IGdyb3VwcyBmb3IgYWxsIHRoZSBjaGlsZCBvdXRsZXRzXG4gICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZENoaWxkcmVuID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZXMsIHNlZ21lbnRHcm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gd2FpdEZvck1hcChzZWdtZW50R3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZE91dGxldCwgY2hpbGQpIHsgcmV0dXJuIF90aGlzLmV4cGFuZFNlZ21lbnRHcm91cChuZ01vZHVsZSwgcm91dGVzLCBjaGlsZCwgY2hpbGRPdXRsZXQpOyB9KTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRTZWdtZW50ID0gZnVuY3Rpb24gKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgc2VnbWVudHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9mLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQocm91dGVzKSkucGlwZShtYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCQgPSBfdGhpcy5leHBhbmRTZWdtZW50QWdhaW5zdFJvdXRlKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgciwgc2VnbWVudHMsIG91dGxldCwgYWxsb3dSZWRpcmVjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkJC5waXBlKGNhdGNoRXJyb3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5vTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhpKTogdGhpcyByZXR1cm4gdHlwZSBkb2Vzbid0IG1hdGNoIHRoZSBkZWNsYXJlZCBPYnNlcnZhYmxlPFVybFNlZ21lbnRHcm91cD4gLVxuICAgICAgICAgICAgICAgICAgICAvLyB0YWxrIHRvIEphc29uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSksIGNvbmNhdEFsbCgpLCBmaXJzdChmdW5jdGlvbiAocykgeyByZXR1cm4gISFzOyB9KSwgY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSwgXykge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFbXB0eUVycm9yIHx8IGUubmFtZSA9PT0gJ0VtcHR5RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm5vTGVmdG92ZXJzSW5Vcmwoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YobmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2goc2VnbWVudEdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5ub0xlZnRvdmVyc0luVXJsID0gZnVuY3Rpb24gKHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID09PSAwICYmICFzZWdtZW50R3JvdXAuY2hpbGRyZW5bb3V0bGV0XTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRTZWdtZW50QWdhaW5zdFJvdXRlID0gZnVuY3Rpb24gKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgcm91dGUsIHBhdGhzLCBvdXRsZXQsIGFsbG93UmVkaXJlY3RzKSB7XG4gICAgICAgIGlmIChnZXRPdXRsZXQocm91dGUpICE9PSBvdXRsZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBub01hdGNoKHNlZ21lbnRHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hTZWdtZW50QWdhaW5zdFJvdXRlKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93UmVkaXJlY3RzICYmIHRoaXMuYWxsb3dSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNlZ21lbnRBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0KG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgcm91dGUsIHBhdGhzLCBvdXRsZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub01hdGNoKHNlZ21lbnRHcm91cCk7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kU2VnbWVudEFnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByb3V0ZSwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJyoqJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kV2lsZENhcmRXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChuZ01vZHVsZSwgcm91dGVzLCByb3V0ZSwgb3V0bGV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRSZWd1bGFyU2VnbWVudEFnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByb3V0ZSwgc2VnbWVudHMsIG91dGxldCk7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kV2lsZENhcmRXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdCA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGVzLCByb3V0ZSwgb3V0bGV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdUcmVlID0gdGhpcy5hcHBseVJlZGlyZWN0Q29tbWFuZHMoW10sIHJvdXRlLnJlZGlyZWN0VG8sIHt9KTtcbiAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzb2x1dGVSZWRpcmVjdChuZXdUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lcmFsaXplU2VnbWVudHMocm91dGUsIG5ld1RyZWUpLnBpcGUobWVyZ2VNYXAoZnVuY3Rpb24gKG5ld1NlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVXJsU2VnbWVudEdyb3VwKG5ld1NlZ21lbnRzLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZXhwYW5kU2VnbWVudChuZ01vZHVsZSwgZ3JvdXAsIHJvdXRlcywgbmV3U2VnbWVudHMsIG91dGxldCwgZmFsc2UpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kUmVndWxhclNlZ21lbnRBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0ID0gZnVuY3Rpb24gKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgcm91dGUsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gbWF0Y2goc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpLCBtYXRjaGVkID0gX2EubWF0Y2hlZCwgY29uc3VtZWRTZWdtZW50cyA9IF9hLmNvbnN1bWVkU2VnbWVudHMsIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHMgPSBfYS5wb3NpdGlvbmFsUGFyYW1TZWdtZW50cztcbiAgICAgICAgaWYgKCFtYXRjaGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2goc2VnbWVudEdyb3VwKTtcbiAgICAgICAgdmFyIG5ld1RyZWUgPSB0aGlzLmFwcGx5UmVkaXJlY3RDb21tYW5kcyhjb25zdW1lZFNlZ21lbnRzLCByb3V0ZS5yZWRpcmVjdFRvLCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50cyk7XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFic29sdXRlUmVkaXJlY3QobmV3VHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXJhbGl6ZVNlZ21lbnRzKHJvdXRlLCBuZXdUcmVlKS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChuZXdTZWdtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4cGFuZFNlZ21lbnQobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCBuZXdTZWdtZW50cy5jb25jYXQoc2VnbWVudHMuc2xpY2UobGFzdENoaWxkKSksIG91dGxldCwgZmFsc2UpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUubWF0Y2hTZWdtZW50QWdhaW5zdFJvdXRlID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByYXdTZWdtZW50R3JvdXAsIHJvdXRlLCBzZWdtZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJyoqJykge1xuICAgICAgICAgICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ0xvYWRlci5sb2FkKG5nTW9kdWxlLmluamVjdG9yLCByb3V0ZSlcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUobWFwKGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUuX2xvYWRlZENvbmZpZyA9IGNmZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudHMsIHt9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2YobmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50cywge30pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBtYXRjaChyYXdTZWdtZW50R3JvdXAsIHJvdXRlLCBzZWdtZW50cyksIG1hdGNoZWQgPSBfYS5tYXRjaGVkLCBjb25zdW1lZFNlZ21lbnRzID0gX2EuY29uc3VtZWRTZWdtZW50cywgbGFzdENoaWxkID0gX2EubGFzdENoaWxkO1xuICAgICAgICBpZiAoIW1hdGNoZWQpXG4gICAgICAgICAgICByZXR1cm4gbm9NYXRjaChyYXdTZWdtZW50R3JvdXApO1xuICAgICAgICB2YXIgcmF3U2xpY2VkU2VnbWVudHMgPSBzZWdtZW50cy5zbGljZShsYXN0Q2hpbGQpO1xuICAgICAgICB2YXIgY2hpbGRDb25maWckID0gdGhpcy5nZXRDaGlsZENvbmZpZyhuZ01vZHVsZSwgcm91dGUsIHNlZ21lbnRzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkQ29uZmlnJC5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChyb3V0ZXJDb25maWcpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE1vZHVsZSA9IHJvdXRlckNvbmZpZy5tb2R1bGU7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb25maWcgPSByb3V0ZXJDb25maWcucm91dGVzO1xuICAgICAgICAgICAgdmFyIF9hID0gc3BsaXQocmF3U2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCByYXdTbGljZWRTZWdtZW50cywgY2hpbGRDb25maWcpLCBzZWdtZW50R3JvdXAgPSBfYS5zZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzID0gX2Euc2xpY2VkU2VnbWVudHM7XG4gICAgICAgICAgICBpZiAoc2xpY2VkU2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkJF8xID0gX3RoaXMuZXhwYW5kQ2hpbGRyZW4oY2hpbGRNb2R1bGUsIGNoaWxkQ29uZmlnLCBzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCRfMS5waXBlKG1hcChmdW5jdGlvbiAoY2hpbGRyZW4pIHsgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cywgY2hpbGRyZW4pOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRDb25maWcubGVuZ3RoID09PSAwICYmIHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZihuZXcgVXJsU2VnbWVudEdyb3VwKGNvbnN1bWVkU2VnbWVudHMsIHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwYW5kZWQkID0gX3RoaXMuZXhwYW5kU2VnbWVudChjaGlsZE1vZHVsZSwgc2VnbWVudEdyb3VwLCBjaGlsZENvbmZpZywgc2xpY2VkU2VnbWVudHMsIFBSSU1BUllfT1VUTEVULCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCQucGlwZShtYXAoZnVuY3Rpb24gKGNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cy5jb25jYXQoY3Muc2VnbWVudHMpLCBjcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5nZXRDaGlsZENvbmZpZyA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGUsIHNlZ21lbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGJlbG9uZyB0byB0aGUgc2FtZSBtb2R1bGVcbiAgICAgICAgICAgIHJldHVybiBvZihuZXcgTG9hZGVkUm91dGVyQ29uZmlnKHJvdXRlLmNoaWxkcmVuLCBuZ01vZHVsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIGxhenkgY2hpbGRyZW4gYmVsb25nIHRvIHRoZSBsb2FkZWQgbW9kdWxlXG4gICAgICAgICAgICBpZiAocm91dGUuX2xvYWRlZENvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHJvdXRlLl9sb2FkZWRDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bkNhbkxvYWRHdWFyZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUsIHNlZ21lbnRzKVxuICAgICAgICAgICAgICAgIC5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChzaG91bGRMb2FkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbmZpZ0xvYWRlci5sb2FkKG5nTW9kdWxlLmluamVjdG9yLCByb3V0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKG1hcChmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZS5fbG9hZGVkQ29uZmlnID0gY2ZnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNmZztcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuTG9hZEZhaWxzKHJvdXRlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2YobmV3IExvYWRlZFJvdXRlckNvbmZpZyhbXSwgbmdNb2R1bGUpKTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5saW5lcmFsaXplU2VnbWVudHMgPSBmdW5jdGlvbiAocm91dGUsIHVybFRyZWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICB2YXIgYyA9IHVybFRyZWUucm9vdDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoYy5zZWdtZW50cyk7XG4gICAgICAgICAgICBpZiAoYy5udW1iZXJPZkNoaWxkcmVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5udW1iZXJPZkNoaWxkcmVuID4gMSB8fCAhYy5jaGlsZHJlbltQUklNQVJZX09VVExFVF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZWRPdXRsZXRzUmVkaXJlY3Qocm91dGUucmVkaXJlY3RUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gYy5jaGlsZHJlbltQUklNQVJZX09VVExFVF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5hcHBseVJlZGlyZWN0Q29tbWFuZHMgPSBmdW5jdGlvbiAoc2VnbWVudHMsIHJlZGlyZWN0VG8sIHBvc1BhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVJlZGlyZWN0Q3JlYXRyZVVybFRyZWUocmVkaXJlY3RUbywgdGhpcy51cmxTZXJpYWxpemVyLnBhcnNlKHJlZGlyZWN0VG8pLCBzZWdtZW50cywgcG9zUGFyYW1zKTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5hcHBseVJlZGlyZWN0Q3JlYXRyZVVybFRyZWUgPSBmdW5jdGlvbiAocmVkaXJlY3RUbywgdXJsVHJlZSwgc2VnbWVudHMsIHBvc1BhcmFtcykge1xuICAgICAgICB2YXIgbmV3Um9vdCA9IHRoaXMuY3JlYXRlU2VnbWVudEdyb3VwKHJlZGlyZWN0VG8sIHVybFRyZWUucm9vdCwgc2VnbWVudHMsIHBvc1BhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgVXJsVHJlZShuZXdSb290LCB0aGlzLmNyZWF0ZVF1ZXJ5UGFyYW1zKHVybFRyZWUucXVlcnlQYXJhbXMsIHRoaXMudXJsVHJlZS5xdWVyeVBhcmFtcyksIHVybFRyZWUuZnJhZ21lbnQpO1xuICAgIH07XG4gICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKHJlZGlyZWN0VG9QYXJhbXMsIGFjdHVhbFBhcmFtcykge1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIGZvckVhY2gocmVkaXJlY3RUb1BhcmFtcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIHZhciBjb3B5U291cmNlVmFsdWUgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5zdGFydHNXaXRoKCc6Jyk7XG4gICAgICAgICAgICBpZiAoY29weVNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5hbWUgPSB2LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICByZXNba10gPSBhY3R1YWxQYXJhbXNbc291cmNlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5jcmVhdGVTZWdtZW50R3JvdXAgPSBmdW5jdGlvbiAocmVkaXJlY3RUbywgZ3JvdXAsIHNlZ21lbnRzLCBwb3NQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZWRTZWdtZW50cyA9IHRoaXMuY3JlYXRlU2VnbWVudHMocmVkaXJlY3RUbywgZ3JvdXAuc2VnbWVudHMsIHNlZ21lbnRzLCBwb3NQYXJhbXMpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgZm9yRWFjaChncm91cC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBuYW1lKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IF90aGlzLmNyZWF0ZVNlZ21lbnRHcm91cChyZWRpcmVjdFRvLCBjaGlsZCwgc2VnbWVudHMsIHBvc1BhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cCh1cGRhdGVkU2VnbWVudHMsIGNoaWxkcmVuKTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5jcmVhdGVTZWdtZW50cyA9IGZ1bmN0aW9uIChyZWRpcmVjdFRvLCByZWRpcmVjdFRvU2VnbWVudHMsIGFjdHVhbFNlZ21lbnRzLCBwb3NQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0VG9TZWdtZW50cy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucGF0aC5zdGFydHNXaXRoKCc6JykgPyBfdGhpcy5maW5kUG9zUGFyYW0ocmVkaXJlY3RUbywgcywgcG9zUGFyYW1zKSA6XG4gICAgICAgICAgICBfdGhpcy5maW5kT3JSZXR1cm4ocywgYWN0dWFsU2VnbWVudHMpOyB9KTtcbiAgICB9O1xuICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5maW5kUG9zUGFyYW0gPSBmdW5jdGlvbiAocmVkaXJlY3RUbywgcmVkaXJlY3RUb1VybFNlZ21lbnQsIHBvc1BhcmFtcykge1xuICAgICAgICB2YXIgcG9zID0gcG9zUGFyYW1zW3JlZGlyZWN0VG9VcmxTZWdtZW50LnBhdGguc3Vic3RyaW5nKDEpXTtcbiAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVkaXJlY3QgdG8gJ1wiICsgcmVkaXJlY3RUbyArIFwiJy4gQ2Fubm90IGZpbmQgJ1wiICsgcmVkaXJlY3RUb1VybFNlZ21lbnQucGF0aCArIFwiJy5cIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZmluZE9yUmV0dXJuID0gZnVuY3Rpb24gKHJlZGlyZWN0VG9VcmxTZWdtZW50LCBhY3R1YWxTZWdtZW50cykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhY3R1YWxTZWdtZW50c18xID0gX192YWx1ZXMoYWN0dWFsU2VnbWVudHMpLCBhY3R1YWxTZWdtZW50c18xXzEgPSBhY3R1YWxTZWdtZW50c18xLm5leHQoKTsgIWFjdHVhbFNlZ21lbnRzXzFfMS5kb25lOyBhY3R1YWxTZWdtZW50c18xXzEgPSBhY3R1YWxTZWdtZW50c18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gYWN0dWFsU2VnbWVudHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzLnBhdGggPT09IHJlZGlyZWN0VG9VcmxTZWdtZW50LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsU2VnbWVudHMuc3BsaWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdHVhbFNlZ21lbnRzXzFfMSAmJiAhYWN0dWFsU2VnbWVudHNfMV8xLmRvbmUgJiYgKF9hID0gYWN0dWFsU2VnbWVudHNfMS5yZXR1cm4pKSBfYS5jYWxsKGFjdHVhbFNlZ21lbnRzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWRpcmVjdFRvVXJsU2VnbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBBcHBseVJlZGlyZWN0cztcbn0oKSk7XG5mdW5jdGlvbiBydW5DYW5Mb2FkR3VhcmQobW9kdWxlSW5qZWN0b3IsIHJvdXRlLCBzZWdtZW50cykge1xuICAgIHZhciBjYW5Mb2FkID0gcm91dGUuY2FuTG9hZDtcbiAgICBpZiAoIWNhbkxvYWQgfHwgY2FuTG9hZC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBvZih0cnVlKTtcbiAgICB2YXIgb2JzID0gZnJvbShjYW5Mb2FkKS5waXBlKG1hcChmdW5jdGlvbiAoaW5qZWN0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIGd1YXJkID0gbW9kdWxlSW5qZWN0b3IuZ2V0KGluamVjdGlvblRva2VuKTtcbiAgICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZC5jYW5Mb2FkID8gZ3VhcmQuY2FuTG9hZChyb3V0ZSwgc2VnbWVudHMpIDogZ3VhcmQocm91dGUsIHNlZ21lbnRzKSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBhbmRPYnNlcnZhYmxlcyhvYnMpO1xufVxuZnVuY3Rpb24gbWF0Y2goc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gJycpIHtcbiAgICAgICAgaWYgKChyb3V0ZS5wYXRoTWF0Y2ggPT09ICdmdWxsJykgJiYgKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHNlZ21lbnRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaGVkOiBmYWxzZSwgY29uc3VtZWRTZWdtZW50czogW10sIGxhc3RDaGlsZDogMCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHM6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWF0Y2hlZDogdHJ1ZSwgY29uc3VtZWRTZWdtZW50czogW10sIGxhc3RDaGlsZDogMCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHM6IHt9IH07XG4gICAgfVxuICAgIHZhciBtYXRjaGVyID0gcm91dGUubWF0Y2hlciB8fCBkZWZhdWx0VXJsTWF0Y2hlcjtcbiAgICB2YXIgcmVzID0gbWF0Y2hlcihzZWdtZW50cywgc2VnbWVudEdyb3VwLCByb3V0ZSk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29uc3VtZWRTZWdtZW50czogW10sXG4gICAgICAgICAgICBsYXN0Q2hpbGQ6IDAsXG4gICAgICAgICAgICBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZWQ6IHRydWUsXG4gICAgICAgIGNvbnN1bWVkU2VnbWVudHM6IHJlcy5jb25zdW1lZCxcbiAgICAgICAgbGFzdENoaWxkOiByZXMuY29uc3VtZWQubGVuZ3RoLFxuICAgICAgICBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czogcmVzLnBvc1BhcmFtcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3BsaXQoc2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSB7XG4gICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgY29udGFpbnNFbXB0eVBhdGhSZWRpcmVjdHNXaXRoTmFtZWRPdXRsZXRzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKGNvbnN1bWVkU2VnbWVudHMsIGNyZWF0ZUNoaWxkcmVuRm9yRW1wdHlTZWdtZW50cyhjb25maWcsIG5ldyBVcmxTZWdtZW50R3JvdXAoc2xpY2VkU2VnbWVudHMsIHNlZ21lbnRHcm91cC5jaGlsZHJlbikpKTtcbiAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBtZXJnZVRyaXZpYWxDaGlsZHJlbihzKSwgc2xpY2VkU2VnbWVudHM6IFtdIH07XG4gICAgfVxuICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgY29udGFpbnNFbXB0eVBhdGhSZWRpcmVjdHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSkge1xuICAgICAgICB2YXIgcyA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLCBhZGRFbXB0eVNlZ21lbnRzVG9DaGlsZHJlbklmTmVlZGVkKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZywgc2VnbWVudEdyb3VwLmNoaWxkcmVuKSk7XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogbWVyZ2VUcml2aWFsQ2hpbGRyZW4ocyksIHNsaWNlZFNlZ21lbnRzOiBzbGljZWRTZWdtZW50cyB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzZWdtZW50R3JvdXA6IHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG59XG5mdW5jdGlvbiBtZXJnZVRyaXZpYWxDaGlsZHJlbihzKSB7XG4gICAgaWYgKHMubnVtYmVyT2ZDaGlsZHJlbiA9PT0gMSAmJiBzLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSkge1xuICAgICAgICB2YXIgYyA9IHMuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdO1xuICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzLnNlZ21lbnRzLmNvbmNhdChjLnNlZ21lbnRzKSwgYy5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gYWRkRW1wdHlTZWdtZW50c1RvQ2hpbGRyZW5JZk5lZWRlZChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByb3V0ZXMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHJvdXRlc18xID0gX192YWx1ZXMocm91dGVzKSwgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKTsgIXJvdXRlc18xXzEuZG9uZTsgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHlQYXRoUmVkaXJlY3Qoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcikgJiYgIWNoaWxkcmVuW2dldE91dGxldChyKV0pIHtcbiAgICAgICAgICAgICAgICByZXNbZ2V0T3V0bGV0KHIpXSA9IG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJvdXRlc18xXzEgJiYgIXJvdXRlc18xXzEuZG9uZSAmJiAoX2EgPSByb3V0ZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHJvdXRlc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgY2hpbGRyZW4sIHJlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkZvckVtcHR5U2VnbWVudHMocm91dGVzLCBwcmltYXJ5U2VnbWVudEdyb3VwKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBwcmltYXJ5U2VnbWVudEdyb3VwO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHJvdXRlc18yID0gX192YWx1ZXMocm91dGVzKSwgcm91dGVzXzJfMSA9IHJvdXRlc18yLm5leHQoKTsgIXJvdXRlc18yXzEuZG9uZTsgcm91dGVzXzJfMSA9IHJvdXRlc18yLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHIucGF0aCA9PT0gJycgJiYgZ2V0T3V0bGV0KHIpICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgIHJlc1tnZXRPdXRsZXQocildID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm91dGVzXzJfMSAmJiAhcm91dGVzXzJfMS5kb25lICYmIChfYSA9IHJvdXRlc18yLnJldHVybikpIF9hLmNhbGwocm91dGVzXzIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zRW1wdHlQYXRoUmVkaXJlY3RzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICByZXR1cm4gcm91dGVzLnNvbWUoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGlzRW1wdHlQYXRoUmVkaXJlY3Qoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgcikgJiYgZ2V0T3V0bGV0KHIpICE9PSBQUklNQVJZX09VVExFVDsgfSk7XG59XG5mdW5jdGlvbiBjb250YWluc0VtcHR5UGF0aFJlZGlyZWN0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICByZXR1cm4gcm91dGVzLnNvbWUoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGlzRW1wdHlQYXRoUmVkaXJlY3Qoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgcik7IH0pO1xufVxuZnVuY3Rpb24gaXNFbXB0eVBhdGhSZWRpcmVjdChzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByKSB7XG4gICAgaWYgKChzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSB8fCBzZWdtZW50cy5sZW5ndGggPiAwKSAmJiByLnBhdGhNYXRjaCA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHIucGF0aCA9PT0gJycgJiYgci5yZWRpcmVjdFRvICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRPdXRsZXQocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUub3V0bGV0IHx8IFBSSU1BUllfT1VUTEVUO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBhcHBseVJlZGlyZWN0cyQxKG1vZHVsZUluamVjdG9yLCBjb25maWdMb2FkZXIsIHVybFNlcmlhbGl6ZXIsIGNvbmZpZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucGlwZShzd2l0Y2hNYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGFwcGx5UmVkaXJlY3RzKG1vZHVsZUluamVjdG9yLCBjb25maWdMb2FkZXIsIHVybFNlcmlhbGl6ZXIsIHQuZXh0cmFjdGVkVXJsLCBjb25maWcpXG4gICAgICAgICAgICAucGlwZShtYXAoZnVuY3Rpb24gKHVybEFmdGVyUmVkaXJlY3RzKSB7IHJldHVybiAoX19hc3NpZ24oe30sIHQsIHsgdXJsQWZ0ZXJSZWRpcmVjdHM6IHVybEFmdGVyUmVkaXJlY3RzIH0pKTsgfSkpOyB9KSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENhbkFjdGl2YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbkFjdGl2YXRlKHBhdGgpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBDYW5BY3RpdmF0ZTtcbn0oKSk7XG52YXIgQ2FuRGVhY3RpdmF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgcm91dGUpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIENhbkRlYWN0aXZhdGU7XG59KCkpO1xuZnVuY3Rpb24gZ2V0QWxsUm91dGVHdWFyZHMoZnV0dXJlLCBjdXJyLCBwYXJlbnRDb250ZXh0cykge1xuICAgIHZhciBmdXR1cmVSb290ID0gZnV0dXJlLl9yb290O1xuICAgIHZhciBjdXJyUm9vdCA9IGN1cnIgPyBjdXJyLl9yb290IDogbnVsbDtcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50Q29udGV4dHMsIFtmdXR1cmVSb290LnZhbHVlXSk7XG59XG5mdW5jdGlvbiBnZXRDYW5BY3RpdmF0ZUNoaWxkKHApIHtcbiAgICB2YXIgY2FuQWN0aXZhdGVDaGlsZCA9IHAucm91dGVDb25maWcgPyBwLnJvdXRlQ29uZmlnLmNhbkFjdGl2YXRlQ2hpbGQgOiBudWxsO1xuICAgIGlmICghY2FuQWN0aXZhdGVDaGlsZCB8fCBjYW5BY3RpdmF0ZUNoaWxkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHsgbm9kZTogcCwgZ3VhcmRzOiBjYW5BY3RpdmF0ZUNoaWxkIH07XG59XG5mdW5jdGlvbiBnZXRUb2tlbih0b2tlbiwgc25hcHNob3QsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgdmFyIGNvbmZpZyA9IGdldENsb3Nlc3RMb2FkZWRDb25maWcoc25hcHNob3QpO1xuICAgIHZhciBpbmplY3RvciA9IGNvbmZpZyA/IGNvbmZpZy5tb2R1bGUuaW5qZWN0b3IgOiBtb2R1bGVJbmplY3RvcjtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KHRva2VuKTtcbn1cbmZ1bmN0aW9uIGdldENsb3Nlc3RMb2FkZWRDb25maWcoc25hcHNob3QpIHtcbiAgICBpZiAoIXNuYXBzaG90KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKHZhciBzID0gc25hcHNob3QucGFyZW50OyBzOyBzID0gcy5wYXJlbnQpIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcy5yb3V0ZUNvbmZpZztcbiAgICAgICAgaWYgKHJvdXRlICYmIHJvdXRlLl9sb2FkZWRDb25maWcpXG4gICAgICAgICAgICByZXR1cm4gcm91dGUuX2xvYWRlZENvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBjb250ZXh0cywgZnV0dXJlUGF0aCwgY2hlY2tzKSB7XG4gICAgaWYgKGNoZWNrcyA9PT0gdm9pZCAwKSB7IGNoZWNrcyA9IHtcbiAgICAgICAgY2FuRGVhY3RpdmF0ZUNoZWNrczogW10sXG4gICAgICAgIGNhbkFjdGl2YXRlQ2hlY2tzOiBbXVxuICAgIH07IH1cbiAgICB2YXIgcHJldkNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAoY3Vyck5vZGUpO1xuICAgIC8vIFByb2Nlc3MgdGhlIGNoaWxkcmVuIG9mIHRoZSBmdXR1cmUgcm91dGVcbiAgICBmdXR1cmVOb2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgZ2V0Um91dGVHdWFyZHMoYywgcHJldkNoaWxkcmVuW2MudmFsdWUub3V0bGV0XSwgY29udGV4dHMsIGZ1dHVyZVBhdGguY29uY2F0KFtjLnZhbHVlXSksIGNoZWNrcyk7XG4gICAgICAgIGRlbGV0ZSBwcmV2Q2hpbGRyZW5bYy52YWx1ZS5vdXRsZXRdO1xuICAgIH0pO1xuICAgIC8vIFByb2Nlc3MgYW55IGNoaWxkcmVuIGxlZnQgZnJvbSB0aGUgY3VycmVudCByb3V0ZSAobm90IGFjdGl2ZSBmb3IgdGhlIGZ1dHVyZSByb3V0ZSlcbiAgICBmb3JFYWNoKHByZXZDaGlsZHJlbiwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmV0dXJuIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHYsIGNvbnRleHRzLmdldENvbnRleHQoayksIGNoZWNrcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoZWNrcztcbn1cbmZ1bmN0aW9uIGdldFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cywgZnV0dXJlUGF0aCwgY2hlY2tzKSB7XG4gICAgaWYgKGNoZWNrcyA9PT0gdm9pZCAwKSB7IGNoZWNrcyA9IHtcbiAgICAgICAgY2FuRGVhY3RpdmF0ZUNoZWNrczogW10sXG4gICAgICAgIGNhbkFjdGl2YXRlQ2hlY2tzOiBbXVxuICAgIH07IH1cbiAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICB2YXIgY3VyciA9IGN1cnJOb2RlID8gY3Vyck5vZGUudmFsdWUgOiBudWxsO1xuICAgIHZhciBjb250ZXh0ID0gcGFyZW50Q29udGV4dHMgPyBwYXJlbnRDb250ZXh0cy5nZXRDb250ZXh0KGZ1dHVyZU5vZGUudmFsdWUub3V0bGV0KSA6IG51bGw7XG4gICAgLy8gcmV1c2luZyB0aGUgbm9kZVxuICAgIGlmIChjdXJyICYmIGZ1dHVyZS5yb3V0ZUNvbmZpZyA9PT0gY3Vyci5yb3V0ZUNvbmZpZykge1xuICAgICAgICB2YXIgc2hvdWxkUnVuID0gc2hvdWxkUnVuR3VhcmRzQW5kUmVzb2x2ZXJzKGN1cnIsIGZ1dHVyZSwgZnV0dXJlLnJvdXRlQ29uZmlnLnJ1bkd1YXJkc0FuZFJlc29sdmVycyk7XG4gICAgICAgIGlmIChzaG91bGRSdW4pIHtcbiAgICAgICAgICAgIGNoZWNrcy5jYW5BY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5BY3RpdmF0ZShmdXR1cmVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgZGF0YVxuICAgICAgICAgICAgZnV0dXJlLmRhdGEgPSBjdXJyLmRhdGE7XG4gICAgICAgICAgICBmdXR1cmUuX3Jlc29sdmVkRGF0YSA9IGN1cnIuX3Jlc29sdmVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW4gb3V0bGV0LlxuICAgICAgICBpZiAoZnV0dXJlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dCA/IGNvbnRleHQuY2hpbGRyZW4gOiBudWxsLCBmdXR1cmVQYXRoLCBjaGVja3MpO1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbXBvbmVudGxlc3Mgcm91dGUsIHdlIHJlY3Vyc2UgYnV0IGtlZXAgdGhlIHNhbWUgb3V0bGV0IG1hcC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldENoaWxkUm91dGVHdWFyZHMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudENvbnRleHRzLCBmdXR1cmVQYXRoLCBjaGVja3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSdW4pIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb250ZXh0ICYmIGNvbnRleHQub3V0bGV0ICYmIGNvbnRleHQub3V0bGV0LmNvbXBvbmVudCB8fCBudWxsO1xuICAgICAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShjb21wb25lbnQsIGN1cnIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICAgIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKGN1cnJOb2RlLCBjb250ZXh0LCBjaGVja3MpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrcy5jYW5BY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5BY3RpdmF0ZShmdXR1cmVQYXRoKSk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBhbiBvdXRsZXQuXG4gICAgICAgIGlmIChmdXR1cmUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIG51bGwsIGNvbnRleHQgPyBjb250ZXh0LmNoaWxkcmVuIDogbnVsbCwgZnV0dXJlUGF0aCwgY2hlY2tzKTtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjb21wb25lbnRsZXNzIHJvdXRlLCB3ZSByZWN1cnNlIGJ1dCBrZWVwIHRoZSBzYW1lIG91dGxldCBtYXAuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRDaGlsZFJvdXRlR3VhcmRzKGZ1dHVyZU5vZGUsIG51bGwsIHBhcmVudENvbnRleHRzLCBmdXR1cmVQYXRoLCBjaGVja3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGVja3M7XG59XG5mdW5jdGlvbiBzaG91bGRSdW5HdWFyZHNBbmRSZXNvbHZlcnMoY3VyciwgZnV0dXJlLCBtb2RlKSB7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAncGFyYW1zT3JRdWVyeVBhcmFtc0NoYW5nZSc6XG4gICAgICAgICAgICByZXR1cm4gIWVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoY3VyciwgZnV0dXJlKSB8fFxuICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwoY3Vyci5xdWVyeVBhcmFtcywgZnV0dXJlLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgY2FzZSAncGFyYW1zQ2hhbmdlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAhZXF1YWxQYXJhbXNBbmRVcmxTZWdtZW50cyhjdXJyLCBmdXR1cmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHJvdXRlLCBjb250ZXh0LCBjaGVja3MpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChyb3V0ZSk7XG4gICAgdmFyIHIgPSByb3V0ZS52YWx1ZTtcbiAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSwgY2hpbGROYW1lKSB7XG4gICAgICAgIGlmICghci5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKG5vZGUsIGNvbnRleHQsIGNoZWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4obm9kZSwgY29udGV4dC5jaGlsZHJlbi5nZXRDb250ZXh0KGNoaWxkTmFtZSksIGNoZWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbihub2RlLCBudWxsLCBjaGVja3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyLmNvbXBvbmVudCkge1xuICAgICAgICBjaGVja3MuY2FuRGVhY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5EZWFjdGl2YXRlKG51bGwsIHIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm91dGxldCAmJiBjb250ZXh0Lm91dGxldC5pc0FjdGl2YXRlZCkge1xuICAgICAgICBjaGVja3MuY2FuRGVhY3RpdmF0ZUNoZWNrcy5wdXNoKG5ldyBDYW5EZWFjdGl2YXRlKGNvbnRleHQub3V0bGV0LmNvbXBvbmVudCwgcikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShudWxsLCByKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjaGVja0d1YXJkcyhtb2R1bGVJbmplY3RvciwgZm9yd2FyZEV2ZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBjdXJyZW50U25hcHNob3QgPSB0LmN1cnJlbnRTbmFwc2hvdCwgX2EgPSB0Lmd1YXJkcywgY2FuQWN0aXZhdGVDaGVja3MgPSBfYS5jYW5BY3RpdmF0ZUNoZWNrcywgY2FuRGVhY3RpdmF0ZUNoZWNrcyA9IF9hLmNhbkRlYWN0aXZhdGVDaGVja3M7XG4gICAgICAgICAgICBpZiAoY2FuRGVhY3RpdmF0ZUNoZWNrcy5sZW5ndGggPT09IDAgJiYgY2FuQWN0aXZhdGVDaGVja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKF9fYXNzaWduKHt9LCB0LCB7IGd1YXJkc1Jlc3VsdDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVuQ2FuRGVhY3RpdmF0ZUNoZWNrcyhjYW5EZWFjdGl2YXRlQ2hlY2tzLCB0YXJnZXRTbmFwc2hvdCwgY3VycmVudFNuYXBzaG90LCBtb2R1bGVJbmplY3RvcilcbiAgICAgICAgICAgICAgICAucGlwZShtZXJnZU1hcChmdW5jdGlvbiAoY2FuRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5EZWFjdGl2YXRlID9cbiAgICAgICAgICAgICAgICAgICAgcnVuQ2FuQWN0aXZhdGVDaGVja3ModGFyZ2V0U25hcHNob3QsIGNhbkFjdGl2YXRlQ2hlY2tzLCBtb2R1bGVJbmplY3RvciwgZm9yd2FyZEV2ZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG9mKGZhbHNlKTtcbiAgICAgICAgICAgIH0pLCBtYXAoZnVuY3Rpb24gKGd1YXJkc1Jlc3VsdCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCB0LCB7IGd1YXJkc1Jlc3VsdDogZ3VhcmRzUmVzdWx0IH0pKTsgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bkNhbkRlYWN0aXZhdGVDaGVja3MoY2hlY2tzLCBmdXR1cmVSU1MsIGN1cnJSU1MsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgcmV0dXJuIGZyb20oY2hlY2tzKS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICByZXR1cm4gcnVuQ2FuRGVhY3RpdmF0ZShjaGVjay5jb21wb25lbnQsIGNoZWNrLnJvdXRlLCBjdXJyUlNTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKTtcbiAgICB9KSwgZXZlcnkoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ID09PSB0cnVlOyB9KSk7XG59XG5mdW5jdGlvbiBydW5DYW5BY3RpdmF0ZUNoZWNrcyhmdXR1cmVTbmFwc2hvdCwgY2hlY2tzLCBtb2R1bGVJbmplY3RvciwgZm9yd2FyZEV2ZW50KSB7XG4gICAgcmV0dXJuIGZyb20oY2hlY2tzKS5waXBlKGNvbmNhdE1hcChmdW5jdGlvbiAoY2hlY2spIHsgcmV0dXJuIGFuZE9ic2VydmFibGVzKGZyb20oW1xuICAgICAgICBmaXJlQ2hpbGRBY3RpdmF0aW9uU3RhcnQoY2hlY2sucm91dGUucGFyZW50LCBmb3J3YXJkRXZlbnQpLFxuICAgICAgICBmaXJlQWN0aXZhdGlvblN0YXJ0KGNoZWNrLnJvdXRlLCBmb3J3YXJkRXZlbnQpLFxuICAgICAgICBydW5DYW5BY3RpdmF0ZUNoaWxkKGZ1dHVyZVNuYXBzaG90LCBjaGVjay5wYXRoLCBtb2R1bGVJbmplY3RvciksXG4gICAgICAgIHJ1bkNhbkFjdGl2YXRlKGZ1dHVyZVNuYXBzaG90LCBjaGVjay5yb3V0ZSwgbW9kdWxlSW5qZWN0b3IpXG4gICAgXSkpOyB9KSwgZXZlcnkoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ID09PSB0cnVlOyB9KSk7XG59XG4vKipcbiAgICogVGhpcyBzaG91bGQgZmlyZSBvZmYgYEFjdGl2YXRpb25TdGFydGAgZXZlbnRzIGZvciBlYWNoIHJvdXRlIGJlaW5nIGFjdGl2YXRlZCBhdCB0aGlzXG4gICAqIGxldmVsLlxuICAgKiBJbiBvdGhlciB3b3JkcywgaWYgeW91J3JlIGFjdGl2YXRpbmcgYGFgIGFuZCBgYmAgYmVsb3csIGBwYXRoYCB3aWxsIGNvbnRhaW4gdGhlXG4gICAqIGBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90YHMgZm9yIGJvdGggYW5kIHdlIHdpbGwgZmlyZSBgQWN0aXZhdGlvblN0YXJ0YCBmb3IgYm90aC4gQWx3YXlzXG4gICAqIHJldHVyblxuICAgKiBgdHJ1ZWAgc28gY2hlY2tzIGNvbnRpbnVlIHRvIHJ1bi5cbiAgICovXG5mdW5jdGlvbiBmaXJlQWN0aXZhdGlvblN0YXJ0KHNuYXBzaG90LCBmb3J3YXJkRXZlbnQpIHtcbiAgICBpZiAoc25hcHNob3QgIT09IG51bGwgJiYgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIGZvcndhcmRFdmVudChuZXcgQWN0aXZhdGlvblN0YXJ0KHNuYXBzaG90KSk7XG4gICAgfVxuICAgIHJldHVybiBvZih0cnVlKTtcbn1cbi8qKlxuICAgKiBUaGlzIHNob3VsZCBmaXJlIG9mZiBgQ2hpbGRBY3RpdmF0aW9uU3RhcnRgIGV2ZW50cyBmb3IgZWFjaCByb3V0ZSBiZWluZyBhY3RpdmF0ZWQgYXQgdGhpc1xuICAgKiBsZXZlbC5cbiAgICogSW4gb3RoZXIgd29yZHMsIGlmIHlvdSdyZSBhY3RpdmF0aW5nIGBhYCBhbmQgYGJgIGJlbG93LCBgcGF0aGAgd2lsbCBjb250YWluIHRoZVxuICAgKiBgQWN0aXZhdGVkUm91dGVTbmFwc2hvdGBzIGZvciBib3RoIGFuZCB3ZSB3aWxsIGZpcmUgYENoaWxkQWN0aXZhdGlvblN0YXJ0YCBmb3IgYm90aC4gQWx3YXlzXG4gICAqIHJldHVyblxuICAgKiBgdHJ1ZWAgc28gY2hlY2tzIGNvbnRpbnVlIHRvIHJ1bi5cbiAgICovXG5mdW5jdGlvbiBmaXJlQ2hpbGRBY3RpdmF0aW9uU3RhcnQoc25hcHNob3QsIGZvcndhcmRFdmVudCkge1xuICAgIGlmIChzbmFwc2hvdCAhPT0gbnVsbCAmJiBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgZm9yd2FyZEV2ZW50KG5ldyBDaGlsZEFjdGl2YXRpb25TdGFydChzbmFwc2hvdCkpO1xuICAgIH1cbiAgICByZXR1cm4gb2YodHJ1ZSk7XG59XG5mdW5jdGlvbiBydW5DYW5BY3RpdmF0ZShmdXR1cmVSU1MsIGZ1dHVyZUFSUywgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICB2YXIgY2FuQWN0aXZhdGUgPSBmdXR1cmVBUlMucm91dGVDb25maWcgPyBmdXR1cmVBUlMucm91dGVDb25maWcuY2FuQWN0aXZhdGUgOiBudWxsO1xuICAgIGlmICghY2FuQWN0aXZhdGUgfHwgY2FuQWN0aXZhdGUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gb2YodHJ1ZSk7XG4gICAgdmFyIG9icyA9IGZyb20oY2FuQWN0aXZhdGUpLnBpcGUobWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBndWFyZCA9IGdldFRva2VuKGMsIGZ1dHVyZUFSUywgbW9kdWxlSW5qZWN0b3IpO1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgaWYgKGd1YXJkLmNhbkFjdGl2YXRlKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkLmNhbkFjdGl2YXRlKGZ1dHVyZUFSUywgZnV0dXJlUlNTKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkKGZ1dHVyZUFSUywgZnV0dXJlUlNTKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUucGlwZShmaXJzdCgpKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGFuZE9ic2VydmFibGVzKG9icyk7XG59XG5mdW5jdGlvbiBydW5DYW5BY3RpdmF0ZUNoaWxkKGZ1dHVyZVJTUywgcGF0aCwgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICB2YXIgZnV0dXJlQVJTID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkR3VhcmRzID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gZ2V0Q2FuQWN0aXZhdGVDaGlsZChwKTsgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXyAhPT0gbnVsbDsgfSk7XG4gICAgcmV0dXJuIGFuZE9ic2VydmFibGVzKGZyb20oY2FuQWN0aXZhdGVDaGlsZEd1YXJkcykucGlwZShtYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIG9icyA9IGZyb20oZC5ndWFyZHMpLnBpcGUobWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmQgPSBnZXRUb2tlbihjLCBkLm5vZGUsIG1vZHVsZUluamVjdG9yKTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlO1xuICAgICAgICAgICAgaWYgKGd1YXJkLmNhbkFjdGl2YXRlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkLmNhbkFjdGl2YXRlQ2hpbGQoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUoZmlyc3QoKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGFuZE9ic2VydmFibGVzKG9icyk7XG4gICAgfSkpKTtcbn1cbmZ1bmN0aW9uIHJ1bkNhbkRlYWN0aXZhdGUoY29tcG9uZW50LCBjdXJyQVJTLCBjdXJyUlNTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgdmFyIGNhbkRlYWN0aXZhdGUgPSBjdXJyQVJTICYmIGN1cnJBUlMucm91dGVDb25maWcgPyBjdXJyQVJTLnJvdXRlQ29uZmlnLmNhbkRlYWN0aXZhdGUgOiBudWxsO1xuICAgIGlmICghY2FuRGVhY3RpdmF0ZSB8fCBjYW5EZWFjdGl2YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG9mKHRydWUpO1xuICAgIHZhciBjYW5EZWFjdGl2YXRlJCA9IGZyb20oY2FuRGVhY3RpdmF0ZSkucGlwZShtZXJnZU1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZ3VhcmQgPSBnZXRUb2tlbihjLCBjdXJyQVJTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlO1xuICAgICAgICBpZiAoZ3VhcmQuY2FuRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZC5jYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgY3VyckFSUywgY3VyclJTUywgZnV0dXJlUlNTKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkKGNvbXBvbmVudCwgY3VyckFSUywgY3VyclJTUywgZnV0dXJlUlNTKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUucGlwZShmaXJzdCgpKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNhbkRlYWN0aXZhdGUkLnBpcGUoZXZlcnkoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ID09PSB0cnVlOyB9KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBOb01hdGNoJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9NYXRjaCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE5vTWF0Y2g7XG59KCkpO1xuZnVuY3Rpb24gcmVjb2duaXplKHJvb3RDb21wb25lbnRUeXBlLCBjb25maWcsIHVybFRyZWUsIHVybCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikge1xuICAgIGlmIChwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID09PSB2b2lkIDApIHsgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9ICdlbXB0eU9ubHknOyB9XG4gICAgaWYgKHJlbGF0aXZlTGlua1Jlc29sdXRpb24gPT09IHZvaWQgMCkgeyByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gJ2xlZ2FjeSc7IH1cbiAgICByZXR1cm4gbmV3IFJlY29nbml6ZXIocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgdXJsVHJlZSwgdXJsLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKVxuICAgICAgICAucmVjb2duaXplKCk7XG59XG52YXIgUmVjb2duaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvZ25pemVyKHJvb3RDb21wb25lbnRUeXBlLCBjb25maWcsIHVybFRyZWUsIHVybCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnVybFRyZWUgPSB1cmxUcmVlO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5wYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID0gcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gcmVsYXRpdmVMaW5rUmVzb2x1dGlvbjtcbiAgICB9XG4gICAgUmVjb2duaXplci5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJvb3RTZWdtZW50R3JvdXAgPSBzcGxpdCQxKHRoaXMudXJsVHJlZS5yb290LCBbXSwgW10sIHRoaXMuY29uZmlnLCB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pLnNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvY2Vzc1NlZ21lbnRHcm91cCh0aGlzLmNvbmZpZywgcm9vdFNlZ21lbnRHcm91cCwgUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBuZXcgQWN0aXZhdGVkUm91dGVTbmFwc2hvdChbXSwgT2JqZWN0LmZyZWV6ZSh7fSksIE9iamVjdC5mcmVlemUoX19hc3NpZ24oe30sIHRoaXMudXJsVHJlZS5xdWVyeVBhcmFtcykpLCB0aGlzLnVybFRyZWUuZnJhZ21lbnQsIHt9LCBQUklNQVJZX09VVExFVCwgdGhpcy5yb290Q29tcG9uZW50VHlwZSwgbnVsbCwgdGhpcy51cmxUcmVlLnJvb3QsIC0xLCB7fSk7XG4gICAgICAgICAgICB2YXIgcm9vdE5vZGUgPSBuZXcgVHJlZU5vZGUocm9vdCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgdmFyIHJvdXRlU3RhdGUgPSBuZXcgUm91dGVyU3RhdGVTbmFwc2hvdCh0aGlzLnVybCwgcm9vdE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0UGFyYW1zQW5kRGF0YShyb3V0ZVN0YXRlLl9yb290KTtcbiAgICAgICAgICAgIHJldHVybiBvZihyb3V0ZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXIucHJvdG90eXBlLmluaGVyaXRQYXJhbXNBbmREYXRhID0gZnVuY3Rpb24gKHJvdXRlTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZU5vZGUudmFsdWU7XG4gICAgICAgIHZhciBpID0gaW5oZXJpdGVkUGFyYW1zRGF0YVJlc29sdmUocm91dGUsIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSk7XG4gICAgICAgIHJvdXRlLnBhcmFtcyA9IE9iamVjdC5mcmVlemUoaS5wYXJhbXMpO1xuICAgICAgICByb3V0ZS5kYXRhID0gT2JqZWN0LmZyZWV6ZShpLmRhdGEpO1xuICAgICAgICByb3V0ZU5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gX3RoaXMuaW5oZXJpdFBhcmFtc0FuZERhdGEobik7IH0pO1xuICAgIH07XG4gICAgUmVjb2duaXplci5wcm90b3R5cGUucHJvY2Vzc1NlZ21lbnRHcm91cCA9IGZ1bmN0aW9uIChjb25maWcsIHNlZ21lbnRHcm91cCwgb3V0bGV0KSB7XG4gICAgICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQ2hpbGRyZW4oY29uZmlnLCBzZWdtZW50R3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NTZWdtZW50KGNvbmZpZywgc2VnbWVudEdyb3VwLCBzZWdtZW50R3JvdXAuc2VnbWVudHMsIG91dGxldCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY29uZmlnLCBzZWdtZW50R3JvdXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbWFwQ2hpbGRyZW5JbnRvQXJyYXkoc2VnbWVudEdyb3VwLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7IHJldHVybiBfdGhpcy5wcm9jZXNzU2VnbWVudEdyb3VwKGNvbmZpZywgY2hpbGQsIGNoaWxkT3V0bGV0KTsgfSk7XG4gICAgICAgIGNoZWNrT3V0bGV0TmFtZVVuaXF1ZW5lc3MoY2hpbGRyZW4pO1xuICAgICAgICBzb3J0QWN0aXZhdGVkUm91dGVTbmFwc2hvdHMoY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfTtcbiAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzU2VnbWVudCA9IGZ1bmN0aW9uIChjb25maWcsIHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIG91dGxldCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbmZpZ18xID0gX192YWx1ZXMoY29uZmlnKSwgY29uZmlnXzFfMSA9IGNvbmZpZ18xLm5leHQoKTsgIWNvbmZpZ18xXzEuZG9uZTsgY29uZmlnXzFfMSA9IGNvbmZpZ18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gY29uZmlnXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU2VnbWVudEFnYWluc3RSb3V0ZShyLCBzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCBvdXRsZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgTm9NYXRjaCQxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnXzFfMSAmJiAhY29uZmlnXzFfMS5kb25lICYmIChfYSA9IGNvbmZpZ18xLnJldHVybikpIF9hLmNhbGwoY29uZmlnXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vTGVmdG92ZXJzSW5Vcmwoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb01hdGNoJDEoKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXIucHJvdG90eXBlLm5vTGVmdG92ZXJzSW5VcmwgPSBmdW5jdGlvbiAoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXNlZ21lbnRHcm91cC5jaGlsZHJlbltvdXRsZXRdO1xuICAgIH07XG4gICAgUmVjb2duaXplci5wcm90b3R5cGUucHJvY2Vzc1NlZ21lbnRBZ2FpbnN0Um91dGUgPSBmdW5jdGlvbiAocm91dGUsIHJhd1NlZ21lbnQsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCQxKCk7XG4gICAgICAgIGlmICgocm91dGUub3V0bGV0IHx8IFBSSU1BUllfT1VUTEVUKSAhPT0gb3V0bGV0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgIHZhciBjb25zdW1lZFNlZ21lbnRzID0gW107XG4gICAgICAgIHZhciByYXdTbGljZWRTZWdtZW50cyA9IFtdO1xuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJyoqJykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNlZ21lbnRzLmxlbmd0aCA+IDAgPyBsYXN0JDEoc2VnbWVudHMpLnBhcmFtZXRlcnMgOiB7fTtcbiAgICAgICAgICAgIHNuYXBzaG90ID0gbmV3IEFjdGl2YXRlZFJvdXRlU25hcHNob3Qoc2VnbWVudHMsIHBhcmFtcywgT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbih7fSwgdGhpcy51cmxUcmVlLnF1ZXJ5UGFyYW1zKSksIHRoaXMudXJsVHJlZS5mcmFnbWVudCwgZ2V0RGF0YShyb3V0ZSksIG91dGxldCwgcm91dGUuY29tcG9uZW50LCByb3V0ZSwgZ2V0U291cmNlU2VnbWVudEdyb3VwKHJhd1NlZ21lbnQpLCBnZXRQYXRoSW5kZXhTaGlmdChyYXdTZWdtZW50KSArIHNlZ21lbnRzLmxlbmd0aCwgZ2V0UmVzb2x2ZShyb3V0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoJDEocmF3U2VnbWVudCwgcm91dGUsIHNlZ21lbnRzKTtcbiAgICAgICAgICAgIGNvbnN1bWVkU2VnbWVudHMgPSByZXN1bHQuY29uc3VtZWRTZWdtZW50cztcbiAgICAgICAgICAgIHJhd1NsaWNlZFNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UocmVzdWx0Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICBzbmFwc2hvdCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KGNvbnN1bWVkU2VnbWVudHMsIHJlc3VsdC5wYXJhbWV0ZXJzLCBPYmplY3QuZnJlZXplKF9fYXNzaWduKHt9LCB0aGlzLnVybFRyZWUucXVlcnlQYXJhbXMpKSwgdGhpcy51cmxUcmVlLmZyYWdtZW50LCBnZXREYXRhKHJvdXRlKSwgb3V0bGV0LCByb3V0ZS5jb21wb25lbnQsIHJvdXRlLCBnZXRTb3VyY2VTZWdtZW50R3JvdXAocmF3U2VnbWVudCksIGdldFBhdGhJbmRleFNoaWZ0KHJhd1NlZ21lbnQpICsgY29uc3VtZWRTZWdtZW50cy5sZW5ndGgsIGdldFJlc29sdmUocm91dGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRDb25maWcgPSBnZXRDaGlsZENvbmZpZyhyb3V0ZSk7XG4gICAgICAgIHZhciBfYSA9IHNwbGl0JDEocmF3U2VnbWVudCwgY29uc3VtZWRTZWdtZW50cywgcmF3U2xpY2VkU2VnbWVudHMsIGNoaWxkQ29uZmlnLCB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pLCBzZWdtZW50R3JvdXAgPSBfYS5zZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzID0gX2Euc2xpY2VkU2VnbWVudHM7XG4gICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiYgc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbl8xID0gdGhpcy5wcm9jZXNzQ2hpbGRyZW4oY2hpbGRDb25maWcsIHNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBUcmVlTm9kZShzbmFwc2hvdCwgY2hpbGRyZW5fMSldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZENvbmZpZy5sZW5ndGggPT09IDAgJiYgc2xpY2VkU2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBUcmVlTm9kZShzbmFwc2hvdCwgW10pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb2Nlc3NTZWdtZW50KGNoaWxkQ29uZmlnLCBzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCBQUklNQVJZX09VVExFVCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRyZWVOb2RlKHNuYXBzaG90LCBjaGlsZHJlbildO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXI7XG59KCkpO1xuZnVuY3Rpb24gc29ydEFjdGl2YXRlZFJvdXRlU25hcHNob3RzKG5vZGVzKSB7XG4gICAgbm9kZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS52YWx1ZS5vdXRsZXQgPT09IFBSSU1BUllfT1VUTEVUKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYi52YWx1ZS5vdXRsZXQgPT09IFBSSU1BUllfT1VUTEVUKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBhLnZhbHVlLm91dGxldC5sb2NhbGVDb21wYXJlKGIudmFsdWUub3V0bGV0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkQ29uZmlnKHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiByb3V0ZS5jaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gcm91dGUuX2xvYWRlZENvbmZpZy5yb3V0ZXM7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoJDEoc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICBpZiAocm91dGUucGF0aCA9PT0gJycpIHtcbiAgICAgICAgaWYgKHJvdXRlLnBhdGhNYXRjaCA9PT0gJ2Z1bGwnICYmIChzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSB8fCBzZWdtZW50cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkU2VnbWVudHM6IFtdLCBsYXN0Q2hpbGQ6IDAsIHBhcmFtZXRlcnM6IHt9IH07XG4gICAgfVxuICAgIHZhciBtYXRjaGVyID0gcm91dGUubWF0Y2hlciB8fCBkZWZhdWx0VXJsTWF0Y2hlcjtcbiAgICB2YXIgcmVzID0gbWF0Y2hlcihzZWdtZW50cywgc2VnbWVudEdyb3VwLCByb3V0ZSk7XG4gICAgaWYgKCFyZXMpXG4gICAgICAgIHRocm93IG5ldyBOb01hdGNoJDEoKTtcbiAgICB2YXIgcG9zUGFyYW1zID0ge307XG4gICAgZm9yRWFjaChyZXMucG9zUGFyYW1zLCBmdW5jdGlvbiAodiwgaykgeyBwb3NQYXJhbXNba10gPSB2LnBhdGg7IH0pO1xuICAgIHZhciBwYXJhbWV0ZXJzID0gcmVzLmNvbnN1bWVkLmxlbmd0aCA+IDAgPyBfX2Fzc2lnbih7fSwgcG9zUGFyYW1zLCByZXMuY29uc3VtZWRbcmVzLmNvbnN1bWVkLmxlbmd0aCAtIDFdLnBhcmFtZXRlcnMpIDpcbiAgICAgICAgcG9zUGFyYW1zO1xuICAgIHJldHVybiB7IGNvbnN1bWVkU2VnbWVudHM6IHJlcy5jb25zdW1lZCwgbGFzdENoaWxkOiByZXMuY29uc3VtZWQubGVuZ3RoLCBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzIH07XG59XG5mdW5jdGlvbiBjaGVja091dGxldE5hbWVVbmlxdWVuZXNzKG5vZGVzKSB7XG4gICAgdmFyIG5hbWVzID0ge307XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICB2YXIgcm91dGVXaXRoU2FtZU91dGxldE5hbWUgPSBuYW1lc1tuLnZhbHVlLm91dGxldF07XG4gICAgICAgIGlmIChyb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIHAgPSByb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZS51cmwubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIHZhciBjID0gbi52YWx1ZS51cmwubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR3byBzZWdtZW50cyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBvdXRsZXQgbmFtZTogJ1wiICsgcCArIFwiJyBhbmQgJ1wiICsgYyArIFwiJy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXNbbi52YWx1ZS5vdXRsZXRdID0gbi52YWx1ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZVNlZ21lbnRHcm91cChzZWdtZW50R3JvdXApIHtcbiAgICB2YXIgcyA9IHNlZ21lbnRHcm91cDtcbiAgICB3aGlsZSAocy5fc291cmNlU2VnbWVudCkge1xuICAgICAgICBzID0gcy5fc291cmNlU2VnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBnZXRQYXRoSW5kZXhTaGlmdChzZWdtZW50R3JvdXApIHtcbiAgICB2YXIgcyA9IHNlZ21lbnRHcm91cDtcbiAgICB2YXIgcmVzID0gKHMuX3NlZ21lbnRJbmRleFNoaWZ0ID8gcy5fc2VnbWVudEluZGV4U2hpZnQgOiAwKTtcbiAgICB3aGlsZSAocy5fc291cmNlU2VnbWVudCkge1xuICAgICAgICBzID0gcy5fc291cmNlU2VnbWVudDtcbiAgICAgICAgcmVzICs9IChzLl9zZWdtZW50SW5kZXhTaGlmdCA/IHMuX3NlZ21lbnRJbmRleFNoaWZ0IDogMCk7XG4gICAgfVxuICAgIHJldHVybiByZXMgLSAxO1xufVxuZnVuY3Rpb24gc3BsaXQkMShzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcsIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICBpZiAoc2xpY2VkU2VnbWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICBjb250YWluc0VtcHR5UGF0aE1hdGNoZXNXaXRoTmFtZWRPdXRsZXRzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIHNfMSA9IG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cywgY3JlYXRlQ2hpbGRyZW5Gb3JFbXB0eVBhdGhzKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgY29uZmlnLCBuZXcgVXJsU2VnbWVudEdyb3VwKHNsaWNlZFNlZ21lbnRzLCBzZWdtZW50R3JvdXAuY2hpbGRyZW4pKSk7XG4gICAgICAgIHNfMS5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgc18xLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBzZWdtZW50R3JvdXA6IHNfMSwgc2xpY2VkU2VnbWVudHM6IFtdIH07XG4gICAgfVxuICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIHNfMiA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLCBhZGRFbXB0eVBhdGhzVG9DaGlsZHJlbklmTmVlZGVkKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgc2xpY2VkU2VnbWVudHMsIGNvbmZpZywgc2VnbWVudEdyb3VwLmNoaWxkcmVuLCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSk7XG4gICAgICAgIHNfMi5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgc18yLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4geyBzZWdtZW50R3JvdXA6IHNfMiwgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG4gICAgfVxuICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIHNlZ21lbnRHcm91cC5jaGlsZHJlbik7XG4gICAgcy5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICBzLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogcywgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG59XG5mdW5jdGlvbiBhZGRFbXB0eVBhdGhzVG9DaGlsZHJlbklmTmVlZGVkKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgc2xpY2VkU2VnbWVudHMsIHJvdXRlcywgY2hpbGRyZW4sIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgcm91dGVzXzEgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpOyAhcm91dGVzXzFfMS5kb25lOyByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHJvdXRlc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcikgJiYgIWNoaWxkcmVuW2dldE91dGxldCQxKHIpXSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgICAgIHMuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlTGlua1Jlc29sdXRpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuX3NlZ21lbnRJbmRleFNoaWZ0ID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc1tnZXRPdXRsZXQkMShyKV0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm91dGVzXzFfMSAmJiAhcm91dGVzXzFfMS5kb25lICYmIChfYSA9IHJvdXRlc18xLnJldHVybikpIF9hLmNhbGwocm91dGVzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBjaGlsZHJlbiwgcmVzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuRm9yRW1wdHlQYXRocyhzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHJvdXRlcywgcHJpbWFyeVNlZ21lbnQpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB2YXIgcmVzID0ge307XG4gICAgcmVzW1BSSU1BUllfT1VUTEVUXSA9IHByaW1hcnlTZWdtZW50O1xuICAgIHByaW1hcnlTZWdtZW50Ll9zb3VyY2VTZWdtZW50ID0gc2VnbWVudEdyb3VwO1xuICAgIHByaW1hcnlTZWdtZW50Ll9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHJvdXRlc18yID0gX192YWx1ZXMocm91dGVzKSwgcm91dGVzXzJfMSA9IHJvdXRlc18yLm5leHQoKTsgIXJvdXRlc18yXzEuZG9uZTsgcm91dGVzXzJfMSA9IHJvdXRlc18yLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHIucGF0aCA9PT0gJycgJiYgZ2V0T3V0bGV0JDEocikgIT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgICAgICAgICAgICAgcy5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgICAgICBzLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc1tnZXRPdXRsZXQkMShyKV0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocm91dGVzXzJfMSAmJiAhcm91dGVzXzJfMS5kb25lICYmIChfYSA9IHJvdXRlc18yLnJldHVybikpIF9hLmNhbGwocm91dGVzXzIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zRW1wdHlQYXRoTWF0Y2hlc1dpdGhOYW1lZE91dGxldHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcm91dGVzKSB7XG4gICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBlbXB0eVBhdGhNYXRjaChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByKSAmJiBnZXRPdXRsZXQkMShyKSAhPT0gUFJJTUFSWV9PVVRMRVQ7IH0pO1xufVxuZnVuY3Rpb24gY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikgeyByZXR1cm4gZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcik7IH0pO1xufVxuZnVuY3Rpb24gZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcikge1xuICAgIGlmICgoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgc2xpY2VkU2VnbWVudHMubGVuZ3RoID4gMCkgJiYgci5wYXRoTWF0Y2ggPT09ICdmdWxsJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByLnBhdGggPT09ICcnICYmIHIucmVkaXJlY3RUbyA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0T3V0bGV0JDEocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUub3V0bGV0IHx8IFBSSU1BUllfT1VUTEVUO1xufVxuZnVuY3Rpb24gZ2V0RGF0YShyb3V0ZSkge1xuICAgIHJldHVybiByb3V0ZS5kYXRhIHx8IHt9O1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZShyb3V0ZSkge1xuICAgIHJldHVybiByb3V0ZS5yZXNvbHZlIHx8IHt9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiByZWNvZ25pemUkMShyb290Q29tcG9uZW50VHlwZSwgY29uZmlnLCBzZXJpYWxpemVyLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiByZWNvZ25pemUocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgdC51cmxBZnRlclJlZGlyZWN0cywgc2VyaWFsaXplcih0LnVybEFmdGVyUmVkaXJlY3RzKSwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbilcbiAgICAgICAgICAgIC5waXBlKG1hcChmdW5jdGlvbiAodGFyZ2V0U25hcHNob3QpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgdCwgeyB0YXJnZXRTbmFwc2hvdDogdGFyZ2V0U25hcHNob3QgfSkpOyB9KSk7IH0pKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiByZXNvbHZlRGF0YShwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCBtb2R1bGVJbmplY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucGlwZShtZXJnZU1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFNuYXBzaG90ID0gdC50YXJnZXRTbmFwc2hvdCwgY2FuQWN0aXZhdGVDaGVja3MgPSB0Lmd1YXJkcy5jYW5BY3RpdmF0ZUNoZWNrcztcbiAgICAgICAgICAgIGlmICghY2FuQWN0aXZhdGVDaGVja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb20oY2FuQWN0aXZhdGVDaGVja3MpXG4gICAgICAgICAgICAgICAgLnBpcGUoY29uY2F0TWFwKGZ1bmN0aW9uIChjaGVjaykgeyByZXR1cm4gcnVuUmVzb2x2ZShjaGVjay5yb3V0ZSwgdGFyZ2V0U25hcHNob3QsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIG1vZHVsZUluamVjdG9yKTsgfSksIHJlZHVjZShmdW5jdGlvbiAoXywgX18pIHsgcmV0dXJuIF87IH0pLCBtYXAoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIHQ7IH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBydW5SZXNvbHZlKGZ1dHVyZUFSUywgZnV0dXJlUlNTLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCBtb2R1bGVJbmplY3Rvcikge1xuICAgIHZhciByZXNvbHZlID0gZnV0dXJlQVJTLl9yZXNvbHZlO1xuICAgIHJldHVybiByZXNvbHZlTm9kZShyZXNvbHZlLCBmdXR1cmVBUlMsIGZ1dHVyZVJTUywgbW9kdWxlSW5qZWN0b3IpXG4gICAgICAgIC5waXBlKG1hcChmdW5jdGlvbiAocmVzb2x2ZWREYXRhKSB7XG4gICAgICAgIGZ1dHVyZUFSUy5fcmVzb2x2ZWREYXRhID0gcmVzb2x2ZWREYXRhO1xuICAgICAgICBmdXR1cmVBUlMuZGF0YSA9IF9fYXNzaWduKHt9LCBmdXR1cmVBUlMuZGF0YSwgaW5oZXJpdGVkUGFyYW1zRGF0YVJlc29sdmUoZnV0dXJlQVJTLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5KS5yZXNvbHZlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUocmVzb2x2ZSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG9mKHt9KTtcbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBrZXlfMSA9IGtleXNbMF07XG4gICAgICAgIHJldHVybiBnZXRSZXNvbHZlcihyZXNvbHZlW2tleV8xXSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgLnBpcGUobWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW2tleV8xXSA9IHZhbHVlLCBfYTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBydW5uaW5nUmVzb2x2ZXJzJCA9IGZyb20oa2V5cykucGlwZShtZXJnZU1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRSZXNvbHZlcihyZXNvbHZlW2tleV0sIGZ1dHVyZUFSUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3RvcilcbiAgICAgICAgICAgIC5waXBlKG1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBydW5uaW5nUmVzb2x2ZXJzJC5waXBlKGxhc3QoKSwgbWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0pKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKGluamVjdGlvblRva2VuLCBmdXR1cmVBUlMsIGZ1dHVyZVJTUywgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSBnZXRUb2tlbihpbmplY3Rpb25Ub2tlbiwgZnV0dXJlQVJTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUgPyB3cmFwSW50b09ic2VydmFibGUocmVzb2x2ZXIucmVzb2x2ZShmdXR1cmVBUlMsIGZ1dHVyZVJTUykpIDpcbiAgICAgICAgd3JhcEludG9PYnNlcnZhYmxlKHJlc29sdmVyKGZ1dHVyZUFSUywgZnV0dXJlUlNTKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IHRocm91Z2ggYSBzd2l0Y2hNYXAgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSxcbiAqIGJ1dCByZXR1cm4gYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLiBJdCdzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzXG4gKiB0aGUgYHRhcGAgb3BlcmF0b3IsIGJ1dCBpZiB0aGUgc2lkZSBlZmZlY3RmdWwgYG5leHRgIGZ1bmN0aW9uIHJldHVybnMgYW4gT2JzZXJ2YWJsZUlucHV0LFxuICogaXQgd2lsbCB3YWl0IGJlZm9yZSBjb250aW51aW5nIHdpdGggdGhlIG9yaWdpbmFsIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzd2l0Y2hUYXAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucGlwZShzd2l0Y2hNYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UmVzdWx0ID0gbmV4dCh2KTtcbiAgICAgICAgICAgIGlmIChuZXh0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb20obmV4dFJlc3VsdCkucGlwZShtYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdjsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZyb20oW3ZdKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gY3VzdG9taXplIHdoZW4gYWN0aXZhdGVkIHJvdXRlcyBnZXQgcmV1c2VkLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlUmV1c2VTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZVJldXNlU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIHJldHVybiBSb3V0ZVJldXNlU3RyYXRlZ3k7XG59KCkpO1xuLyoqXG4gKiBEb2VzIG5vdCBkZXRhY2ggYW55IHN1YnRyZWVzLiBSZXVzZXMgcm91dGVzIGFzIGxvbmcgYXMgdGhlaXIgcm91dGUgY29uZmlnIGlzIHRoZSBzYW1lLlxuICovXG52YXIgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGREZXRhY2ggPSBmdW5jdGlvbiAocm91dGUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKHJvdXRlLCBkZXRhY2hlZFRyZWUpIHsgfTtcbiAgICBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5LnByb3RvdHlwZS5zaG91bGRBdHRhY2ggPSBmdW5jdGlvbiAocm91dGUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gKHJvdXRlKSB7IHJldHVybiBudWxsOyB9O1xuICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnNob3VsZFJldXNlUm91dGUgPSBmdW5jdGlvbiAoZnV0dXJlLCBjdXJyKSB7XG4gICAgICAgIHJldHVybiBmdXR1cmUucm91dGVDb25maWcgPT09IGN1cnIucm91dGVDb25maWc7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRvY3NOb3RSZXF1aXJlZFxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUk9VVEVTID0gbmV3IEluamVjdGlvblRva2VuKCdST1VURVMnKTtcbnZhciBSb3V0ZXJDb25maWdMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVyQ29uZmlnTG9hZGVyKGxvYWRlciwgY29tcGlsZXIsIG9uTG9hZFN0YXJ0TGlzdGVuZXIsIG9uTG9hZEVuZExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xuICAgICAgICB0aGlzLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gICAgICAgIHRoaXMub25Mb2FkU3RhcnRMaXN0ZW5lciA9IG9uTG9hZFN0YXJ0TGlzdGVuZXI7XG4gICAgICAgIHRoaXMub25Mb2FkRW5kTGlzdGVuZXIgPSBvbkxvYWRFbmRMaXN0ZW5lcjtcbiAgICB9XG4gICAgUm91dGVyQ29uZmlnTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhcmVudEluamVjdG9yLCByb3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5vbkxvYWRTdGFydExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9uTG9hZFN0YXJ0TGlzdGVuZXIocm91dGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2R1bGVGYWN0b3J5JCA9IHRoaXMubG9hZE1vZHVsZUZhY3Rvcnkocm91dGUubG9hZENoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZUZhY3RvcnkkLnBpcGUobWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25Mb2FkRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkxvYWRFbmRMaXN0ZW5lcihyb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9kdWxlID0gZmFjdG9yeS5jcmVhdGUocGFyZW50SW5qZWN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2FkZWRSb3V0ZXJDb25maWcoZmxhdHRlbihtb2R1bGUuaW5qZWN0b3IuZ2V0KFJPVVRFUykpLm1hcChzdGFuZGFyZGl6ZUNvbmZpZyksIG1vZHVsZSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIFJvdXRlckNvbmZpZ0xvYWRlci5wcm90b3R5cGUubG9hZE1vZHVsZUZhY3RvcnkgPSBmdW5jdGlvbiAobG9hZENoaWxkcmVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgbG9hZENoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb20odGhpcy5sb2FkZXIubG9hZChsb2FkQ2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUobG9hZENoaWxkcmVuKCkpLnBpcGUobWVyZ2VNYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIE5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbShfdGhpcy5jb21waWxlci5jb21waWxlTW9kdWxlQXN5bmModCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJvdXRlckNvbmZpZ0xvYWRlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gbWlncmF0ZSBBbmd1bGFySlMgYXBwbGljYXRpb25zIHRvIEFuZ3VsYXIuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgVXJsSGFuZGxpbmdTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxIYW5kbGluZ1N0cmF0ZWd5KCkge1xuICAgIH1cbiAgICByZXR1cm4gVXJsSGFuZGxpbmdTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5KCkge1xuICAgIH1cbiAgICBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneS5wcm90b3R5cGUuc2hvdWxkUHJvY2Vzc1VybCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgRGVmYXVsdFVybEhhbmRsaW5nU3RyYXRlZ3kucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiB1cmw7IH07XG4gICAgRGVmYXVsdFVybEhhbmRsaW5nU3RyYXRlZ3kucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG5ld1VybFBhcnQsIHdob2xlVXJsKSB7IHJldHVybiBuZXdVcmxQYXJ0OyB9O1xuICAgIHJldHVybiBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRNYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIoZXJyb3IsIHVybFNlcmlhbGl6ZXIsIHVybCkge1xuICAgIHJldHVybiB1cmxTZXJpYWxpemVyLnBhcnNlKCcvJyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWZhdWx0Um91dGVySG9vayhzbmFwc2hvdCwgcnVuRXh0cmFzKSB7XG4gICAgcmV0dXJuIG9mKG51bGwpO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBQcm92aWRlcyB0aGUgbmF2aWdhdGlvbiBhbmQgdXJsIG1hbmlwdWxhdGlvbiBjYXBhYmlsaXRpZXMuXG4gKlxuICogU2VlIGBSb3V0ZXNgIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICpcbiAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSb3V0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcm91dGVyIHNlcnZpY2UuXG4gICAgICovXG4gICAgLy8gVE9ETzogdnNhdmtpbiBtYWtlIGludGVybmFsIGFmdGVyIHRoZSBmaW5hbCBpcyBvdXQuXG4gICAgZnVuY3Rpb24gUm91dGVyKHJvb3RDb21wb25lbnRUeXBlLCB1cmxTZXJpYWxpemVyLCByb290Q29udGV4dHMsIGxvY2F0aW9uLCBpbmplY3RvciwgbG9hZGVyLCBjb21waWxlciwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPSByb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgdGhpcy51cmxTZXJpYWxpemVyID0gdXJsU2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy5yb290Q29udGV4dHMgPSByb290Q29udGV4dHM7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbklkID0gMDtcbiAgICAgICAgdGhpcy5pc05nWm9uZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXJyb3IgaGFuZGxlciB0aGF0IGlzIGludm9rZWQgd2hlbiBhIG5hdmlnYXRpb24gZXJyb3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYEVycm9ySGFuZGxlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGRlZmF1bHRFcnJvckhhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWxmb3JtZWQgdXJpIGVycm9yIGhhbmRsZXIgaXMgaW52b2tlZCB3aGVuIGBSb3V0ZXIucGFyc2VVcmwodXJsKWAgdGhyb3dzIGFuXG4gICAgICAgICAqIGVycm9yIGR1ZSB0byBjb250YWluaW5nIGFuIGludmFsaWQgY2hhcmFjdGVyLiBUaGUgbW9zdCBjb21tb24gY2FzZSB3b3VsZCBiZSBhIGAlYCBzaWduXG4gICAgICAgICAqIHRoYXQncyBub3QgZW5jb2RlZCBhbmQgaXMgbm90IHBhcnQgb2YgYSBwZXJjZW50IGVuY29kZWQgc2VxdWVuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hbGZvcm1lZFVyaUVycm9ySGFuZGxlciA9IGRlZmF1bHRNYWxmb3JtZWRVcmlFcnJvckhhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgYXQgbGVhc3Qgb25lIG5hdmlnYXRpb24gaGFwcGVuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RTdWNjZXNzZnVsSWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgYnkgUm91dGVyTW9kdWxlLiBUaGlzIGFsbG93cyB1cyB0b1xuICAgICAgICAgKiBwYXVzZSB0aGUgbmF2aWdhdGlvbiBlaXRoZXIgYmVmb3JlIHByZWFjdGl2YXRpb24gb3IgYWZ0ZXIgaXQuXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob29rcyA9IHtcbiAgICAgICAgICAgIGJlZm9yZVByZWFjdGl2YXRpb246IGRlZmF1bHRSb3V0ZXJIb29rLFxuICAgICAgICAgICAgYWZ0ZXJQcmVhY3RpdmF0aW9uOiBkZWZhdWx0Um91dGVySG9va1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgYW5kIG1lcmdlcyBVUkxzLiBVc2VkIGZvciBBbmd1bGFySlMgdG8gQW5ndWxhciBtaWdyYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5ID0gbmV3IERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5KCk7XG4gICAgICAgIHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5ID0gbmV3IERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3koKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB3aGF0IHRoZSByb3V0ZXIgc2hvdWxkIGRvIGlmIGl0IHJlY2VpdmVzIGEgbmF2aWdhdGlvbiByZXF1ZXN0IHRvIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIHJvdXRlciB3aWxsIGlnbm9yZSB0aGlzIG5hdmlnYXRpb24uIEhvd2V2ZXIsIHRoaXMgcHJldmVudHMgZmVhdHVyZXMgc3VjaFxuICAgICAgICAgKiBhcyBhIFwicmVmcmVzaFwiIGJ1dHRvbi4gVXNlIHRoaXMgb3B0aW9uIHRvIGNvbmZpZ3VyZSB0aGUgYmVoYXZpb3Igd2hlbiBuYXZpZ2F0aW5nIHRvIHRoZVxuICAgICAgICAgKiBjdXJyZW50IFVSTC4gRGVmYXVsdCBpcyAnaWdub3JlJy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25TYW1lVXJsTmF2aWdhdGlvbiA9ICdpZ25vcmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBob3cgdGhlIHJvdXRlciBtZXJnZXMgcGFyYW1zLCBkYXRhIGFuZCByZXNvbHZlZCBkYXRhIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgICAgICAqIHJvdXRlcy4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGAnZW1wdHlPbmx5J2AsIHRoZSBkZWZhdWx0LCBvbmx5IGluaGVyaXRzIHBhcmVudCBwYXJhbXMgZm9yIHBhdGgtbGVzcyBvciBjb21wb25lbnQtbGVzc1xuICAgICAgICAgKiAgIHJvdXRlcy5cbiAgICAgICAgICogLSBgJ2Fsd2F5cydgLCBlbmFibGVzIHVuY29uZGl0aW9uYWwgaW5oZXJpdGFuY2Ugb2YgcGFyZW50IHBhcmFtcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9ICdlbXB0eU9ubHknO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGVuIHRoZSByb3V0ZXIgdXBkYXRlcyB0aGUgYnJvd3NlciBVUkwuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHVwZGF0ZSBhZnRlclxuICAgICAgICAgKiBzdWNjZXNzZnVsIG5hdmlnYXRpb24uIEhvd2V2ZXIsIHNvbWUgYXBwbGljYXRpb25zIG1heSBwcmVmZXIgYSBtb2RlIHdoZXJlIHRoZSBVUkwgZ2V0c1xuICAgICAgICAgKiB1cGRhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgbmF2aWdhdGlvbi4gVGhlIG1vc3QgY29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHVwZGF0aW5nIHRoZVxuICAgICAgICAgKiBVUkwgZWFybHkgc28gaWYgbmF2aWdhdGlvbiBmYWlscywgeW91IGNhbiBzaG93IGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGUgVVJMIHRoYXQgZmFpbGVkLlxuICAgICAgICAgKiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYCdkZWZlcnJlZCdgLCB0aGUgZGVmYXVsdCwgdXBkYXRlcyB0aGUgYnJvd3NlciBVUkwgYWZ0ZXIgbmF2aWdhdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICAgICAqIC0gYCdlYWdlcidgLCB1cGRhdGVzIGJyb3dzZXIgVVJMIGF0IHRoZSBiZWdpbm5pbmcgb2YgbmF2aWdhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsVXBkYXRlU3RyYXRlZ3kgPSAnZGVmZXJyZWQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIHtAbGluayBSb3V0ZXJNb2R1bGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgIHZhciBvbkxvYWRTdGFydCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy50cmlnZ2VyRXZlbnQobmV3IFJvdXRlQ29uZmlnTG9hZFN0YXJ0KHIpKTsgfTtcbiAgICAgICAgdmFyIG9uTG9hZEVuZCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy50cmlnZ2VyRXZlbnQobmV3IFJvdXRlQ29uZmlnTG9hZEVuZChyKSk7IH07XG4gICAgICAgIHRoaXMubmdNb2R1bGUgPSBpbmplY3Rvci5nZXQoTmdNb2R1bGVSZWYpO1xuICAgICAgICB0aGlzLmNvbnNvbGUgPSBpbmplY3Rvci5nZXQoybVDb25zb2xlKTtcbiAgICAgICAgdmFyIG5nWm9uZSA9IGluamVjdG9yLmdldChOZ1pvbmUpO1xuICAgICAgICB0aGlzLmlzTmdab25lRW5hYmxlZCA9IG5nWm9uZSBpbnN0YW5jZW9mIE5nWm9uZTtcbiAgICAgICAgdGhpcy5yZXNldENvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gY3JlYXRlRW1wdHlVcmxUcmVlKCk7XG4gICAgICAgIHRoaXMucmF3VXJsVHJlZSA9IHRoaXMuY3VycmVudFVybFRyZWU7XG4gICAgICAgIHRoaXMuY29uZmlnTG9hZGVyID0gbmV3IFJvdXRlckNvbmZpZ0xvYWRlcihsb2FkZXIsIGNvbXBpbGVyLCBvbkxvYWRTdGFydCwgb25Mb2FkRW5kKTtcbiAgICAgICAgdGhpcy5yb3V0ZXJTdGF0ZSA9IGNyZWF0ZUVtcHR5U3RhdGUodGhpcy5jdXJyZW50VXJsVHJlZSwgdGhpcy5yb290Q29tcG9uZW50VHlwZSk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgY3VycmVudFVybFRyZWU6IHRoaXMuY3VycmVudFVybFRyZWUsXG4gICAgICAgICAgICBjdXJyZW50UmF3VXJsOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgZXh0cmFjdGVkVXJsOiB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuZXh0cmFjdCh0aGlzLmN1cnJlbnRVcmxUcmVlKSxcbiAgICAgICAgICAgIHVybEFmdGVyUmVkaXJlY3RzOiB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuZXh0cmFjdCh0aGlzLmN1cnJlbnRVcmxUcmVlKSxcbiAgICAgICAgICAgIHJhd1VybDogdGhpcy5jdXJyZW50VXJsVHJlZSxcbiAgICAgICAgICAgIGV4dHJhczoge30sXG4gICAgICAgICAgICByZXNvbHZlOiBudWxsLFxuICAgICAgICAgICAgcmVqZWN0OiBudWxsLFxuICAgICAgICAgICAgcHJvbWlzZTogUHJvbWlzZS5yZXNvbHZlKHRydWUpLFxuICAgICAgICAgICAgc291cmNlOiAnaW1wZXJhdGl2ZScsXG4gICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRTbmFwc2hvdDogdGhpcy5yb3V0ZXJTdGF0ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgIHRhcmdldFNuYXBzaG90OiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFJvdXRlclN0YXRlOiB0aGlzLnJvdXRlclN0YXRlLFxuICAgICAgICAgICAgdGFyZ2V0Um91dGVyU3RhdGU6IG51bGwsXG4gICAgICAgICAgICBndWFyZHM6IHsgY2FuQWN0aXZhdGVDaGVja3M6IFtdLCBjYW5EZWFjdGl2YXRlQ2hlY2tzOiBbXSB9LFxuICAgICAgICAgICAgZ3VhcmRzUmVzdWx0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9ucyA9IHRoaXMuc2V0dXBOYXZpZ2F0aW9ucyh0aGlzLnRyYW5zaXRpb25zKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzTmF2aWdhdGlvbnMoKTtcbiAgICB9XG4gICAgUm91dGVyLnByb3RvdHlwZS5zZXR1cE5hdmlnYXRpb25zID0gZnVuY3Rpb24gKHRyYW5zaXRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudHNTdWJqZWN0ID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9ucy5waXBlKGZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5pZCAhPT0gMDsgfSksIFxuICAgICAgICAvLyBFeHRyYWN0IFVSTFxuICAgICAgICBtYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgdCwgeyBleHRyYWN0ZWRVcmw6IF90aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuZXh0cmFjdCh0LnJhd1VybCkgfSkpOyB9KSwgXG4gICAgICAgIC8vIFVzaW5nIHN3aXRjaE1hcCBzbyB3ZSBjYW5jZWwgZXhlY3V0aW5nIG5hdmlnYXRpb25zIHdoZW4gYSBuZXcgb25lIGNvbWVzIGluXG4gICAgICAgIHN3aXRjaE1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBvZih0KS5waXBlKHN3aXRjaE1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB1cmxUcmFuc2l0aW9uID0gIV90aGlzLm5hdmlnYXRlZCB8fCB0LmV4dHJhY3RlZFVybC50b1N0cmluZygpICE9PSBfdGhpcy5jdXJyZW50VXJsVHJlZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzQ3VycmVudFVybCA9IChfdGhpcy5vblNhbWVVcmxOYXZpZ2F0aW9uID09PSAncmVsb2FkJyA/IHRydWUgOiB1cmxUcmFuc2l0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5LnNob3VsZFByb2Nlc3NVcmwodC5yYXdVcmwpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzQ3VycmVudFVybCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YodCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIFVSTCBpZiBpbiBgZWFnZXJgIHVwZGF0ZSBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHRhcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX3RoaXMudXJsVXBkYXRlU3RyYXRlZ3kgPT09ICdlYWdlcicgJiYgIXQuZXh0cmFzLnNraXBMb2NhdGlvbkNoYW5nZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QnJvd3NlclVybCh0LnJhd1VybCwgISF0LmV4dHJhcy5yZXBsYWNlVXJsLCB0LmlkKTsgfSksIFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIE5hdmlnYXRpb25TdGFydCBldmVudFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gX3RoaXMudHJhbnNpdGlvbnMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuZXcgTmF2aWdhdGlvblN0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIHQuc291cmNlLCB0LnN0YXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNpdGlvbiAhPT0gX3RoaXMudHJhbnNpdGlvbnMuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkZWxheSBpcyByZXF1aXJlZCB0byBtYXRjaCBvbGQgYmVoYXZpb3IgdGhhdCBmb3JjZWQgbmF2aWdhdGlvbiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgYmUgYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodCk7IH0pLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHlSZWRpcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlSZWRpcmVjdHMkMShfdGhpcy5uZ01vZHVsZS5pbmplY3RvciwgX3RoaXMuY29uZmlnTG9hZGVyLCBfdGhpcy51cmxTZXJpYWxpemVyLCBfdGhpcy5jb25maWcpLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb2duaXplXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZSQxKF90aGlzLnJvb3RDb21wb25lbnRUeXBlLCBfdGhpcy5jb25maWcsIGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLnNlcmlhbGl6ZVVybCh1cmwpOyB9LCBfdGhpcy5wYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCBfdGhpcy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSwgXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgUm91dGVzUmVjb2duaXplZFxuICAgICAgICAgICAgICAgICAgICB0YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZXNSZWNvZ25pemVkID0gbmV3IFJvdXRlc1JlY29nbml6ZWQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMpLCB0LnRhcmdldFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChyb3V0ZXNSZWNvZ25pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NQcmV2aW91c1VybCA9IHVybFRyYW5zaXRpb24gJiYgX3RoaXMucmF3VXJsVHJlZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXJsSGFuZGxpbmdTdHJhdGVneS5zaG91bGRQcm9jZXNzVXJsKF90aGlzLnJhd1VybFRyZWUpO1xuICAgICAgICAgICAgICAgICAgICAvKiBXaGVuIHRoZSBjdXJyZW50IFVSTCBzaG91bGRuJ3QgYmUgcHJvY2Vzc2VkLCBidXQgdGhlIHByZXZpb3VzIG9uZSB3YXMsIHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGhhbmRsZSB0aGlzIFwiZXJyb3IgY29uZGl0aW9uXCIgYnkgbmF2aWdhdGluZyB0byB0aGUgcHJldmlvdXNseSBzdWNjZXNzZnVsIFVSTCxcbiAgICAgICAgICAgICAgICAgICAgICogYnV0IGxlYXZpbmcgdGhlIFVSTCBpbnRhY3QuKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NQcmV2aW91c1VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdC5pZCwgZXh0cmFjdGVkVXJsID0gdC5leHRyYWN0ZWRVcmwsIHNvdXJjZSA9IHQuc291cmNlLCBzdGF0ZSA9IHQuc3RhdGUsIGV4dHJhcyA9IHQuZXh0cmFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdlN0YXJ0ID0gbmV3IE5hdmlnYXRpb25TdGFydChpZCwgX3RoaXMuc2VyaWFsaXplVXJsKGV4dHJhY3RlZFVybCksIHNvdXJjZSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KG5hdlN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IGNyZWF0ZUVtcHR5U3RhdGUoZXh0cmFjdGVkVXJsLCBfdGhpcy5yb290Q29tcG9uZW50VHlwZSkuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YoX19hc3NpZ24oe30sIHQsIHsgdGFyZ2V0U25hcHNob3Q6IHRhcmdldFNuYXBzaG90LCB1cmxBZnRlclJlZGlyZWN0czogZXh0cmFjdGVkVXJsLCBleHRyYXM6IF9fYXNzaWduKHt9LCBleHRyYXMsIHsgc2tpcExvY2F0aW9uQ2hhbmdlOiBmYWxzZSwgcmVwbGFjZVVybDogZmFsc2UgfSkgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogV2hlbiBuZWl0aGVyIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIFVSTCBjYW4gYmUgcHJvY2Vzc2VkLCBkbyBub3RoaW5nIG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGFuIHVwZGF0ZSByb3V0ZXIncyBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgXCJzZXR0bGVkXCIgVVJMLiBUaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3YXkgdGhlIG5leHQgbmF2aWdhdGlvbiB3aWxsIGJlIGNvbWluZyBmcm9tIHRoZSBjdXJyZW50IFVSTCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmF3VXJsVHJlZSA9IHQucmF3VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLy8gQmVmb3JlIFByZWFjdGl2YXRpb25cbiAgICAgICAgICAgIHN3aXRjaFRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IHQudGFyZ2V0U25hcHNob3QsIG5hdmlnYXRpb25JZCA9IHQuaWQsIGFwcGxpZWRVcmxUcmVlID0gdC5leHRyYWN0ZWRVcmwsIHJhd1VybFRyZWUgPSB0LnJhd1VybCwgX2EgPSB0LmV4dHJhcywgc2tpcExvY2F0aW9uQ2hhbmdlID0gX2Euc2tpcExvY2F0aW9uQ2hhbmdlLCByZXBsYWNlVXJsID0gX2EucmVwbGFjZVVybDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaG9va3MuYmVmb3JlUHJlYWN0aXZhdGlvbih0YXJnZXRTbmFwc2hvdCwge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWQ6IG5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFVybFRyZWU6IGFwcGxpZWRVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICByYXdVcmxUcmVlOiByYXdVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwTG9jYXRpb25DaGFuZ2U6ICEhc2tpcExvY2F0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlVXJsOiAhIXJlcGxhY2VVcmwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAvLyAtLS0gR1VBUkRTIC0tLVxuICAgICAgICAgICAgdGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkc1N0YXJ0ID0gbmV3IEd1YXJkc0NoZWNrU3RhcnQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMpLCB0LnRhcmdldFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoZ3VhcmRzU3RhcnQpO1xuICAgICAgICAgICAgfSksIG1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCB0LCB7IGd1YXJkczogZ2V0QWxsUm91dGVHdWFyZHModC50YXJnZXRTbmFwc2hvdCwgdC5jdXJyZW50U25hcHNob3QsIF90aGlzLnJvb3RDb250ZXh0cykgfSkpOyB9KSwgY2hlY2tHdWFyZHMoX3RoaXMubmdNb2R1bGUuaW5qZWN0b3IsIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnRyaWdnZXJFdmVudChldnQpOyB9KSwgdGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkc0VuZCA9IG5ldyBHdWFyZHNDaGVja0VuZCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwodC51cmxBZnRlclJlZGlyZWN0cyksIHQudGFyZ2V0U25hcHNob3QsICEhdC5ndWFyZHNSZXN1bHQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChndWFyZHNFbmQpO1xuICAgICAgICAgICAgfSksIGZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGlmICghdC5ndWFyZHNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzZXRVcmxUb0N1cnJlbnRVcmxUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZDYW5jZWwgPSBuZXcgTmF2aWdhdGlvbkNhbmNlbCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuYXZDYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICB0LnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLy8gLS0tIFJFU09MVkUgLS0tXG4gICAgICAgICAgICBzd2l0Y2hUYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodC5ndWFyZHMuY2FuQWN0aXZhdGVDaGVja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZih0KS5waXBlKHRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVTdGFydCA9IG5ldyBSZXNvbHZlU3RhcnQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMpLCB0LnRhcmdldFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChyZXNvbHZlU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzb2x2ZURhdGEoX3RoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgX3RoaXMubmdNb2R1bGUuaW5qZWN0b3IpLCAvL1xuICAgICAgICAgICAgICAgICAgICB0YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlRW5kID0gbmV3IFJlc29sdmVFbmQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKHQudXJsQWZ0ZXJSZWRpcmVjdHMpLCB0LnRhcmdldFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChyZXNvbHZlRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLy8gLS0tIEFGVEVSIFBSRUFDVElWQVRJT04gLS0tXG4gICAgICAgICAgICBzd2l0Y2hUYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBuYXZpZ2F0aW9uSWQgPSB0LmlkLCBhcHBsaWVkVXJsVHJlZSA9IHQuZXh0cmFjdGVkVXJsLCByYXdVcmxUcmVlID0gdC5yYXdVcmwsIF9hID0gdC5leHRyYXMsIHNraXBMb2NhdGlvbkNoYW5nZSA9IF9hLnNraXBMb2NhdGlvbkNoYW5nZSwgcmVwbGFjZVVybCA9IF9hLnJlcGxhY2VVcmw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhvb2tzLmFmdGVyUHJlYWN0aXZhdGlvbih0YXJnZXRTbmFwc2hvdCwge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWQ6IG5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFVybFRyZWU6IGFwcGxpZWRVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICByYXdVcmxUcmVlOiByYXdVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICBza2lwTG9jYXRpb25DaGFuZ2U6ICEhc2tpcExvY2F0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlVXJsOiAhIXJlcGxhY2VVcmwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgbWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFJvdXRlclN0YXRlID0gY3JlYXRlUm91dGVyU3RhdGUoX3RoaXMucm91dGVSZXVzZVN0cmF0ZWd5LCB0LnRhcmdldFNuYXBzaG90LCB0LmN1cnJlbnRSb3V0ZXJTdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbih7fSwgdCwgeyB0YXJnZXRSb3V0ZXJTdGF0ZTogdGFyZ2V0Um91dGVyU3RhdGUgfSkpO1xuICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgLyogT25jZSBoZXJlLCB3ZSBhcmUgYWJvdXQgdG8gYWN0aXZhdGUgc3luY3Jvbm91c2x5LiBUaGUgYXNzdW1wdGlvbiBpcyB0aGlzIHdpbGxcbiAgICAgICAgICAgICAgIHN1Y2NlZWQsIGFuZCB1c2VyIGNvZGUgbWF5IHJlYWQgZnJvbSB0aGUgUm91dGVyIHNlcnZpY2UuIFRoZXJlZm9yZSBiZWZvcmVcbiAgICAgICAgICAgICAgIGFjdGl2YXRpb24sIHdlIG5lZWQgdG8gdXBkYXRlIHJvdXRlciBwcm9wZXJ0aWVzIHN0b3JpbmcgdGhlIGN1cnJlbnQgVVJMIGFuZCB0aGVcbiAgICAgICAgICAgICAgIFJvdXRlclN0YXRlLCBhcyB3ZWxsIGFzIHVwZGF0ZWQgdGhlIGJyb3dzZXIgVVJMLiBBbGwgdGhpcyBzaG91bGQgaGFwcGVuICpiZWZvcmUqXG4gICAgICAgICAgICAgICBhY3RpdmF0aW5nLiAqL1xuICAgICAgICAgICAgdGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFVybFRyZWUgPSB0LnVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgICAgIF90aGlzLnJhd1VybFRyZWUgPSBfdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5Lm1lcmdlKF90aGlzLmN1cnJlbnRVcmxUcmVlLCB0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucm91dGVyU3RhdGUgPSB0LnRhcmdldFJvdXRlclN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51cmxVcGRhdGVTdHJhdGVneSA9PT0gJ2RlZmVycmVkJyAmJiAhdC5leHRyYXMuc2tpcExvY2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEJyb3dzZXJVcmwoX3RoaXMucmF3VXJsVHJlZSwgISF0LmV4dHJhcy5yZXBsYWNlVXJsLCB0LmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgYWN0aXZhdGVSb3V0ZXMoX3RoaXMucm9vdENvbnRleHRzLCBfdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3ksIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnRyaWdnZXJFdmVudChldnQpOyB9KSwgdGFwKHsgbmV4dDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZWQgPSB0cnVlOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZWQgPSB0cnVlOyB9IH0pLCBmaW5hbGl6ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLyogV2hlbiB0aGUgbmF2aWdhdGlvbiBzdHJlYW0gZmluaXNoZXMgZWl0aGVyIHRocm91Z2ggZXJyb3Igb3Igc3VjY2Vzcywgd2Ugc2V0IHRoZVxuICAgICAgICAgICAgICAgICAqIGBjb21wbGV0ZWRgIG9yIGBlcnJvcmVkYCBmbGFnLiBIb3dldmVyLCB0aGVyZSBhcmUgc29tZSBzaXR1YXRpb25zIHdoZXJlIHdlIGNvdWxkXG4gICAgICAgICAgICAgICAgICogZ2V0IGhlcmUgd2l0aG91dCBlaXRoZXIgb2YgdGhvc2UgYmVpbmcgc2V0LiBGb3IgaW5zdGFuY2UsIGEgcmVkaXJlY3QgZHVyaW5nXG4gICAgICAgICAgICAgICAgICogTmF2aWdhdGlvblN0YXJ0LiBUaGVyZWZvcmUsIHRoaXMgaXMgYSBjYXRjaC1hbGwgdG8gbWFrZSBzdXJlIHRoZSBOYXZpZ2F0aW9uQ2FuY2VsXG4gICAgICAgICAgICAgICAgICogZXZlbnQgaXMgZmlyZWQgd2hlbiBhIG5hdmlnYXRpb24gZ2V0cyBjYW5jZWxsZWQgYnV0IG5vdCBjYXVnaHQgYnkgb3RoZXIgbWVhbnMuICovXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGV0ZWQgJiYgIWVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCByZXNldCB0byBjdXJyZW50IFVSTCB0cmVlIGhlcmUgdG8gZW5zdXJlIGhpc3Rvcnkuc3RhdGUgaXMgc2V0LiBPbiBhIGZyZXNoXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2UgbG9hZCwgaWYgYSBuZXcgbmF2aWdhdGlvbiBjb21lcyBpbiBiZWZvcmUgYSBzdWNjZXNzZnVsIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVzLCB0aGVyZSB3aWxsIGJlIG5vdGhpbmcgaW4gaGlzdG9yeS5zdGF0ZS5uYXZpZ2F0aW9uSWQuIFRoaXMgY2FuIGNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bmMgcHJvYmxlbXMgd2l0aCBBbmd1bGFySlMgc3luYyBjb2RlIHdoaWNoIGxvb2tzIGZvciBhIHZhbHVlIGhlcmUgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGhhbmRsZSBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IG9yIHRvIGxlYXZlIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBBbmd1YWxyIHJvdXRlci5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzZXRVcmxUb0N1cnJlbnRVcmxUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZDYW5jZWwgPSBuZXcgTmF2aWdhdGlvbkNhbmNlbCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBcIk5hdmlnYXRpb24gSUQgXCIgKyB0LmlkICsgXCIgaXMgbm90IGVxdWFsIHRvIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gaWQgXCIgKyBfdGhpcy5uYXZpZ2F0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2Q2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgY2F0Y2hFcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qIFRoaXMgZXJyb3IgdHlwZSBpcyBpc3N1ZWQgZHVyaW5nIFJlZGlyZWN0LCBhbmQgaXMgaGFuZGxlZCBhcyBhIGNhbmNlbGxhdGlvblxuICAgICAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGFuIGVycm9yLiAqL1xuICAgICAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25DYW5jZWxpbmdFcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNldFN0YXRlQW5kVXJsKHQuY3VycmVudFJvdXRlclN0YXRlLCB0LmN1cnJlbnRVcmxUcmVlLCB0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZDYW5jZWwgPSBuZXcgTmF2aWdhdGlvbkNhbmNlbCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2Q2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgLyogQWxsIG90aGVyIGVycm9ycyBzaG91bGQgcmVzZXQgdG8gdGhlIHJvdXRlcidzIGludGVybmFsIFVSTCByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHByZS1lcnJvciBzdGF0ZS4gKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0U3RhdGVBbmRVcmwodC5jdXJyZW50Um91dGVyU3RhdGUsIHQuY3VycmVudFVybFRyZWUsIHQucmF3VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdkVycm9yID0gbmV3IE5hdmlnYXRpb25FcnJvcih0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KG5hdkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzb2x2ZShfdGhpcy5lcnJvckhhbmRsZXIoZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZWplY3QoZWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFRPRE8oamFzb25hZGVuKTogcmVtb3ZlIGNhc3Qgb25jZSBnMyBpcyBvbiB1cGRhdGVkIFR5cGVTY3JpcHRcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogVE9ETzogdGhpcyBzaG91bGQgYmUgcmVtb3ZlZCBvbmNlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgcm91dGVyIG1hZGUgaW50ZXJuYWxcbiAgICAgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0Um9vdENvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAocm9vdENvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5yb290Q29tcG9uZW50VHlwZSA9IHJvb3RDb21wb25lbnRUeXBlO1xuICAgICAgICAvLyBUT0RPOiB2c2F2a2luIHJvdXRlciA0LjAgc2hvdWxkIG1ha2UgdGhlIHJvb3QgY29tcG9uZW50IHNldCB0byBudWxsXG4gICAgICAgIC8vIHRoaXMgd2lsbCBzaW1wbGlmeSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByb3V0ZXIuXG4gICAgICAgIHRoaXMucm91dGVyU3RhdGUucm9vdC5jb21wb25lbnQgPSB0aGlzLnJvb3RDb21wb25lbnRUeXBlO1xuICAgIH07XG4gICAgUm91dGVyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy52YWx1ZTsgfTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zLm5leHQoX19hc3NpZ24oe30sIHRoaXMuZ2V0VHJhbnNpdGlvbigpLCB0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBsb2NhdGlvbiBjaGFuZ2UgbGlzdGVuZXIgYW5kIHBlcmZvcm1zIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXG4gICAgICovXG4gICAgUm91dGVyLnByb3RvdHlwZS5pbml0aWFsTmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRVcExvY2F0aW9uQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbklkID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpLCB7IHJlcGxhY2VVcmw6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGxvY2F0aW9uIGNoYW5nZSBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB1c2UgWm9uZS53cmFwIGFueSBtb3JlLCBiZWNhdXNlIHpvbmUuanNcbiAgICAgICAgLy8gYWxyZWFkeSBwYXRjaCBvblBvcFN0YXRlLCBzbyBsb2NhdGlvbiBjaGFuZ2UgY2FsbGJhY2sgd2lsbFxuICAgICAgICAvLyBydW4gaW50byBuZ1pvbmVcbiAgICAgICAgaWYgKCF0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciByYXdVcmxUcmVlID0gX3RoaXMucGFyc2VVcmwoY2hhbmdlWyd1cmwnXSk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGNoYW5nZVsndHlwZSddID09PSAncG9wc3RhdGUnID8gJ3BvcHN0YXRlJyA6ICdoYXNoY2hhbmdlJztcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBjaGFuZ2Uuc3RhdGUgJiYgY2hhbmdlLnN0YXRlLm5hdmlnYXRpb25JZCA/XG4gICAgICAgICAgICAgICAgICAgIHsgbmF2aWdhdGlvbklkOiBjaGFuZ2Uuc3RhdGUubmF2aWdhdGlvbklkIH0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBfdGhpcy5zY2hlZHVsZU5hdmlnYXRpb24ocmF3VXJsVHJlZSwgc291cmNlLCBzdGF0ZSwgeyByZXBsYWNlVXJsOiB0cnVlIH0pOyB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgdXJsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zZXJpYWxpemVVcmwodGhpcy5jdXJyZW50VXJsVHJlZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudCkgeyB0aGlzLmV2ZW50cy5uZXh0KGV2ZW50KTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNvbmZpZ3VyYXRpb24gdXNlZCBmb3IgbmF2aWdhdGlvbiBhbmQgZ2VuZXJhdGluZyBsaW5rcy5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogcm91dGVyLnJlc2V0Q29uZmlnKFtcbiAgICAgKiAgeyBwYXRoOiAndGVhbS86aWQnLCBjb21wb25lbnQ6IFRlYW1DbXAsIGNoaWxkcmVuOiBbXG4gICAgICogICAgeyBwYXRoOiAnc2ltcGxlJywgY29tcG9uZW50OiBTaW1wbGVDbXAgfSxcbiAgICAgKiAgICB7IHBhdGg6ICd1c2VyLzpuYW1lJywgY29tcG9uZW50OiBVc2VyQ21wIH1cbiAgICAgKiAgXX1cbiAgICAgKiBdKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YWxpZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZy5tYXAoc3RhbmRhcmRpemVDb25maWcpO1xuICAgICAgICB0aGlzLm5hdmlnYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RTdWNjZXNzZnVsSWQgPSAtMTtcbiAgICB9O1xuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgUm91dGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXNwb3NlKCk7IH07XG4gICAgLyoqIERpc3Bvc2VzIG9mIHRoZSByb3V0ZXIgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbiBhcnJheSBvZiBjb21tYW5kcyB0byB0aGUgY3VycmVudCB1cmwgdHJlZSBhbmQgY3JlYXRlcyBhIG5ldyB1cmwgdHJlZS5cbiAgICAgKlxuICAgICAqIFdoZW4gZ2l2ZW4gYW4gYWN0aXZhdGUgcm91dGUsIGFwcGxpZXMgdGhlIGdpdmVuIGNvbW1hbmRzIHN0YXJ0aW5nIGZyb20gdGhlIHJvdXRlLlxuICAgICAqIFdoZW4gbm90IGdpdmVuIGEgcm91dGUsIGFwcGxpZXMgdGhlIGdpdmVuIGNvbW1hbmQgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gY3JlYXRlIC90ZWFtLzMzL3VzZXIvMTFcbiAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy90ZWFtJywgMzMsICd1c2VyJywgMTFdKTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSAvdGVhbS8zMztleHBhbmQ9dHJ1ZS91c2VyLzExXG4gICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbScsIDMzLCB7ZXhwYW5kOiB0cnVlfSwgJ3VzZXInLCAxMV0pO1xuICAgICAqXG4gICAgICogLy8geW91IGNhbiBjb2xsYXBzZSBzdGF0aWMgc2VnbWVudHMgbGlrZSB0aGlzICh0aGlzIHdvcmtzIG9ubHkgd2l0aCB0aGUgZmlyc3QgcGFzc2VkLWluIHZhbHVlKTpcbiAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy90ZWFtLzMzL3VzZXInLCB1c2VySWRdKTtcbiAgICAgKlxuICAgICAqIC8vIElmIHRoZSBmaXJzdCBzZWdtZW50IGNhbiBjb250YWluIHNsYXNoZXMsIGFuZCB5b3UgZG8gbm90IHdhbnQgdGhlIHJvdXRlciB0byBzcGxpdCBpdCwgeW91XG4gICAgICogLy8gY2FuIGRvIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbe3NlZ21lbnRQYXRoOiAnL29uZS90d28nfV0pO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIC90ZWFtLzMzLyh1c2VyLzExLy9yaWdodDpjaGF0KVxuICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiAnY2hhdCd9fV0pO1xuICAgICAqXG4gICAgICogLy8gcmVtb3ZlIHRoZSByaWdodCBzZWNvbmRhcnkgbm9kZVxuICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiBudWxsfX1dKTtcbiAgICAgKlxuICAgICAqIC8vIGFzc3VtaW5nIHRoZSBjdXJyZW50IHVybCBpcyBgL3RlYW0vMzMvdXNlci8xMWAgYW5kIHRoZSByb3V0ZSBwb2ludHMgdG8gYHVzZXIvMTFgXG4gICAgICpcbiAgICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS8zMy91c2VyLzExL2RldGFpbHNcbiAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJ2RldGFpbHMnXSwge3JlbGF0aXZlVG86IHJvdXRlfSk7XG4gICAgICpcbiAgICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS8zMy91c2VyLzIyXG4gICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycuLi8yMiddLCB7cmVsYXRpdmVUbzogcm91dGV9KTtcbiAgICAgKlxuICAgICAqIC8vIG5hdmlnYXRlIHRvIC90ZWFtLzQ0L3VzZXIvMjJcbiAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy4uLy4uL3RlYW0vNDQvdXNlci8yMiddLCB7cmVsYXRpdmVUbzogcm91dGV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSb3V0ZXIucHJvdG90eXBlLmNyZWF0ZVVybFRyZWUgPSBmdW5jdGlvbiAoY29tbWFuZHMsIG5hdmlnYXRpb25FeHRyYXMpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRpb25FeHRyYXMgPT09IHZvaWQgMCkgeyBuYXZpZ2F0aW9uRXh0cmFzID0ge307IH1cbiAgICAgICAgdmFyIHJlbGF0aXZlVG8gPSBuYXZpZ2F0aW9uRXh0cmFzLnJlbGF0aXZlVG8sIHF1ZXJ5UGFyYW1zID0gbmF2aWdhdGlvbkV4dHJhcy5xdWVyeVBhcmFtcywgZnJhZ21lbnQgPSBuYXZpZ2F0aW9uRXh0cmFzLmZyYWdtZW50LCBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zID0gbmF2aWdhdGlvbkV4dHJhcy5wcmVzZXJ2ZVF1ZXJ5UGFyYW1zLCBxdWVyeVBhcmFtc0hhbmRsaW5nID0gbmF2aWdhdGlvbkV4dHJhcy5xdWVyeVBhcmFtc0hhbmRsaW5nLCBwcmVzZXJ2ZUZyYWdtZW50ID0gbmF2aWdhdGlvbkV4dHJhcy5wcmVzZXJ2ZUZyYWdtZW50O1xuICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgcHJlc2VydmVRdWVyeVBhcmFtcyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdwcmVzZXJ2ZVF1ZXJ5UGFyYW1zIGlzIGRlcHJlY2F0ZWQsIHVzZSBxdWVyeVBhcmFtc0hhbmRsaW5nIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSByZWxhdGl2ZVRvIHx8IHRoaXMucm91dGVyU3RhdGUucm9vdDtcbiAgICAgICAgdmFyIGYgPSBwcmVzZXJ2ZUZyYWdtZW50ID8gdGhpcy5jdXJyZW50VXJsVHJlZS5mcmFnbWVudCA6IGZyYWdtZW50O1xuICAgICAgICB2YXIgcSA9IG51bGw7XG4gICAgICAgIGlmIChxdWVyeVBhcmFtc0hhbmRsaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHF1ZXJ5UGFyYW1zSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtZXJnZSc6XG4gICAgICAgICAgICAgICAgICAgIHEgPSBfX2Fzc2lnbih7fSwgdGhpcy5jdXJyZW50VXJsVHJlZS5xdWVyeVBhcmFtcywgcXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVzZXJ2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHEgPSB0aGlzLmN1cnJlbnRVcmxUcmVlLnF1ZXJ5UGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBxID0gcXVlcnlQYXJhbXMgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHEgPSBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zID8gdGhpcy5jdXJyZW50VXJsVHJlZS5xdWVyeVBhcmFtcyA6IHF1ZXJ5UGFyYW1zIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHEgPSB0aGlzLnJlbW92ZUVtcHR5UHJvcHMocSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVVybFRyZWUoYSwgdGhpcy5jdXJyZW50VXJsVHJlZSwgY29tbWFuZHMsIHEsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHVybC4gVGhpcyBuYXZpZ2F0aW9uIGlzIGFsd2F5cyBhYnNvbHV0ZS5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQ6XG4gICAgICogLSByZXNvbHZlcyB0byAndHJ1ZScgd2hlbiBuYXZpZ2F0aW9uIHN1Y2NlZWRzLFxuICAgICAqIC0gcmVzb2x2ZXMgdG8gJ2ZhbHNlJyB3aGVuIG5hdmlnYXRpb24gZmFpbHMsXG4gICAgICogLSBpcyByZWplY3RlZCB3aGVuIGFuIGVycm9yIGhhcHBlbnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFwiL3RlYW0vMzMvdXNlci8xMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIE5hdmlnYXRlIHdpdGhvdXQgdXBkYXRpbmcgdGhlIFVSTFxuICAgICAqIHJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFwiL3RlYW0vMzMvdXNlci8xMVwiLCB7IHNraXBMb2NhdGlvbkNoYW5nZTogdHJ1ZSB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNpbmNlIGBuYXZpZ2F0ZUJ5VXJsKClgIHRha2VzIGFuIGFic29sdXRlIFVSTCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLFxuICAgICAqIGl0IHdpbGwgbm90IGFwcGx5IGFueSBkZWx0YSB0byB0aGUgY3VycmVudCBVUkwgYW5kIGlnbm9yZXMgYW55IHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciAodGhlIGBOYXZpZ2F0aW9uRXh0cmFzYCkgdGhhdCB3b3VsZCBjaGFuZ2UgdGhlXG4gICAgICogcHJvdmlkZWQgVVJMLlxuICAgICAqL1xuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGVCeVVybCA9IGZ1bmN0aW9uICh1cmwsIGV4dHJhcykge1xuICAgICAgICBpZiAoZXh0cmFzID09PSB2b2lkIDApIHsgZXh0cmFzID0geyBza2lwTG9jYXRpb25DaGFuZ2U6IGZhbHNlIH07IH1cbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpICYmIHRoaXMuaXNOZ1pvbmVFbmFibGVkICYmICFOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc29sZS53YXJuKFwiTmF2aWdhdGlvbiB0cmlnZ2VyZWQgb3V0c2lkZSBBbmd1bGFyIHpvbmUsIGRpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgJ25nWm9uZS5ydW4oKSc/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmxUcmVlID0gdXJsIGluc3RhbmNlb2YgVXJsVHJlZSA/IHVybCA6IHRoaXMucGFyc2VVcmwodXJsKTtcbiAgICAgICAgdmFyIG1lcmdlZFRyZWUgPSB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kubWVyZ2UodXJsVHJlZSwgdGhpcy5yYXdVcmxUcmVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKG1lcmdlZFRyZWUsICdpbXBlcmF0aXZlJywgbnVsbCwgZXh0cmFzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcnJheSBvZiBjb21tYW5kcyBhbmQgYSBzdGFydGluZyBwb2ludC5cbiAgICAgKiBJZiBubyBzdGFydGluZyByb3V0ZSBpcyBwcm92aWRlZCwgdGhlIG5hdmlnYXRpb24gaXMgYWJzb2x1dGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0OlxuICAgICAqIC0gcmVzb2x2ZXMgdG8gJ3RydWUnIHdoZW4gbmF2aWdhdGlvbiBzdWNjZWVkcyxcbiAgICAgKiAtIHJlc29sdmVzIHRvICdmYWxzZScgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzLFxuICAgICAqIC0gaXMgcmVqZWN0ZWQgd2hlbiBhbiBlcnJvciBoYXBwZW5zLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiByb3V0ZXIubmF2aWdhdGUoWyd0ZWFtJywgMzMsICd1c2VyJywgMTFdLCB7cmVsYXRpdmVUbzogcm91dGV9KTtcbiAgICAgKlxuICAgICAqIC8vIE5hdmlnYXRlIHdpdGhvdXQgdXBkYXRpbmcgdGhlIFVSTFxuICAgICAqIHJvdXRlci5uYXZpZ2F0ZShbJ3RlYW0nLCAzMywgJ3VzZXInLCAxMV0sIHtyZWxhdGl2ZVRvOiByb3V0ZSwgc2tpcExvY2F0aW9uQ2hhbmdlOiB0cnVlfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgcGFyYW1ldGVyIG9mIGBuYXZpZ2F0ZSgpYCBpcyBhIGRlbHRhIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgVVJMXG4gICAgICogb3IgdGhlIG9uZSBwcm92aWRlZCBpbiB0aGUgYHJlbGF0aXZlVG9gIHByb3BlcnR5IG9mIHRoZSBzZWNvbmQgcGFyYW1ldGVyICh0aGVcbiAgICAgKiBgTmF2aWdhdGlvbkV4dHJhc2ApLlxuICAgICAqL1xuICAgIFJvdXRlci5wcm90b3R5cGUubmF2aWdhdGUgPSBmdW5jdGlvbiAoY29tbWFuZHMsIGV4dHJhcykge1xuICAgICAgICBpZiAoZXh0cmFzID09PSB2b2lkIDApIHsgZXh0cmFzID0geyBza2lwTG9jYXRpb25DaGFuZ2U6IGZhbHNlIH07IH1cbiAgICAgICAgdmFsaWRhdGVDb21tYW5kcyhjb21tYW5kcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5jcmVhdGVVcmxUcmVlKGNvbW1hbmRzLCBleHRyYXMpLCBleHRyYXMpO1xuICAgIH07XG4gICAgLyoqIFNlcmlhbGl6ZXMgYSBgVXJsVHJlZWAgaW50byBhIHN0cmluZyAqL1xuICAgIFJvdXRlci5wcm90b3R5cGUuc2VyaWFsaXplVXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh1cmwpOyB9O1xuICAgIC8qKiBQYXJzZXMgYSBzdHJpbmcgaW50byBhIGBVcmxUcmVlYCAqL1xuICAgIFJvdXRlci5wcm90b3R5cGUucGFyc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciB1cmxUcmVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsVHJlZSA9IHRoaXMudXJsU2VyaWFsaXplci5wYXJzZSh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1cmxUcmVlID0gdGhpcy5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIoZSwgdGhpcy51cmxTZXJpYWxpemVyLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxUcmVlO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIGlzIGFjdGl2YXRlZCAqL1xuICAgIFJvdXRlci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAodXJsLCBleGFjdCkge1xuICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgVXJsVHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zVHJlZSh0aGlzLmN1cnJlbnRVcmxUcmVlLCB1cmwsIGV4YWN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsVHJlZSA9IHRoaXMucGFyc2VVcmwodXJsKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zVHJlZSh0aGlzLmN1cnJlbnRVcmxUcmVlLCB1cmxUcmVlLCBleGFjdCk7XG4gICAgfTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlbW92ZUVtcHR5UHJvcHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgUm91dGVyLnByb3RvdHlwZS5wcm9jZXNzTmF2aWdhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbnMuc3Vic2NyaWJlKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMubGFzdFN1Y2Nlc3NmdWxJZCA9IHQuaWQ7XG4gICAgICAgICAgICBfdGhpcy5ldmVudHNcbiAgICAgICAgICAgICAgICAubmV4dChuZXcgTmF2aWdhdGlvbkVuZCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwoX3RoaXMuY3VycmVudFVybFRyZWUpKSk7XG4gICAgICAgICAgICB0LnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7IF90aGlzLmNvbnNvbGUud2FybihcIlVuaGFuZGxlZCBOYXZpZ2F0aW9uIEVycm9yOiBcIik7IH0pO1xuICAgIH07XG4gICAgUm91dGVyLnByb3RvdHlwZS5zY2hlZHVsZU5hdmlnYXRpb24gPSBmdW5jdGlvbiAocmF3VXJsLCBzb3VyY2UsIHN0YXRlLCBleHRyYXMpIHtcbiAgICAgICAgdmFyIGxhc3ROYXZpZ2F0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKCk7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHRyaWdnZXJzIGEgbmF2aWdhdGlvbiBpbXBlcmF0aXZlbHkgKGUuZy4sIGJ5IHVzaW5nIG5hdmlnYXRlQnlVcmwpLFxuICAgICAgICAvLyBhbmQgdGhhdCBuYXZpZ2F0aW9uIHJlc3VsdHMgaW4gJ3JlcGxhY2VTdGF0ZScgdGhhdCBsZWFkcyB0byB0aGUgc2FtZSBVUkwsXG4gICAgICAgIC8vIHdlIHNob3VsZCBza2lwIHRob3NlLlxuICAgICAgICBpZiAobGFzdE5hdmlnYXRpb24gJiYgc291cmNlICE9PSAnaW1wZXJhdGl2ZScgJiYgbGFzdE5hdmlnYXRpb24uc291cmNlID09PSAnaW1wZXJhdGl2ZScgJiZcbiAgICAgICAgICAgIGxhc3ROYXZpZ2F0aW9uLnJhd1VybC50b1N0cmluZygpID09PSByYXdVcmwudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgLy8gcmV0dXJuIHZhbHVlIGlzIG5vdCB1c2VkXG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRSBhbmQgRWRnZSwgdGhlIGxvY2F0aW9uIGNsYXNzIGZpcmVzIHR3byBldmVudHMgKHBvcHN0YXRlIGFuZFxuICAgICAgICAvLyBoYXNoY2hhbmdlKSBldmVyeSBzaW5nbGUgdGltZS4gVGhlIHNlY29uZCBvbmUgc2hvdWxkIGJlIGlnbm9yZWQuIE90aGVyd2lzZSwgdGhlIFVSTCB3aWxsXG4gICAgICAgIC8vIGZsaWNrZXIuIEhhbmRsZXMgdGhlIGNhc2Ugd2hlbiBhIHBvcHN0YXRlIHdhcyBlbWl0dGVkIGZpcnN0LlxuICAgICAgICBpZiAobGFzdE5hdmlnYXRpb24gJiYgc291cmNlID09ICdoYXNoY2hhbmdlJyAmJiBsYXN0TmF2aWdhdGlvbi5zb3VyY2UgPT09ICdwb3BzdGF0ZScgJiZcbiAgICAgICAgICAgIGxhc3ROYXZpZ2F0aW9uLnJhd1VybC50b1N0cmluZygpID09PSByYXdVcmwudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgLy8gcmV0dXJuIHZhbHVlIGlzIG5vdCB1c2VkXG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRSBhbmQgRWRnZSwgdGhlIGxvY2F0aW9uIGNsYXNzIGZpcmVzIHR3byBldmVudHMgKHBvcHN0YXRlIGFuZFxuICAgICAgICAvLyBoYXNoY2hhbmdlKSBldmVyeSBzaW5nbGUgdGltZS4gVGhlIHNlY29uZCBvbmUgc2hvdWxkIGJlIGlnbm9yZWQuIE90aGVyd2lzZSwgdGhlIFVSTCB3aWxsXG4gICAgICAgIC8vIGZsaWNrZXIuIEhhbmRsZXMgdGhlIGNhc2Ugd2hlbiBhIGhhc2hjaGFuZ2Ugd2FzIGVtaXR0ZWQgZmlyc3QuXG4gICAgICAgIGlmIChsYXN0TmF2aWdhdGlvbiAmJiBzb3VyY2UgPT0gJ3BvcHN0YXRlJyAmJiBsYXN0TmF2aWdhdGlvbi5zb3VyY2UgPT09ICdoYXNoY2hhbmdlJyAmJlxuICAgICAgICAgICAgbGFzdE5hdmlnYXRpb24ucmF3VXJsLnRvU3RyaW5nKCkgPT09IHJhd1VybC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpOyAvLyByZXR1cm4gdmFsdWUgaXMgbm90IHVzZWRcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHZhciByZWplY3QgPSBudWxsO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpZCA9ICsrdGhpcy5uYXZpZ2F0aW9uSWQ7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbih7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRVcmxUcmVlOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgY3VycmVudFJhd1VybDogdGhpcy5yYXdVcmxUcmVlLCByYXdVcmw6IHJhd1VybCwgZXh0cmFzOiBleHRyYXMsIHJlc29sdmU6IHJlc29sdmUsIHJlamVjdDogcmVqZWN0LCBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgY3VycmVudFNuYXBzaG90OiB0aGlzLnJvdXRlclN0YXRlLnNuYXBzaG90LFxuICAgICAgICAgICAgY3VycmVudFJvdXRlclN0YXRlOiB0aGlzLnJvdXRlclN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgcHJvcGFnYXRlZCBldmVuIHRob3VnaCBgcHJvY2Vzc05hdmlnYXRpb25zYCBjYXRjaFxuICAgICAgICAvLyBoYW5kbGVyIGRvZXMgbm90IHJldGhyb3dcbiAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9KTtcbiAgICB9O1xuICAgIFJvdXRlci5wcm90b3R5cGUuc2V0QnJvd3NlclVybCA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2VVcmwsIGlkKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh1cmwpO1xuICAgICAgICBpZiAodGhpcy5sb2NhdGlvbi5pc0N1cnJlbnRQYXRoRXF1YWxUbyhwYXRoKSB8fCByZXBsYWNlVXJsKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2VTdGF0ZShwYXRoLCAnJywgeyBuYXZpZ2F0aW9uSWQ6IGlkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5nbyhwYXRoLCAnJywgeyBuYXZpZ2F0aW9uSWQ6IGlkIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0U3RhdGVBbmRVcmwgPSBmdW5jdGlvbiAoc3RvcmVkU3RhdGUsIHN0b3JlZFVybCwgcmF3VXJsKSB7XG4gICAgICAgIHRoaXMucm91dGVyU3RhdGUgPSBzdG9yZWRTdGF0ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VXJsVHJlZSA9IHN0b3JlZFVybDtcbiAgICAgICAgdGhpcy5yYXdVcmxUcmVlID0gdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5Lm1lcmdlKHRoaXMuY3VycmVudFVybFRyZWUsIHJhd1VybCk7XG4gICAgICAgIHRoaXMucmVzZXRVcmxUb0N1cnJlbnRVcmxUcmVlKCk7XG4gICAgfTtcbiAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlU3RhdGUodGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLnJhd1VybFRyZWUpLCAnJywgeyBuYXZpZ2F0aW9uSWQ6IHRoaXMubGFzdFN1Y2Nlc3NmdWxJZCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSb3V0ZXI7XG59KCkpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21tYW5kcyhjb21tYW5kcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgcGF0aCBjb250YWlucyBcIiArIGNtZCArIFwiIHNlZ21lbnQgYXQgaW5kZXggXCIgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBMZXRzIHlvdSBsaW5rIHRvIHNwZWNpZmljIHJvdXRlcyBpbiB5b3VyIGFwcC5cbiAqXG4gKiBDb25zaWRlciB0aGUgZm9sbG93aW5nIHJvdXRlIGNvbmZpZ3VyYXRpb246XG4gKiBgW3sgcGF0aDogJ3VzZXIvOm5hbWUnLCBjb21wb25lbnQ6IFVzZXJDbXAgfV1gLlxuICogV2hlbiBsaW5raW5nIHRvIHRoaXMgYHVzZXIvOm5hbWVgIHJvdXRlLCB5b3UgdXNlIHRoZSBgUm91dGVyTGlua2AgZGlyZWN0aXZlLlxuICpcbiAqIElmIHRoZSBsaW5rIGlzIHN0YXRpYywgeW91IGNhbiB1c2UgdGhlIGRpcmVjdGl2ZSBhcyBmb2xsb3dzOlxuICogYDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIj5saW5rIHRvIHVzZXIgY29tcG9uZW50PC9hPmBcbiAqXG4gKiBJZiB5b3UgdXNlIGR5bmFtaWMgdmFsdWVzIHRvIGdlbmVyYXRlIHRoZSBsaW5rLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgb2YgcGF0aFxuICogc2VnbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBwYXJhbXMgZm9yIGVhY2ggc2VnbWVudC5cbiAqXG4gKiBGb3IgaW5zdGFuY2UgYFsnL3RlYW0nLCB0ZWFtSWQsICd1c2VyJywgdXNlck5hbWUsIHtkZXRhaWxzOiB0cnVlfV1gXG4gKiBtZWFucyB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgYSBsaW5rIHRvIGAvdGVhbS8xMS91c2VyL2JvYjtkZXRhaWxzPXRydWVgLlxuICpcbiAqIE11bHRpcGxlIHN0YXRpYyBzZWdtZW50cyBjYW4gYmUgbWVyZ2VkIGludG8gb25lXG4gKiAoZS5nLiwgYFsnL3RlYW0vMTEvdXNlcicsIHVzZXJOYW1lLCB7ZGV0YWlsczogdHJ1ZX1dYCkuXG4gKlxuICogVGhlIGZpcnN0IHNlZ21lbnQgbmFtZSBjYW4gYmUgcHJlcGVuZGVkIHdpdGggYC9gLCBgLi9gLCBvciBgLi4vYDpcbiAqICogSWYgdGhlIGZpcnN0IHNlZ21lbnQgYmVnaW5zIHdpdGggYC9gLCB0aGUgcm91dGVyIHdpbGwgbG9vayB1cCB0aGUgcm91dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGVcbiAqICAgYXBwLlxuICogKiBJZiB0aGUgZmlyc3Qgc2VnbWVudCBiZWdpbnMgd2l0aCBgLi9gLCBvciBkb2Vzbid0IGJlZ2luIHdpdGggYSBzbGFzaCwgdGhlIHJvdXRlciB3aWxsXG4gKiAgIGluc3RlYWQgbG9vayBpbiB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgYWN0aXZhdGVkIHJvdXRlLlxuICogKiBBbmQgaWYgdGhlIGZpcnN0IHNlZ21lbnQgYmVnaW5zIHdpdGggYC4uL2AsIHRoZSByb3V0ZXIgd2lsbCBnbyB1cCBvbmUgbGV2ZWwuXG4gKlxuICogWW91IGNhbiBzZXQgcXVlcnkgcGFyYW1zIGFuZCBmcmFnbWVudCBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYFxuICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgZnJhZ21lbnQ9XCJlZHVjYXRpb25cIj5cbiAqICAgbGluayB0byB1c2VyIGNvbXBvbmVudFxuICogPC9hPlxuICogYGBgXG4gKiBSb3V0ZXJMaW5rIHdpbGwgdXNlIHRoZXNlIHRvIGdlbmVyYXRlIHRoaXMgbGluazogYC91c2VyL2JvYiNlZHVjYXRpb24/ZGVidWc9dHJ1ZWAuXG4gKlxuICogKERlcHJlY2F0ZWQgaW4gdjQuMC4wIHVzZSBgcXVlcnlQYXJhbXNIYW5kbGluZ2AgaW5zdGVhZCkgWW91IGNhbiBhbHNvIHRlbGwgdGhlXG4gKiBkaXJlY3RpdmUgdG8gcHJlc2VydmUgdGhlIGN1cnJlbnQgcXVlcnkgcGFyYW1zIGFuZCBmcmFnbWVudDpcbiAqXG4gKiBgYGBcbiAqIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3VzZXIvYm9iJ11cIiBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zIHByZXNlcnZlRnJhZ21lbnQ+XG4gKiAgIGxpbmsgdG8gdXNlciBjb21wb25lbnRcbiAqIDwvYT5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gdGVsbCB0aGUgZGlyZWN0aXZlIHRvIGhvdyB0byBoYW5kbGUgcXVlcnlQYXJhbXMsIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAqICAtIGAnbWVyZ2UnYDogbWVyZ2UgdGhlIHF1ZXJ5UGFyYW1zIGludG8gdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXNcbiAqICAtIGAncHJlc2VydmUnYDogcHJlc2VydmUgdGhlIGN1cnJlbnQgcXVlcnlQYXJhbXNcbiAqICAtIGRlZmF1bHQvYCcnYDogdXNlIHRoZSBxdWVyeVBhcmFtcyBvbmx5XG4gKlxuICogU2FtZSBvcHRpb25zIGZvciB7QGxpbmsgTmF2aWdhdGlvbkV4dHJhcyNxdWVyeVBhcmFtc0hhbmRsaW5nXG4gKiBOYXZpZ2F0aW9uRXh0cmFzI3F1ZXJ5UGFyYW1zSGFuZGxpbmd9LlxuICpcbiAqIGBgYFxuICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgcXVlcnlQYXJhbXNIYW5kbGluZz1cIm1lcmdlXCI+XG4gKiAgIGxpbmsgdG8gdXNlciBjb21wb25lbnRcbiAqIDwvYT5cbiAqIGBgYFxuICpcbiAqIFRoZSByb3V0ZXIgbGluayBkaXJlY3RpdmUgYWx3YXlzIHRyZWF0cyB0aGUgcHJvdmlkZWQgaW5wdXQgYXMgYSBkZWx0YSB0byB0aGUgY3VycmVudCB1cmwuXG4gKlxuICogRm9yIGluc3RhbmNlLCBpZiB0aGUgY3VycmVudCB1cmwgaXMgYC91c2VyLyhib3gvL2F1eDp0ZWFtKWAuXG4gKlxuICogVGhlbiB0aGUgZm9sbG93aW5nIGxpbmsgYDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3VzZXIvamltJ11cIj5KaW08L2E+YCB3aWxsIGdlbmVyYXRlIHRoZSBsaW5rXG4gKiBgL3VzZXIvKGppbS8vYXV4OnRlYW0pYC5cbiAqXG4gKiBTZWUge0BsaW5rIFJvdXRlciNjcmVhdGVVcmxUcmVlIGNyZWF0ZVVybFRyZWV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSb3V0ZXJMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmsocm91dGVyLCByb3V0ZSwgdGFiSW5kZXgsIHJlbmRlcmVyLCBlbCkge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWwubmF0aXZlRWxlbWVudCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyTGluay5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICAgICAgICAgICBpZiAoY29tbWFuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmRzKSA/IGNvbW1hbmRzIDogW2NvbW1hbmRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmsucHJvdG90eXBlLCBcInByZXNlcnZlUXVlcnlQYXJhbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgNC4wLjAgdXNlIGBxdWVyeVBhcmFtc0hhbmRsaW5nYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJlc2VydmVRdWVyeVBhcmFtcyBpcyBkZXByZWNhdGVkISwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlc2VydmUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUm91dGVyTGluay5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4dHJhcyA9IHtcbiAgICAgICAgICAgIHNraXBMb2NhdGlvbkNoYW5nZTogYXR0ckJvb2xWYWx1ZSh0aGlzLnNraXBMb2NhdGlvbkNoYW5nZSksXG4gICAgICAgICAgICByZXBsYWNlVXJsOiBhdHRyQm9vbFZhbHVlKHRoaXMucmVwbGFjZVVybCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGhpcy51cmxUcmVlLCBleHRyYXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJ1cmxUcmVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIuY3JlYXRlVXJsVHJlZSh0aGlzLmNvbW1hbmRzLCB7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5yb3V0ZSxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogdGhpcy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBmcmFnbWVudDogdGhpcy5mcmFnbWVudCxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zOiBhdHRyQm9vbFZhbHVlKHRoaXMucHJlc2VydmUpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zSGFuZGxpbmc6IHRoaXMucXVlcnlQYXJhbXNIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUZyYWdtZW50OiBhdHRyQm9vbFZhbHVlKHRoaXMucHJlc2VydmVGcmFnbWVudCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwicXVlcnlQYXJhbXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJmcmFnbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zSGFuZGxpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwicHJlc2VydmVGcmFnbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJza2lwTG9jYXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwicmVwbGFjZVVybFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJvdXRlckxpbmtcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbiAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG4gICAgUm91dGVyTGluayA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJzpub3QoYSlbcm91dGVyTGlua10nIH0pLFxuICAgICAgICBfX3BhcmFtKDIsIEF0dHJpYnV0ZSgndGFiaW5kZXgnKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm91dGVyLCBBY3RpdmF0ZWRSb3V0ZSwgU3RyaW5nLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWZdKVxuICAgIF0sIFJvdXRlckxpbmspO1xuICAgIHJldHVybiBSb3V0ZXJMaW5rO1xufSgpKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTGV0cyB5b3UgbGluayB0byBzcGVjaWZpYyByb3V0ZXMgaW4geW91ciBhcHAuXG4gKlxuICogU2VlIGBSb3V0ZXJMaW5rYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAbmdNb2R1bGUgUm91dGVyTW9kdWxlXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUm91dGVyTGlua1dpdGhIcmVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtXaXRoSHJlZihyb3V0ZXIsIHJvdXRlLCBsb2NhdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMubG9jYXRpb25TdHJhdGVneSA9IGxvY2F0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVGFyZ2V0VXJsQW5kSHJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNvbW1hbmRzKSB7XG4gICAgICAgICAgICBpZiAoY29tbWFuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmRzKSA/IGNvbW1hbmRzIDogW2NvbW1hbmRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicHJlc2VydmVRdWVyeVBhcmFtc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3ByZXNlcnZlUXVlcnlQYXJhbXMgaXMgZGVwcmVjYXRlZCwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJlc2VydmUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHRoaXMudXBkYXRlVGFyZ2V0VXJsQW5kSHJlZigpOyB9O1xuICAgIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGJ1dHRvbiwgY3RybEtleSwgbWV0YUtleSwgc2hpZnRLZXkpIHtcbiAgICAgICAgaWYgKGJ1dHRvbiAhPT0gMCB8fCBjdHJsS2V5IHx8IG1ldGFLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICdzdHJpbmcnICYmIHRoaXMudGFyZ2V0ICE9ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHRyYXMgPSB7XG4gICAgICAgICAgICBza2lwTG9jYXRpb25DaGFuZ2U6IGF0dHJCb29sVmFsdWUodGhpcy5za2lwTG9jYXRpb25DaGFuZ2UpLFxuICAgICAgICAgICAgcmVwbGFjZVVybDogYXR0ckJvb2xWYWx1ZSh0aGlzLnJlcGxhY2VVcmwpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHRoaXMudXJsVHJlZSwgZXh0cmFzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS51cGRhdGVUYXJnZXRVcmxBbmRIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmxvY2F0aW9uU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHRoaXMucm91dGVyLnNlcmlhbGl6ZVVybCh0aGlzLnVybFRyZWUpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInVybFRyZWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jcmVhdGVVcmxUcmVlKHRoaXMuY29tbWFuZHMsIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB0aGlzLnJvdXRlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB0aGlzLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgIHByZXNlcnZlUXVlcnlQYXJhbXM6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZSksXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNIYW5kbGluZzogdGhpcy5xdWVyeVBhcmFtc0hhbmRsaW5nLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlRnJhZ21lbnQ6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZUZyYWdtZW50KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdEJpbmRpbmcoJ2F0dHIudGFyZ2V0JyksIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJmcmFnbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicXVlcnlQYXJhbXNIYW5kbGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInByZXNlcnZlRnJhZ21lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJza2lwTG9jYXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJyZXBsYWNlVXJsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RCaW5kaW5nKCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJocmVmXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQuYnV0dG9uJywgJyRldmVudC5jdHJsS2V5JywgJyRldmVudC5tZXRhS2V5JywgJyRldmVudC5zaGlmdEtleSddKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXIsIEJvb2xlYW4sIEJvb2xlYW4sIEJvb2xlYW5dKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuICAgIFJvdXRlckxpbmtXaXRoSHJlZiA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Fbcm91dGVyTGlua10nIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgQWN0aXZhdGVkUm91dGUsXG4gICAgICAgICAgICBMb2NhdGlvblN0cmF0ZWd5XSlcbiAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYpO1xuICAgIHJldHVybiBSb3V0ZXJMaW5rV2l0aEhyZWY7XG59KCkpO1xuZnVuY3Rpb24gYXR0ckJvb2xWYWx1ZShzKSB7XG4gICAgcmV0dXJuIHMgPT09ICcnIHx8ICEhcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogTGV0cyB5b3UgYWRkIGEgQ1NTIGNsYXNzIHRvIGFuIGVsZW1lbnQgd2hlbiB0aGUgbGluaydzIHJvdXRlIGJlY29tZXMgYWN0aXZlLlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGxldHMgeW91IGFkZCBhIENTUyBjbGFzcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlIGxpbmsncyByb3V0ZVxuICogYmVjb21lcyBhY3RpdmUuXG4gKlxuICogQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBleGFtcGxlOlxuICpcbiAqIGBgYFxuICogPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiIHJvdXRlckxpbmtBY3RpdmU9XCJhY3RpdmUtbGlua1wiPkJvYjwvYT5cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIHVybCBpcyBlaXRoZXIgJy91c2VyJyBvciAnL3VzZXIvYm9iJywgdGhlIGFjdGl2ZS1saW5rIGNsYXNzIHdpbGxcbiAqIGJlIGFkZGVkIHRvIHRoZSBgYWAgdGFnLiBJZiB0aGUgdXJsIGNoYW5nZXMsIHRoZSBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuXG4gKlxuICogWW91IGNhbiBzZXQgbW9yZSB0aGFuIG9uZSBjbGFzcywgYXMgZm9sbG93czpcbiAqXG4gKiBgYGBcbiAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiByb3V0ZXJMaW5rQWN0aXZlPVwiY2xhc3MxIGNsYXNzMlwiPkJvYjwvYT5cbiAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiBbcm91dGVyTGlua0FjdGl2ZV09XCJbJ2NsYXNzMScsICdjbGFzczInXVwiPkJvYjwvYT5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gY29uZmlndXJlIFJvdXRlckxpbmtBY3RpdmUgYnkgcGFzc2luZyBgZXhhY3Q6IHRydWVgLiBUaGlzIHdpbGwgYWRkIHRoZSBjbGFzc2VzXG4gKiBvbmx5IHdoZW4gdGhlIHVybCBtYXRjaGVzIHRoZSBsaW5rIGV4YWN0bHkuXG4gKlxuICogYGBgXG4gKiA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvYm9iXCIgcm91dGVyTGlua0FjdGl2ZT1cImFjdGl2ZS1saW5rXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cIntleGFjdDpcbiAqIHRydWV9XCI+Qm9iPC9hPlxuICogYGBgXG4gKlxuICogWW91IGNhbiBhc3NpZ24gdGhlIFJvdXRlckxpbmtBY3RpdmUgaW5zdGFuY2UgdG8gYSB0ZW1wbGF0ZSB2YXJpYWJsZSBhbmQgZGlyZWN0bHkgY2hlY2tcbiAqIHRoZSBgaXNBY3RpdmVgIHN0YXR1cy5cbiAqIGBgYFxuICogPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiIHJvdXRlckxpbmtBY3RpdmUgI3JsYT1cInJvdXRlckxpbmtBY3RpdmVcIj5cbiAqICAgQm9iIHt7IHJsYS5pc0FjdGl2ZSA/ICcoYWxyZWFkeSBvcGVuKScgOiAnJ319XG4gKiA8L2E+XG4gKiBgYGBcbiAqXG4gKiBGaW5hbGx5LCB5b3UgY2FuIGFwcGx5IHRoZSBSb3V0ZXJMaW5rQWN0aXZlIGRpcmVjdGl2ZSB0byBhbiBhbmNlc3RvciBvZiBhIFJvdXRlckxpbmsuXG4gKlxuICogYGBgXG4gKiA8ZGl2IHJvdXRlckxpbmtBY3RpdmU9XCJhY3RpdmUtbGlua1wiIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XCJ7ZXhhY3Q6IHRydWV9XCI+XG4gKiAgIDxhIHJvdXRlckxpbms9XCIvdXNlci9qaW1cIj5KaW08L2E+XG4gKiAgIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIj5Cb2I8L2E+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFRoaXMgd2lsbCBzZXQgdGhlIGFjdGl2ZS1saW5rIGNsYXNzIG9uIHRoZSBkaXYgdGFnIGlmIHRoZSB1cmwgaXMgZWl0aGVyICcvdXNlci9qaW0nIG9yXG4gKiAnL3VzZXIvYm9iJy5cbiAqXG4gKiBAbmdNb2R1bGUgUm91dGVyTW9kdWxlXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUm91dGVyTGlua0FjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJMaW5rQWN0aXZlKHJvdXRlciwgZWxlbWVudCwgcmVuZGVyZXIsIGNkcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNkciA9IGNkcjtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3V0ZXJMaW5rQWN0aXZlT3B0aW9ucyA9IHsgZXhhY3Q6IGZhbHNlIH07XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzIGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxpbmtzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XG4gICAgICAgIHRoaXMubGlua3NXaXRoSHJlZnMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IGRhdGEuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhIWM7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHRoaXMudXBkYXRlKCk7IH07XG4gICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMubGlua3MgfHwgIXRoaXMubGlua3NXaXRoSHJlZnMgfHwgIXRoaXMucm91dGVyLm5hdmlnYXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFzQWN0aXZlTGlua3MgPSBfdGhpcy5oYXNBY3RpdmVMaW5rcygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzQWN0aXZlICE9PSBoYXNBY3RpdmVMaW5rcykge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gaGFzQWN0aXZlTGlua3M7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNBY3RpdmVMaW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIuYWRkQ2xhc3MoX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKF90aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZS5pc0xpbmtBY3RpdmUgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5pc0FjdGl2ZShsaW5rLnVybFRyZWUsIF90aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zLmV4YWN0KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLmhhc0FjdGl2ZUxpbmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rcy5zb21lKHRoaXMuaXNMaW5rQWN0aXZlKHRoaXMucm91dGVyKSkgfHxcbiAgICAgICAgICAgIHRoaXMubGlua3NXaXRoSHJlZnMuc29tZSh0aGlzLmlzTGlua0FjdGl2ZSh0aGlzLnJvdXRlcikpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZHJlbihSb3V0ZXJMaW5rLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuICAgIF0sIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLCBcImxpbmtzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZHJlbihSb3V0ZXJMaW5rV2l0aEhyZWYsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG4gICAgXSwgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUsIFwibGlua3NXaXRoSHJlZnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgIF0sIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLCBcInJvdXRlckxpbmtBY3RpdmVcIiwgbnVsbCk7XG4gICAgUm91dGVyTGlua0FjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBEaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbcm91dGVyTGlua0FjdGl2ZV0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdyb3V0ZXJMaW5rQWN0aXZlJyxcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm91dGVyLCBFbGVtZW50UmVmLCBSZW5kZXJlcjIsXG4gICAgICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgUm91dGVyTGlua0FjdGl2ZSk7XG4gICAgcmV0dXJuIFJvdXRlckxpbmtBY3RpdmU7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFN0b3JlIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgYSBgUm91dGVyT3V0bGV0YFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIE91dGxldENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3V0bGV0Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5vdXRsZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnJvdXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cygpO1xuICAgICAgICB0aGlzLmF0dGFjaFJlZiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPdXRsZXRDb250ZXh0O1xufSgpKTtcbi8qKlxuICogU3RvcmUgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGRyZW4gKD0gbmVzdGVkKSBgUm91dGVyT3V0bGV0YFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIENoaWxkcmVuT3V0bGV0Q29udGV4dHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cygpIHtcbiAgICAgICAgLy8gY29udGV4dHMgZm9yIGNoaWxkIG91dGxldHMsIGJ5IG5hbWUuXG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgd2hlbiBhIGBSb3V0ZXJPdXRsZXRgIGRpcmVjdGl2ZSBpcyBpbnN0YW50aWF0ZWQgKi9cbiAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5vbkNoaWxkT3V0bGV0Q3JlYXRlZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIG91dGxldCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0T3JDcmVhdGVDb250ZXh0KGNoaWxkTmFtZSk7XG4gICAgICAgIGNvbnRleHQub3V0bGV0ID0gb3V0bGV0O1xuICAgICAgICB0aGlzLmNvbnRleHRzLnNldChjaGlsZE5hbWUsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBgUm91dGVyT3V0bGV0YCBkaXJlY3RpdmUgaXMgZGVzdHJveWVkLlxuICAgICAqIFdlIG5lZWQgdG8ga2VlcCB0aGUgY29udGV4dCBhcyB0aGUgb3V0bGV0IGNvdWxkIGJlIGRlc3Ryb3llZCBpbnNpZGUgYSBOZ0lmIGFuZCBtaWdodCBiZVxuICAgICAqIHJlLWNyZWF0ZWQgbGF0ZXIuXG4gICAgICovXG4gICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUub25DaGlsZE91dGxldERlc3Ryb3llZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY2hpbGROYW1lKTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQub3V0bGV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgcm91dGUgaXMgZGVhY3RpdmF0ZWQgZHVyaW5nIG5hdmlnYXRpb24uXG4gICAgICogQmVjYXVzZSB0aGUgY29tcG9uZW50IGdldCBkZXN0cm95ZWQsIGFsbCBjaGlsZHJlbiBvdXRsZXQgYXJlIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5vbk91dGxldERlYWN0aXZhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gY29udGV4dHM7XG4gICAgfTtcbiAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5vbk91dGxldFJlQXR0YWNoZWQgPSBmdW5jdGlvbiAoY29udGV4dHMpIHsgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzOyB9O1xuICAgIENoaWxkcmVuT3V0bGV0Q29udGV4dHMucHJvdG90eXBlLmdldE9yQ3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY2hpbGROYW1lKTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gbmV3IE91dGxldENvbnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc2V0KGNoaWxkTmFtZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfTtcbiAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkgeyByZXR1cm4gdGhpcy5jb250ZXh0cy5nZXQoY2hpbGROYW1lKSB8fCBudWxsOyB9O1xuICAgIHJldHVybiBDaGlsZHJlbk91dGxldENvbnRleHRzO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBBY3RzIGFzIGEgcGxhY2Vob2xkZXIgdGhhdCBBbmd1bGFyIGR5bmFtaWNhbGx5IGZpbGxzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZS5cbiAqXG4gKiBgYGBcbiAqIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cbiAqIDxyb3V0ZXItb3V0bGV0IG5hbWU9J2xlZnQnPjwvcm91dGVyLW91dGxldD5cbiAqIDxyb3V0ZXItb3V0bGV0IG5hbWU9J3JpZ2h0Jz48L3JvdXRlci1vdXRsZXQ+XG4gKiBgYGBcbiAqXG4gKiBBIHJvdXRlciBvdXRsZXQgd2lsbCBlbWl0IGFuIGFjdGl2YXRlIGV2ZW50IGFueSB0aW1lIGEgbmV3IGNvbXBvbmVudCBpcyBiZWluZyBpbnN0YW50aWF0ZWQsXG4gKiBhbmQgYSBkZWFjdGl2YXRlIGV2ZW50IHdoZW4gaXQgaXMgYmVpbmcgZGVzdHJveWVkLlxuICpcbiAqIGBgYFxuICogPHJvdXRlci1vdXRsZXRcbiAqICAgKGFjdGl2YXRlKT0nb25BY3RpdmF0ZSgkZXZlbnQpJ1xuICogICAoZGVhY3RpdmF0ZSk9J29uRGVhY3RpdmF0ZSgkZXZlbnQpJz48L3JvdXRlci1vdXRsZXQ+XG4gKiBgYGBcbiAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBSb3V0ZXJPdXRsZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVyT3V0bGV0KHBhcmVudENvbnRleHRzLCBsb2NhdGlvbiwgcmVzb2x2ZXIsIG5hbWUsIGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Q29udGV4dHMgPSBwYXJlbnRDb250ZXh0cztcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVFdmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCBQUklNQVJZX09VVExFVDtcbiAgICAgICAgcGFyZW50Q29udGV4dHMub25DaGlsZE91dGxldENyZWF0ZWQodGhpcy5uYW1lLCB0aGlzKTtcbiAgICB9XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wYXJlbnRDb250ZXh0cy5vbkNoaWxkT3V0bGV0RGVzdHJveWVkKHRoaXMubmFtZSk7IH07XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG91dGxldCB3YXMgbm90IGluc3RhbnRpYXRlZCBhdCB0aGUgdGltZSB0aGUgcm91dGUgZ290IGFjdGl2YXRlZCB3ZSBuZWVkIHRvIHBvcHVsYXRlXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGV0IHdoZW4gaXQgaXMgaW5pdGlhbGl6ZWQgKGllIGluc2lkZSBhIE5nSWYpXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucGFyZW50Q29udGV4dHMuZ2V0Q29udGV4dCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5yb3V0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmF0dGFjaFJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBgYXR0YWNoUmVmYCBpcyBwb3B1bGF0ZWQgd2hlbiB0aGVyZSBpcyBhbiBleGlzdGluZyBjb21wb25lbnQgdG8gbW91bnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goY29udGV4dC5hdHRhY2hSZWYsIGNvbnRleHQucm91dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgZGVmaW5lZCBpbiB0aGUgY29uZmlndXJhdGlvbiBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVXaXRoKGNvbnRleHQucm91dGUsIGNvbnRleHQucmVzb2x2ZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJpc0FjdGl2YXRlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmFjdGl2YXRlZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0bGV0IGlzIG5vdCBhY3RpdmF0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZC5pbnN0YW5jZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiYWN0aXZhdGVkUm91dGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmF0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRsZXQgaXMgbm90IGFjdGl2YXRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2YXRlZFJvdXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJhY3RpdmF0ZWRSb3V0ZURhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmF0ZWRSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmF0ZWRSb3V0ZS5zbmFwc2hvdC5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYFJvdXRlUmV1c2VTdHJhdGVneWAgaW5zdHJ1Y3RzIHRvIGRldGFjaCB0aGUgc3VidHJlZVxuICAgICAqL1xuICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRsZXQgaXMgbm90IGFjdGl2YXRlZCcpO1xuICAgICAgICB0aGlzLmxvY2F0aW9uLmRldGFjaCgpO1xuICAgICAgICB2YXIgY21wID0gdGhpcy5hY3RpdmF0ZWQ7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gY21wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGBSb3V0ZVJldXNlU3RyYXRlZ3lgIGluc3RydWN0cyB0byByZS1hdHRhY2ggYSBwcmV2aW91c2x5IGRldGFjaGVkIHN1YnRyZWVcbiAgICAgKi9cbiAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChyZWYsIGFjdGl2YXRlZFJvdXRlKSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gcmVmO1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uLmluc2VydChyZWYuaG9zdFZpZXcpO1xuICAgIH07XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVFdmVudHMuZW1pdChjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5hY3RpdmF0ZVdpdGggPSBmdW5jdGlvbiAoYWN0aXZhdGVkUm91dGUsIHJlc29sdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY3RpdmF0ZSBhbiBhbHJlYWR5IGFjdGl2YXRlZCBvdXRsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuICAgICAgICB2YXIgc25hcHNob3QgPSBhY3RpdmF0ZWRSb3V0ZS5fZnV0dXJlU25hcHNob3Q7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBzbmFwc2hvdC5yb3V0ZUNvbmZpZy5jb21wb25lbnQ7XG4gICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZXIgfHwgdGhpcy5yZXNvbHZlcjtcbiAgICAgICAgdmFyIGZhY3RvcnkgPSByZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuICAgICAgICB2YXIgY2hpbGRDb250ZXh0cyA9IHRoaXMucGFyZW50Q29udGV4dHMuZ2V0T3JDcmVhdGVDb250ZXh0KHRoaXMubmFtZSkuY2hpbGRyZW47XG4gICAgICAgIHZhciBpbmplY3RvciA9IG5ldyBPdXRsZXRJbmplY3RvcihhY3RpdmF0ZWRSb3V0ZSwgY2hpbGRDb250ZXh0cywgdGhpcy5sb2NhdGlvbi5pbmplY3Rvcik7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gdGhpcy5sb2NhdGlvbi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSwgdGhpcy5sb2NhdGlvbi5sZW5ndGgsIGluamVjdG9yKTtcbiAgICAgICAgLy8gQ2FsbGluZyBgbWFya0ZvckNoZWNrYCB0byBtYWtlIHN1cmUgd2Ugd2lsbCBydW4gdGhlIGNoYW5nZSBkZXRlY3Rpb24gd2hlbiB0aGVcbiAgICAgICAgLy8gYFJvdXRlck91dGxldGAgaXMgaW5zaWRlIGEgYENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaGAgY29tcG9uZW50LlxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlRXZlbnRzLmVtaXQodGhpcy5hY3RpdmF0ZWQuaW5zdGFuY2UpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgnYWN0aXZhdGUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlRXZlbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgnZGVhY3RpdmF0ZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZUV2ZW50c1wiLCB2b2lkIDApO1xuICAgIFJvdXRlck91dGxldCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ3JvdXRlci1vdXRsZXQnLCBleHBvcnRBczogJ291dGxldCcgfSksXG4gICAgICAgIF9fcGFyYW0oMywgQXR0cmlidXRlKCduYW1lJykpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoaWxkcmVuT3V0bGV0Q29udGV4dHMsIFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIFN0cmluZywgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgIF0sIFJvdXRlck91dGxldCk7XG4gICAgcmV0dXJuIFJvdXRlck91dGxldDtcbn0oKSk7XG52YXIgT3V0bGV0SW5qZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3V0bGV0SW5qZWN0b3Iocm91dGUsIGNoaWxkQ29udGV4dHMsIHBhcmVudCkge1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMuY2hpbGRDb250ZXh0cyA9IGNoaWxkQ29udGV4dHM7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBPdXRsZXRJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gQWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gQ2hpbGRyZW5PdXRsZXRDb250ZXh0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDb250ZXh0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRsZXRJbmplY3Rvcjtcbn0oKSk7XG5cbi8qKlxuKkBsaWNlbnNlXG4qQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4qXG4qVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbipmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4qL1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBQcm92aWRlcyBhIHByZWxvYWRpbmcgc3RyYXRlZ3kuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUHJlbG9hZGluZ1N0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZWxvYWRpbmdTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFByZWxvYWRpbmdTdHJhdGVneTtcbn0oKSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFByb3ZpZGVzIGEgcHJlbG9hZGluZyBzdHJhdGVneSB0aGF0IHByZWxvYWRzIGFsbCBtb2R1bGVzIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gKlxuICogYGBgXG4gKiBSb3V0ZU1vZHVsZS5mb3JSb290KFJPVVRFUywge3ByZWxvYWRpbmdTdHJhdGVneTogUHJlbG9hZEFsbE1vZHVsZXN9KVxuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUHJlbG9hZEFsbE1vZHVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlbG9hZEFsbE1vZHVsZXMoKSB7XG4gICAgfVxuICAgIFByZWxvYWRBbGxNb2R1bGVzLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKHJvdXRlLCBmbikge1xuICAgICAgICByZXR1cm4gZm4oKS5waXBlKGNhdGNoRXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gb2YobnVsbCk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVsb2FkQWxsTW9kdWxlcztcbn0oKSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFByb3ZpZGVzIGEgcHJlbG9hZGluZyBzdHJhdGVneSB0aGF0IGRvZXMgbm90IHByZWxvYWQgYW55IG1vZHVsZXMuXG4gKlxuICogVGhpcyBzdHJhdGVneSBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgTm9QcmVsb2FkaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vUHJlbG9hZGluZygpIHtcbiAgICB9XG4gICAgTm9QcmVsb2FkaW5nLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKHJvdXRlLCBmbikgeyByZXR1cm4gb2YobnVsbCk7IH07XG4gICAgcmV0dXJuIE5vUHJlbG9hZGluZztcbn0oKSk7XG4vKipcbiAqIFRoZSBwcmVsb2FkZXIgb3B0aW1pc3RpY2FsbHkgbG9hZHMgYWxsIHJvdXRlciBjb25maWd1cmF0aW9ucyB0b1xuICogbWFrZSBuYXZpZ2F0aW9ucyBpbnRvIGxhemlseS1sb2FkZWQgc2VjdGlvbnMgb2YgdGhlIGFwcGxpY2F0aW9uIGZhc3Rlci5cbiAqXG4gKiBUaGUgcHJlbG9hZGVyIHJ1bnMgaW4gdGhlIGJhY2tncm91bmQuIFdoZW4gdGhlIHJvdXRlciBib290c3RyYXBzLCB0aGUgcHJlbG9hZGVyXG4gKiBzdGFydHMgbGlzdGVuaW5nIHRvIGFsbCBuYXZpZ2F0aW9uIGV2ZW50cy4gQWZ0ZXIgZXZlcnkgc3VjaCBldmVudCwgdGhlIHByZWxvYWRlclxuICogd2lsbCBjaGVjayBpZiBhbnkgY29uZmlndXJhdGlvbnMgY2FuIGJlIGxvYWRlZCBsYXppbHkuXG4gKlxuICogSWYgYSByb3V0ZSBpcyBwcm90ZWN0ZWQgYnkgYGNhbkxvYWRgIGd1YXJkcywgdGhlIHByZWxvYWRlZCB3aWxsIG5vdCBsb2FkIGl0LlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFJvdXRlclByZWxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJQcmVsb2FkZXIocm91dGVyLCBtb2R1bGVMb2FkZXIsIGNvbXBpbGVyLCBpbmplY3RvciwgcHJlbG9hZGluZ1N0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMucHJlbG9hZGluZ1N0cmF0ZWd5ID0gcHJlbG9hZGluZ1N0cmF0ZWd5O1xuICAgICAgICB2YXIgb25TdGFydExvYWQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcm91dGVyLnRyaWdnZXJFdmVudChuZXcgUm91dGVDb25maWdMb2FkU3RhcnQocikpOyB9O1xuICAgICAgICB2YXIgb25FbmRMb2FkID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJvdXRlci50cmlnZ2VyRXZlbnQobmV3IFJvdXRlQ29uZmlnTG9hZEVuZChyKSk7IH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJvdXRlckNvbmZpZ0xvYWRlcihtb2R1bGVMb2FkZXIsIGNvbXBpbGVyLCBvblN0YXJ0TG9hZCwgb25FbmRMb2FkKTtcbiAgICB9XG4gICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5zZXRVcFByZWxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgIHRoaXMucm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQ7IH0pLCBjb25jYXRNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJlbG9hZCgpOyB9KSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgfTtcbiAgICBSb3V0ZXJQcmVsb2FkZXIucHJvdG90eXBlLnByZWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZ01vZHVsZSA9IHRoaXMuaW5qZWN0b3IuZ2V0KE5nTW9kdWxlUmVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1JvdXRlcyhuZ01vZHVsZSwgdGhpcy5yb3V0ZXIuY29uZmlnKTtcbiAgICB9O1xuICAgIC8vIFRPRE8oamFzb25hZGVuKTogVGhpcyBjbGFzcyByZWxpZXMgb24gY29kZSBleHRlcm5hbCB0byB0aGUgY2xhc3MgdG8gY2FsbCBzZXRVcFByZWxvYWRpbmcuIElmXG4gICAgLy8gdGhpcyBoYXNuJ3QgYmVlbiBkb25lLCBuZ09uRGVzdHJveSB3aWxsIGZhaWwgYXMgdGhpcy5zdWJzY3JpcHRpb24gd2lsbCBiZSB1bmRlZmluZWQuIFRoaXNcbiAgICAvLyBzaG91bGQgYmUgcmVmYWN0b3JlZC5cbiAgICBSb3V0ZXJQcmVsb2FkZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUucHJvY2Vzc1JvdXRlcyA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGVzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3V0ZXNfMSA9IF9fdmFsdWVzKHJvdXRlcyksIHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCk7ICFyb3V0ZXNfMV8xLmRvbmU7IHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSB0aGUgY29uZmlnIGxvYWRlZCwganVzdCByZWN1cnNlXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbiAmJiAhcm91dGUuY2FuTG9hZCAmJiByb3V0ZS5fbG9hZGVkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbmZpZyA9IHJvdXRlLl9sb2FkZWRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMucHJvY2Vzc1JvdXRlcyhjaGlsZENvbmZpZy5tb2R1bGUsIGNoaWxkQ29uZmlnLnJvdXRlcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb25maWcgbG9hZGVkLCBmZXRjaCB0aGUgY29uZmlnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbiAmJiAhcm91dGUuY2FuTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnByZWxvYWRDb25maWcobmdNb2R1bGUsIHJvdXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBjaGlsZHJlblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnByb2Nlc3NSb3V0ZXMobmdNb2R1bGUsIHJvdXRlLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzFfMSAmJiAhcm91dGVzXzFfMS5kb25lICYmIChfYSA9IHJvdXRlc18xLnJldHVybikpIF9hLmNhbGwocm91dGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tKHJlcykucGlwZShtZXJnZUFsbCgpLCBtYXAoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIHZvaWQgMDsgfSkpO1xuICAgIH07XG4gICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5wcmVsb2FkQ29uZmlnID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVsb2FkaW5nU3RyYXRlZ3kucHJlbG9hZChyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvYWRlZCQgPSBfdGhpcy5sb2FkZXIubG9hZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUpO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZCQucGlwZShtZXJnZU1hcChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcm91dGUuX2xvYWRlZENvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvY2Vzc1JvdXRlcyhjb25maWcubW9kdWxlLCBjb25maWcucm91dGVzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3V0ZXJQcmVsb2FkZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgTmdNb2R1bGVGYWN0b3J5TG9hZGVyLCBDb21waWxlcixcbiAgICAgICAgICAgIEluamVjdG9yLCBQcmVsb2FkaW5nU3RyYXRlZ3ldKVxuICAgIF0sIFJvdXRlclByZWxvYWRlcik7XG4gICAgcmV0dXJuIFJvdXRlclByZWxvYWRlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSb3V0ZXJTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIFxuICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovIHZpZXdwb3J0U2Nyb2xsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMudmlld3BvcnRTY3JvbGxlciA9IHZpZXdwb3J0U2Nyb2xsZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubGFzdElkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U291cmNlID0gJ2ltcGVyYXRpdmUnO1xuICAgICAgICB0aGlzLnJlc3RvcmVkSWQgPSAwO1xuICAgICAgICB0aGlzLnN0b3JlID0ge307XG4gICAgICAgIC8vIERlZmF1bHQgYm90aCBvcHRpb25zIHRvICdkaXNhYmxlZCdcbiAgICAgICAgb3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uID0gb3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uIHx8ICdkaXNhYmxlZCc7XG4gICAgICAgIG9wdGlvbnMuYW5jaG9yU2Nyb2xsaW5nID0gb3B0aW9ucy5hbmNob3JTY3JvbGxpbmcgfHwgJ2Rpc2FibGVkJztcbiAgICB9XG4gICAgUm91dGVyU2Nyb2xsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZGlzYWJsZSB0aGUgYXV0b21hdGljIHNjcm9sbGluZyBiZWNhdXNlIGhhdmluZyB0d28gcGxhY2VzXG4gICAgICAgIC8vIHJlc3BvbnNpYmxlIGZvciBzY3JvbGxpbmcgcmVzdWx0cyByYWNlIGNvbmRpdGlvbnMsIGVzcGVjaWFsbHkgZ2l2ZW5cbiAgICAgICAgLy8gdGhhdCBicm93c2VyIGRvbid0IGltcGxlbWVudCB0aGlzIGJlaGF2aW9yIGNvbnNpc3RlbnRseVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRTY3JvbGxlci5zZXRIaXN0b3J5U2Nyb2xsUmVzdG9yYXRpb24oJ21hbnVhbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm91dGVyRXZlbnRzU3Vic2NyaXB0aW9uID0gdGhpcy5jcmVhdGVTY3JvbGxFdmVudHMoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxFdmVudHNTdWJzY3JpcHRpb24gPSB0aGlzLmNvbnN1bWVTY3JvbGxFdmVudHMoKTtcbiAgICB9O1xuICAgIFJvdXRlclNjcm9sbGVyLnByb3RvdHlwZS5jcmVhdGVTY3JvbGxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5ldmVudHMuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgc3RhYmxlIG5hdmlnYXRpb25zLlxuICAgICAgICAgICAgICAgIF90aGlzLnN0b3JlW190aGlzLmxhc3RJZF0gPSBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFNvdXJjZSA9IGUubmF2aWdhdGlvblRyaWdnZXI7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzdG9yZWRJZCA9IGUucmVzdG9yZWRTdGF0ZSA/IGUucmVzdG9yZWRTdGF0ZS5uYXZpZ2F0aW9uSWQgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0SWQgPSBlLmlkO1xuICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlU2Nyb2xsRXZlbnQoZSwgX3RoaXMucm91dGVyLnBhcnNlVXJsKGUudXJsQWZ0ZXJSZWRpcmVjdHMpLmZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUuY29uc3VtZVNjcm9sbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTY3JvbGwpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGEgcG9wc3RhdGUgZXZlbnQuIFRoZSBwb3Agc3RhdGUgZXZlbnQgd2lsbCBhbHdheXMgaWdub3JlIGFuY2hvciBzY3JvbGxpbmcuXG4gICAgICAgICAgICBpZiAoZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0U2Nyb2xsZXIuc2Nyb2xsVG9Qb3NpdGlvbihbMCwgMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5vcHRpb25zLnNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb24gPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oZS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGltcGVyYXRpdmUgbmF2aWdhdGlvbiBcImZvcndhcmRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuYW5jaG9yICYmIF90aGlzLm9wdGlvbnMuYW5jaG9yU2Nyb2xsaW5nID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnRTY3JvbGxlci5zY3JvbGxUb0FuY2hvcihlLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm9wdGlvbnMuc2Nyb2xsUG9zaXRpb25SZXN0b3JhdGlvbiAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oWzAsIDBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm91dGVyU2Nyb2xsZXIucHJvdG90eXBlLnNjaGVkdWxlU2Nyb2xsRXZlbnQgPSBmdW5jdGlvbiAocm91dGVyRXZlbnQsIGFuY2hvcikge1xuICAgICAgICB0aGlzLnJvdXRlci50cmlnZ2VyRXZlbnQobmV3IFNjcm9sbChyb3V0ZXJFdmVudCwgdGhpcy5sYXN0U291cmNlID09PSAncG9wc3RhdGUnID8gdGhpcy5zdG9yZVt0aGlzLnJlc3RvcmVkSWRdIDogbnVsbCwgYW5jaG9yKSk7XG4gICAgfTtcbiAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvdXRlckV2ZW50c1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXJFdmVudHNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY3JvbGxFdmVudHNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRXZlbnRzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSb3V0ZXJTY3JvbGxlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogQ29udGFpbnMgYSBsaXN0IG9mIGRpcmVjdGl2ZXNcbiAqXG4gKlxuICovXG52YXIgUk9VVEVSX0RJUkVDVElWRVMgPSBbUm91dGVyT3V0bGV0LCBSb3V0ZXJMaW5rLCBSb3V0ZXJMaW5rV2l0aEhyZWYsIFJvdXRlckxpbmtBY3RpdmUsIEVtcHR5T3V0bGV0Q29tcG9uZW50XTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogSXMgdXNlZCBpbiBESSB0byBjb25maWd1cmUgdGhlIHJvdXRlci5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbnZhciBST1VURVJfQ09ORklHVVJBVElPTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignUk9VVEVSX0NPTkZJR1VSQVRJT04nKTtcbi8qKlxuICogQGRvY3NOb3RSZXF1aXJlZFxuICovXG52YXIgUk9VVEVSX0ZPUlJPT1RfR1VBUkQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1JPVVRFUl9GT1JST09UX0dVQVJEJyk7XG52YXIgUk9VVEVSX1BST1ZJREVSUyA9IFtcbiAgICBMb2NhdGlvbixcbiAgICB7IHByb3ZpZGU6IFVybFNlcmlhbGl6ZXIsIHVzZUNsYXNzOiBEZWZhdWx0VXJsU2VyaWFsaXplciB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogUm91dGVyLFxuICAgICAgICB1c2VGYWN0b3J5OiBzZXR1cFJvdXRlcixcbiAgICAgICAgZGVwczogW1xuICAgICAgICAgICAgQXBwbGljYXRpb25SZWYsIFVybFNlcmlhbGl6ZXIsIENoaWxkcmVuT3V0bGV0Q29udGV4dHMsIExvY2F0aW9uLCBJbmplY3RvcixcbiAgICAgICAgICAgIE5nTW9kdWxlRmFjdG9yeUxvYWRlciwgQ29tcGlsZXIsIFJPVVRFUywgUk9VVEVSX0NPTkZJR1VSQVRJT04sXG4gICAgICAgICAgICBbVXJsSGFuZGxpbmdTdHJhdGVneSwgbmV3IE9wdGlvbmFsKCldLCBbUm91dGVSZXVzZVN0cmF0ZWd5LCBuZXcgT3B0aW9uYWwoKV1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cyxcbiAgICB7IHByb3ZpZGU6IEFjdGl2YXRlZFJvdXRlLCB1c2VGYWN0b3J5OiByb290Um91dGUsIGRlcHM6IFtSb3V0ZXJdIH0sXG4gICAgeyBwcm92aWRlOiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIsIHVzZUNsYXNzOiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyIH0sXG4gICAgUm91dGVyUHJlbG9hZGVyLFxuICAgIE5vUHJlbG9hZGluZyxcbiAgICBQcmVsb2FkQWxsTW9kdWxlcyxcbiAgICB7IHByb3ZpZGU6IFJPVVRFUl9DT05GSUdVUkFUSU9OLCB1c2VWYWx1ZTogeyBlbmFibGVUcmFjaW5nOiBmYWxzZSB9IH0sXG5dO1xuZnVuY3Rpb24gcm91dGVyTmdQcm9iZVRva2VuKCkge1xuICAgIHJldHVybiBuZXcgTmdQcm9iZVRva2VuKCdSb3V0ZXInLCBSb3V0ZXIpO1xufVxuLyoqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFJvdXRlck1vZHVsZSBjYW4gYmUgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXM6IG9uY2UgcGVyIGxhemlseS1sb2FkZWQgYnVuZGxlLlxuICogU2luY2UgdGhlIHJvdXRlciBkZWFscyB3aXRoIGEgZ2xvYmFsIHNoYXJlZCByZXNvdXJjZS0tbG9jYXRpb24sIHdlIGNhbm5vdCBoYXZlXG4gKiBtb3JlIHRoYW4gb25lIHJvdXRlciBzZXJ2aWNlIGFjdGl2ZS5cbiAqXG4gKiBUaGF0IGlzIHdoeSB0aGVyZSBhcmUgdHdvIHdheXMgdG8gY3JlYXRlIHRoZSBtb2R1bGU6IGBSb3V0ZXJNb2R1bGUuZm9yUm9vdGAgYW5kXG4gKiBgUm91dGVyTW9kdWxlLmZvckNoaWxkYC5cbiAqXG4gKiAqIGBmb3JSb290YCBjcmVhdGVzIGEgbW9kdWxlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzLCB0aGUgZ2l2ZW4gcm91dGVzLCBhbmQgdGhlIHJvdXRlclxuICogICBzZXJ2aWNlIGl0c2VsZi5cbiAqICogYGZvckNoaWxkYCBjcmVhdGVzIGEgbW9kdWxlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzIGFuZCB0aGUgZ2l2ZW4gcm91dGVzLCBidXQgZG9lcyBub3RcbiAqICAgaW5jbHVkZSB0aGUgcm91dGVyIHNlcnZpY2UuXG4gKlxuICogV2hlbiByZWdpc3RlcmVkIGF0IHRoZSByb290LCB0aGUgbW9kdWxlIHNob3VsZCBiZSB1c2VkIGFzIGZvbGxvd3NcbiAqXG4gKiBgYGBcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtSb3V0ZXJNb2R1bGUuZm9yUm9vdChST1VURVMpXVxuICogfSlcbiAqIGNsYXNzIE15TmdNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIEZvciBzdWJtb2R1bGVzIGFuZCBsYXp5IGxvYWRlZCBzdWJtb2R1bGVzIHRoZSBtb2R1bGUgc2hvdWxkIGJlIHVzZWQgYXMgZm9sbG93czpcbiAqXG4gKiBgYGBcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoUk9VVEVTKV1cbiAqIH0pXG4gKiBjbGFzcyBNeU5nTW9kdWxlIHt9XG4gKiBgYGBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBBZGRzIHJvdXRlciBkaXJlY3RpdmVzIGFuZCBwcm92aWRlcnMuXG4gKlxuICogTWFuYWdpbmcgc3RhdGUgdHJhbnNpdGlvbnMgaXMgb25lIG9mIHRoZSBoYXJkZXN0IHBhcnRzIG9mIGJ1aWxkaW5nIGFwcGxpY2F0aW9ucy4gVGhpcyBpc1xuICogZXNwZWNpYWxseSB0cnVlIG9uIHRoZSB3ZWIsIHdoZXJlIHlvdSBhbHNvIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHN0YXRlIGlzIHJlZmxlY3RlZCBpbiB0aGUgVVJMLlxuICogSW4gYWRkaXRpb24sIHdlIG9mdGVuIHdhbnQgdG8gc3BsaXQgYXBwbGljYXRpb25zIGludG8gbXVsdGlwbGUgYnVuZGxlcyBhbmQgbG9hZCB0aGVtIG9uIGRlbWFuZC5cbiAqIERvaW5nIHRoaXMgdHJhbnNwYXJlbnRseSBpcyBub3QgdHJpdmlhbC5cbiAqXG4gKiBUaGUgQW5ndWxhciByb3V0ZXIgc29sdmVzIHRoZXNlIHByb2JsZW1zLiBVc2luZyB0aGUgcm91dGVyLCB5b3UgY2FuIGRlY2xhcmF0aXZlbHkgc3BlY2lmeVxuICogYXBwbGljYXRpb24gc3RhdGVzLCBtYW5hZ2Ugc3RhdGUgdHJhbnNpdGlvbnMgd2hpbGUgdGFraW5nIGNhcmUgb2YgdGhlIFVSTCwgYW5kIGxvYWQgYnVuZGxlcyBvblxuICogZGVtYW5kLlxuICpcbiAqIFtSZWFkIHRoaXMgZGV2ZWxvcGVyIGd1aWRlXShodHRwczovL2FuZ3VsYXIuaW8vZG9jcy90cy9sYXRlc3QvZ3VpZGUvcm91dGVyLmh0bWwpIHRvIGdldCBhblxuICogb3ZlcnZpZXcgb2YgaG93IHRoZSByb3V0ZXIgc2hvdWxkIGJlIHVzZWQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUm91dGVyTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIE5vdGU6IFdlIGFyZSBpbmplY3RpbmcgdGhlIFJvdXRlciBzbyBpdCBnZXRzIGNyZWF0ZWQgZWFnZXJseS4uLlxuICAgIGZ1bmN0aW9uIFJvdXRlck1vZHVsZShndWFyZCwgcm91dGVyKSB7XG4gICAgfVxuICAgIFJvdXRlck1vZHVsZV8xID0gUm91dGVyTW9kdWxlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIHJvdXRlciBwcm92aWRlcnMgYW5kIGRpcmVjdGl2ZXMuIEl0IGFsc28gb3B0aW9uYWxseSBzZXRzIHVwIGFuXG4gICAgICogYXBwbGljYXRpb24gbGlzdGVuZXIgdG8gcGVyZm9ybSBhbiBpbml0aWFsIG5hdmlnYXRpb24uXG4gICAgICpcbiAgICAgKiBPcHRpb25zIChzZWUgYEV4dHJhT3B0aW9uc2ApOlxuICAgICAqICogYGVuYWJsZVRyYWNpbmdgIG1ha2VzIHRoZSByb3V0ZXIgbG9nIGFsbCBpdHMgaW50ZXJuYWwgZXZlbnRzIHRvIHRoZSBjb25zb2xlLlxuICAgICAqICogYHVzZUhhc2hgIGVuYWJsZXMgdGhlIGxvY2F0aW9uIHN0cmF0ZWd5IHRoYXQgdXNlcyB0aGUgVVJMIGZyYWdtZW50IGluc3RlYWQgb2YgdGhlIGhpc3RvcnlcbiAgICAgKiBBUEkuXG4gICAgICogKiBgaW5pdGlhbE5hdmlnYXRpb25gIGRpc2FibGVzIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXG4gICAgICogKiBgZXJyb3JIYW5kbGVyYCBwcm92aWRlcyBhIGN1c3RvbSBlcnJvciBoYW5kbGVyLlxuICAgICAqICogYHByZWxvYWRpbmdTdHJhdGVneWAgY29uZmlndXJlcyBhIHByZWxvYWRpbmcgc3RyYXRlZ3kgKHNlZSBgUHJlbG9hZEFsbE1vZHVsZXNgKS5cbiAgICAgKiAqIGBvblNhbWVVcmxOYXZpZ2F0aW9uYCBjb25maWd1cmVzIGhvdyB0aGUgcm91dGVyIGhhbmRsZXMgbmF2aWdhdGlvbiB0byB0aGUgY3VycmVudCBVUkwuIFNlZVxuICAgICAqIGBFeHRyYU9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogKiBgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneWAgZGVmaW5lcyBob3cgdGhlIHJvdXRlciBtZXJnZXMgcGFyYW1zLCBkYXRhIGFuZCByZXNvbHZlZCBkYXRhXG4gICAgICogZnJvbSBwYXJlbnQgdG8gY2hpbGQgcm91dGVzLlxuICAgICAqL1xuICAgIFJvdXRlck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKHJvdXRlcywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogUm91dGVyTW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBST1VURVJfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVSb3V0ZXMocm91dGVzKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFJPVVRFUl9GT1JST09UX0dVQVJELFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlRm9yUm9vdEd1YXJkLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbW1JvdXRlciwgbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpXV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogUk9VVEVSX0NPTkZJR1VSQVRJT04sIHVzZVZhbHVlOiBjb25maWcgPyBjb25maWcgOiB7fSB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTG9jYXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZUxvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsYXRmb3JtTG9jYXRpb24sIFtuZXcgSW5qZWN0KEFQUF9CQVNFX0hSRUYpLCBuZXcgT3B0aW9uYWwoKV0sIFJPVVRFUl9DT05GSUdVUkFUSU9OXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUm91dGVyU2Nyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGNyZWF0ZVJvdXRlclNjcm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbUm91dGVyLCBWaWV3cG9ydFNjcm9sbGVyLCBST1VURVJfQ09ORklHVVJBVElPTl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUHJlbG9hZGluZ1N0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogY29uZmlnICYmIGNvbmZpZy5wcmVsb2FkaW5nU3RyYXRlZ3kgPyBjb25maWcucHJlbG9hZGluZ1N0cmF0ZWd5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vUHJlbG9hZGluZ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOZ1Byb2JlVG9rZW4sIG11bHRpOiB0cnVlLCB1c2VGYWN0b3J5OiByb3V0ZXJOZ1Byb2JlVG9rZW4gfSxcbiAgICAgICAgICAgICAgICBwcm92aWRlUm91dGVySW5pdGlhbGl6ZXIoKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbW9kdWxlIHdpdGggYWxsIHRoZSByb3V0ZXIgZGlyZWN0aXZlcyBhbmQgYSBwcm92aWRlciByZWdpc3RlcmluZyByb3V0ZXMuXG4gICAgICovXG4gICAgUm91dGVyTW9kdWxlLmZvckNoaWxkID0gZnVuY3Rpb24gKHJvdXRlcykge1xuICAgICAgICByZXR1cm4geyBuZ01vZHVsZTogUm91dGVyTW9kdWxlXzEsIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMocm91dGVzKV0gfTtcbiAgICB9O1xuICAgIHZhciBSb3V0ZXJNb2R1bGVfMTtcbiAgICBSb3V0ZXJNb2R1bGUgPSBSb3V0ZXJNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFJPVVRFUl9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgZXhwb3J0czogUk9VVEVSX0RJUkVDVElWRVMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtFbXB0eU91dGxldENvbXBvbmVudF1cbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMCwgSW5qZWN0KFJPVVRFUl9GT1JST09UX0dVQVJEKSksIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBSb3V0ZXJdKVxuICAgIF0sIFJvdXRlck1vZHVsZSk7XG4gICAgcmV0dXJuIFJvdXRlck1vZHVsZTtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIHZpZXdwb3J0U2Nyb2xsZXIsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcuc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgIHZpZXdwb3J0U2Nyb2xsZXIuc2V0T2Zmc2V0KGNvbmZpZy5zY3JvbGxPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJvdXRlclNjcm9sbGVyKHJvdXRlciwgdmlld3BvcnRTY3JvbGxlciwgY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVMb2NhdGlvblN0cmF0ZWd5KHBsYXRmb3JtTG9jYXRpb25TdHJhdGVneSwgYmFzZUhyZWYsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBvcHRpb25zLnVzZUhhc2ggPyBuZXcgSGFzaExvY2F0aW9uU3RyYXRlZ3kocGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5LCBiYXNlSHJlZikgOlxuICAgICAgICBuZXcgUGF0aExvY2F0aW9uU3RyYXRlZ3kocGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5LCBiYXNlSHJlZik7XG59XG5mdW5jdGlvbiBwcm92aWRlRm9yUm9vdEd1YXJkKHJvdXRlcikge1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm91dGVyTW9kdWxlLmZvclJvb3QoKSBjYWxsZWQgdHdpY2UuIExhenkgbG9hZGVkIG1vZHVsZXMgc2hvdWxkIHVzZSBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoKSBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuICdndWFyZGVkJztcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmVnaXN0ZXJzIHJvdXRlcy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoUk9VVEVTKV0sXG4gKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMoRVhUUkFfUk9VVEVTKV1cbiAqIH0pXG4gKiBjbGFzcyBNeU5nTW9kdWxlIHt9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXMocm91dGVzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBwcm92aWRlOiBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCBtdWx0aTogdHJ1ZSwgdXNlVmFsdWU6IHJvdXRlcyB9LFxuICAgICAgICB7IHByb3ZpZGU6IFJPVVRFUywgbXVsdGk6IHRydWUsIHVzZVZhbHVlOiByb3V0ZXMgfSxcbiAgICBdO1xufVxuZnVuY3Rpb24gc2V0dXBSb3V0ZXIocmVmLCB1cmxTZXJpYWxpemVyLCBjb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBjb25maWcsIG9wdHMsIHVybEhhbmRsaW5nU3RyYXRlZ3ksIHJvdXRlUmV1c2VTdHJhdGVneSkge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgdmFyIHJvdXRlciA9IG5ldyBSb3V0ZXIobnVsbCwgdXJsU2VyaWFsaXplciwgY29udGV4dHMsIGxvY2F0aW9uLCBpbmplY3RvciwgbG9hZGVyLCBjb21waWxlciwgZmxhdHRlbihjb25maWcpKTtcbiAgICBpZiAodXJsSGFuZGxpbmdTdHJhdGVneSkge1xuICAgICAgICByb3V0ZXIudXJsSGFuZGxpbmdTdHJhdGVneSA9IHVybEhhbmRsaW5nU3RyYXRlZ3k7XG4gICAgfVxuICAgIGlmIChyb3V0ZVJldXNlU3RyYXRlZ3kpIHtcbiAgICAgICAgcm91dGVyLnJvdXRlUmV1c2VTdHJhdGVneSA9IHJvdXRlUmV1c2VTdHJhdGVneTtcbiAgICB9XG4gICAgaWYgKG9wdHMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHJvdXRlci5lcnJvckhhbmRsZXIgPSBvcHRzLmVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKG9wdHMubWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHJvdXRlci5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIgPSBvcHRzLm1hbGZvcm1lZFVyaUVycm9ySGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZW5hYmxlVHJhY2luZykge1xuICAgICAgICB2YXIgZG9tXzEgPSDJtWdldERPTSgpO1xuICAgICAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9tXzEubG9nR3JvdXAoXCJSb3V0ZXIgRXZlbnQ6IFwiICsgZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIGRvbV8xLmxvZyhlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZG9tXzEubG9nKGUpO1xuICAgICAgICAgICAgZG9tXzEubG9nR3JvdXBFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRzLm9uU2FtZVVybE5hdmlnYXRpb24pIHtcbiAgICAgICAgcm91dGVyLm9uU2FtZVVybE5hdmlnYXRpb24gPSBvcHRzLm9uU2FtZVVybE5hdmlnYXRpb247XG4gICAgfVxuICAgIGlmIChvcHRzLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kpIHtcbiAgICAgICAgcm91dGVyLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgPSBvcHRzLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3k7XG4gICAgfVxuICAgIGlmIChvcHRzLnVybFVwZGF0ZVN0cmF0ZWd5KSB7XG4gICAgICAgIHJvdXRlci51cmxVcGRhdGVTdHJhdGVneSA9IG9wdHMudXJsVXBkYXRlU3RyYXRlZ3k7XG4gICAgfVxuICAgIGlmIChvcHRzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICAgICAgcm91dGVyLnJlbGF0aXZlTGlua1Jlc29sdXRpb24gPSBvcHRzLnJlbGF0aXZlTGlua1Jlc29sdXRpb247XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG59XG5mdW5jdGlvbiByb290Um91dGUocm91dGVyKSB7XG4gICAgcmV0dXJuIHJvdXRlci5yb3V0ZXJTdGF0ZS5yb290O1xufVxuLyoqXG4gKiBUbyBpbml0aWFsaXplIHRoZSByb3V0ZXIgcHJvcGVybHkgd2UgbmVlZCB0byBkbyBpbiB0d28gc3RlcHM6XG4gKlxuICogV2UgbmVlZCB0byBzdGFydCB0aGUgbmF2aWdhdGlvbiBpbiBhIEFQUF9JTklUSUFMSVpFUiB0byBibG9jayB0aGUgYm9vdHN0cmFwIGlmXG4gKiBhIHJlc29sdmVyIG9yIGEgZ3VhcmRzIGV4ZWN1dGVzIGFzeW5jaHJvbm91c2x5LiBTZWNvbmQsIHdlIG5lZWQgdG8gYWN0dWFsbHkgcnVuXG4gKiBhY3RpdmF0aW9uIGluIGEgQk9PVFNUUkFQX0xJU1RFTkVSLiBXZSB1dGlsaXplIHRoZSBhZnRlclByZWFjdGl2YXRpb25cbiAqIGhvb2sgcHJvdmlkZWQgYnkgdGhlIHJvdXRlciB0byBkbyB0aGF0LlxuICpcbiAqIFRoZSByb3V0ZXIgbmF2aWdhdGlvbiBzdGFydHMsIHJlYWNoZXMgdGhlIHBvaW50IHdoZW4gcHJlYWN0aXZhdGlvbiBpcyBkb25lLCBhbmQgdGhlblxuICogcGF1c2VzLiBJdCB3YWl0cyBmb3IgdGhlIGhvb2sgdG8gYmUgcmVzb2x2ZWQuIFdlIHRoZW4gcmVzb2x2ZSBpdCBvbmx5IGluIGEgYm9vdHN0cmFwIGxpc3RlbmVyLlxuICovXG52YXIgUm91dGVySW5pdGlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVySW5pdGlhbGl6ZXIoaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmluaXROYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIFJvdXRlckluaXRpYWxpemVyLnByb3RvdHlwZS5hcHBJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHAgPSB0aGlzLmluamVjdG9yLmdldChMT0NBVElPTl9JTklUSUFMSVpFRCwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtcbiAgICAgICAgcmV0dXJuIHAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc29sdmUgPSByOyB9KTtcbiAgICAgICAgICAgIHZhciByb3V0ZXIgPSBfdGhpcy5pbmplY3Rvci5nZXQoUm91dGVyKTtcbiAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuaW5qZWN0b3IuZ2V0KFJPVVRFUl9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0xlZ2FjeURpc2FibGVkKG9wdHMpIHx8IF90aGlzLmlzTGVnYWN5RW5hYmxlZChvcHRzKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICByb3V0ZXIuaG9va3MuYWZ0ZXJQcmVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBpbml0aWFsIG5hdmlnYXRpb24gc2hvdWxkIGJlIGRlbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pbml0TmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdE5hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXN1bHRPZlByZWFjdGl2YXRpb25Eb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBuYXZpZ2F0aW9ucyBzaG91bGQgbm90IGJlIGRlbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcm91dGVyLmluaXRpYWxOYXZpZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluaXRpYWxOYXZpZ2F0aW9uIG9wdGlvbnM6ICdcIiArIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJvdXRlckluaXRpYWxpemVyLnByb3RvdHlwZS5ib290c3RyYXBMaXN0ZW5lciA9IGZ1bmN0aW9uIChib290c3RyYXBwZWRDb21wb25lbnRSZWYpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLmluamVjdG9yLmdldChST1VURVJfQ09ORklHVVJBVElPTik7XG4gICAgICAgIHZhciBwcmVsb2FkZXIgPSB0aGlzLmluamVjdG9yLmdldChSb3V0ZXJQcmVsb2FkZXIpO1xuICAgICAgICB2YXIgcm91dGVyU2Nyb2xsZXIgPSB0aGlzLmluamVjdG9yLmdldChSb3V0ZXJTY3JvbGxlcik7XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLmluamVjdG9yLmdldChSb3V0ZXIpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5pbmplY3Rvci5nZXQoQXBwbGljYXRpb25SZWYpO1xuICAgICAgICBpZiAoYm9vdHN0cmFwcGVkQ29tcG9uZW50UmVmICE9PSByZWYuY29tcG9uZW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTGVnYWN5RW5hYmxlZChvcHRzKSkge1xuICAgICAgICAgICAgcm91dGVyLmluaXRpYWxOYXZpZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0xlZ2FjeURpc2FibGVkKG9wdHMpKSB7XG4gICAgICAgICAgICByb3V0ZXIuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlbG9hZGVyLnNldFVwUHJlbG9hZGluZygpO1xuICAgICAgICByb3V0ZXJTY3JvbGxlci5pbml0KCk7XG4gICAgICAgIHJvdXRlci5yZXNldFJvb3RDb21wb25lbnRUeXBlKHJlZi5jb21wb25lbnRUeXBlc1swXSk7XG4gICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZS5uZXh0KG51bGwpO1xuICAgICAgICB0aGlzLnJlc3VsdE9mUHJlYWN0aXZhdGlvbkRvbmUuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFJvdXRlckluaXRpYWxpemVyLnByb3RvdHlwZS5pc0xlZ2FjeUVuYWJsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICByZXR1cm4gb3B0cy5pbml0aWFsTmF2aWdhdGlvbiA9PT0gJ2xlZ2FjeV9lbmFibGVkJyB8fCBvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSB0cnVlIHx8XG4gICAgICAgICAgICBvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBSb3V0ZXJJbml0aWFsaXplci5wcm90b3R5cGUuaXNMZWdhY3lEaXNhYmxlZCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSAnbGVnYWN5X2Rpc2FibGVkJyB8fCBvcHRzLmluaXRpYWxOYXZpZ2F0aW9uID09PSBmYWxzZTtcbiAgICB9O1xuICAgIFJvdXRlckluaXRpYWxpemVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbmplY3Rvcl0pXG4gICAgXSwgUm91dGVySW5pdGlhbGl6ZXIpO1xuICAgIHJldHVybiBSb3V0ZXJJbml0aWFsaXplcjtcbn0oKSk7XG5mdW5jdGlvbiBnZXRBcHBJbml0aWFsaXplcihyKSB7XG4gICAgcmV0dXJuIHIuYXBwSW5pdGlhbGl6ZXIuYmluZChyKTtcbn1cbmZ1bmN0aW9uIGdldEJvb3RzdHJhcExpc3RlbmVyKHIpIHtcbiAgICByZXR1cm4gci5ib290c3RyYXBMaXN0ZW5lci5iaW5kKHIpO1xufVxuLyoqXG4gKiBBIHRva2VuIGZvciB0aGUgcm91dGVyIGluaXRpYWxpemVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFwcCBpcyBib290c3RyYXBwZWQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgUk9VVEVSX0lOSVRJQUxJWkVSID0gbmV3IEluamVjdGlvblRva2VuKCdSb3V0ZXIgSW5pdGlhbGl6ZXInKTtcbmZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXJJbml0aWFsaXplcigpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBSb3V0ZXJJbml0aWFsaXplcixcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBnZXRBcHBJbml0aWFsaXplcixcbiAgICAgICAgICAgIGRlcHM6IFtSb3V0ZXJJbml0aWFsaXplcl1cbiAgICAgICAgfSxcbiAgICAgICAgeyBwcm92aWRlOiBST1VURVJfSU5JVElBTElaRVIsIHVzZUZhY3Rvcnk6IGdldEJvb3RzdHJhcExpc3RlbmVyLCBkZXBzOiBbUm91dGVySW5pdGlhbGl6ZXJdIH0sXG4gICAgICAgIHsgcHJvdmlkZTogQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgbXVsdGk6IHRydWUsIHVzZUV4aXN0aW5nOiBST1VURVJfSU5JVElBTElaRVIgfSxcbiAgICBdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIFZFUlNJT04gPSBuZXcgVmVyc2lvbignNy4wLjQnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBST1VURVJfRk9SUk9PVF9HVUFSRCBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9hLCBSb3V0ZXJJbml0aWFsaXplciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9oLCBjcmVhdGVSb3V0ZXJTY3JvbGxlciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9jLCBnZXRBcHBJbml0aWFsaXplciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9pLCBnZXRCb290c3RyYXBMaXN0ZW5lciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9qLCBwcm92aWRlRm9yUm9vdEd1YXJkIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19yb3V0ZXJfcm91dGVyX2UsIHByb3ZpZGVMb2NhdGlvblN0cmF0ZWd5IGFzIMm1YW5ndWxhcl9wYWNrYWdlc19yb3V0ZXJfcm91dGVyX2QsIHByb3ZpZGVSb3V0ZXJJbml0aWFsaXplciBhcyDJtWFuZ3VsYXJfcGFja2FnZXNfcm91dGVyX3JvdXRlcl9rLCByb290Um91dGUgYXMgybVhbmd1bGFyX3BhY2thZ2VzX3JvdXRlcl9yb3V0ZXJfZywgcm91dGVyTmdQcm9iZVRva2VuIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19yb3V0ZXJfcm91dGVyX2IsIHNldHVwUm91dGVyIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19yb3V0ZXJfcm91dGVyX2YsIFJvdXRlclNjcm9sbGVyIGFzIMm1YW5ndWxhcl9wYWNrYWdlc19yb3V0ZXJfcm91dGVyX24sIFRyZWUgYXMgybVhbmd1bGFyX3BhY2thZ2VzX3JvdXRlcl9yb3V0ZXJfbCwgVHJlZU5vZGUgYXMgybVhbmd1bGFyX3BhY2thZ2VzX3JvdXRlcl9yb3V0ZXJfbSwgUm91dGVyTGluaywgUm91dGVyTGlua1dpdGhIcmVmLCBSb3V0ZXJMaW5rQWN0aXZlLCBSb3V0ZXJPdXRsZXQsIEFjdGl2YXRpb25FbmQsIEFjdGl2YXRpb25TdGFydCwgQ2hpbGRBY3RpdmF0aW9uRW5kLCBDaGlsZEFjdGl2YXRpb25TdGFydCwgR3VhcmRzQ2hlY2tFbmQsIEd1YXJkc0NoZWNrU3RhcnQsIE5hdmlnYXRpb25DYW5jZWwsIE5hdmlnYXRpb25FbmQsIE5hdmlnYXRpb25FcnJvciwgTmF2aWdhdGlvblN0YXJ0LCBSZXNvbHZlRW5kLCBSZXNvbHZlU3RhcnQsIFJvdXRlQ29uZmlnTG9hZEVuZCwgUm91dGVDb25maWdMb2FkU3RhcnQsIFJvdXRlckV2ZW50LCBSb3V0ZXNSZWNvZ25pemVkLCBTY3JvbGwsIFJvdXRlUmV1c2VTdHJhdGVneSwgUm91dGVyLCBST1VURVMsIFJPVVRFUl9DT05GSUdVUkFUSU9OLCBST1VURVJfSU5JVElBTElaRVIsIFJvdXRlck1vZHVsZSwgcHJvdmlkZVJvdXRlcywgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgT3V0bGV0Q29udGV4dCwgTm9QcmVsb2FkaW5nLCBQcmVsb2FkQWxsTW9kdWxlcywgUHJlbG9hZGluZ1N0cmF0ZWd5LCBSb3V0ZXJQcmVsb2FkZXIsIEFjdGl2YXRlZFJvdXRlLCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZSwgUm91dGVyU3RhdGVTbmFwc2hvdCwgUFJJTUFSWV9PVVRMRVQsIGNvbnZlcnRUb1BhcmFtTWFwLCBVcmxIYW5kbGluZ1N0cmF0ZWd5LCBEZWZhdWx0VXJsU2VyaWFsaXplciwgVXJsU2VnbWVudCwgVXJsU2VnbWVudEdyb3VwLCBVcmxTZXJpYWxpemVyLCBVcmxUcmVlLCBWRVJTSU9OLCBFbXB0eU91dGxldENvbXBvbmVudCBhcyDJtUVtcHR5T3V0bGV0Q29tcG9uZW50LCBST1VURVJfUFJPVklERVJTIGFzIMm1Uk9VVEVSX1BST1ZJREVSUywgZmxhdHRlbiBhcyDJtWZsYXR0ZW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///354\\n')},54:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return EmptyError; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction EmptyErrorImpl() {\\n    Error.call(this);\\n    this.message = 'no elements in sequence';\\n    this.name = 'EmptyError';\\n    return this;\\n}\\nEmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\\nvar EmptyError = EmptyErrorImpl;\\n//# sourceMappingURL=EmptyError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanM/ZGRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5mdW5jdGlvbiBFbXB0eUVycm9ySW1wbCgpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdubyBlbGVtZW50cyBpbiBzZXF1ZW5jZSc7XG4gICAgdGhpcy5uYW1lID0gJ0VtcHR5RXJyb3InO1xuICAgIHJldHVybiB0aGlzO1xufVxuRW1wdHlFcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qLyBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5leHBvcnQgdmFyIEVtcHR5RXJyb3IgPSBFbXB0eUVycm9ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5RXJyb3IuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///54\\n\")},71:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"a\\\", function() { return ArgumentOutOfRangeError; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction ArgumentOutOfRangeErrorImpl() {\\n    Error.call(this);\\n    this.message = 'argument out of range';\\n    this.name = 'ArgumentOutOfRangeError';\\n    return this;\\n}\\nArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\\nvar ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzPzZmYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsKCkge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tZXNzYWdlID0gJ2FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgdGhpcy5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICByZXR1cm4gdGhpcztcbn1cbkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovIE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmV4cG9ydCB2YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///71\\n\")},72:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isScheduler.js\\nvar isScheduler = __webpack_require__(17);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js\\nvar fromArray = __webpack_require__(27);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js\\nvar empty = __webpack_require__(11);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 1 modules\\nvar Observable = __webpack_require__(4);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/scalar.js\\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\\n\\nfunction scalar(value) {\\n    var result = new Observable[\"a\" /* Observable */](function (subscriber) {\\n        subscriber.next(value);\\n        subscriber.complete();\\n    });\\n    result._isScalar = true;\\n    result.value = value;\\n    return result;\\n}\\n//# sourceMappingURL=scalar.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return of; });\\n/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction of() {\\n    var args = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        args[_i] = arguments[_i];\\n    }\\n    var scheduler = args[args.length - 1];\\n    if (Object(isScheduler[\"a\" /* isScheduler */])(scheduler)) {\\n        args.pop();\\n    }\\n    else {\\n        scheduler = undefined;\\n    }\\n    switch (args.length) {\\n        case 0:\\n            return Object(empty[\"b\" /* empty */])(scheduler);\\n        case 1:\\n            return scheduler ? Object(fromArray[\"a\" /* fromArray */])(args, scheduler) : scalar(args[0]);\\n        default:\\n            return Object(fromArray[\"a\" /* fromArray */])(args, scheduler);\\n    }\\n}\\n//# sourceMappingURL=of.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL3NjYWxhci5qcz8zZDRmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvb2YuanM/MTdmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXIodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5faXNTY2FsYXIgPSB0cnVlO1xuICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FsYXIuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF91dGlsX2lzU2NoZWR1bGVyLF9mcm9tQXJyYXksX2VtcHR5LF9zY2FsYXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcbmltcG9ydCB7IGZyb21BcnJheSB9IGZyb20gJy4vZnJvbUFycmF5JztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAnLi9lbXB0eSc7XG5pbXBvcnQgeyBzY2FsYXIgfSBmcm9tICcuL3NjYWxhcic7XG5leHBvcnQgZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzY2hlZHVsZXIgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgYXJncy5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoc2NoZWR1bGVyKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlciA/IGZyb21BcnJheShhcmdzLCBzY2hlZHVsZXIpIDogc2NhbGFyKGFyZ3NbMF0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZyb21BcnJheShhcmdzLCBzY2hlZHVsZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///72\\n')},90:function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval('__webpack_require__.r(__webpack_exports__);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 1 modules\\nvar Observable = __webpack_require__(4);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js\\nvar ConnectableObservable = __webpack_require__(91);\\n\\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\\nvar tslib_es6 = __webpack_require__(0);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js\\nvar Subscriber = __webpack_require__(5);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 2 modules\\nvar Subscription = __webpack_require__(6);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js\\nvar Subject = __webpack_require__(20);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/groupBy.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\\n    return function (source) {\\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\\n    };\\n}\\nvar GroupByOperator = /*@__PURE__*/ (function () {\\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\\n        this.keySelector = keySelector;\\n        this.elementSelector = elementSelector;\\n        this.durationSelector = durationSelector;\\n        this.subjectSelector = subjectSelector;\\n    }\\n    GroupByOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new groupBy_GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\\n    };\\n    return GroupByOperator;\\n}());\\nvar groupBy_GroupBySubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](GroupBySubscriber, _super);\\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.keySelector = keySelector;\\n        _this.elementSelector = elementSelector;\\n        _this.durationSelector = durationSelector;\\n        _this.subjectSelector = subjectSelector;\\n        _this.groups = null;\\n        _this.attemptedToUnsubscribe = false;\\n        _this.count = 0;\\n        return _this;\\n    }\\n    GroupBySubscriber.prototype._next = function (value) {\\n        var key;\\n        try {\\n            key = this.keySelector(value);\\n        }\\n        catch (err) {\\n            this.error(err);\\n            return;\\n        }\\n        this._group(value, key);\\n    };\\n    GroupBySubscriber.prototype._group = function (value, key) {\\n        var groups = this.groups;\\n        if (!groups) {\\n            groups = this.groups = new Map();\\n        }\\n        var group = groups.get(key);\\n        var element;\\n        if (this.elementSelector) {\\n            try {\\n                element = this.elementSelector(value);\\n            }\\n            catch (err) {\\n                this.error(err);\\n            }\\n        }\\n        else {\\n            element = value;\\n        }\\n        if (!group) {\\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject[\"a\" /* Subject */]());\\n            groups.set(key, group);\\n            var groupedObservable = new groupBy_GroupedObservable(key, group, this);\\n            this.destination.next(groupedObservable);\\n            if (this.durationSelector) {\\n                var duration = void 0;\\n                try {\\n                    duration = this.durationSelector(new groupBy_GroupedObservable(key, group));\\n                }\\n                catch (err) {\\n                    this.error(err);\\n                    return;\\n                }\\n                this.add(duration.subscribe(new groupBy_GroupDurationSubscriber(key, group, this)));\\n            }\\n        }\\n        if (!group.closed) {\\n            group.next(element);\\n        }\\n    };\\n    GroupBySubscriber.prototype._error = function (err) {\\n        var groups = this.groups;\\n        if (groups) {\\n            groups.forEach(function (group, key) {\\n                group.error(err);\\n            });\\n            groups.clear();\\n        }\\n        this.destination.error(err);\\n    };\\n    GroupBySubscriber.prototype._complete = function () {\\n        var groups = this.groups;\\n        if (groups) {\\n            groups.forEach(function (group, key) {\\n                group.complete();\\n            });\\n            groups.clear();\\n        }\\n        this.destination.complete();\\n    };\\n    GroupBySubscriber.prototype.removeGroup = function (key) {\\n        this.groups.delete(key);\\n    };\\n    GroupBySubscriber.prototype.unsubscribe = function () {\\n        if (!this.closed) {\\n            this.attemptedToUnsubscribe = true;\\n            if (this.count === 0) {\\n                _super.prototype.unsubscribe.call(this);\\n            }\\n        }\\n    };\\n    return GroupBySubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\nvar groupBy_GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](GroupDurationSubscriber, _super);\\n    function GroupDurationSubscriber(key, group, parent) {\\n        var _this = _super.call(this, group) || this;\\n        _this.key = key;\\n        _this.group = group;\\n        _this.parent = parent;\\n        return _this;\\n    }\\n    GroupDurationSubscriber.prototype._next = function (value) {\\n        this.complete();\\n    };\\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\\n        var _a = this, parent = _a.parent, key = _a.key;\\n        this.key = this.parent = null;\\n        if (parent) {\\n            parent.removeGroup(key);\\n        }\\n    };\\n    return GroupDurationSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\nvar groupBy_GroupedObservable = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](GroupedObservable, _super);\\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\\n        var _this = _super.call(this) || this;\\n        _this.key = key;\\n        _this.groupSubject = groupSubject;\\n        _this.refCountSubscription = refCountSubscription;\\n        return _this;\\n    }\\n    GroupedObservable.prototype._subscribe = function (subscriber) {\\n        var subscription = new Subscription[\"a\" /* Subscription */]();\\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\\n        if (refCountSubscription && !refCountSubscription.closed) {\\n            subscription.add(new groupBy_InnerRefCountSubscription(refCountSubscription));\\n        }\\n        subscription.add(groupSubject.subscribe(subscriber));\\n        return subscription;\\n    };\\n    return GroupedObservable;\\n}(Observable[\"a\" /* Observable */]));\\n\\nvar groupBy_InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](InnerRefCountSubscription, _super);\\n    function InnerRefCountSubscription(parent) {\\n        var _this = _super.call(this) || this;\\n        _this.parent = parent;\\n        parent.count++;\\n        return _this;\\n    }\\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\\n        var parent = this.parent;\\n        if (!parent.closed && !this.closed) {\\n            _super.prototype.unsubscribe.call(this);\\n            parent.count -= 1;\\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\\n                parent.unsubscribe();\\n            }\\n        }\\n    };\\n    return InnerRefCountSubscription;\\n}(Subscription[\"a\" /* Subscription */]));\\n//# sourceMappingURL=groupBy.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js\\nvar symbol_observable = __webpack_require__(32);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/BehaviorSubject.js\\nvar BehaviorSubject = __webpack_require__(162);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/Action.js\\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\\n\\n\\nvar Action_Action = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](Action, _super);\\n    function Action(scheduler, work) {\\n        return _super.call(this) || this;\\n    }\\n    Action.prototype.schedule = function (state, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        return this;\\n    };\\n    return Action;\\n}(Subscription[\"a\" /* Subscription */]));\\n\\n//# sourceMappingURL=Action.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js\\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\\n\\n\\nvar AsyncAction_AsyncAction = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AsyncAction, _super);\\n    function AsyncAction(scheduler, work) {\\n        var _this = _super.call(this, scheduler, work) || this;\\n        _this.scheduler = scheduler;\\n        _this.work = work;\\n        _this.pending = false;\\n        return _this;\\n    }\\n    AsyncAction.prototype.schedule = function (state, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (this.closed) {\\n            return this;\\n        }\\n        this.state = state;\\n        var id = this.id;\\n        var scheduler = this.scheduler;\\n        if (id != null) {\\n            this.id = this.recycleAsyncId(scheduler, id, delay);\\n        }\\n        this.pending = true;\\n        this.delay = delay;\\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\\n        return this;\\n    };\\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\\n    };\\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (delay !== null && this.delay === delay && this.pending === false) {\\n            return id;\\n        }\\n        clearInterval(id);\\n    };\\n    AsyncAction.prototype.execute = function (state, delay) {\\n        if (this.closed) {\\n            return new Error(\\'executing a cancelled action\\');\\n        }\\n        this.pending = false;\\n        var error = this._execute(state, delay);\\n        if (error) {\\n            return error;\\n        }\\n        else if (this.pending === false && this.id != null) {\\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\\n        }\\n    };\\n    AsyncAction.prototype._execute = function (state, delay) {\\n        var errored = false;\\n        var errorValue = undefined;\\n        try {\\n            this.work(state);\\n        }\\n        catch (e) {\\n            errored = true;\\n            errorValue = !!e && e || new Error(e);\\n        }\\n        if (errored) {\\n            this.unsubscribe();\\n            return errorValue;\\n        }\\n    };\\n    AsyncAction.prototype._unsubscribe = function () {\\n        var id = this.id;\\n        var scheduler = this.scheduler;\\n        var actions = scheduler.actions;\\n        var index = actions.indexOf(this);\\n        this.work = null;\\n        this.state = null;\\n        this.pending = false;\\n        this.scheduler = null;\\n        if (index !== -1) {\\n            actions.splice(index, 1);\\n        }\\n        if (id != null) {\\n            this.id = this.recycleAsyncId(scheduler, id, null);\\n        }\\n        this.delay = null;\\n    };\\n    return AsyncAction;\\n}(Action_Action));\\n\\n//# sourceMappingURL=AsyncAction.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js\\n/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\\n\\n\\nvar QueueAction_QueueAction = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](QueueAction, _super);\\n    function QueueAction(scheduler, work) {\\n        var _this = _super.call(this, scheduler, work) || this;\\n        _this.scheduler = scheduler;\\n        _this.work = work;\\n        return _this;\\n    }\\n    QueueAction.prototype.schedule = function (state, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (delay > 0) {\\n            return _super.prototype.schedule.call(this, state, delay);\\n        }\\n        this.delay = delay;\\n        this.state = state;\\n        this.scheduler.flush(this);\\n        return this;\\n    };\\n    QueueAction.prototype.execute = function (state, delay) {\\n        return (delay > 0 || this.closed) ?\\n            _super.prototype.execute.call(this, state, delay) :\\n            this._execute(state, delay);\\n    };\\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\\n        }\\n        return scheduler.flush(this);\\n    };\\n    return QueueAction;\\n}(AsyncAction_AsyncAction));\\n\\n//# sourceMappingURL=QueueAction.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js\\nvar Scheduler = /*@__PURE__*/ (function () {\\n    function Scheduler(SchedulerAction, now) {\\n        if (now === void 0) {\\n            now = Scheduler.now;\\n        }\\n        this.SchedulerAction = SchedulerAction;\\n        this.now = now;\\n    }\\n    Scheduler.prototype.schedule = function (work, delay, state) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        return new this.SchedulerAction(this, work).schedule(state, delay);\\n    };\\n    Scheduler.now = function () { return Date.now(); };\\n    return Scheduler;\\n}());\\n\\n//# sourceMappingURL=Scheduler.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js\\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\\n\\n\\nvar AsyncScheduler_AsyncScheduler = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AsyncScheduler, _super);\\n    function AsyncScheduler(SchedulerAction, now) {\\n        if (now === void 0) {\\n            now = Scheduler.now;\\n        }\\n        var _this = _super.call(this, SchedulerAction, function () {\\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\\n                return AsyncScheduler.delegate.now();\\n            }\\n            else {\\n                return now();\\n            }\\n        }) || this;\\n        _this.actions = [];\\n        _this.active = false;\\n        _this.scheduled = undefined;\\n        return _this;\\n    }\\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\\n            return AsyncScheduler.delegate.schedule(work, delay, state);\\n        }\\n        else {\\n            return _super.prototype.schedule.call(this, work, delay, state);\\n        }\\n    };\\n    AsyncScheduler.prototype.flush = function (action) {\\n        var actions = this.actions;\\n        if (this.active) {\\n            actions.push(action);\\n            return;\\n        }\\n        var error;\\n        this.active = true;\\n        do {\\n            if (error = action.execute(action.state, action.delay)) {\\n                break;\\n            }\\n        } while (action = actions.shift());\\n        this.active = false;\\n        if (error) {\\n            while (action = actions.shift()) {\\n                action.unsubscribe();\\n            }\\n            throw error;\\n        }\\n    };\\n    return AsyncScheduler;\\n}(Scheduler));\\n\\n//# sourceMappingURL=AsyncScheduler.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js\\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\\n\\n\\nvar QueueScheduler_QueueScheduler = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](QueueScheduler, _super);\\n    function QueueScheduler() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return QueueScheduler;\\n}(AsyncScheduler_AsyncScheduler));\\n\\n//# sourceMappingURL=QueueScheduler.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/queue.js\\n/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */\\n\\n\\nvar queue = /*@__PURE__*/ new QueueScheduler_QueueScheduler(QueueAction_QueueAction);\\n//# sourceMappingURL=queue.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js\\nvar empty = __webpack_require__(11);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js + 1 modules\\nvar of = __webpack_require__(72);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js\\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\\n\\nfunction throwError(error, scheduler) {\\n    if (!scheduler) {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) { return subscriber.error(error); });\\n    }\\n    else {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });\\n    }\\n}\\nfunction dispatch(_a) {\\n    var error = _a.error, subscriber = _a.subscriber;\\n    subscriber.error(error);\\n}\\n//# sourceMappingURL=throwError.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js\\n/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */\\n\\n\\n\\nvar Notification_Notification = /*@__PURE__*/ (function () {\\n    function Notification(kind, value, error) {\\n        this.kind = kind;\\n        this.value = value;\\n        this.error = error;\\n        this.hasValue = kind === \\'N\\';\\n    }\\n    Notification.prototype.observe = function (observer) {\\n        switch (this.kind) {\\n            case \\'N\\':\\n                return observer.next && observer.next(this.value);\\n            case \\'E\\':\\n                return observer.error && observer.error(this.error);\\n            case \\'C\\':\\n                return observer.complete && observer.complete();\\n        }\\n    };\\n    Notification.prototype.do = function (next, error, complete) {\\n        var kind = this.kind;\\n        switch (kind) {\\n            case \\'N\\':\\n                return next && next(this.value);\\n            case \\'E\\':\\n                return error && error(this.error);\\n            case \\'C\\':\\n                return complete && complete();\\n        }\\n    };\\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\\n        if (nextOrObserver && typeof nextOrObserver.next === \\'function\\') {\\n            return this.observe(nextOrObserver);\\n        }\\n        else {\\n            return this.do(nextOrObserver, error, complete);\\n        }\\n    };\\n    Notification.prototype.toObservable = function () {\\n        var kind = this.kind;\\n        switch (kind) {\\n            case \\'N\\':\\n                return Object(of[\"a\" /* of */])(this.value);\\n            case \\'E\\':\\n                return throwError(this.error);\\n            case \\'C\\':\\n                return Object(empty[\"b\" /* empty */])();\\n        }\\n        throw new Error(\\'unexpected notification kind value\\');\\n    };\\n    Notification.createNext = function (value) {\\n        if (typeof value !== \\'undefined\\') {\\n            return new Notification(\\'N\\', value);\\n        }\\n        return Notification.undefinedValueNotification;\\n    };\\n    Notification.createError = function (err) {\\n        return new Notification(\\'E\\', undefined, err);\\n    };\\n    Notification.createComplete = function () {\\n        return Notification.completeNotification;\\n    };\\n    Notification.completeNotification = new Notification(\\'C\\');\\n    Notification.undefinedValueNotification = new Notification(\\'N\\', undefined);\\n    return Notification;\\n}());\\n\\n//# sourceMappingURL=Notification.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/observeOn.js\\n/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\\n\\n\\n\\nfunction observeOn(scheduler, delay) {\\n    if (delay === void 0) {\\n        delay = 0;\\n    }\\n    return function observeOnOperatorFunction(source) {\\n        return source.lift(new ObserveOnOperator(scheduler, delay));\\n    };\\n}\\nvar ObserveOnOperator = /*@__PURE__*/ (function () {\\n    function ObserveOnOperator(scheduler, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        this.scheduler = scheduler;\\n        this.delay = delay;\\n    }\\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\\n    };\\n    return ObserveOnOperator;\\n}());\\n\\nvar observeOn_ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ObserveOnSubscriber, _super);\\n    function ObserveOnSubscriber(destination, scheduler, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        var _this = _super.call(this, destination) || this;\\n        _this.scheduler = scheduler;\\n        _this.delay = delay;\\n        return _this;\\n    }\\n    ObserveOnSubscriber.dispatch = function (arg) {\\n        var notification = arg.notification, destination = arg.destination;\\n        notification.observe(destination);\\n        this.unsubscribe();\\n    };\\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\\n        var destination = this.destination;\\n        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\\n    };\\n    ObserveOnSubscriber.prototype._next = function (value) {\\n        this.scheduleMessage(Notification_Notification.createNext(value));\\n    };\\n    ObserveOnSubscriber.prototype._error = function (err) {\\n        this.scheduleMessage(Notification_Notification.createError(err));\\n        this.unsubscribe();\\n    };\\n    ObserveOnSubscriber.prototype._complete = function () {\\n        this.scheduleMessage(Notification_Notification.createComplete());\\n        this.unsubscribe();\\n    };\\n    return ObserveOnSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n\\nvar ObserveOnMessage = /*@__PURE__*/ (function () {\\n    function ObserveOnMessage(notification, destination) {\\n        this.notification = notification;\\n        this.destination = destination;\\n    }\\n    return ObserveOnMessage;\\n}());\\n\\n//# sourceMappingURL=observeOn.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js\\nvar ObjectUnsubscribedError = __webpack_require__(33);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/SubjectSubscription.js\\nvar SubjectSubscription = __webpack_require__(93);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js\\n/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\nvar ReplaySubject_ReplaySubject = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ReplaySubject, _super);\\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\\n        if (bufferSize === void 0) {\\n            bufferSize = Number.POSITIVE_INFINITY;\\n        }\\n        if (windowTime === void 0) {\\n            windowTime = Number.POSITIVE_INFINITY;\\n        }\\n        var _this = _super.call(this) || this;\\n        _this.scheduler = scheduler;\\n        _this._events = [];\\n        _this._infiniteTimeWindow = false;\\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\\n        if (windowTime === Number.POSITIVE_INFINITY) {\\n            _this._infiniteTimeWindow = true;\\n            _this.next = _this.nextInfiniteTimeWindow;\\n        }\\n        else {\\n            _this.next = _this.nextTimeWindow;\\n        }\\n        return _this;\\n    }\\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\\n        var _events = this._events;\\n        _events.push(value);\\n        if (_events.length > this._bufferSize) {\\n            _events.shift();\\n        }\\n        _super.prototype.next.call(this, value);\\n    };\\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\\n        this._events.push(new ReplayEvent(this._getNow(), value));\\n        this._trimBufferThenGetEvents();\\n        _super.prototype.next.call(this, value);\\n    };\\n    ReplaySubject.prototype._subscribe = function (subscriber) {\\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\\n        var scheduler = this.scheduler;\\n        var len = _events.length;\\n        var subscription;\\n        if (this.closed) {\\n            throw new ObjectUnsubscribedError[\"a\" /* ObjectUnsubscribedError */]();\\n        }\\n        else if (this.isStopped || this.hasError) {\\n            subscription = Subscription[\"a\" /* Subscription */].EMPTY;\\n        }\\n        else {\\n            this.observers.push(subscriber);\\n            subscription = new SubjectSubscription[\"a\" /* SubjectSubscription */](this, subscriber);\\n        }\\n        if (scheduler) {\\n            subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler));\\n        }\\n        if (_infiniteTimeWindow) {\\n            for (var i = 0; i < len && !subscriber.closed; i++) {\\n                subscriber.next(_events[i]);\\n            }\\n        }\\n        else {\\n            for (var i = 0; i < len && !subscriber.closed; i++) {\\n                subscriber.next(_events[i].value);\\n            }\\n        }\\n        if (this.hasError) {\\n            subscriber.error(this.thrownError);\\n        }\\n        else if (this.isStopped) {\\n            subscriber.complete();\\n        }\\n        return subscription;\\n    };\\n    ReplaySubject.prototype._getNow = function () {\\n        return (this.scheduler || queue).now();\\n    };\\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\\n        var now = this._getNow();\\n        var _bufferSize = this._bufferSize;\\n        var _windowTime = this._windowTime;\\n        var _events = this._events;\\n        var eventsCount = _events.length;\\n        var spliceCount = 0;\\n        while (spliceCount < eventsCount) {\\n            if ((now - _events[spliceCount].time) < _windowTime) {\\n                break;\\n            }\\n            spliceCount++;\\n        }\\n        if (eventsCount > _bufferSize) {\\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\\n        }\\n        if (spliceCount > 0) {\\n            _events.splice(0, spliceCount);\\n        }\\n        return _events;\\n    };\\n    return ReplaySubject;\\n}(Subject[\"a\" /* Subject */]));\\n\\nvar ReplayEvent = /*@__PURE__*/ (function () {\\n    function ReplayEvent(time, value) {\\n        this.time = time;\\n        this.value = value;\\n    }\\n    return ReplayEvent;\\n}());\\n//# sourceMappingURL=ReplaySubject.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/AsyncSubject.js\\n/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\\n\\n\\n\\nvar AsyncSubject_AsyncSubject = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AsyncSubject, _super);\\n    function AsyncSubject() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        _this.value = null;\\n        _this.hasNext = false;\\n        _this.hasCompleted = false;\\n        return _this;\\n    }\\n    AsyncSubject.prototype._subscribe = function (subscriber) {\\n        if (this.hasError) {\\n            subscriber.error(this.thrownError);\\n            return Subscription[\"a\" /* Subscription */].EMPTY;\\n        }\\n        else if (this.hasCompleted && this.hasNext) {\\n            subscriber.next(this.value);\\n            subscriber.complete();\\n            return Subscription[\"a\" /* Subscription */].EMPTY;\\n        }\\n        return _super.prototype._subscribe.call(this, subscriber);\\n    };\\n    AsyncSubject.prototype.next = function (value) {\\n        if (!this.hasCompleted) {\\n            this.value = value;\\n            this.hasNext = true;\\n        }\\n    };\\n    AsyncSubject.prototype.error = function (error) {\\n        if (!this.hasCompleted) {\\n            _super.prototype.error.call(this, error);\\n        }\\n    };\\n    AsyncSubject.prototype.complete = function () {\\n        this.hasCompleted = true;\\n        if (this.hasNext) {\\n            _super.prototype.next.call(this, this.value);\\n        }\\n        _super.prototype.complete.call(this);\\n    };\\n    return AsyncSubject;\\n}(Subject[\"a\" /* Subject */]));\\n\\n//# sourceMappingURL=AsyncSubject.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nvar nextHandle = 1;\\nvar tasksByHandle = {};\\nfunction runIfPresent(handle) {\\n    var cb = tasksByHandle[handle];\\n    if (cb) {\\n        cb();\\n    }\\n}\\nvar Immediate = {\\n    setImmediate: function (cb) {\\n        var handle = nextHandle++;\\n        tasksByHandle[handle] = cb;\\n        Promise.resolve().then(function () { return runIfPresent(handle); });\\n        return handle;\\n    },\\n    clearImmediate: function (handle) {\\n        delete tasksByHandle[handle];\\n    },\\n};\\n//# sourceMappingURL=Immediate.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js\\n/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */\\n\\n\\n\\nvar AsapAction_AsapAction = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AsapAction, _super);\\n    function AsapAction(scheduler, work) {\\n        var _this = _super.call(this, scheduler, work) || this;\\n        _this.scheduler = scheduler;\\n        _this.work = work;\\n        return _this;\\n    }\\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (delay !== null && delay > 0) {\\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\\n        }\\n        scheduler.actions.push(this);\\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\\n    };\\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\\n        }\\n        if (scheduler.actions.length === 0) {\\n            Immediate.clearImmediate(id);\\n            scheduler.scheduled = undefined;\\n        }\\n        return undefined;\\n    };\\n    return AsapAction;\\n}(AsyncAction_AsyncAction));\\n\\n//# sourceMappingURL=AsapAction.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js\\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\\n\\n\\nvar AsapScheduler_AsapScheduler = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AsapScheduler, _super);\\n    function AsapScheduler() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    AsapScheduler.prototype.flush = function (action) {\\n        this.active = true;\\n        this.scheduled = undefined;\\n        var actions = this.actions;\\n        var error;\\n        var index = -1;\\n        var count = actions.length;\\n        action = action || actions.shift();\\n        do {\\n            if (error = action.execute(action.state, action.delay)) {\\n                break;\\n            }\\n        } while (++index < count && (action = actions.shift()));\\n        this.active = false;\\n        if (error) {\\n            while (++index < count && (action = actions.shift())) {\\n                action.unsubscribe();\\n            }\\n            throw error;\\n        }\\n    };\\n    return AsapScheduler;\\n}(AsyncScheduler_AsyncScheduler));\\n\\n//# sourceMappingURL=AsapScheduler.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js\\n/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */\\n\\n\\nvar asap = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);\\n//# sourceMappingURL=asap.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js\\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\\n\\n\\nvar async_async = /*@__PURE__*/ new AsyncScheduler_AsyncScheduler(AsyncAction_AsyncAction);\\n//# sourceMappingURL=async.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js\\n/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\\n\\n\\nvar AnimationFrameAction_AnimationFrameAction = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AnimationFrameAction, _super);\\n    function AnimationFrameAction(scheduler, work) {\\n        var _this = _super.call(this, scheduler, work) || this;\\n        _this.scheduler = scheduler;\\n        _this.work = work;\\n        return _this;\\n    }\\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (delay !== null && delay > 0) {\\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\\n        }\\n        scheduler.actions.push(this);\\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));\\n    };\\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\\n        }\\n        if (scheduler.actions.length === 0) {\\n            cancelAnimationFrame(id);\\n            scheduler.scheduled = undefined;\\n        }\\n        return undefined;\\n    };\\n    return AnimationFrameAction;\\n}(AsyncAction_AsyncAction));\\n\\n//# sourceMappingURL=AnimationFrameAction.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js\\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\\n\\n\\nvar AnimationFrameScheduler_AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](AnimationFrameScheduler, _super);\\n    function AnimationFrameScheduler() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    AnimationFrameScheduler.prototype.flush = function (action) {\\n        this.active = true;\\n        this.scheduled = undefined;\\n        var actions = this.actions;\\n        var error;\\n        var index = -1;\\n        var count = actions.length;\\n        action = action || actions.shift();\\n        do {\\n            if (error = action.execute(action.state, action.delay)) {\\n                break;\\n            }\\n        } while (++index < count && (action = actions.shift()));\\n        this.active = false;\\n        if (error) {\\n            while (++index < count && (action = actions.shift())) {\\n                action.unsubscribe();\\n            }\\n            throw error;\\n        }\\n    };\\n    return AnimationFrameScheduler;\\n}(AsyncScheduler_AsyncScheduler));\\n\\n//# sourceMappingURL=AnimationFrameScheduler.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js\\n/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */\\n\\n\\nvar animationFrame = /*@__PURE__*/ new AnimationFrameScheduler_AnimationFrameScheduler(AnimationFrameAction_AnimationFrameAction);\\n//# sourceMappingURL=animationFrame.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js\\n/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\\n\\n\\n\\nvar VirtualTimeScheduler_VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](VirtualTimeScheduler, _super);\\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\\n        if (SchedulerAction === void 0) {\\n            SchedulerAction = VirtualTimeScheduler_VirtualAction;\\n        }\\n        if (maxFrames === void 0) {\\n            maxFrames = Number.POSITIVE_INFINITY;\\n        }\\n        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\\n        _this.maxFrames = maxFrames;\\n        _this.frame = 0;\\n        _this.index = -1;\\n        return _this;\\n    }\\n    VirtualTimeScheduler.prototype.flush = function () {\\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\\n        var error, action;\\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\\n            if (error = action.execute(action.state, action.delay)) {\\n                break;\\n            }\\n        }\\n        if (error) {\\n            while (action = actions.shift()) {\\n                action.unsubscribe();\\n            }\\n            throw error;\\n        }\\n    };\\n    VirtualTimeScheduler.frameTimeFactor = 10;\\n    return VirtualTimeScheduler;\\n}(AsyncScheduler_AsyncScheduler));\\n\\nvar VirtualTimeScheduler_VirtualAction = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](VirtualAction, _super);\\n    function VirtualAction(scheduler, work, index) {\\n        if (index === void 0) {\\n            index = scheduler.index += 1;\\n        }\\n        var _this = _super.call(this, scheduler, work) || this;\\n        _this.scheduler = scheduler;\\n        _this.work = work;\\n        _this.index = index;\\n        _this.active = true;\\n        _this.index = scheduler.index = index;\\n        return _this;\\n    }\\n    VirtualAction.prototype.schedule = function (state, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        if (!this.id) {\\n            return _super.prototype.schedule.call(this, state, delay);\\n        }\\n        this.active = false;\\n        var action = new VirtualAction(this.scheduler, this.work);\\n        this.add(action);\\n        return action.schedule(state, delay);\\n    };\\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        this.delay = scheduler.frame + delay;\\n        var actions = scheduler.actions;\\n        actions.push(this);\\n        actions.sort(VirtualAction.sortActions);\\n        return true;\\n    };\\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\\n        if (delay === void 0) {\\n            delay = 0;\\n        }\\n        return undefined;\\n    };\\n    VirtualAction.prototype._execute = function (state, delay) {\\n        if (this.active === true) {\\n            return _super.prototype._execute.call(this, state, delay);\\n        }\\n    };\\n    VirtualAction.sortActions = function (a, b) {\\n        if (a.delay === b.delay) {\\n            if (a.index === b.index) {\\n                return 0;\\n            }\\n            else if (a.index > b.index) {\\n                return 1;\\n            }\\n            else {\\n                return -1;\\n            }\\n        }\\n        else if (a.delay > b.delay) {\\n            return 1;\\n        }\\n        else {\\n            return -1;\\n        }\\n    };\\n    return VirtualAction;\\n}(AsyncAction_AsyncAction));\\n\\n//# sourceMappingURL=VirtualTimeScheduler.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js\\nvar pipe = __webpack_require__(63);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js\\nvar noop = __webpack_require__(21);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js\\nvar identity = __webpack_require__(36);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isObservable.js\\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\\n\\nfunction isObservable(obj) {\\n    return !!obj && (obj instanceof Observable[\"a\" /* Observable */] || (typeof obj.lift === \\'function\\' && typeof obj.subscribe === \\'function\\'));\\n}\\n//# sourceMappingURL=isObservable.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js\\nvar ArgumentOutOfRangeError = __webpack_require__(71);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/EmptyError.js\\nvar EmptyError = __webpack_require__(54);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js\\nvar UnsubscriptionError = __webpack_require__(64);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\nfunction TimeoutErrorImpl() {\\n    Error.call(this);\\n    this.message = \\'Timeout has occurred\\';\\n    this.name = \\'TimeoutError\\';\\n    return this;\\n}\\nTimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\\nvar TimeoutError = TimeoutErrorImpl;\\n//# sourceMappingURL=TimeoutError.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js\\nvar map = __webpack_require__(23);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js\\nvar canReportError = __webpack_require__(73);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js\\nvar isArray = __webpack_require__(13);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isScheduler.js\\nvar isScheduler = __webpack_require__(17);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/bindCallback.js\\n/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction bindCallback(callbackFunc, resultSelector, scheduler) {\\n    if (resultSelector) {\\n        if (Object(isScheduler[\"a\" /* isScheduler */])(resultSelector)) {\\n            scheduler = resultSelector;\\n        }\\n        else {\\n            return function () {\\n                var args = [];\\n                for (var _i = 0; _i < arguments.length; _i++) {\\n                    args[_i] = arguments[_i];\\n                }\\n                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(map[\"a\" /* map */])(function (args) { return Object(isArray[\"a\" /* isArray */])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\\n            };\\n        }\\n    }\\n    return function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var context = this;\\n        var subject;\\n        var params = {\\n            context: context,\\n            subject: subject,\\n            callbackFunc: callbackFunc,\\n            scheduler: scheduler,\\n        };\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            if (!scheduler) {\\n                if (!subject) {\\n                    subject = new AsyncSubject_AsyncSubject();\\n                    var handler = function () {\\n                        var innerArgs = [];\\n                        for (var _i = 0; _i < arguments.length; _i++) {\\n                            innerArgs[_i] = arguments[_i];\\n                        }\\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\\n                        subject.complete();\\n                    };\\n                    try {\\n                        callbackFunc.apply(context, args.concat([handler]));\\n                    }\\n                    catch (err) {\\n                        if (Object(canReportError[\"a\" /* canReportError */])(subject)) {\\n                            subject.error(err);\\n                        }\\n                        else {\\n                            console.warn(err);\\n                        }\\n                    }\\n                }\\n                return subject.subscribe(subscriber);\\n            }\\n            else {\\n                var state = {\\n                    args: args, subscriber: subscriber, params: params,\\n                };\\n                return scheduler.schedule(bindCallback_dispatch, 0, state);\\n            }\\n        });\\n    };\\n}\\nfunction bindCallback_dispatch(state) {\\n    var _this = this;\\n    var self = this;\\n    var args = state.args, subscriber = state.subscriber, params = state.params;\\n    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;\\n    var subject = params.subject;\\n    if (!subject) {\\n        subject = params.subject = new AsyncSubject_AsyncSubject();\\n        var handler = function () {\\n            var innerArgs = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                innerArgs[_i] = arguments[_i];\\n            }\\n            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\\n            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\\n        };\\n        try {\\n            callbackFunc.apply(context, args.concat([handler]));\\n        }\\n        catch (err) {\\n            subject.error(err);\\n        }\\n    }\\n    this.add(subject.subscribe(subscriber));\\n}\\nfunction dispatchNext(state) {\\n    var value = state.value, subject = state.subject;\\n    subject.next(value);\\n    subject.complete();\\n}\\nfunction dispatchError(state) {\\n    var err = state.err, subject = state.subject;\\n    subject.error(err);\\n}\\n//# sourceMappingURL=bindCallback.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js\\n/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nfunction bindNodeCallback(callbackFunc, resultSelector, scheduler) {\\n    if (resultSelector) {\\n        if (Object(isScheduler[\"a\" /* isScheduler */])(resultSelector)) {\\n            scheduler = resultSelector;\\n        }\\n        else {\\n            return function () {\\n                var args = [];\\n                for (var _i = 0; _i < arguments.length; _i++) {\\n                    args[_i] = arguments[_i];\\n                }\\n                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(Object(map[\"a\" /* map */])(function (args) { return Object(isArray[\"a\" /* isArray */])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\\n            };\\n        }\\n    }\\n    return function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        var params = {\\n            subject: undefined,\\n            args: args,\\n            callbackFunc: callbackFunc,\\n            scheduler: scheduler,\\n            context: this,\\n        };\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var context = params.context;\\n            var subject = params.subject;\\n            if (!scheduler) {\\n                if (!subject) {\\n                    subject = params.subject = new AsyncSubject_AsyncSubject();\\n                    var handler = function () {\\n                        var innerArgs = [];\\n                        for (var _i = 0; _i < arguments.length; _i++) {\\n                            innerArgs[_i] = arguments[_i];\\n                        }\\n                        var err = innerArgs.shift();\\n                        if (err) {\\n                            subject.error(err);\\n                            return;\\n                        }\\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\\n                        subject.complete();\\n                    };\\n                    try {\\n                        callbackFunc.apply(context, args.concat([handler]));\\n                    }\\n                    catch (err) {\\n                        if (Object(canReportError[\"a\" /* canReportError */])(subject)) {\\n                            subject.error(err);\\n                        }\\n                        else {\\n                            console.warn(err);\\n                        }\\n                    }\\n                }\\n                return subject.subscribe(subscriber);\\n            }\\n            else {\\n                return scheduler.schedule(bindNodeCallback_dispatch, 0, { params: params, subscriber: subscriber, context: context });\\n            }\\n        });\\n    };\\n}\\nfunction bindNodeCallback_dispatch(state) {\\n    var _this = this;\\n    var params = state.params, subscriber = state.subscriber, context = state.context;\\n    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;\\n    var subject = params.subject;\\n    if (!subject) {\\n        subject = params.subject = new AsyncSubject_AsyncSubject();\\n        var handler = function () {\\n            var innerArgs = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                innerArgs[_i] = arguments[_i];\\n            }\\n            var err = innerArgs.shift();\\n            if (err) {\\n                _this.add(scheduler.schedule(bindNodeCallback_dispatchError, 0, { err: err, subject: subject }));\\n            }\\n            else {\\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\\n                _this.add(scheduler.schedule(bindNodeCallback_dispatchNext, 0, { value: value, subject: subject }));\\n            }\\n        };\\n        try {\\n            callbackFunc.apply(context, args.concat([handler]));\\n        }\\n        catch (err) {\\n            this.add(scheduler.schedule(bindNodeCallback_dispatchError, 0, { err: err, subject: subject }));\\n        }\\n    }\\n    this.add(subject.subscribe(subscriber));\\n}\\nfunction bindNodeCallback_dispatchNext(arg) {\\n    var value = arg.value, subject = arg.subject;\\n    subject.next(value);\\n    subject.complete();\\n}\\nfunction bindNodeCallback_dispatchError(arg) {\\n    var err = arg.err, subject = arg.subject;\\n    subject.error(err);\\n}\\n//# sourceMappingURL=bindNodeCallback.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js\\nvar OuterSubscriber = __webpack_require__(25);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js\\nvar subscribeToResult = __webpack_require__(24);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromArray.js\\nvar fromArray = __webpack_require__(27);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js\\n/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\nvar NONE = {};\\nfunction combineLatest() {\\n    var observables = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        observables[_i] = arguments[_i];\\n    }\\n    var resultSelector = null;\\n    var scheduler = null;\\n    if (Object(isScheduler[\"a\" /* isScheduler */])(observables[observables.length - 1])) {\\n        scheduler = observables.pop();\\n    }\\n    if (typeof observables[observables.length - 1] === \\'function\\') {\\n        resultSelector = observables.pop();\\n    }\\n    if (observables.length === 1 && Object(isArray[\"a\" /* isArray */])(observables[0])) {\\n        observables = observables[0];\\n    }\\n    return Object(fromArray[\"a\" /* fromArray */])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));\\n}\\nvar CombineLatestOperator = /*@__PURE__*/ (function () {\\n    function CombineLatestOperator(resultSelector) {\\n        this.resultSelector = resultSelector;\\n    }\\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new combineLatest_CombineLatestSubscriber(subscriber, this.resultSelector));\\n    };\\n    return CombineLatestOperator;\\n}());\\n\\nvar combineLatest_CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](CombineLatestSubscriber, _super);\\n    function CombineLatestSubscriber(destination, resultSelector) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.resultSelector = resultSelector;\\n        _this.active = 0;\\n        _this.values = [];\\n        _this.observables = [];\\n        return _this;\\n    }\\n    CombineLatestSubscriber.prototype._next = function (observable) {\\n        this.values.push(NONE);\\n        this.observables.push(observable);\\n    };\\n    CombineLatestSubscriber.prototype._complete = function () {\\n        var observables = this.observables;\\n        var len = observables.length;\\n        if (len === 0) {\\n            this.destination.complete();\\n        }\\n        else {\\n            this.active = len;\\n            this.toRespond = len;\\n            for (var i = 0; i < len; i++) {\\n                var observable = observables[i];\\n                this.add(Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, observable, observable, i));\\n            }\\n        }\\n    };\\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\\n        if ((this.active -= 1) === 0) {\\n            this.destination.complete();\\n        }\\n    };\\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        var values = this.values;\\n        var oldVal = values[outerIndex];\\n        var toRespond = !this.toRespond\\n            ? 0\\n            : oldVal === NONE ? --this.toRespond : this.toRespond;\\n        values[outerIndex] = innerValue;\\n        if (toRespond === 0) {\\n            if (this.resultSelector) {\\n                this._tryResultSelector(values);\\n            }\\n            else {\\n                this.destination.next(values.slice());\\n            }\\n        }\\n    };\\n    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {\\n        var result;\\n        try {\\n            result = this.resultSelector.apply(this, values);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.destination.next(result);\\n    };\\n    return CombineLatestSubscriber;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n\\n//# sourceMappingURL=combineLatest.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 5 modules\\nvar from = __webpack_require__(22);\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatAll.js\\nvar concatAll = __webpack_require__(163);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js\\n/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction concat() {\\n    var observables = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        observables[_i] = arguments[_i];\\n    }\\n    if (observables.length === 1 || (observables.length === 2 && Object(isScheduler[\"a\" /* isScheduler */])(observables[1]))) {\\n        return Object(from[\"a\" /* from */])(observables[0]);\\n    }\\n    return Object(concatAll[\"a\" /* concatAll */])()(of[\"a\" /* of */].apply(void 0, observables));\\n}\\n//# sourceMappingURL=concat.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js\\n/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\\n\\n\\n\\nfunction defer(observableFactory) {\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var input;\\n        try {\\n            input = observableFactory();\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n        var source = input ? Object(from[\"a\" /* from */])(input) : Object(empty[\"b\" /* empty */])();\\n        return source.subscribe(subscriber);\\n    });\\n}\\n//# sourceMappingURL=defer.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/forkJoin.js\\n/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\nfunction forkJoin() {\\n    var sources = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        sources[_i] = arguments[_i];\\n    }\\n    var resultSelector;\\n    if (typeof sources[sources.length - 1] === \\'function\\') {\\n        resultSelector = sources.pop();\\n    }\\n    if (sources.length === 1 && Object(isArray[\"a\" /* isArray */])(sources[0])) {\\n        sources = sources[0];\\n    }\\n    if (sources.length === 0) {\\n        return empty[\"a\" /* EMPTY */];\\n    }\\n    if (resultSelector) {\\n        return forkJoin(sources).pipe(Object(map[\"a\" /* map */])(function (args) { return resultSelector.apply(void 0, args); }));\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        return new forkJoin_ForkJoinSubscriber(subscriber, sources);\\n    });\\n}\\nvar forkJoin_ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ForkJoinSubscriber, _super);\\n    function ForkJoinSubscriber(destination, sources) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.sources = sources;\\n        _this.completed = 0;\\n        _this.haveValues = 0;\\n        var len = sources.length;\\n        _this.values = new Array(len);\\n        for (var i = 0; i < len; i++) {\\n            var source = sources[i];\\n            var innerSubscription = Object(subscribeToResult[\"a\" /* subscribeToResult */])(_this, source, null, i);\\n            if (innerSubscription) {\\n                _this.add(innerSubscription);\\n            }\\n        }\\n        return _this;\\n    }\\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        this.values[outerIndex] = innerValue;\\n        if (!innerSub._hasValue) {\\n            innerSub._hasValue = true;\\n            this.haveValues++;\\n        }\\n    };\\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\\n        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;\\n        var len = values.length;\\n        if (!innerSub._hasValue) {\\n            destination.complete();\\n            return;\\n        }\\n        this.completed++;\\n        if (this.completed !== len) {\\n            return;\\n        }\\n        if (haveValues === len) {\\n            destination.next(values);\\n        }\\n        destination.complete();\\n    };\\n    return ForkJoinSubscriber;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n//# sourceMappingURL=forkJoin.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js\\nvar isFunction = __webpack_require__(37);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js\\n/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\\n\\n\\n\\n\\nvar fromEvent_toString = Object.prototype.toString;\\nfunction fromEvent(target, eventName, options, resultSelector) {\\n    if (Object(isFunction[\"a\" /* isFunction */])(options)) {\\n        resultSelector = options;\\n        options = undefined;\\n    }\\n    if (resultSelector) {\\n        return fromEvent(target, eventName, options).pipe(Object(map[\"a\" /* map */])(function (args) { return Object(isArray[\"a\" /* isArray */])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        function handler(e) {\\n            if (arguments.length > 1) {\\n                subscriber.next(Array.prototype.slice.call(arguments));\\n            }\\n            else {\\n                subscriber.next(e);\\n            }\\n        }\\n        setupSubscription(target, eventName, handler, subscriber, options);\\n    });\\n}\\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\\n    var unsubscribe;\\n    if (isEventTarget(sourceObj)) {\\n        var source_1 = sourceObj;\\n        sourceObj.addEventListener(eventName, handler, options);\\n        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };\\n    }\\n    else if (isJQueryStyleEventEmitter(sourceObj)) {\\n        var source_2 = sourceObj;\\n        sourceObj.on(eventName, handler);\\n        unsubscribe = function () { return source_2.off(eventName, handler); };\\n    }\\n    else if (isNodeStyleEventEmitter(sourceObj)) {\\n        var source_3 = sourceObj;\\n        sourceObj.addListener(eventName, handler);\\n        unsubscribe = function () { return source_3.removeListener(eventName, handler); };\\n    }\\n    else if (sourceObj && sourceObj.length) {\\n        for (var i = 0, len = sourceObj.length; i < len; i++) {\\n            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\\n        }\\n    }\\n    else {\\n        throw new TypeError(\\'Invalid event target\\');\\n    }\\n    subscriber.add(unsubscribe);\\n}\\nfunction isNodeStyleEventEmitter(sourceObj) {\\n    return sourceObj && typeof sourceObj.addListener === \\'function\\' && typeof sourceObj.removeListener === \\'function\\';\\n}\\nfunction isJQueryStyleEventEmitter(sourceObj) {\\n    return sourceObj && typeof sourceObj.on === \\'function\\' && typeof sourceObj.off === \\'function\\';\\n}\\nfunction isEventTarget(sourceObj) {\\n    return sourceObj && typeof sourceObj.addEventListener === \\'function\\' && typeof sourceObj.removeEventListener === \\'function\\';\\n}\\n//# sourceMappingURL=fromEvent.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js\\n/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction fromEventPattern(addHandler, removeHandler, resultSelector) {\\n    if (resultSelector) {\\n        return fromEventPattern(addHandler, removeHandler).pipe(Object(map[\"a\" /* map */])(function (args) { return Object(isArray[\"a\" /* isArray */])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var handler = function () {\\n            var e = [];\\n            for (var _i = 0; _i < arguments.length; _i++) {\\n                e[_i] = arguments[_i];\\n            }\\n            return subscriber.next(e.length === 1 ? e[0] : e);\\n        };\\n        var retValue;\\n        try {\\n            retValue = addHandler(handler);\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n        if (!Object(isFunction[\"a\" /* isFunction */])(removeHandler)) {\\n            return undefined;\\n        }\\n        return function () { return removeHandler(handler, retValue); };\\n    });\\n}\\n//# sourceMappingURL=fromEventPattern.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/generate.js\\n/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\\n\\n\\n\\nfunction generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\\n    var resultSelector;\\n    var initialState;\\n    if (arguments.length == 1) {\\n        var options = initialStateOrOptions;\\n        initialState = options.initialState;\\n        condition = options.condition;\\n        iterate = options.iterate;\\n        resultSelector = options.resultSelector || identity[\"a\" /* identity */];\\n        scheduler = options.scheduler;\\n    }\\n    else if (resultSelectorOrObservable === undefined || Object(isScheduler[\"a\" /* isScheduler */])(resultSelectorOrObservable)) {\\n        initialState = initialStateOrOptions;\\n        resultSelector = identity[\"a\" /* identity */];\\n        scheduler = resultSelectorOrObservable;\\n    }\\n    else {\\n        initialState = initialStateOrOptions;\\n        resultSelector = resultSelectorOrObservable;\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var state = initialState;\\n        if (scheduler) {\\n            return scheduler.schedule(generate_dispatch, 0, {\\n                subscriber: subscriber,\\n                iterate: iterate,\\n                condition: condition,\\n                resultSelector: resultSelector,\\n                state: state\\n            });\\n        }\\n        do {\\n            if (condition) {\\n                var conditionResult = void 0;\\n                try {\\n                    conditionResult = condition(state);\\n                }\\n                catch (err) {\\n                    subscriber.error(err);\\n                    return undefined;\\n                }\\n                if (!conditionResult) {\\n                    subscriber.complete();\\n                    break;\\n                }\\n            }\\n            var value = void 0;\\n            try {\\n                value = resultSelector(state);\\n            }\\n            catch (err) {\\n                subscriber.error(err);\\n                return undefined;\\n            }\\n            subscriber.next(value);\\n            if (subscriber.closed) {\\n                break;\\n            }\\n            try {\\n                state = iterate(state);\\n            }\\n            catch (err) {\\n                subscriber.error(err);\\n                return undefined;\\n            }\\n        } while (true);\\n        return undefined;\\n    });\\n}\\nfunction generate_dispatch(state) {\\n    var subscriber = state.subscriber, condition = state.condition;\\n    if (subscriber.closed) {\\n        return undefined;\\n    }\\n    if (state.needIterate) {\\n        try {\\n            state.state = state.iterate(state.state);\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n    }\\n    else {\\n        state.needIterate = true;\\n    }\\n    if (condition) {\\n        var conditionResult = void 0;\\n        try {\\n            conditionResult = condition(state.state);\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n        if (!conditionResult) {\\n            subscriber.complete();\\n            return undefined;\\n        }\\n        if (subscriber.closed) {\\n            return undefined;\\n        }\\n    }\\n    var value;\\n    try {\\n        value = state.resultSelector(state.state);\\n    }\\n    catch (err) {\\n        subscriber.error(err);\\n        return undefined;\\n    }\\n    if (subscriber.closed) {\\n        return undefined;\\n    }\\n    subscriber.next(value);\\n    if (subscriber.closed) {\\n        return undefined;\\n    }\\n    return this.schedule(state);\\n}\\n//# sourceMappingURL=generate.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/iif.js\\n/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */\\n\\n\\nfunction iif(condition, trueResult, falseResult) {\\n    if (trueResult === void 0) {\\n        trueResult = empty[\"a\" /* EMPTY */];\\n    }\\n    if (falseResult === void 0) {\\n        falseResult = empty[\"a\" /* EMPTY */];\\n    }\\n    return defer(function () { return condition() ? trueResult : falseResult; });\\n}\\n//# sourceMappingURL=iif.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isNumeric.js\\n/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\\n\\nfunction isNumeric(val) {\\n    return !Object(isArray[\"a\" /* isArray */])(val) && (val - parseFloat(val) + 1) >= 0;\\n}\\n//# sourceMappingURL=isNumeric.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js\\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\\n\\n\\n\\nfunction interval(period, scheduler) {\\n    if (period === void 0) {\\n        period = 0;\\n    }\\n    if (scheduler === void 0) {\\n        scheduler = async_async;\\n    }\\n    if (!isNumeric(period) || period < 0) {\\n        period = 0;\\n    }\\n    if (!scheduler || typeof scheduler.schedule !== \\'function\\') {\\n        scheduler = async_async;\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        subscriber.add(scheduler.schedule(interval_dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\\n        return subscriber;\\n    });\\n}\\nfunction interval_dispatch(state) {\\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\\n    subscriber.next(counter);\\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\\n}\\n//# sourceMappingURL=interval.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js\\nvar merge = __webpack_require__(129);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/never.js\\n/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */\\n\\n\\nvar NEVER = /*@__PURE__*/ new Observable[\"a\" /* Observable */](noop[\"a\" /* noop */]);\\nfunction never() {\\n    return NEVER;\\n}\\n//# sourceMappingURL=never.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js\\n/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction onErrorResumeNext() {\\n    var sources = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        sources[_i] = arguments[_i];\\n    }\\n    if (sources.length === 0) {\\n        return empty[\"a\" /* EMPTY */];\\n    }\\n    var first = sources[0], remainder = sources.slice(1);\\n    if (sources.length === 1 && Object(isArray[\"a\" /* isArray */])(first)) {\\n        return onErrorResumeNext.apply(void 0, first);\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };\\n        return Object(from[\"a\" /* from */])(first).subscribe({\\n            next: function (value) { subscriber.next(value); },\\n            error: subNext,\\n            complete: subNext,\\n        });\\n    });\\n}\\n//# sourceMappingURL=onErrorResumeNext.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/pairs.js\\n/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\\n\\n\\nfunction pairs(obj, scheduler) {\\n    if (!scheduler) {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var keys = Object.keys(obj);\\n            for (var i = 0; i < keys.length && !subscriber.closed; i++) {\\n                var key = keys[i];\\n                if (obj.hasOwnProperty(key)) {\\n                    subscriber.next([key, obj[key]]);\\n                }\\n            }\\n            subscriber.complete();\\n        });\\n    }\\n    else {\\n        return new Observable[\"a\" /* Observable */](function (subscriber) {\\n            var keys = Object.keys(obj);\\n            var subscription = new Subscription[\"a\" /* Subscription */]();\\n            subscription.add(scheduler.schedule(pairs_dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));\\n            return subscription;\\n        });\\n    }\\n}\\nfunction pairs_dispatch(state) {\\n    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;\\n    if (!subscriber.closed) {\\n        if (index < keys.length) {\\n            var key = keys[index];\\n            subscriber.next([key, obj[key]]);\\n            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));\\n        }\\n        else {\\n            subscriber.complete();\\n        }\\n    }\\n}\\n//# sourceMappingURL=pairs.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js\\n/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\nfunction race() {\\n    var observables = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        observables[_i] = arguments[_i];\\n    }\\n    if (observables.length === 1) {\\n        if (Object(isArray[\"a\" /* isArray */])(observables[0])) {\\n            observables = observables[0];\\n        }\\n        else {\\n            return observables[0];\\n        }\\n    }\\n    return Object(fromArray[\"a\" /* fromArray */])(observables, undefined).lift(new RaceOperator());\\n}\\nvar RaceOperator = /*@__PURE__*/ (function () {\\n    function RaceOperator() {\\n    }\\n    RaceOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new race_RaceSubscriber(subscriber));\\n    };\\n    return RaceOperator;\\n}());\\n\\nvar race_RaceSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](RaceSubscriber, _super);\\n    function RaceSubscriber(destination) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.hasFirst = false;\\n        _this.observables = [];\\n        _this.subscriptions = [];\\n        return _this;\\n    }\\n    RaceSubscriber.prototype._next = function (observable) {\\n        this.observables.push(observable);\\n    };\\n    RaceSubscriber.prototype._complete = function () {\\n        var observables = this.observables;\\n        var len = observables.length;\\n        if (len === 0) {\\n            this.destination.complete();\\n        }\\n        else {\\n            for (var i = 0; i < len && !this.hasFirst; i++) {\\n                var observable = observables[i];\\n                var subscription = Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, observable, observable, i);\\n                if (this.subscriptions) {\\n                    this.subscriptions.push(subscription);\\n                }\\n                this.add(subscription);\\n            }\\n            this.observables = null;\\n        }\\n    };\\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        if (!this.hasFirst) {\\n            this.hasFirst = true;\\n            for (var i = 0; i < this.subscriptions.length; i++) {\\n                if (i !== outerIndex) {\\n                    var subscription = this.subscriptions[i];\\n                    subscription.unsubscribe();\\n                    this.remove(subscription);\\n                }\\n            }\\n            this.subscriptions = null;\\n        }\\n        this.destination.next(innerValue);\\n    };\\n    return RaceSubscriber;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n\\n//# sourceMappingURL=race.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/range.js\\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\\n\\nfunction range(start, count, scheduler) {\\n    if (start === void 0) {\\n        start = 0;\\n    }\\n    if (count === void 0) {\\n        count = 0;\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var index = 0;\\n        var current = start;\\n        if (scheduler) {\\n            return scheduler.schedule(range_dispatch, 0, {\\n                index: index, count: count, start: start, subscriber: subscriber\\n            });\\n        }\\n        else {\\n            do {\\n                if (index++ >= count) {\\n                    subscriber.complete();\\n                    break;\\n                }\\n                subscriber.next(current++);\\n                if (subscriber.closed) {\\n                    break;\\n                }\\n            } while (true);\\n        }\\n        return undefined;\\n    });\\n}\\nfunction range_dispatch(state) {\\n    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\\n    if (index >= count) {\\n        subscriber.complete();\\n        return;\\n    }\\n    subscriber.next(start);\\n    if (subscriber.closed) {\\n        return;\\n    }\\n    state.index = index + 1;\\n    state.start = start + 1;\\n    this.schedule(state);\\n}\\n//# sourceMappingURL=range.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js\\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\\n\\n\\n\\n\\nfunction timer(dueTime, periodOrScheduler, scheduler) {\\n    if (dueTime === void 0) {\\n        dueTime = 0;\\n    }\\n    var period = -1;\\n    if (isNumeric(periodOrScheduler)) {\\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\\n    }\\n    else if (Object(isScheduler[\"a\" /* isScheduler */])(periodOrScheduler)) {\\n        scheduler = periodOrScheduler;\\n    }\\n    if (!Object(isScheduler[\"a\" /* isScheduler */])(scheduler)) {\\n        scheduler = async_async;\\n    }\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var due = isNumeric(dueTime)\\n            ? dueTime\\n            : (+dueTime - scheduler.now());\\n        return scheduler.schedule(timer_dispatch, due, {\\n            index: 0, period: period, subscriber: subscriber\\n        });\\n    });\\n}\\nfunction timer_dispatch(state) {\\n    var index = state.index, period = state.period, subscriber = state.subscriber;\\n    subscriber.next(index);\\n    if (subscriber.closed) {\\n        return;\\n    }\\n    else if (period === -1) {\\n        return subscriber.complete();\\n    }\\n    state.index = index + 1;\\n    this.schedule(state, period);\\n}\\n//# sourceMappingURL=timer.js.map\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/using.js\\n/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\\n\\n\\n\\nfunction using(resourceFactory, observableFactory) {\\n    return new Observable[\"a\" /* Observable */](function (subscriber) {\\n        var resource;\\n        try {\\n            resource = resourceFactory();\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n        var result;\\n        try {\\n            result = observableFactory(resource);\\n        }\\n        catch (err) {\\n            subscriber.error(err);\\n            return undefined;\\n        }\\n        var source = result ? Object(from[\"a\" /* from */])(result) : empty[\"a\" /* EMPTY */];\\n        var subscription = source.subscribe(subscriber);\\n        return function () {\\n            subscription.unsubscribe();\\n            if (resource) {\\n                resource.unsubscribe();\\n            }\\n        };\\n    });\\n}\\n//# sourceMappingURL=using.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js\\nvar iterator = __webpack_require__(28);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/zip.js\\n/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\nfunction zip() {\\n    var observables = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        observables[_i] = arguments[_i];\\n    }\\n    var resultSelector = observables[observables.length - 1];\\n    if (typeof resultSelector === \\'function\\') {\\n        observables.pop();\\n    }\\n    return Object(fromArray[\"a\" /* fromArray */])(observables, undefined).lift(new ZipOperator(resultSelector));\\n}\\nvar ZipOperator = /*@__PURE__*/ (function () {\\n    function ZipOperator(resultSelector) {\\n        this.resultSelector = resultSelector;\\n    }\\n    ZipOperator.prototype.call = function (subscriber, source) {\\n        return source.subscribe(new zip_ZipSubscriber(subscriber, this.resultSelector));\\n    };\\n    return ZipOperator;\\n}());\\n\\nvar zip_ZipSubscriber = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ZipSubscriber, _super);\\n    function ZipSubscriber(destination, resultSelector, values) {\\n        if (values === void 0) {\\n            values = Object.create(null);\\n        }\\n        var _this = _super.call(this, destination) || this;\\n        _this.iterators = [];\\n        _this.active = 0;\\n        _this.resultSelector = (typeof resultSelector === \\'function\\') ? resultSelector : null;\\n        _this.values = values;\\n        return _this;\\n    }\\n    ZipSubscriber.prototype._next = function (value) {\\n        var iterators = this.iterators;\\n        if (Object(isArray[\"a\" /* isArray */])(value)) {\\n            iterators.push(new zip_StaticArrayIterator(value));\\n        }\\n        else if (typeof value[iterator[\"a\" /* iterator */]] === \\'function\\') {\\n            iterators.push(new StaticIterator(value[iterator[\"a\" /* iterator */]]()));\\n        }\\n        else {\\n            iterators.push(new zip_ZipBufferIterator(this.destination, this, value));\\n        }\\n    };\\n    ZipSubscriber.prototype._complete = function () {\\n        var iterators = this.iterators;\\n        var len = iterators.length;\\n        this.unsubscribe();\\n        if (len === 0) {\\n            this.destination.complete();\\n            return;\\n        }\\n        this.active = len;\\n        for (var i = 0; i < len; i++) {\\n            var iterator = iterators[i];\\n            if (iterator.stillUnsubscribed) {\\n                var destination = this.destination;\\n                destination.add(iterator.subscribe(iterator, i));\\n            }\\n            else {\\n                this.active--;\\n            }\\n        }\\n    };\\n    ZipSubscriber.prototype.notifyInactive = function () {\\n        this.active--;\\n        if (this.active === 0) {\\n            this.destination.complete();\\n        }\\n    };\\n    ZipSubscriber.prototype.checkIterators = function () {\\n        var iterators = this.iterators;\\n        var len = iterators.length;\\n        var destination = this.destination;\\n        for (var i = 0; i < len; i++) {\\n            var iterator = iterators[i];\\n            if (typeof iterator.hasValue === \\'function\\' && !iterator.hasValue()) {\\n                return;\\n            }\\n        }\\n        var shouldComplete = false;\\n        var args = [];\\n        for (var i = 0; i < len; i++) {\\n            var iterator = iterators[i];\\n            var result = iterator.next();\\n            if (iterator.hasCompleted()) {\\n                shouldComplete = true;\\n            }\\n            if (result.done) {\\n                destination.complete();\\n                return;\\n            }\\n            args.push(result.value);\\n        }\\n        if (this.resultSelector) {\\n            this._tryresultSelector(args);\\n        }\\n        else {\\n            destination.next(args);\\n        }\\n        if (shouldComplete) {\\n            destination.complete();\\n        }\\n    };\\n    ZipSubscriber.prototype._tryresultSelector = function (args) {\\n        var result;\\n        try {\\n            result = this.resultSelector.apply(this, args);\\n        }\\n        catch (err) {\\n            this.destination.error(err);\\n            return;\\n        }\\n        this.destination.next(result);\\n    };\\n    return ZipSubscriber;\\n}(Subscriber[\"a\" /* Subscriber */]));\\n\\nvar StaticIterator = /*@__PURE__*/ (function () {\\n    function StaticIterator(iterator) {\\n        this.iterator = iterator;\\n        this.nextResult = iterator.next();\\n    }\\n    StaticIterator.prototype.hasValue = function () {\\n        return true;\\n    };\\n    StaticIterator.prototype.next = function () {\\n        var result = this.nextResult;\\n        this.nextResult = this.iterator.next();\\n        return result;\\n    };\\n    StaticIterator.prototype.hasCompleted = function () {\\n        var nextResult = this.nextResult;\\n        return nextResult && nextResult.done;\\n    };\\n    return StaticIterator;\\n}());\\nvar zip_StaticArrayIterator = /*@__PURE__*/ (function () {\\n    function StaticArrayIterator(array) {\\n        this.array = array;\\n        this.index = 0;\\n        this.length = 0;\\n        this.length = array.length;\\n    }\\n    StaticArrayIterator.prototype[iterator[\"a\" /* iterator */]] = function () {\\n        return this;\\n    };\\n    StaticArrayIterator.prototype.next = function (value) {\\n        var i = this.index++;\\n        var array = this.array;\\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\\n    };\\n    StaticArrayIterator.prototype.hasValue = function () {\\n        return this.array.length > this.index;\\n    };\\n    StaticArrayIterator.prototype.hasCompleted = function () {\\n        return this.array.length === this.index;\\n    };\\n    return StaticArrayIterator;\\n}());\\nvar zip_ZipBufferIterator = /*@__PURE__*/ (function (_super) {\\n    tslib_es6[\"c\" /* __extends */](ZipBufferIterator, _super);\\n    function ZipBufferIterator(destination, parent, observable) {\\n        var _this = _super.call(this, destination) || this;\\n        _this.parent = parent;\\n        _this.observable = observable;\\n        _this.stillUnsubscribed = true;\\n        _this.buffer = [];\\n        _this.isComplete = false;\\n        return _this;\\n    }\\n    ZipBufferIterator.prototype[iterator[\"a\" /* iterator */]] = function () {\\n        return this;\\n    };\\n    ZipBufferIterator.prototype.next = function () {\\n        var buffer = this.buffer;\\n        if (buffer.length === 0 && this.isComplete) {\\n            return { value: null, done: true };\\n        }\\n        else {\\n            return { value: buffer.shift(), done: false };\\n        }\\n    };\\n    ZipBufferIterator.prototype.hasValue = function () {\\n        return this.buffer.length > 0;\\n    };\\n    ZipBufferIterator.prototype.hasCompleted = function () {\\n        return this.buffer.length === 0 && this.isComplete;\\n    };\\n    ZipBufferIterator.prototype.notifyComplete = function () {\\n        if (this.buffer.length > 0) {\\n            this.isComplete = true;\\n            this.parent.notifyInactive();\\n        }\\n        else {\\n            this.destination.complete();\\n        }\\n    };\\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\\n        this.buffer.push(innerValue);\\n        this.parent.checkIterators();\\n    };\\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\\n        return Object(subscribeToResult[\"a\" /* subscribeToResult */])(this, this.observable, this, index);\\n    };\\n    return ZipBufferIterator;\\n}(OuterSubscriber[\"a\" /* OuterSubscriber */]));\\n//# sourceMappingURL=zip.js.map\\n\\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js\\nvar config = __webpack_require__(19);\\n\\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/index.js\\n/* concated harmony reexport Observable */__webpack_require__.d(__webpack_exports__, \"Observable\", function() { return Observable[\"a\" /* Observable */]; });\\n/* concated harmony reexport ConnectableObservable */__webpack_require__.d(__webpack_exports__, \"ConnectableObservable\", function() { return ConnectableObservable[\"a\" /* ConnectableObservable */]; });\\n/* concated harmony reexport GroupedObservable */__webpack_require__.d(__webpack_exports__, \"GroupedObservable\", function() { return groupBy_GroupedObservable; });\\n/* concated harmony reexport observable */__webpack_require__.d(__webpack_exports__, \"observable\", function() { return symbol_observable[\"a\" /* observable */]; });\\n/* concated harmony reexport Subject */__webpack_require__.d(__webpack_exports__, \"Subject\", function() { return Subject[\"a\" /* Subject */]; });\\n/* concated harmony reexport BehaviorSubject */__webpack_require__.d(__webpack_exports__, \"BehaviorSubject\", function() { return BehaviorSubject[\"a\" /* BehaviorSubject */]; });\\n/* concated harmony reexport ReplaySubject */__webpack_require__.d(__webpack_exports__, \"ReplaySubject\", function() { return ReplaySubject_ReplaySubject; });\\n/* concated harmony reexport AsyncSubject */__webpack_require__.d(__webpack_exports__, \"AsyncSubject\", function() { return AsyncSubject_AsyncSubject; });\\n/* concated harmony reexport asapScheduler */__webpack_require__.d(__webpack_exports__, \"asapScheduler\", function() { return asap; });\\n/* concated harmony reexport asyncScheduler */__webpack_require__.d(__webpack_exports__, \"asyncScheduler\", function() { return async_async; });\\n/* concated harmony reexport queueScheduler */__webpack_require__.d(__webpack_exports__, \"queueScheduler\", function() { return queue; });\\n/* concated harmony reexport animationFrameScheduler */__webpack_require__.d(__webpack_exports__, \"animationFrameScheduler\", function() { return animationFrame; });\\n/* concated harmony reexport VirtualTimeScheduler */__webpack_require__.d(__webpack_exports__, \"VirtualTimeScheduler\", function() { return VirtualTimeScheduler_VirtualTimeScheduler; });\\n/* concated harmony reexport VirtualAction */__webpack_require__.d(__webpack_exports__, \"VirtualAction\", function() { return VirtualTimeScheduler_VirtualAction; });\\n/* concated harmony reexport Scheduler */__webpack_require__.d(__webpack_exports__, \"Scheduler\", function() { return Scheduler; });\\n/* concated harmony reexport Subscription */__webpack_require__.d(__webpack_exports__, \"Subscription\", function() { return Subscription[\"a\" /* Subscription */]; });\\n/* concated harmony reexport Subscriber */__webpack_require__.d(__webpack_exports__, \"Subscriber\", function() { return Subscriber[\"a\" /* Subscriber */]; });\\n/* concated harmony reexport Notification */__webpack_require__.d(__webpack_exports__, \"Notification\", function() { return Notification_Notification; });\\n/* concated harmony reexport pipe */__webpack_require__.d(__webpack_exports__, \"pipe\", function() { return pipe[\"a\" /* pipe */]; });\\n/* concated harmony reexport noop */__webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop[\"a\" /* noop */]; });\\n/* concated harmony reexport identity */__webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity[\"a\" /* identity */]; });\\n/* concated harmony reexport isObservable */__webpack_require__.d(__webpack_exports__, \"isObservable\", function() { return isObservable; });\\n/* concated harmony reexport ArgumentOutOfRangeError */__webpack_require__.d(__webpack_exports__, \"ArgumentOutOfRangeError\", function() { return ArgumentOutOfRangeError[\"a\" /* ArgumentOutOfRangeError */]; });\\n/* concated harmony reexport EmptyError */__webpack_require__.d(__webpack_exports__, \"EmptyError\", function() { return EmptyError[\"a\" /* EmptyError */]; });\\n/* concated harmony reexport ObjectUnsubscribedError */__webpack_require__.d(__webpack_exports__, \"ObjectUnsubscribedError\", function() { return ObjectUnsubscribedError[\"a\" /* ObjectUnsubscribedError */]; });\\n/* concated harmony reexport UnsubscriptionError */__webpack_require__.d(__webpack_exports__, \"UnsubscriptionError\", function() { return UnsubscriptionError[\"a\" /* UnsubscriptionError */]; });\\n/* concated harmony reexport TimeoutError */__webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\\n/* concated harmony reexport bindCallback */__webpack_require__.d(__webpack_exports__, \"bindCallback\", function() { return bindCallback; });\\n/* concated harmony reexport bindNodeCallback */__webpack_require__.d(__webpack_exports__, \"bindNodeCallback\", function() { return bindNodeCallback; });\\n/* concated harmony reexport combineLatest */__webpack_require__.d(__webpack_exports__, \"combineLatest\", function() { return combineLatest; });\\n/* concated harmony reexport concat */__webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat; });\\n/* concated harmony reexport defer */__webpack_require__.d(__webpack_exports__, \"defer\", function() { return defer; });\\n/* concated harmony reexport empty */__webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty[\"b\" /* empty */]; });\\n/* concated harmony reexport forkJoin */__webpack_require__.d(__webpack_exports__, \"forkJoin\", function() { return forkJoin; });\\n/* concated harmony reexport from */__webpack_require__.d(__webpack_exports__, \"from\", function() { return from[\"a\" /* from */]; });\\n/* concated harmony reexport fromEvent */__webpack_require__.d(__webpack_exports__, \"fromEvent\", function() { return fromEvent; });\\n/* concated harmony reexport fromEventPattern */__webpack_require__.d(__webpack_exports__, \"fromEventPattern\", function() { return fromEventPattern; });\\n/* concated harmony reexport generate */__webpack_require__.d(__webpack_exports__, \"generate\", function() { return generate; });\\n/* concated harmony reexport iif */__webpack_require__.d(__webpack_exports__, \"iif\", function() { return iif; });\\n/* concated harmony reexport interval */__webpack_require__.d(__webpack_exports__, \"interval\", function() { return interval; });\\n/* concated harmony reexport merge */__webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge[\"a\" /* merge */]; });\\n/* concated harmony reexport never */__webpack_require__.d(__webpack_exports__, \"never\", function() { return never; });\\n/* concated harmony reexport of */__webpack_require__.d(__webpack_exports__, \"of\", function() { return of[\"a\" /* of */]; });\\n/* concated harmony reexport onErrorResumeNext */__webpack_require__.d(__webpack_exports__, \"onErrorResumeNext\", function() { return onErrorResumeNext; });\\n/* concated harmony reexport pairs */__webpack_require__.d(__webpack_exports__, \"pairs\", function() { return pairs; });\\n/* concated harmony reexport race */__webpack_require__.d(__webpack_exports__, \"race\", function() { return race; });\\n/* concated harmony reexport range */__webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\\n/* concated harmony reexport throwError */__webpack_require__.d(__webpack_exports__, \"throwError\", function() { return throwError; });\\n/* concated harmony reexport timer */__webpack_require__.d(__webpack_exports__, \"timer\", function() { return timer; });\\n/* concated harmony reexport using */__webpack_require__.d(__webpack_exports__, \"using\", function() { return using; });\\n/* concated harmony reexport zip */__webpack_require__.d(__webpack_exports__, \"zip\", function() { return zip; });\\n/* concated harmony reexport EMPTY */__webpack_require__.d(__webpack_exports__, \"EMPTY\", function() { return empty[\"a\" /* EMPTY */]; });\\n/* concated harmony reexport NEVER */__webpack_require__.d(__webpack_exports__, \"NEVER\", function() { return NEVER; });\\n/* concated harmony reexport config */__webpack_require__.d(__webpack_exports__, \"config\", function() { return config[\"a\" /* config */]; });\\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceMappingURL=index.js.map\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZ3JvdXBCeS5qcz8yMzEzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL3NjaGVkdWxlci9BY3Rpb24uanM/ZGMxYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanM/ODdkMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVBY3Rpb24uanM/MmI3MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9TY2hlZHVsZXIuanM/YjIyMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanM/MDkyZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXIuanM/MTA2MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvcXVldWUuanM/Y2U4ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL3Rocm93RXJyb3IuanM/NWU1MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9Ob3RpZmljYXRpb24uanM/ZWI0OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzPzk5OTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvUmVwbGF5U3ViamVjdC5qcz80Yjk2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL0FzeW5jU3ViamVjdC5qcz9iMmY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL3V0aWwvSW1tZWRpYXRlLmpzP2Q0MTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanM/ZTVjMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qcz81ZWZiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL3NjaGVkdWxlci9hc2FwLmpzPzI5MGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jLmpzPzRmNTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lQWN0aW9uLmpzPzRkNTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzP2QwMWIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzP2I0NzMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzPzUxMWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvdXRpbC9pc09ic2VydmFibGUuanM/Y2ViYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC91dGlsL1RpbWVvdXRFcnJvci5qcz9kZDRkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvYmluZENhbGxiYWNrLmpzP2E1YjgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzPzdhNjEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzPzc3MzgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb25jYXQuanM/NzQ0YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyLmpzPzk1ODYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qcz81NGRhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50LmpzPzZlNzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzPzkwNDQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9nZW5lcmF0ZS5qcz8xODU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvaWlmLmpzPzk4NDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvdXRpbC9pc051bWVyaWMuanM/ZmY2ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLmpzP2M1NzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9uZXZlci5qcz8xODNjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanM/MTBiYyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhaXJzLmpzPzExNjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9yYWNlLmpzPzViNDAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9yYW5nZS5qcz9iYzBjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yeGpzL19lc201L2ludGVybmFsL29ic2VydmFibGUvdGltZXIuanM/ODA4ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL3VzaW5nLmpzP2VkMGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3J4anMvX2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS96aXAuanM/Zjc0ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcnhqcy9fZXNtNS9pbmRleC5qcz8wZWRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIsX1N1YnNjcmlwdGlvbixfT2JzZXJ2YWJsZSxfU3ViamVjdCBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5KGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IsIHN1YmplY3RTZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgR3JvdXBCeU9wZXJhdG9yKGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IsIGR1cmF0aW9uU2VsZWN0b3IsIHN1YmplY3RTZWxlY3RvcikpO1xuICAgIH07XG59XG52YXIgR3JvdXBCeU9wZXJhdG9yID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblNlbGVjdG9yID0gZHVyYXRpb25TZWxlY3RvcjtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgfVxuICAgIEdyb3VwQnlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEdyb3VwQnlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMua2V5U2VsZWN0b3IsIHRoaXMuZWxlbWVudFNlbGVjdG9yLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IsIHRoaXMuc3ViamVjdFNlbGVjdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeU9wZXJhdG9yO1xufSgpKTtcbnZhciBHcm91cEJ5U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhHcm91cEJ5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cEJ5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwga2V5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgZHVyYXRpb25TZWxlY3Rvciwgc3ViamVjdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgICAgICBfdGhpcy5lbGVtZW50U2VsZWN0b3IgPSBlbGVtZW50U2VsZWN0b3I7XG4gICAgICAgIF90aGlzLmR1cmF0aW9uU2VsZWN0b3IgPSBkdXJhdGlvblNlbGVjdG9yO1xuICAgICAgICBfdGhpcy5zdWJqZWN0U2VsZWN0b3IgPSBzdWJqZWN0U2VsZWN0b3I7XG4gICAgICAgIF90aGlzLmdyb3VwcyA9IG51bGw7XG4gICAgICAgIF90aGlzLmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dyb3VwKHZhbHVlLCBrZXkpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLl9ncm91cCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKCFncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IHRoaXMuZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwcy5nZXQoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50U2VsZWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgICBncm91cCA9ICh0aGlzLnN1YmplY3RTZWxlY3RvciA/IHRoaXMuc3ViamVjdFNlbGVjdG9yKCkgOiBuZXcgU3ViamVjdCgpKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zZXQoa2V5LCBncm91cCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXBlZE9ic2VydmFibGUgPSBuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoZ3JvdXBlZE9ic2VydmFibGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25TZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25TZWxlY3RvcihuZXcgR3JvdXBlZE9ic2VydmFibGUoa2V5LCBncm91cCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZChkdXJhdGlvbi5zdWJzY3JpYmUobmV3IEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHRoaXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgICAgICAgIGdyb3VwLm5leHQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBHcm91cEJ5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCwga2V5KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgR3JvdXBCeVN1YnNjcmliZXIucHJvdG90eXBlLnJlbW92ZUdyb3VwID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0aGlzLmdyb3Vwcy5kZWxldGUoa2V5KTtcbiAgICB9O1xuICAgIEdyb3VwQnlTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBCeVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbnZhciBHcm91cER1cmF0aW9uU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhHcm91cER1cmF0aW9uU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cER1cmF0aW9uU3Vic2NyaWJlcihrZXksIGdyb3VwLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JvdXApIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleSA9IGtleTtcbiAgICAgICAgX3RoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBHcm91cER1cmF0aW9uU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwYXJlbnQgPSBfYS5wYXJlbnQsIGtleSA9IF9hLmtleTtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVHcm91cChrZXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR3JvdXBEdXJhdGlvblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbnZhciBHcm91cGVkT2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhHcm91cGVkT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCwgcmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy5ncm91cFN1YmplY3QgPSBncm91cFN1YmplY3Q7XG4gICAgICAgIF90aGlzLnJlZkNvdW50U3Vic2NyaXB0aW9uID0gcmVmQ291bnRTdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgR3JvdXBlZE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZWZDb3VudFN1YnNjcmlwdGlvbiA9IF9hLnJlZkNvdW50U3Vic2NyaXB0aW9uLCBncm91cFN1YmplY3QgPSBfYS5ncm91cFN1YmplY3Q7XG4gICAgICAgIGlmIChyZWZDb3VudFN1YnNjcmlwdGlvbiAmJiAhcmVmQ291bnRTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uYWRkKG5ldyBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uKHJlZkNvdW50U3Vic2NyaXB0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChncm91cFN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBHcm91cGVkT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZSkpO1xuZXhwb3J0IHsgR3JvdXBlZE9ic2VydmFibGUgfTtcbnZhciBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbihwYXJlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQuY291bnQrKztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbm5lclJlZkNvdW50U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudC5jbG9zZWQgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwYXJlbnQuY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY291bnQgPT09IDAgJiYgcGFyZW50LmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBCeS5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmlwdGlvbiBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbnZhciBBY3Rpb24gPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uO1xufShTdWJzY3JpcHRpb24pKTtcbmV4cG9ydCB7IEFjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfQWN0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbic7XG52YXIgQXN5bmNBY3Rpb24gPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yaykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBfdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgX3RoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5ICYmIHRoaXMucGVuZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb24pKTtcbmV4cG9ydCB7IEFzeW5jQWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0FjdGlvbi5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX0FzeW5jQWN0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xudmFyIFF1ZXVlQWN0aW9uID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFF1ZXVlQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1ZXVlQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgX3RoaXMud29yayA9IHdvcms7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNjaGVkdWxlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuZmx1c2godGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHJldHVybiAoZGVsYXkgPiAwIHx8IHRoaXMuY2xvc2VkKSA/XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpIDpcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICB9O1xuICAgIFF1ZXVlQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB8fCAoZGVsYXkgPT09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLmZsdXNoKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXVlQWN0aW9uO1xufShBc3luY0FjdGlvbikpO1xuZXhwb3J0IHsgUXVldWVBY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlQWN0aW9uLmpzLm1hcFxuIiwidmFyIFNjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBub3cgPSBTY2hlZHVsZXIubm93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgICAgICB0aGlzLm5vdyA9IG5vdztcbiAgICB9XG4gICAgU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh3b3JrLCBkZWxheSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU2NoZWR1bGVyQWN0aW9uKHRoaXMsIHdvcmspLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIubm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcbiAgICByZXR1cm4gU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydCB7IFNjaGVkdWxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NoZWR1bGVyLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU2NoZWR1bGVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xudmFyIEFzeW5jU2NoZWR1bGVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbm93ID0gU2NoZWR1bGVyLm5vdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTY2hlZHVsZXJBY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAmJiBBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAhPT0gX3RoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAod29yaywgZGVsYXksIHN0YXRlKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUuc2NoZWR1bGUod29yaywgZGVsYXksIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNjaGVkdWxlLmNhbGwodGhpcywgd29yaywgZGVsYXksIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyKSk7XG5leHBvcnQgeyBBc3luY1NjaGVkdWxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTY2hlZHVsZXIuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9Bc3luY1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuL0FzeW5jU2NoZWR1bGVyJztcbnZhciBRdWV1ZVNjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhRdWV1ZVNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZVNjaGVkdWxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUXVldWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyKSk7XG5leHBvcnQgeyBRdWV1ZVNjaGVkdWxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVTY2hlZHVsZXIuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9RdWV1ZUFjdGlvbixfUXVldWVTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgUXVldWVBY3Rpb24gfSBmcm9tICcuL1F1ZXVlQWN0aW9uJztcbmltcG9ydCB7IFF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnLi9RdWV1ZVNjaGVkdWxlcic7XG5leHBvcnQgdmFyIHF1ZXVlID0gLypAX19QVVJFX18qLyBuZXcgUXVldWVTY2hlZHVsZXIoUXVldWVBY3Rpb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0Vycm9yKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoIXNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpOyB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7IGVycm9yOiBlcnJvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTsgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2goX2EpIHtcbiAgICB2YXIgZXJyb3IgPSBfYS5lcnJvciwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXI7XG4gICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd0Vycm9yLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfb2JzZXJ2YWJsZV9lbXB0eSxfb2JzZXJ2YWJsZV9vZixfb2JzZXJ2YWJsZV90aHJvd0Vycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAnLi9vYnNlcnZhYmxlL2VtcHR5JztcbmltcG9ydCB7IG9mIH0gZnJvbSAnLi9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IHRocm93RXJyb3IgfSBmcm9tICcuL29ic2VydmFibGUvdGhyb3dFcnJvcic7XG52YXIgTm90aWZpY2F0aW9uID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihraW5kLCB2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBraW5kID09PSAnTic7XG4gICAgfVxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSAmJiBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCAmJiBuZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlICYmIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyICYmIHR5cGVvZiBuZXh0T3JPYnNlcnZlci5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgbm90aWZpY2F0aW9uIGtpbmQgdmFsdWUnKTtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignTicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm90aWZpY2F0aW9uLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcbiAgICB9O1xuICAgIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKTtcbiAgICBOb3RpZmljYXRpb24udW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdOJywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xufSgpKTtcbmV4cG9ydCB7IE5vdGlmaWNhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfTm90aWZpY2F0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb24gfSBmcm9tICcuLi9Ob3RpZmljYXRpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gb2JzZXJ2ZU9uT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG4gICAgfTtcbn1cbnZhciBPYnNlcnZlT25PcGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB9XG4gICAgT2JzZXJ2ZU9uT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBPYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2NoZWR1bGVyLCB0aGlzLmRlbGF5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2ZU9uT3BlcmF0b3IgfTtcbnZhciBPYnNlcnZlT25TdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE9ic2VydmVPblN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIF90aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IGFyZy5ub3RpZmljYXRpb24sIGRlc3RpbmF0aW9uID0gYXJnLmRlc3RpbmF0aW9uO1xuICAgICAgICBub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTWVzc2FnZSA9IGZ1bmN0aW9uIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVzdGluYXRpb24uYWRkKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKE9ic2VydmVPblN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIG5ldyBPYnNlcnZlT25NZXNzYWdlKG5vdGlmaWNhdGlvbiwgdGhpcy5kZXN0aW5hdGlvbikpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUoKSk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZlT25TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBPYnNlcnZlT25TdWJzY3JpYmVyIH07XG52YXIgT2JzZXJ2ZU9uTWVzc2FnZSA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25NZXNzYWdlKG5vdGlmaWNhdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmVPbk1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2ZU9uTWVzc2FnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZU9uLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3ViamVjdCxfc2NoZWR1bGVyX3F1ZXVlLF9TdWJzY3JpcHRpb24sX29wZXJhdG9yc19vYnNlcnZlT24sX3V0aWxfT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IsX1N1YmplY3RTdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuL1N1YmplY3QnO1xuaW1wb3J0IHsgcXVldWUgfSBmcm9tICcuL3NjaGVkdWxlci9xdWV1ZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPYnNlcnZlT25TdWJzY3JpYmVyIH0gZnJvbSAnLi9vcGVyYXRvcnMvb2JzZXJ2ZU9uJztcbmltcG9ydCB7IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yIH0gZnJvbSAnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbmltcG9ydCB7IFN1YmplY3RTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YmplY3RTdWJzY3JpcHRpb24nO1xudmFyIFJlcGxheVN1YmplY3QgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVwbGF5U3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBidWZmZXJTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3dUaW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHdpbmRvd1RpbWUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBfdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLl9pbmZpbml0ZVRpbWVXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2J1ZmZlclNpemUgPSBidWZmZXJTaXplIDwgMSA/IDEgOiBidWZmZXJTaXplO1xuICAgICAgICBfdGhpcy5fd2luZG93VGltZSA9IHdpbmRvd1RpbWUgPCAxID8gMSA6IHdpbmRvd1RpbWU7XG4gICAgICAgIGlmICh3aW5kb3dUaW1lID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgIF90aGlzLl9pbmZpbml0ZVRpbWVXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMubmV4dCA9IF90aGlzLm5leHRJbmZpbml0ZVRpbWVXaW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uZXh0ID0gX3RoaXMubmV4dFRpbWVXaW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5uZXh0SW5maW5pdGVUaW1lV2luZG93ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICBfZXZlbnRzLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAoX2V2ZW50cy5sZW5ndGggPiB0aGlzLl9idWZmZXJTaXplKSB7XG4gICAgICAgICAgICBfZXZlbnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUubmV4dFRpbWVXaW5kb3cgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2gobmV3IFJlcGxheUV2ZW50KHRoaXMuX2dldE5vdygpLCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9pbmZpbml0ZVRpbWVXaW5kb3cgPSB0aGlzLl9pbmZpbml0ZVRpbWVXaW5kb3c7XG4gICAgICAgIHZhciBfZXZlbnRzID0gX2luZmluaXRlVGltZVdpbmRvdyA/IHRoaXMuX2V2ZW50cyA6IHRoaXMuX3RyaW1CdWZmZXJUaGVuR2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGxlbiA9IF9ldmVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzdWJzY3JpYmVyID0gbmV3IE9ic2VydmVPblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc2NoZWR1bGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbmZpbml0ZVRpbWVXaW5kb3cpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KF9ldmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoX2V2ZW50c1tpXS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUuX2dldE5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjaGVkdWxlciB8fCBxdWV1ZSkubm93KCk7XG4gICAgfTtcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLl9nZXROb3coKTtcbiAgICAgICAgdmFyIF9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgICAgICAgdmFyIF93aW5kb3dUaW1lID0gdGhpcy5fd2luZG93VGltZTtcbiAgICAgICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIHZhciBldmVudHNDb3VudCA9IF9ldmVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgc3BsaWNlQ291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoc3BsaWNlQ291bnQgPCBldmVudHNDb3VudCkge1xuICAgICAgICAgICAgaWYgKChub3cgLSBfZXZlbnRzW3NwbGljZUNvdW50XS50aW1lKSA8IF93aW5kb3dUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGxpY2VDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudHNDb3VudCA+IF9idWZmZXJTaXplKSB7XG4gICAgICAgICAgICBzcGxpY2VDb3VudCA9IE1hdGgubWF4KHNwbGljZUNvdW50LCBldmVudHNDb3VudCAtIF9idWZmZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaWNlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBfZXZlbnRzLnNwbGljZSgwLCBzcGxpY2VDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ldmVudHM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwbGF5U3ViamVjdDtcbn0oU3ViamVjdCkpO1xuZXhwb3J0IHsgUmVwbGF5U3ViamVjdCB9O1xudmFyIFJlcGxheUV2ZW50ID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGxheUV2ZW50KHRpbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlcGxheUV2ZW50O1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheVN1YmplY3QuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJqZWN0LF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJzY3JpcHRpb24nO1xudmFyIEFzeW5jU3ViamVjdCA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBc3luY1N1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNTdWJqZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICBfdGhpcy5oYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmhhc05leHQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oYXNOZXh0KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnQgeyBBc3luY1N1YmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jU3ViamVjdC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cbnZhciBuZXh0SGFuZGxlID0gMTtcbnZhciB0YXNrc0J5SGFuZGxlID0ge307XG5mdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgdmFyIGNiID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIGlmIChjYikge1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgSW1tZWRpYXRlID0ge1xuICAgIHNldEltbWVkaWF0ZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBoYW5kbGUgPSBuZXh0SGFuZGxlKys7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbaGFuZGxlXSA9IGNiO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9LFxuICAgIGNsZWFySW1tZWRpYXRlOiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW1lZGlhdGUuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF91dGlsX0ltbWVkaWF0ZSxfQXN5bmNBY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEltbWVkaWF0ZSB9IGZyb20gJy4uL3V0aWwvSW1tZWRpYXRlJztcbmltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG52YXIgQXNhcEFjdGlvbiA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBc2FwQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzYXBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yaykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBfdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBc2FwQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlci5hY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVkIHx8IChzY2hlZHVsZXIuc2NoZWR1bGVkID0gSW1tZWRpYXRlLnNldEltbWVkaWF0ZShzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIG51bGwpKSk7XG4gICAgfTtcbiAgICBBc2FwQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB8fCAoZGVsYXkgPT09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBJbW1lZGlhdGUuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgICAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEFzYXBBY3Rpb247XG59KEFzeW5jQWN0aW9uKSk7XG5leHBvcnQgeyBBc2FwQWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc2FwQWN0aW9uLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfQXN5bmNTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnLi9Bc3luY1NjaGVkdWxlcic7XG52YXIgQXNhcFNjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBc2FwU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzYXBTY2hlZHVsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQXNhcFNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgY291bnQgPSBhY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGFjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc2FwU2NoZWR1bGVyO1xufShBc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0IHsgQXNhcFNjaGVkdWxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNhcFNjaGVkdWxlci5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX0FzYXBBY3Rpb24sX0FzYXBTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgQXNhcEFjdGlvbiB9IGZyb20gJy4vQXNhcEFjdGlvbic7XG5pbXBvcnQgeyBBc2FwU2NoZWR1bGVyIH0gZnJvbSAnLi9Bc2FwU2NoZWR1bGVyJztcbmV4cG9ydCB2YXIgYXNhcCA9IC8qQF9fUFVSRV9fKi8gbmV3IEFzYXBTY2hlZHVsZXIoQXNhcEFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2FwLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfQXN5bmNBY3Rpb24sX0FzeW5jU2NoZWR1bGVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG5pbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vQXN5bmNTY2hlZHVsZXInO1xuZXhwb3J0IHZhciBhc3luYyA9IC8qQF9fUFVSRV9fKi8gbmV3IEFzeW5jU2NoZWR1bGVyKEFzeW5jQWN0aW9uKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfQXN5bmNBY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG52YXIgQW5pbWF0aW9uRnJhbWVBY3Rpb24gPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQW5pbWF0aW9uRnJhbWVBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRnJhbWVBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yaykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBfdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbmltYXRpb25GcmFtZUFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZXIuYWN0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlZCB8fCAoc2NoZWR1bGVyLnNjaGVkdWxlZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBzY2hlZHVsZXIuZmx1c2gobnVsbCk7IH0pKTtcbiAgICB9O1xuICAgIEFuaW1hdGlvbkZyYW1lQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB8fCAoZGVsYXkgPT09IG51bGwgJiYgdGhpcy5kZWxheSA+IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZC5jYWxsKHRoaXMsIHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZWR1bGVyLmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRnJhbWVBY3Rpb247XG59KEFzeW5jQWN0aW9uKSk7XG5leHBvcnQgeyBBbmltYXRpb25GcmFtZUFjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uRnJhbWVBY3Rpb24uanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9Bc3luY1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuL0FzeW5jU2NoZWR1bGVyJztcbnZhciBBbmltYXRpb25GcmFtZVNjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBbmltYXRpb25GcmFtZVNjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBbmltYXRpb25GcmFtZVNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgY291bnQgPSBhY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGFjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXIpKTtcbmV4cG9ydCB7IEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmltYXRpb25GcmFtZVNjaGVkdWxlci5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX0FuaW1hdGlvbkZyYW1lQWN0aW9uLF9BbmltYXRpb25GcmFtZVNjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBBbmltYXRpb25GcmFtZUFjdGlvbiB9IGZyb20gJy4vQW5pbWF0aW9uRnJhbWVBY3Rpb24nO1xuaW1wb3J0IHsgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICcuL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyJztcbmV4cG9ydCB2YXIgYW5pbWF0aW9uRnJhbWUgPSAvKkBfX1BVUkVfXyovIG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcihBbmltYXRpb25GcmFtZUFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25GcmFtZS5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX0FzeW5jQWN0aW9uLF9Bc3luY1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQXN5bmNBY3Rpb24gfSBmcm9tICcuL0FzeW5jQWN0aW9uJztcbmltcG9ydCB7IEFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnLi9Bc3luY1NjaGVkdWxlcic7XG52YXIgVmlydHVhbFRpbWVTY2hlZHVsZXIgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVmlydHVhbFRpbWVTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlydHVhbFRpbWVTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBtYXhGcmFtZXMpIHtcbiAgICAgICAgaWYgKFNjaGVkdWxlckFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBTY2hlZHVsZXJBY3Rpb24gPSBWaXJ0dWFsQWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhGcmFtZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbWF4RnJhbWVzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZnJhbWU7IH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1heEZyYW1lcyA9IG1heEZyYW1lcztcbiAgICAgICAgX3RoaXMuZnJhbWUgPSAwO1xuICAgICAgICBfdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYWN0aW9ucyA9IF9hLmFjdGlvbnMsIG1heEZyYW1lcyA9IF9hLm1heEZyYW1lcztcbiAgICAgICAgdmFyIGVycm9yLCBhY3Rpb247XG4gICAgICAgIHdoaWxlICgoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSAmJiAodGhpcy5mcmFtZSA9IGFjdGlvbi5kZWxheSkgPD0gbWF4RnJhbWVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaXJ0dWFsVGltZVNjaGVkdWxlci5mcmFtZVRpbWVGYWN0b3IgPSAxMDtcbiAgICByZXR1cm4gVmlydHVhbFRpbWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyKSk7XG5leHBvcnQgeyBWaXJ0dWFsVGltZVNjaGVkdWxlciB9O1xudmFyIFZpcnR1YWxBY3Rpb24gPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVmlydHVhbEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaXJ0dWFsQWN0aW9uKHNjaGVkdWxlciwgd29yaywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gc2NoZWR1bGVyLmluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIF90aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pbmRleCA9IHNjaGVkdWxlci5pbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpcnR1YWxBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHZhciBhY3Rpb24gPSBuZXcgVmlydHVhbEFjdGlvbih0aGlzLnNjaGVkdWxlciwgdGhpcy53b3JrKTtcbiAgICAgICAgdGhpcy5hZGQoYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgVmlydHVhbEFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gc2NoZWR1bGVyLmZyYW1lICsgZGVsYXk7XG4gICAgICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgICAgIGFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgYWN0aW9ucy5zb3J0KFZpcnR1YWxBY3Rpb24uc29ydEFjdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFZpcnR1YWxBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFZpcnR1YWxBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9leGVjdXRlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlydHVhbEFjdGlvbi5zb3J0QWN0aW9ucyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhLmRlbGF5ID09PSBiLmRlbGF5KSB7XG4gICAgICAgICAgICBpZiAoYS5pbmRleCA9PT0gYi5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRlbGF5ID4gYi5kZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBWaXJ0dWFsQWN0aW9uO1xufShBc3luY0FjdGlvbikpO1xuZXhwb3J0IHsgVmlydHVhbEFjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlydHVhbFRpbWVTY2hlZHVsZXIuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGUob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIChvYmogaW5zdGFuY2VvZiBPYnNlcnZhYmxlIHx8ICh0eXBlb2Ygb2JqLmxpZnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JzZXJ2YWJsZS5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cbmZ1bmN0aW9uIFRpbWVvdXRFcnJvckltcGwoKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVGltZW91dCBoYXMgb2NjdXJyZWQnO1xuICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIHJldHVybiB0aGlzO1xufVxuVGltZW91dEVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovIE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmV4cG9ydCB2YXIgVGltZW91dEVycm9yID0gVGltZW91dEVycm9ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVvdXRFcnJvci5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX0FzeW5jU3ViamVjdCxfb3BlcmF0b3JzX21hcCxfdXRpbF9jYW5SZXBvcnRFcnJvcixfdXRpbF9pc0FycmF5LF91dGlsX2lzU2NoZWR1bGVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCB9IGZyb20gJy4uL0FzeW5jU3ViamVjdCc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9vcGVyYXRvcnMvbWFwJztcbmltcG9ydCB7IGNhblJlcG9ydEVycm9yIH0gZnJvbSAnLi4vdXRpbC9jYW5SZXBvcnRFcnJvcic7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5leHBvcnQgZnVuY3Rpb24gYmluZENhbGxiYWNrKGNhbGxiYWNrRnVuYywgcmVzdWx0U2VsZWN0b3IsIHNjaGVkdWxlcikge1xuICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXIocmVzdWx0U2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kQ2FsbGJhY2soY2FsbGJhY2tGdW5jLCBzY2hlZHVsZXIpLmFwcGx5KHZvaWQgMCwgYXJncykucGlwZShtYXAoZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGlzQXJyYXkoYXJncykgPyByZXN1bHRTZWxlY3Rvci5hcHBseSh2b2lkIDAsIGFyZ3MpIDogcmVzdWx0U2VsZWN0b3IoYXJncyk7IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIHZhciBzdWJqZWN0O1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgICAgICAgICBjYWxsYmFja0Z1bmM6IGNhbGxiYWNrRnVuYyxcbiAgICAgICAgICAgIHNjaGVkdWxlcjogc2NoZWR1bGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QubmV4dChpbm5lckFyZ3MubGVuZ3RoIDw9IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KFtoYW5kbGVyXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5SZXBvcnRFcnJvcihzdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJncywgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBkaXNwYXRjaChzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gc3RhdGUuYXJncywgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXIsIHBhcmFtcyA9IHN0YXRlLnBhcmFtcztcbiAgICB2YXIgY2FsbGJhY2tGdW5jID0gcGFyYW1zLmNhbGxiYWNrRnVuYywgY29udGV4dCA9IHBhcmFtcy5jb250ZXh0LCBzY2hlZHVsZXIgPSBwYXJhbXMuc2NoZWR1bGVyO1xuICAgIHZhciBzdWJqZWN0ID0gcGFyYW1zLnN1YmplY3Q7XG4gICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgIHN1YmplY3QgPSBwYXJhbXMuc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGlubmVyQXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzO1xuICAgICAgICAgICAgX3RoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHZhbHVlLCBzdWJqZWN0OiBzdWJqZWN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrRnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChbaGFuZGxlcl0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGQoc3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN0YXRlKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWUsIHN1YmplY3QgPSBzdGF0ZS5zdWJqZWN0O1xuICAgIHN1YmplY3QubmV4dCh2YWx1ZSk7XG4gICAgc3ViamVjdC5jb21wbGV0ZSgpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hFcnJvcihzdGF0ZSkge1xuICAgIHZhciBlcnIgPSBzdGF0ZS5lcnIsIHN1YmplY3QgPSBzdGF0ZS5zdWJqZWN0O1xuICAgIHN1YmplY3QuZXJyb3IoZXJyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRDYWxsYmFjay5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX0FzeW5jU3ViamVjdCxfb3BlcmF0b3JzX21hcCxfdXRpbF9jYW5SZXBvcnRFcnJvcixfdXRpbF9pc1NjaGVkdWxlcixfdXRpbF9pc0FycmF5IFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCB9IGZyb20gJy4uL0FzeW5jU3ViamVjdCc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9vcGVyYXRvcnMvbWFwJztcbmltcG9ydCB7IGNhblJlcG9ydEVycm9yIH0gZnJvbSAnLi4vdXRpbC9jYW5SZXBvcnRFcnJvcic7XG5pbXBvcnQgeyBpc1NjaGVkdWxlciB9IGZyb20gJy4uL3V0aWwvaXNTY2hlZHVsZXInO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL3V0aWwvaXNBcnJheSc7XG5leHBvcnQgZnVuY3Rpb24gYmluZE5vZGVDYWxsYmFjayhjYWxsYmFja0Z1bmMsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzU2NoZWR1bGVyKHJlc3VsdFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZE5vZGVDYWxsYmFjayhjYWxsYmFja0Z1bmMsIHNjaGVkdWxlcikuYXBwbHkodm9pZCAwLCBhcmdzKS5waXBlKG1hcChmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gaXNBcnJheShhcmdzKSA/IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncykgOiByZXN1bHRTZWxlY3RvcihhcmdzKTsgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBzdWJqZWN0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgY2FsbGJhY2tGdW5jOiBjYWxsYmFja0Z1bmMsXG4gICAgICAgICAgICBzY2hlZHVsZXI6IHNjaGVkdWxlcixcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJhbXMuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0ID0gcGFyYW1zLnN1YmplY3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gcGFyYW1zLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KGlubmVyQXJncy5sZW5ndGggPD0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0Z1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoW2hhbmRsZXJdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhblJlcG9ydEVycm9yKHN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgMCwgeyBwYXJhbXM6IHBhcmFtcywgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcGFyYW1zID0gc3RhdGUucGFyYW1zLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgdmFyIGNhbGxiYWNrRnVuYyA9IHBhcmFtcy5jYWxsYmFja0Z1bmMsIGFyZ3MgPSBwYXJhbXMuYXJncywgc2NoZWR1bGVyID0gcGFyYW1zLnNjaGVkdWxlcjtcbiAgICB2YXIgc3ViamVjdCA9IHBhcmFtcy5zdWJqZWN0O1xuICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICBzdWJqZWN0ID0gcGFyYW1zLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBpbm5lckFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnIsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzO1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB2YWx1ZSwgc3ViamVjdDogc3ViamVjdCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFja0Z1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoW2hhbmRsZXJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnIsIHN1YmplY3Q6IHN1YmplY3QgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkKHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmcudmFsdWUsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICAgIHN1YmplY3QuY29tcGxldGUoKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3IoYXJnKSB7XG4gICAgdmFyIGVyciA9IGFyZy5lcnIsIHN1YmplY3QgPSBhcmcuc3ViamVjdDtcbiAgICBzdWJqZWN0LmVycm9yKGVycik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kTm9kZUNhbGxiYWNrLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfdXRpbF9pc1NjaGVkdWxlcixfdXRpbF9pc0FycmF5LF9PdXRlclN1YnNjcmliZXIsX3V0aWxfc3Vic2NyaWJlVG9SZXN1bHQsX2Zyb21BcnJheSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBmcm9tQXJyYXkgfSBmcm9tICcuL2Zyb21BcnJheSc7XG52YXIgTk9ORSA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3QoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICBpZiAoaXNTY2hlZHVsZXIob2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBDb21iaW5lTGF0ZXN0T3BlcmF0b3IocmVzdWx0U2VsZWN0b3IpKTtcbn1cbnZhciBDb21iaW5lTGF0ZXN0T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tYmluZUxhdGVzdE9wZXJhdG9yKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgQ29tYmluZUxhdGVzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ29tYmluZUxhdGVzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnQgeyBDb21iaW5lTGF0ZXN0T3BlcmF0b3IgfTtcbnZhciBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21iaW5lTGF0ZXN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIF90aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIF90aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICBfdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1c2goTk9ORSk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMucHVzaChvYnNlcnZhYmxlKTtcbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IHRoaXMub2JzZXJ2YWJsZXM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgICAgICAgICAgdGhpcy50b1Jlc3BvbmQgPSBsZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICh1bnVzZWQpIHtcbiAgICAgICAgaWYgKCh0aGlzLmFjdGl2ZSAtPSAxKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21iaW5lTGF0ZXN0U3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHZhciBvbGRWYWwgPSB2YWx1ZXNbb3V0ZXJJbmRleF07XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSAhdGhpcy50b1Jlc3BvbmRcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiBvbGRWYWwgPT09IE5PTkUgPyAtLXRoaXMudG9SZXNwb25kIDogdGhpcy50b1Jlc3BvbmQ7XG4gICAgICAgIHZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIGlmICh0b1Jlc3BvbmQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZXMuc2xpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lTGF0ZXN0LmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9pc1NjaGVkdWxlcixfb2YsX2Zyb20sX29wZXJhdG9yc19jb25jYXRBbGwgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcbmltcG9ydCB7IG9mIH0gZnJvbSAnLi9vZic7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9mcm9tJztcbmltcG9ydCB7IGNvbmNhdEFsbCB9IGZyb20gJy4uL29wZXJhdG9ycy9jb25jYXRBbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxIHx8IChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDIgJiYgaXNTY2hlZHVsZXIob2JzZXJ2YWJsZXNbMV0pKSkge1xuICAgICAgICByZXR1cm4gZnJvbShvYnNlcnZhYmxlc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRBbGwoKShvZi5hcHBseSh2b2lkIDAsIG9ic2VydmFibGVzKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9mcm9tLF9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9mcm9tJztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAnLi9lbXB0eSc7XG5leHBvcnQgZnVuY3Rpb24gZGVmZXIob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5wdXQgPSBvYnNlcnZhYmxlRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IGlucHV0ID8gZnJvbShpbnB1dCkgOiBlbXB0eSgpO1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfT2JzZXJ2YWJsZSxfdXRpbF9pc0FycmF5LF9lbXB0eSxfdXRpbF9zdWJzY3JpYmVUb1Jlc3VsdCxfT3V0ZXJTdWJzY3JpYmVyLF9vcGVyYXRvcnNfbWFwIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAnLi9lbXB0eSc7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4uL29wZXJhdG9ycy9tYXAnO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmtKb2luKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0U2VsZWN0b3I7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VzW3NvdXJjZXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBzb3VyY2VzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShzb3VyY2VzWzBdKSkge1xuICAgICAgICBzb3VyY2VzID0gc291cmNlc1swXTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmb3JrSm9pbihzb3VyY2VzKS5waXBlKG1hcChmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gcmVzdWx0U2VsZWN0b3IuYXBwbHkodm9pZCAwLCBhcmdzKTsgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JrSm9pblN1YnNjcmliZXIoc3Vic2NyaWJlciwgc291cmNlcyk7XG4gICAgfSk7XG59XG52YXIgRm9ya0pvaW5TdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZvcmtKb2luU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3JrSm9pblN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgICBfdGhpcy5jb21wbGV0ZWQgPSAwO1xuICAgICAgICBfdGhpcy5oYXZlVmFsdWVzID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdChfdGhpcywgc291cmNlLCBudWxsLCBpKTtcbiAgICAgICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGb3JrSm9pblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICBpZiAoIWlubmVyU3ViLl9oYXNWYWx1ZSkge1xuICAgICAgICAgICAgaW5uZXJTdWIuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGF2ZVZhbHVlcysrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb3JrSm9pblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb24sIGhhdmVWYWx1ZXMgPSBfYS5oYXZlVmFsdWVzLCB2YWx1ZXMgPSBfYS52YWx1ZXM7XG4gICAgICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIWlubmVyU3ViLl9oYXNWYWx1ZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBsZXRlZCsrO1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZWQgIT09IGxlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXZlVmFsdWVzID09PSBsZW4pIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcmtKb2luU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JrSm9pbi5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX3V0aWxfaXNBcnJheSxfdXRpbF9pc0Z1bmN0aW9uLF9vcGVyYXRvcnNfbWFwIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9vcGVyYXRvcnMvbWFwJztcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmcm9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMpLnBpcGUobWFwKGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBpc0FycmF5KGFyZ3MpID8gcmVzdWx0U2VsZWN0b3IuYXBwbHkodm9pZCAwLCBhcmdzKSA6IHJlc3VsdFNlbGVjdG9yKGFyZ3MpOyB9KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXR1cFN1YnNjcmlwdGlvbih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucykge1xuICAgIHZhciB1bnN1YnNjcmliZTtcbiAgICBpZiAoaXNFdmVudFRhcmdldChzb3VyY2VPYmopKSB7XG4gICAgICAgIHZhciBzb3VyY2VfMSA9IHNvdXJjZU9iajtcbiAgICAgICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICB2YXIgc291cmNlXzIgPSBzb3VyY2VPYmo7XG4gICAgICAgIHNvdXJjZU9iai5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgIHZhciBzb3VyY2VfMyA9IHNvdXJjZU9iajtcbiAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlT2JqICYmIHNvdXJjZU9iai5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZU9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqW2ldLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLmFkZCh1bnN1YnNjcmliZSk7XG59XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuIHNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoub2ZmID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF91dGlsX2lzQXJyYXksX3V0aWxfaXNGdW5jdGlvbixfb3BlcmF0b3JzX21hcCBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vb3BlcmF0b3JzL21hcCc7XG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50UGF0dGVybihhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCByZXN1bHRTZWxlY3Rvcikge1xuICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50UGF0dGVybihhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyKS5waXBlKG1hcChmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gaXNBcnJheShhcmdzKSA/IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncykgOiByZXN1bHRTZWxlY3RvcihhcmdzKTsgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBlW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUubGVuZ3RoID09PSAxID8gZVswXSA6IGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmV0VmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXRWYWx1ZSA9IGFkZEhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocmVtb3ZlSGFuZGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZUhhbmRsZXIoaGFuZGxlciwgcmV0VmFsdWUpOyB9O1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50UGF0dGVybi5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX3V0aWxfaWRlbnRpdHksX3V0aWxfaXNTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuLi91dGlsL2lkZW50aXR5JztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGUoaW5pdGlhbFN0YXRlT3JPcHRpb25zLCBjb25kaXRpb24sIGl0ZXJhdGUsIHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgcmVzdWx0U2VsZWN0b3I7XG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gaW5pdGlhbFN0YXRlT3JPcHRpb25zO1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgY29uZGl0aW9uID0gb3B0aW9ucy5jb25kaXRpb247XG4gICAgICAgIGl0ZXJhdGUgPSBvcHRpb25zLml0ZXJhdGU7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gb3B0aW9ucy5yZXN1bHRTZWxlY3RvciB8fCBpZGVudGl0eTtcbiAgICAgICAgc2NoZWR1bGVyID0gb3B0aW9ucy5zY2hlZHVsZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdFNlbGVjdG9yT3JPYnNlcnZhYmxlID09PSB1bmRlZmluZWQgfHwgaXNTY2hlZHVsZXIocmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUpKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZU9yT3B0aW9ucztcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBpZGVudGl0eTtcbiAgICAgICAgc2NoZWR1bGVyID0gcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVPck9wdGlvbnM7XG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyLFxuICAgICAgICAgICAgICAgIGl0ZXJhdGU6IGl0ZXJhdGUsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I6IHJlc3VsdFNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29uZGl0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBpdGVyYXRlKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChzdGF0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlciwgY29uZGl0aW9uID0gc3RhdGUuY29uZGl0aW9uO1xuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubmVlZEl0ZXJhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gc3RhdGUuaXRlcmF0ZShzdGF0ZS5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUubmVlZEl0ZXJhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHZhciBjb25kaXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBjb25kaXRpb24oc3RhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25kaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IHN0YXRlLnJlc3VsdFNlbGVjdG9yKHN0YXRlLnN0YXRlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2RlZmVyLF9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBkZWZlciB9IGZyb20gJy4vZGVmZXInO1xuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICcuL2VtcHR5JztcbmV4cG9ydCBmdW5jdGlvbiBpaWYoY29uZGl0aW9uLCB0cnVlUmVzdWx0LCBmYWxzZVJlc3VsdCkge1xuICAgIGlmICh0cnVlUmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdHJ1ZVJlc3VsdCA9IEVNUFRZO1xuICAgIH1cbiAgICBpZiAoZmFsc2VSZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxzZVJlc3VsdCA9IEVNUFRZO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZGl0aW9uKCkgPyB0cnVlUmVzdWx0IDogZmFsc2VSZXN1bHQ7IH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWlmLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfaXNBcnJheSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi9pc0FycmF5JztcbmV4cG9ydCBmdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gICAgcmV0dXJuICFpc0FycmF5KHZhbCkgJiYgKHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEpID49IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc051bWVyaWMuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9zY2hlZHVsZXJfYXN5bmMsX3V0aWxfaXNOdW1lcmljIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IGlzTnVtZXJpYyB9IGZyb20gJy4uL3V0aWwvaXNOdW1lcmljJztcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnZhbChwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgIGlmIChwZXJpb2QgPT09IHZvaWQgMCkge1xuICAgICAgICBwZXJpb2QgPSAwO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXN5bmM7XG4gICAgfVxuICAgIGlmICghaXNOdW1lcmljKHBlcmlvZCkgfHwgcGVyaW9kIDwgMCkge1xuICAgICAgICBwZXJpb2QgPSAwO1xuICAgIH1cbiAgICBpZiAoIXNjaGVkdWxlciB8fCB0eXBlb2Ygc2NoZWR1bGVyLnNjaGVkdWxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCBwZXJpb2QsIHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgY291bnRlcjogMCwgcGVyaW9kOiBwZXJpb2QgfSkpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKHN0YXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBjb3VudGVyID0gc3RhdGUuY291bnRlciwgcGVyaW9kID0gc3RhdGUucGVyaW9kO1xuICAgIHN1YnNjcmliZXIubmV4dChjb3VudGVyKTtcbiAgICB0aGlzLnNjaGVkdWxlKHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciwgY291bnRlcjogY291bnRlciArIDEsIHBlcmlvZDogcGVyaW9kIH0sIHBlcmlvZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnZhbC5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX3V0aWxfbm9vcCBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbC9ub29wJztcbmV4cG9ydCB2YXIgTkVWRVIgPSAvKkBfX1BVUkVfXyovIG5ldyBPYnNlcnZhYmxlKG5vb3ApO1xuZXhwb3J0IGZ1bmN0aW9uIG5ldmVyKCkge1xuICAgIHJldHVybiBORVZFUjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldmVyLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfZnJvbSxfdXRpbF9pc0FycmF5LF9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9mcm9tJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICcuL2VtcHR5JztcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dCgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gc291cmNlc1swXSwgcmVtYWluZGVyID0gc291cmNlcy5zbGljZSgxKTtcbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShmaXJzdCkpIHtcbiAgICAgICAgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0LmFwcGx5KHZvaWQgMCwgZmlyc3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHN1Yk5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmFkZChvbkVycm9yUmVzdW1lTmV4dC5hcHBseSh2b2lkIDAsIHJlbWFpbmRlcikuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTsgfTtcbiAgICAgICAgcmV0dXJuIGZyb20oZmlyc3QpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSxcbiAgICAgICAgICAgIGVycm9yOiBzdWJOZXh0LFxuICAgICAgICAgICAgY29tcGxldGU6IHN1Yk5leHQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25FcnJvclJlc3VtZU5leHQuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBwYWlycyhvYmosIHNjaGVkdWxlcikge1xuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIDAsIHsga2V5czoga2V5cywgaW5kZXg6IDAsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBvYmo6IG9iaiB9KSk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIga2V5cyA9IHN0YXRlLmtleXMsIGluZGV4ID0gc3RhdGUuaW5kZXgsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyLCBzdWJzY3JpcHRpb24gPSBzdGF0ZS5zdWJzY3JpcHRpb24sIG9iaiA9IHN0YXRlLm9iajtcbiAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgb2JqW2tleV1dKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5hZGQodGhpcy5zY2hlZHVsZSh7IGtleXM6IGtleXMsIGluZGV4OiBpbmRleCArIDEsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBvYmo6IG9iaiB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlycy5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX3V0aWxfaXNBcnJheSxfZnJvbUFycmF5LF9PdXRlclN1YnNjcmliZXIsX3V0aWxfc3Vic2NyaWJlVG9SZXN1bHQgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgZnJvbUFycmF5IH0gZnJvbSAnLi9mcm9tQXJyYXknO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5leHBvcnQgZnVuY3Rpb24gcmFjZSgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChpc0FycmF5KG9ic2VydmFibGVzWzBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5KG9ic2VydmFibGVzLCB1bmRlZmluZWQpLmxpZnQobmV3IFJhY2VPcGVyYXRvcigpKTtcbn1cbnZhciBSYWNlT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFjZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBSYWNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSYWNlU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFjZU9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydCB7IFJhY2VPcGVyYXRvciB9O1xudmFyIFJhY2VTdWJzY3JpYmVyID0gLypAX19QVVJFX18qLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJhY2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhY2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcy5wdXNoKG9ic2VydmFibGUpO1xuICAgIH07XG4gICAgUmFjZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gJiYgIXRoaXMuaGFzRmlyc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYWNlU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gb3V0ZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBSYWNlU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBSYWNlU3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZS5qcy5tYXBcbiIsIi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgY3VycmVudCA9IHN0YXJ0O1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LCBjb3VudDogY291bnQsIHN0YXJ0OiBzdGFydCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4KysgPj0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGN1cnJlbnQrKyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5zdGFydCwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgaWYgKGluZGV4ID49IGNvdW50KSB7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdWJzY3JpYmVyLm5leHQoc3RhcnQpO1xuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgIHN0YXRlLnN0YXJ0ID0gc3RhcnQgKyAxO1xuICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9zY2hlZHVsZXJfYXN5bmMsX3V0aWxfaXNOdW1lcmljLF91dGlsX2lzU2NoZWR1bGVyIFBVUkVfSU1QT1JUU19FTkQgKi9cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IGlzTnVtZXJpYyB9IGZyb20gJy4uL3V0aWwvaXNOdW1lcmljJztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5leHBvcnQgZnVuY3Rpb24gdGltZXIoZHVlVGltZSwgcGVyaW9kT3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICAgIGlmIChkdWVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgZHVlVGltZSA9IDA7XG4gICAgfVxuICAgIHZhciBwZXJpb2QgPSAtMTtcbiAgICBpZiAoaXNOdW1lcmljKHBlcmlvZE9yU2NoZWR1bGVyKSkge1xuICAgICAgICBwZXJpb2QgPSBOdW1iZXIocGVyaW9kT3JTY2hlZHVsZXIpIDwgMSAmJiAxIHx8IE51bWJlcihwZXJpb2RPclNjaGVkdWxlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2NoZWR1bGVyKHBlcmlvZE9yU2NoZWR1bGVyKSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2RPclNjaGVkdWxlcjtcbiAgICB9XG4gICAgaWYgKCFpc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGR1ZSA9IGlzTnVtZXJpYyhkdWVUaW1lKVxuICAgICAgICAgICAgPyBkdWVUaW1lXG4gICAgICAgICAgICA6ICgrZHVlVGltZSAtIHNjaGVkdWxlci5ub3coKSk7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIGR1ZSwge1xuICAgICAgICAgICAgaW5kZXg6IDAsIHBlcmlvZDogcGVyaW9kLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyLm5leHQoaW5kZXgpO1xuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG4gICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfZnJvbSxfZW1wdHkgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vZnJvbSc7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gJy4vZW1wdHknO1xuZXhwb3J0IGZ1bmN0aW9uIHVzaW5nKHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHJlc291cmNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZUZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBvYnNlcnZhYmxlRmFjdG9yeShyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gcmVzdWx0ID8gZnJvbShyZXN1bHQpIDogRU1QVFk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNpbmcuanMubWFwXG4iLCIvKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9mcm9tQXJyYXksX3V0aWxfaXNBcnJheSxfU3Vic2NyaWJlcixfT3V0ZXJTdWJzY3JpYmVyLF91dGlsX3N1YnNjcmliZVRvUmVzdWx0LF8uLl9pbnRlcm5hbF9zeW1ib2xfaXRlcmF0b3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGZyb21BcnJheSB9IGZyb20gJy4vZnJvbUFycmF5JztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBpdGVyYXRvciBhcyBTeW1ib2xfaXRlcmF0b3IgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9zeW1ib2wvaXRlcmF0b3InO1xuZXhwb3J0IGZ1bmN0aW9uIHppcCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5KG9ic2VydmFibGVzLCB1bmRlZmluZWQpLmxpZnQobmV3IFppcE9wZXJhdG9yKHJlc3VsdFNlbGVjdG9yKSk7XG59XG52YXIgWmlwT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmlwT3BlcmF0b3IocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBaaXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydCB7IFppcE9wZXJhdG9yIH07XG52YXIgWmlwU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pdGVyYXRvcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgX3RoaXMucmVzdWx0U2VsZWN0b3IgPSAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSA/IHJlc3VsdFNlbGVjdG9yIDogbnVsbDtcbiAgICAgICAgX3RoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtTeW1ib2xfaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljSXRlcmF0b3IodmFsdWVbU3ltYm9sX2l0ZXJhdG9yXSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgWmlwQnVmZmVySXRlcmF0b3IodGhpcy5kZXN0aW5hdGlvbiwgdGhpcywgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLmhhc1ZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpdGVyYXRvci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmhhc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdHJ5cmVzdWx0U2VsZWN0b3IoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeXJlc3VsdFNlbGVjdG9yID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IFppcFN1YnNjcmliZXIgfTtcbnZhciBTdGF0aWNJdGVyYXRvciA9IC8qQF9fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljQXJyYXlJdGVyYXRvcihhcnJheSkge1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2xfaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHJldHVybiBpIDwgdGhpcy5sZW5ndGggPyB7IHZhbHVlOiBhcnJheVtpXSwgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPiB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPT09IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljQXJyYXlJdGVyYXRvcjtcbn0oKSk7XG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoWmlwQnVmZmVySXRlcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwQnVmZmVySXRlcmF0b3IoZGVzdGluYXRpb24sIHBhcmVudCwgb2JzZXJ2YWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBfdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgX3RoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBfdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgX3RoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2xfaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBidWZmZXIuc2hpZnQoKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5uZXJWYWx1ZSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoZWNrSXRlcmF0b3JzKCk7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwQnVmZmVySXRlcmF0b3I7XG59KE91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxuIiwiLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuZXhwb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4vaW50ZXJuYWwvT2JzZXJ2YWJsZSc7XG5leHBvcnQgeyBDb25uZWN0YWJsZU9ic2VydmFibGUgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJztcbmV4cG9ydCB7IEdyb3VwZWRPYnNlcnZhYmxlIH0gZnJvbSAnLi9pbnRlcm5hbC9vcGVyYXRvcnMvZ3JvdXBCeSc7XG5leHBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSAnLi9pbnRlcm5hbC9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5leHBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi9pbnRlcm5hbC9TdWJqZWN0JztcbmV4cG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJy4vaW50ZXJuYWwvQmVoYXZpb3JTdWJqZWN0JztcbmV4cG9ydCB7IFJlcGxheVN1YmplY3QgfSBmcm9tICcuL2ludGVybmFsL1JlcGxheVN1YmplY3QnO1xuZXhwb3J0IHsgQXN5bmNTdWJqZWN0IH0gZnJvbSAnLi9pbnRlcm5hbC9Bc3luY1N1YmplY3QnO1xuZXhwb3J0IHsgYXNhcCBhcyBhc2FwU2NoZWR1bGVyIH0gZnJvbSAnLi9pbnRlcm5hbC9zY2hlZHVsZXIvYXNhcCc7XG5leHBvcnQgeyBhc3luYyBhcyBhc3luY1NjaGVkdWxlciB9IGZyb20gJy4vaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jJztcbmV4cG9ydCB7IHF1ZXVlIGFzIHF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnLi9pbnRlcm5hbC9zY2hlZHVsZXIvcXVldWUnO1xuZXhwb3J0IHsgYW5pbWF0aW9uRnJhbWUgYXMgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICcuL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZSc7XG5leHBvcnQgeyBWaXJ0dWFsVGltZVNjaGVkdWxlciwgVmlydHVhbEFjdGlvbiB9IGZyb20gJy4vaW50ZXJuYWwvc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyJztcbmV4cG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vaW50ZXJuYWwvU2NoZWR1bGVyJztcbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vaW50ZXJuYWwvU3Vic2NyaXB0aW9uJztcbmV4cG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL2ludGVybmFsL1N1YnNjcmliZXInO1xuZXhwb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi9pbnRlcm5hbC9Ob3RpZmljYXRpb24nO1xuZXhwb3J0IHsgcGlwZSB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbC9waXBlJztcbmV4cG9ydCB7IG5vb3AgfSBmcm9tICcuL2ludGVybmFsL3V0aWwvbm9vcCc7XG5leHBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbC9pZGVudGl0eSc7XG5leHBvcnQgeyBpc09ic2VydmFibGUgfSBmcm9tICcuL2ludGVybmFsL3V0aWwvaXNPYnNlcnZhYmxlJztcbmV4cG9ydCB7IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbmV4cG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvcic7XG5leHBvcnQgeyBPYmplY3RVbnN1YnNjcmliZWRFcnJvciB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG5leHBvcnQgeyBVbnN1YnNjcmlwdGlvbkVycm9yIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuZXhwb3J0IHsgVGltZW91dEVycm9yIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsL1RpbWVvdXRFcnJvcic7XG5leHBvcnQgeyBiaW5kQ2FsbGJhY2sgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvYmluZENhbGxiYWNrJztcbmV4cG9ydCB7IGJpbmROb2RlQ2FsbGJhY2sgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjayc7XG5leHBvcnQgeyBjb21iaW5lTGF0ZXN0IH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QnO1xuZXhwb3J0IHsgY29uY2F0IH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbmNhdCc7XG5leHBvcnQgeyBkZWZlciB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9kZWZlcic7XG5leHBvcnQgeyBlbXB0eSB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eSc7XG5leHBvcnQgeyBmb3JrSm9pbiB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9mb3JrSm9pbic7XG5leHBvcnQgeyBmcm9tIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20nO1xuZXhwb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5leHBvcnQgeyBmcm9tRXZlbnRQYXR0ZXJuIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4nO1xuZXhwb3J0IHsgZ2VuZXJhdGUgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvZ2VuZXJhdGUnO1xuZXhwb3J0IHsgaWlmIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2lpZic7XG5leHBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbnRlcnZhbCc7XG5leHBvcnQgeyBtZXJnZSB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9tZXJnZSc7XG5leHBvcnQgeyBuZXZlciB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9uZXZlcic7XG5leHBvcnQgeyBvZiB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9vZic7XG5leHBvcnQgeyBvbkVycm9yUmVzdW1lTmV4dCB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9vbkVycm9yUmVzdW1lTmV4dCc7XG5leHBvcnQgeyBwYWlycyB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9wYWlycyc7XG5leHBvcnQgeyByYWNlIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhY2UnO1xuZXhwb3J0IHsgcmFuZ2UgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvcmFuZ2UnO1xuZXhwb3J0IHsgdGhyb3dFcnJvciB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS90aHJvd0Vycm9yJztcbmV4cG9ydCB7IHRpbWVyIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyJztcbmV4cG9ydCB7IHVzaW5nIH0gZnJvbSAnLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3VzaW5nJztcbmV4cG9ydCB7IHppcCB9IGZyb20gJy4vaW50ZXJuYWwvb2JzZXJ2YWJsZS96aXAnO1xuZXhwb3J0IHsgRU1QVFkgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvZW1wdHknO1xuZXhwb3J0IHsgTkVWRVIgfSBmcm9tICcuL2ludGVybmFsL29ic2VydmFibGUvbmV2ZXInO1xuZXhwb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9pbnRlcm5hbC9jb25maWcnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6TkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///90\\n')}});","extractedComments":[]}